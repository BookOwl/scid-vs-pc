Index: src/game.cpp
===================================================================
--- src/game.cpp	(revision 2575)
+++ src/game.cpp	(working copy)
@@ -473,7 +473,8 @@
 void
 Game::SaveState ()
 {
-    if (!SavedPos) { SavedPos = new Position; }
+    if (!SavedPos) { SavedPos = new Position(this); }
+    CurrentPos->SetOwner(this); // just in case?
     SavedPos->CopyFrom (CurrentPos);
     SavedMove = CurrentMove;
     SavedPlyCount = CurrentPlyCount;
@@ -490,6 +491,7 @@
     if (SavedMove) {
         ASSERT (SavedPos != NULL);
         CurrentPos->CopyFrom (SavedPos);
+        CurrentPos->SetOwner(this);
         CurrentMove = SavedMove;
         CurrentPlyCount = SavedPlyCount;
         VarDepth = SavedVarDepth;
@@ -591,9 +593,9 @@
     StartPos = NULL;
 #ifdef WINCE
     if (!LowMem)
-      CurrentPos = new Position;
+      CurrentPos = new Position(this);
 #else
-    CurrentPos = new Position;
+    CurrentPos = new Position(this);
 #endif
     KeepDecodedMoves = true;
     SavedPos = NULL;
@@ -700,6 +702,10 @@
 
     // Set up standard start
     CurrentPos->StdStart();
+    CurrentPos->SetOwner(this);
+    if ( ! StartPos ) { StartPos = new Position; }
+    StartPos->CopyFrom( CurrentPos );
+
     KeepDecodedMoves = true;
 }
 
@@ -774,8 +780,12 @@
     }
     VarDepth = 0;
     if (!StartPos) { StartPos = new Position; }
+
+    pos->SetOwner(this);
+    
     StartPos->CopyFrom (pos);
     CurrentPos->CopyFrom (pos);
+    //
     // Now make the material signature:
     FinalMatSig = matsig_Make (StartPos->GetMaterial());
     NonStandardStart = true;
@@ -791,7 +801,7 @@
 Game::SetStartFen (const char * fenStr)
 {
     // First try to read the position:
-    Position * pos = new Position;
+    Position * pos = new Position(this);
     errorT err = pos->ReadFromFEN (fenStr);
     if (err != OK) { delete pos; return err; }
 
@@ -803,6 +813,7 @@
     VarDepth = 0;
     if (StartPos) { delete StartPos; }
     StartPos = pos;
+    StartPos->SetOwner(this);
     CurrentPos->CopyFrom (StartPos);
     // Now make the material signature:
     FinalMatSig = matsig_Make (StartPos->GetMaterial());
@@ -965,6 +976,8 @@
         CurrentPos->CopyFrom (StartPos);
     } else {
         CurrentPos->StdStart();
+        CurrentPos->SetOwner(this);
+        StartPos->CopyFrom(CurrentPos);
     }
     CurrentPlyCount = 0;
     for (ushort i=0; i < hmNumber; i++) {
@@ -1360,6 +1373,7 @@
     ASSERT (CurrentMove != NULL);
     while (MoveExitVariation() == OK);  // exit variations
     if (!StartPos) { StartPos = new Position; }
+    CurrentPos->SetOwner(this); // just in case?
     StartPos->CopyFrom (CurrentPos);
     NonStandardStart = true;
     CurrentMove->prev->marker = END_MARKER;
@@ -3753,7 +3767,7 @@
 // encodeKing(): encoding of King moves.
 //
 static inline void
-encodeKing (ByteBuffer * buf, simpleMoveT * sm)
+encodeKing (ByteBuffer * buf, simpleMoveT * sm, Position * pos)
 {
     // Valid King difference-from-old-square values are:
     // -9, -8, -7, -1, 1, 7, 8, 9, and -2 and 2 for castling.
@@ -3763,6 +3777,31 @@
 
     ASSERT(sm->pieceNum == 0);  // Kings MUST be piece Number zero.
     int diff = (int) sm->to - (int) sm->from;
+
+    squareT kr = NS;
+    squareT qr = NS;
+    rankT krank = square_Rank(sm->from);
+    
+    pieceT * board = pos->GetBoard();
+
+    pieceT friendlyrook = piece_Make( pos->GetToMove(), ROOK );
+
+    squareT kcur;
+    
+    kcur = sm->from;
+    while ( square_Rank(kcur) == krank ) {
+        if ( board[kcur] == friendlyrook ) { kr = kcur; break; }
+        kcur++;
+    }
+    kcur = sm->from;
+    while ( square_Rank(kcur) == krank ) {
+        if ( board[kcur] == friendlyrook ) { qr = kcur; break; }
+        kcur--;
+    }
+
+    if (sm->to == kr) { diff = 2; }
+    if (sm->to == qr) { diff = -2; }
+    
     static const byte val[] = {
     /* -9 -8 -7 -6 -5 -4 -3 -2 -1  0  1   2  3  4  5  6  7  8  9 */
         1, 2, 3, 0, 0, 0, 0, 9, 4, 0, 5, 10, 0, 0, 0, 0, 6, 7, 8
@@ -3785,7 +3824,7 @@
 // decodeKing(): decoding of King moves.
 //
 static inline errorT
-decodeKing (byte val, simpleMoveT * sm)
+decodeKing (byte val, simpleMoveT * sm, Position * pos)
 {
     static const int sqdiff[] = {
         0, -9, -8, -7, -1, 1, 7, 8, 9, -2, 2
@@ -3797,8 +3836,34 @@
     }
 
     if (val < 1  ||  val > 10) { return ERROR_Decode; }
-    sm->to = sm->from + sqdiff[val];
-    return OK;
+    if (val >= 1 && val <= 8) {
+        sm->to = sm->from + sqdiff[val];
+        return OK;
+    }
+    else {
+        int direction;
+        if (val == 9) { direction = -1; }  //queenside
+        if (val == 10) { direction = 1; }  //kingside
+
+        squareT kdest;
+        kdest = NS;
+        squareT kcur = sm->from;
+        rankT krank = square_Rank(sm->from);
+
+        pieceT friendlyrook = piece_Make( pos->GetToMove(), ROOK );
+        pieceT * board = pos->GetBoard();
+
+        while ( square_Rank(kcur) == krank ) {
+            if ( board[kcur] == friendlyrook ) { kdest = kcur; break; }
+            kcur = kcur + direction;
+        }
+        
+        if (kcur != NS) {
+            sm->to = kdest;
+            return OK;
+        }
+    }
+    return ERROR_Decode;
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -4129,7 +4194,7 @@
         err = decodeBishop (val & 15, sm);
         break;
     case KING:
-        err = decodeKing (val & 15, sm);
+        err = decodeKing (val & 15, sm, pos);
         break;
     // For queen moves: Rook-like moves are in 1 byte, diagonals are in 2.
     case QUEEN:
@@ -4146,7 +4211,7 @@
 //  Encode one move and output it to the bytebuffer.
 //
 static void
-encodeMove (ByteBuffer * buf, moveT * m)
+encodeMove (ByteBuffer * buf, moveT * m, Position * pos)
 {
     simpleMoveT * sm = &(m->moveData);
     pieceT pt = piece_Type(sm->movingPiece);
@@ -4154,7 +4219,7 @@
     typedef void encodeFnType (ByteBuffer *, simpleMoveT *);
     static encodeFnType * encodeFn[] = {
         NULL         /* 0 */,
-        encodeKing   /*1=KING*/,
+        NULL         /*1=KING*/,
         encodeQueen  /*2=QUEEN*/,
         encodeRook   /*3=ROOK*/,
         encodeBishop /*4=BISHOP*/,
@@ -4162,7 +4227,10 @@
         encodePawn   /*6=PAWN*/
     };
     ASSERT (pt >= KING  &&  pt <= PAWN);
-    (encodeFn[pt]) (buf, sm);
+    if (pt > KING ) { (encodeFn[pt]) (buf, sm); }
+    else {
+        encodeKing(buf, sm, pos);
+    }
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -4171,7 +4239,7 @@
 //
 static errorT
 encodeVariation (ByteBuffer * buf, moveT * m, uint * subVarCount,
-                 uint * nagCount, uint depth)
+                 uint * nagCount, uint depth, Position * encpos)
 {
     ASSERT (m != NULL);
 
@@ -4180,8 +4248,8 @@
         buf->PutByte (ENCODE_COMMENT);
     }
 
-    while (m->marker != END_MARKER) {
-        encodeMove (buf, m);
+    while (m->marker != END_MARKER) {            
+        encodeMove (buf, m, encpos);         
         for (uint i=0; i < (uint) m->nagCount; i++) {
             buf->PutByte (ENCODE_NAG);
             buf->PutByte (m->nags[i]);
@@ -4195,10 +4263,14 @@
             for (uint i=0; i < m->numVariations; i++) {
                 *subVarCount += 1;
                 buf->PutByte (ENCODE_START_MARKER);
-                encodeVariation (buf, subVar->next, subVarCount, nagCount, depth+1);
+                Position * varencpos = new Position();
+                varencpos->CopyFrom(encpos);
+                encodeVariation (buf, subVar->next, subVarCount, nagCount, depth+1, varencpos);
+                delete varencpos;
                 subVar = subVar->varChild;
             }
         }
+        encpos->DoSimpleMove (&(m->moveData));
         m = m->next;
     }
     // At end, we output the end-variation or end-game token.
@@ -4501,7 +4573,10 @@
     // Now the movelist:
     uint varCount = 0;
     uint nagCount = 0;
-    err = encodeVariation (buf, FirstMove->next, &varCount, &nagCount, 0);
+    Position * encpos = new Position();
+    encpos->CopyFrom(StartPos);
+    err = encodeVariation (buf, FirstMove->next, &varCount, &nagCount, 0, encpos);
+    delete encpos;
     if (err != OK) { return err; }
 
     // Now do the comments
@@ -4689,6 +4764,7 @@
             NonStandardStart = 0;
             return err;
         }
+        StartPos->SetOwner(this);
         CurrentPos->CopyFrom (StartPos);
     }
 
@@ -4737,6 +4813,7 @@
             NonStandardStart = 0;
             return err;
         }
+        StartPos->SetOwner(this);
         *CurrentPos = *StartPos;
     }
 
Index: src/game.h
===================================================================
--- src/game.h	(revision 2575)
+++ src/game.h	(working copy)
@@ -327,6 +327,7 @@
     errorT     DecodeTags (ByteBuffer * buf, bool storeTags);
     errorT     DecodeVariation (ByteBuffer * buf, byte flags, uint level);
 
+
     //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     //  Game:  Public Functions
 public:
Index: src/movelist.h
===================================================================
--- src/movelist.h	(revision 2575)
+++ src/movelist.h	(working copy)
@@ -46,6 +46,11 @@
     squareT  epSquare;       // pre-move information
     ushort   oldHalfMoveClock;
     int      score;          // used for alpha/beta ordering.
+
+    squareT  kingFrom;
+    squareT  kingTo;
+    squareT  rookFrom;
+    squareT  rookTo;
 };
 
 inline bool isNullMove (simpleMoveT * sm)
Index: src/position.cpp
===================================================================
--- src/position.cpp	(revision 2575)
+++ src/position.cpp	(working copy)
@@ -14,6 +14,7 @@
 
 #include "common.h"
 #include "position.h"
+#include "game.h"
 #include "attacks.h"
 #include "misc.h"
 #include "sqlist.h"
@@ -295,6 +296,44 @@
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// Position::GetRookOrigSq():
+//    Get the original square of a rook
+//    Uses newly programmed pointer to the owner game so we
+//    can use it to find the rook in it's StartPos
+//
+squareT
+Position::GetRookOrigSq( colorT color, int dir ) {
+    Game * thisgame = GetOwner();
+    if ( thisgame != NULL ) {
+        Position * startpos = thisgame->GetStartPos();
+        if ( startpos != NULL ) {
+            pieceT * startboard = startpos->GetBoard();
+            squareT kSquare = startpos->GetKingSquare(color);
+            rankT kRank = square_Rank(kSquare);
+            pieceT friendlyRook = piece_Make(color, ROOK);
+            for (squareT sq = kSquare; square_Rank(sq) == kRank; sq=sq+dir) {
+                if (startboard[sq] == friendlyRook) {
+                    return sq;
+                }
+            }
+        }
+    }
+    // this below will have to change (so far at least) if there ever becomes an ECO for 
+    // non standard starts (like for interesting or popular 960 start positions)
+    else {
+        if (color == WHITE) {
+            if (dir == -1) { return A1; }
+            if (dir == 1) { return H1; }
+        }
+        if (color == BLACK) {
+            if (dir == -1) { return A8; }
+            if (dir == 1) { return H8; }
+        }
+    }
+    return NS;
+}
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Position::GenCastling():
 //    Generate the legal castling moves.
 //    Assumes the side to move is NOT in check, so the caller
@@ -305,44 +344,68 @@
 {
     ASSERT (! IsKingInCheck());
     squareT from = GetKingSquare(ToMove);
-    if (from != (ToMove == WHITE ? E1 : E8))  { return; }
     squareT enemyKingSq = GetEnemyKingSquare();
-    squareT target, skip, rookSq;
-    pieceT rookPiece;
+    
+    squareT krookOrig = GetRookOrigSq ( ToMove, 1 );
+    squareT qrookOrig = GetRookOrigSq ( ToMove, -1 );
 
-    // Try kingside first
+    for ( int dir = -1; dir < 2; dir++ ) {
+        if ( dir == 0 ) { continue; }
+        bool ok = false;
+        if ( dir == -1 and (!StrictCastling  ||  GetCastling (ToMove, QSIDE)) ) { ok = true; }
+        if ( dir == 1 and (!StrictCastling  ||  GetCastling (ToMove, KSIDE)) ) { ok = true; }
+        if ( ! ok ) { continue; }
 
-    // Kingside Castling:
-    if (!StrictCastling  ||  GetCastling (ToMove, KSIDE)) {
-        if (ToMove == WHITE) {
-            target = G1; skip = F1; rookSq = H1; rookPiece = WR;
-        } else {
-            target = G8; skip = F8; rookSq = H8; rookPiece = BR;
-        }
-        if (Board[target] == EMPTY  &&  Board[skip] == EMPTY
-                &&  Board[rookSq] == rookPiece
-                &&  CalcNumChecks (target) == 0
-                &&  CalcNumChecks (skip) == 0
-                &&  ! square_Adjacent (target, enemyKingSq)) {
-            AddLegalMove (mlist, from, target, EMPTY);
-        }
-    }
+        for ( squareT rookSq = from; square_Rank(rookSq) == square_Rank(from); rookSq=rookSq+dir ) {
+            if ( Board[rookSq] == piece_Make(ToMove, ROOK) ) { 
+                if ( dir == -1 && rookSq != qrookOrig ) { break; } // correct side, wrong rook
+                if ( dir == 1 && rookSq != krookOrig ) { break; } // correct side, wrong rook
+                squareT furthest_left, furthest_right, king_left, king_right;
+                squareT kdest, rdest;
+                squareT kingSq = from;
 
-    // Queenside Castling:
-    if (!StrictCastling  ||  GetCastling (ToMove, QSIDE)) {
-        if (ToMove == WHITE) {
-            target = C1; skip = D1; rookSq = A1; rookPiece = WR;
-        } else {
-            target = C8; skip = D8; rookSq = A8; rookPiece = BR;
+                if ( dir > 0 ) {
+                    kdest = (ToMove == WHITE ? G1 : G8);
+                    rdest = (ToMove == WHITE ? F1 : F8);
+                }
+                if (dir < 0) {
+                    kdest = (ToMove == WHITE ? C1 : C8);
+                    rdest = (ToMove == WHITE ? D1 : D8);
+                }
+                furthest_left = kdest;
+                if (kingSq < furthest_left) { furthest_left = kingSq; }
+                if (rookSq < furthest_left) { furthest_left = rookSq; }
+                if (rdest < furthest_left) { furthest_left = rdest; }
+
+                king_left = kdest;
+                if (kingSq < king_left) { king_left = kingSq; }
+
+                furthest_right = kdest;
+                if (kingSq > furthest_right) { furthest_right = kingSq; }
+                if (rookSq > furthest_right) { furthest_right = rookSq; }
+                if (rdest > furthest_right) { furthest_right = rdest; }
+
+                king_right = kdest;
+                if (kingSq > king_right) { king_right = kingSq; }
+                
+                bool ok2 = true;
+                for (squareT sq = king_left; sq <= king_right; sq++) {
+                    if (CalcNumChecks(sq) > 0) { ok2 = false; break; }
+                    if (square_Adjacent (sq, enemyKingSq)) { ok2 = false; break; }
+                }
+
+                if ( ! ok2 ) { break; }
+
+                uint piececount = 0;
+                for (squareT sq = furthest_left; sq <= furthest_right; sq++) {
+                    if (Board[sq] != EMPTY) { piececount++ ; }
+                }
+                if (piececount > 2) { break; }
+
+                AddLegalMove (mlist, from, rookSq, EMPTY);
+                break;
+            }
         }
-        if (Board[target] == EMPTY  &&  Board[skip] == EMPTY
-                &&  Board[rookSq] == rookPiece
-                &&  Board[target - 1] == EMPTY // B1 or B8 must be empty too!
-                &&  CalcNumChecks (target) == 0
-                &&  CalcNumChecks (skip) == 0
-                &&  ! square_Adjacent (target, enemyKingSq)) {
-            AddLegalMove (mlist, from, target, EMPTY);
-        }
     }
 }
 
@@ -563,9 +626,10 @@
 //      Initialise the position after it is constructed.
 //
 void
-Position::Init (void)
+Position::Init (Game * owner)
 {
     // Setting up a valid board is left to StdStart() or Clear().
+    Owner = owner;
     Board [COLOR_SQUARE] = EMPTY;
     Board [NULL_SQUARE] = END_OF_BOARD;
 	LegalMoves.Clear();
@@ -1252,51 +1316,83 @@
     squareT kingSq = GetKingSquare(ToMove);
     sint diff = (int)target - (int) kingSq;
 
-    // Valid diffs are: -9, -8, -7, -2, -1, 1, 2, 7, 8, 9. (-2,2: Castling)
-
-    if (diff < -9  ||  diff > 9) { return ERROR_InvalidMove; }
-    if (diff > -7  &&  diff < -2) { return ERROR_InvalidMove; }
-    if (diff > 2  &&  diff < 7) { return ERROR_InvalidMove; }
     if (diff == 0) { return ERROR_InvalidMove; }
 
-    if (diff == 2) { // KingSide Castling
-        if (kingSq != (ToMove == WHITE ? E1 : E8)) {
-            return ERROR_InvalidMove;
+    squareT rookSq;
+    rankT kingRnk = square_Rank(kingSq);
+    rankT targetRnk = square_Rank(target);
+
+    bool castle_attempt = false;
+    if ( Board[target] == piece_Make(ToMove, ROOK) ) { 
+        castle_attempt = true; 
+    }
+    if (! castle_attempt) {
+        if (targetRnk != kingRnk) {
+            if (diff < -9  ||  diff > 9) { return ERROR_InvalidMove; }
+            if (diff > -6  &&  diff < 6) { return ERROR_InvalidMove; }
         }
-        if (StrictCastling  &&  ! GetCastling (ToMove, KSIDE)) {
-            return ERROR_InvalidMove;
+        else if ( diff > 1 || diff < -1 ) { return ERROR_InvalidMove; }
+    }
+
+    //check for all squares king has to move not touched by king or in check
+    //check all furthest  only occupied by 2 pieces
+
+    squareT enemyKingSq = GetEnemyKingSquare();
+
+    if (castle_attempt) {
+        rookSq = target;
+
+        squareT furthest_left, furthest_right, king_left, king_right;
+        squareT kdest, rdest;
+
+        if ( diff > 0 ) { // KingSide Castling
+            if ( rookSq != GetRookOrigSq ( ToMove, 1 ) ) { return ERROR_InvalidMove; }
+            kdest = (ToMove == WHITE ? G1 : G8);
+            rdest = (ToMove == WHITE ? F1 : F8);
         }
+        if (diff < 0) { // Queenside Castling
+            if ( rookSq != GetRookOrigSq ( ToMove, -1 ) ) { return ERROR_InvalidMove; }
+            kdest = (ToMove == WHITE ? C1 : C8);
+            rdest = (ToMove == WHITE ? D1 : D8);
+        }
 
-        // XXX We also need to verify that the target square does not
-        //     lie adjacent to the location of the enemy king!
+        furthest_left = kdest;
+        if (kingSq < furthest_left) { furthest_left = kingSq; }
+        if (rookSq < furthest_left) { furthest_left = rookSq; }
+        if (rdest < furthest_left) { furthest_left = rdest; }
 
-        if (Board[kingSq + 1] != EMPTY  ||  Board[kingSq + 2] != EMPTY
-            ||  CalcNumChecks(kingSq) > 0
-            ||  CalcNumChecks(kingSq + 1) > 0
-            ||  CalcNumChecks(kingSq + 2) > 0) {
-            return ERROR_InvalidMove;
+        king_left = kdest;
+        if (kingSq < king_left) { king_left = kingSq; }
+
+        furthest_right = kdest;
+        if (kingSq > furthest_right) { furthest_right = kingSq; }
+        if (rookSq > furthest_right) { furthest_right = rookSq; }
+        if (rdest > furthest_right) { furthest_right = rdest; }
+
+        king_right = kdest;
+        if (kingSq > king_right) { king_right = kingSq; }
+
+        for (squareT sq = king_left; sq <= king_right; sq++) {
+            if (CalcNumChecks(sq) > 0) { return ERROR_InvalidMove; }
         }
-        AddLegalMove (mlist, kingSq, target, EMPTY);
-        return OK;
-    }
 
-    if (diff == -2) { // Queenside Castling
-        if (kingSq != (ToMove == WHITE ? E1 : E8)) {
-            return ERROR_InvalidMove;
+        uint piececount = 0;
+        for (squareT sq = furthest_left; sq <= furthest_right; sq++) {
+            if (Board[sq] != EMPTY) { piececount++ ; }
         }
-        if (StrictCastling  &&  ! GetCastling (ToMove, QSIDE)) {
-            return ERROR_InvalidMove;
+        if (piececount > 2) { return ERROR_InvalidMove; }
+
+        bool ok2 = true;
+        for (squareT sq = king_left; sq <= king_right; sq++) {
+            if (CalcNumChecks(sq) > 0) { ok2 = false; break; }
+            if (square_Adjacent (sq, enemyKingSq)) { ok2 = false; break; }
         }
-        if (Board[kingSq - 1] != EMPTY  ||  Board[kingSq - 2] != EMPTY
-            ||  Board[kingSq - 3] != EMPTY
-            ||  CalcNumChecks(kingSq) > 0
-            ||  CalcNumChecks(kingSq - 1) > 0
-            ||  CalcNumChecks(kingSq - 2) > 0) {
-            return ERROR_InvalidMove;
-        }
+        if (!ok2) { return ERROR_InvalidMove; }
+
         AddLegalMove (mlist, kingSq, target, EMPTY);
         return OK;
     }
+
     pieceT captured = Board[target];
     if (piece_Color(captured) == ToMove) {
         // Capturing a friendly piece!
@@ -1307,6 +1403,8 @@
     // leaves the King in check:
     // XXX We should also check for adjacency to enemy King!!
 
+    // why not get rid of :
+    /*
     Board[target] = piece_Make(ToMove, KING);
     Board[kingSq] = EMPTY;
     if (captured != EMPTY) { Material[captured]--; }
@@ -1319,10 +1417,18 @@
         AddLegalMove (mlist, kingSq, target, EMPTY);
         return OK;
     }
+    */
+    // and just do:
+    if ( CalcNumChecks(target) == 0 && ! square_Adjacent (target, enemyKingSq) ) {
+        AddLegalMove (mlist, kingSq, target, EMPTY);
+        return OK;
+    }
+
+
+
     return ERROR_InvalidMove;
 }
 
-
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Position::GenCheckEvasions():
 //      Generate legal moves for the side to move when the
@@ -1820,6 +1926,25 @@
     sm->epSquare = EPTarget;
     sm->oldHalfMoveClock = HalfMoveClock;
 
+    sm->kingTo = NS;
+    sm->kingFrom = NS;
+    sm->rookFrom = NS;
+    sm->rookTo = NS;
+
+    if ( ptype == KING && Board[to] == piece_Make( ToMove, ROOK) ) { 
+        sm->capturedPiece = EMPTY; 
+        sm->kingFrom = from;
+        sm->rookFrom = to;
+        if (from < to) {  //kingside
+            sm->kingTo = ( ToMove == WHITE ? G1 : G8 );
+            sm->rookTo = ( ToMove == WHITE ? F1 : F8 );
+        }
+        else {  //queenside
+            sm->kingTo = ( ToMove == WHITE ? C1 : C8 );
+            sm->rookTo = ( ToMove == WHITE ? D1 : D8 );
+        }
+    }
+
     HalfMoveClock++;
     PlyCounter++;
 	LegalMoves.Clear();
@@ -1871,28 +1996,30 @@
     }
 
     // now make the move:
-    List[ToMove][sm->pieceNum] = to;
-    ListPos[to] = sm->pieceNum;
-    RemoveFromBoard (p, from);
-    AddToBoard (p, to);
+    if ( sm->kingFrom == NS ) { // not castling
+        List[ToMove][sm->pieceNum] = to;
+        ListPos[to] = sm->pieceNum;
+        RemoveFromBoard (p, from);
+        AddToBoard (p, to);
+    }
 
     // handle Castling:
 
-    if (ptype == KING  &&  square_Fyle(from) == E_FYLE  &&
-            (square_Fyle(to) == C_FYLE  ||  square_Fyle(to) == G_FYLE)) {
-        squareT rookfrom, rookto;
+    if ( sm->kingFrom != NS ) { // castling
         pieceT rook = piece_Make (ToMove, ROOK);
-        if (square_Fyle(to) == C_FYLE) {
-            rookfrom = to - 2;
-            rookto = to + 1;
-        } else {
-            rookfrom = to + 1;
-            rookto = to - 1;
-        }
-        ListPos[rookto] = ListPos[rookfrom];
-        List[ToMove][ListPos[rookto]] = rookto;
-        RemoveFromBoard (rook, rookfrom);
-        AddToBoard (rook, rookto);
+
+        byte king_pieceNum = sm->pieceNum;
+        byte rook_pieceNum = ListPos[sm->rookFrom];
+
+        List[ToMove][king_pieceNum] = sm->kingTo;
+        List[ToMove][rook_pieceNum] = sm->rookTo;
+        ListPos[sm->kingTo] = king_pieceNum;
+        ListPos[sm->rookTo] = rook_pieceNum;
+
+        RemoveFromBoard (p, sm->kingFrom);
+        RemoveFromBoard (rook, sm->rookFrom);
+        AddToBoard (p, sm->kingTo);
+        AddToBoard (rook, sm->rookTo);
     }
 
     // Handle clearing of castling flags:
@@ -1903,6 +2030,7 @@
             SetCastling (ToMove, KSIDE, false);
         }
         // See if a rook moved or was captured:
+/*
         if (ToMove == WHITE) {
             if (from == A1)  { SetCastling (WHITE, QSIDE, false); }
             if (from == H1)  { SetCastling (WHITE, KSIDE, false); }
@@ -1914,6 +2042,24 @@
             if (to == A1)    { SetCastling (WHITE, QSIDE, false); }
             if (to == H1)    { SetCastling (WHITE, KSIDE, false); }
         }
+*/
+
+        squareT WKR_sq = GetRookOrigSq ( WHITE, 1 );
+        squareT WQR_sq = GetRookOrigSq ( WHITE, -1 );
+        squareT BKR_sq = GetRookOrigSq ( BLACK, 1 );
+        squareT BQR_sq = GetRookOrigSq ( BLACK, -1 );
+
+        if (ToMove == WHITE) {
+            if (from == WQR_sq)  { SetCastling (WHITE, QSIDE, false); }
+            if (from == WKR_sq)  { SetCastling (WHITE, KSIDE, false); }
+            if (to == BQR_sq)    { SetCastling (BLACK, QSIDE, false); }
+            if (to == BKR_sq)    { SetCastling (BLACK, KSIDE, false); }
+        } else {
+            if (from == BQR_sq)  { SetCastling (BLACK, QSIDE, false); }
+            if (from == BKR_sq)  { SetCastling (BLACK, KSIDE, false); }
+            if (to == WQR_sq)    { SetCastling (WHITE, QSIDE, false); }
+            if (to == WKR_sq)    { SetCastling (WHITE, KSIDE, false); }
+        }
     }
 
     // Set the EPTarget square, if a pawn advanced two squares and an
@@ -2000,29 +2146,37 @@
 
     // now make the move:
 
-    List[ToMove][m->pieceNum] = from;
-    ListPos[from] = m->pieceNum;
-    RemoveFromBoard (p, to);
-    AddToBoard (p, from);
-    if (m->capturedPiece != EMPTY) {
-        AddToBoard (m->capturedPiece, m->capturedSquare);
+    if ( m->kingFrom > H8 ) { // not castling
+        List[ToMove][m->pieceNum] = from;
+        ListPos[from] = m->pieceNum;
+        RemoveFromBoard (p, to);
+        AddToBoard (p, from);
+        if (m->capturedPiece != EMPTY) {
+            AddToBoard (m->capturedPiece, m->capturedSquare);
+        }
     }
 
     // handle Castling:
 
-    if ((piece_Type(p) == KING) && square_Fyle(from) == E_FYLE
-            && (square_Fyle(to) == C_FYLE || square_Fyle(to) == G_FYLE)) {
-        squareT rookfrom, rookto;
+    if ( m->kingFrom <= H8 ) { // castling
+        m->pieceNum = ListPos[m->kingTo];
+        p = Board[m->kingTo];
         pieceT rook = (ToMove == WHITE? WR : BR);
-        if (square_Fyle(to) == C_FYLE) {
-            rookfrom = to - 2;   rookto = to + 1;
-        } else {
-            rookfrom = to + 1;   rookto = to - 1;
-        }
-        ListPos[rookfrom] = ListPos[rookto];
-        List[ToMove][ListPos[rookto]] = rookfrom;
-        RemoveFromBoard (rook, rookto);
-        AddToBoard (rook, rookfrom);
+
+        byte king_pieceNum = m->pieceNum;
+        byte rook_pieceNum = ListPos[m->rookTo];
+
+        List[ToMove][king_pieceNum] = m->kingFrom;
+        List[ToMove][rook_pieceNum] = m->rookFrom;
+        ListPos[m->kingFrom] = king_pieceNum;
+        ListPos[m->rookFrom] = rook_pieceNum;
+
+        RemoveFromBoard (p, m->kingTo);
+        RemoveFromBoard (rook, m->rookTo);
+        AddToBoard (p, m->kingFrom);
+        AddToBoard (rook, m->rookFrom);
+
+        m->to = m->rookFrom;
     }
 
 #ifdef ASSERTIONS
@@ -2136,6 +2290,7 @@
 
     // Make sure m->pieceNum is updated:
     m->pieceNum = ListPos[m->from];
+
     pieceT  p    = piece_Type (Board[List[ToMove][m->pieceNum]]);
     squareT from = List[ToMove][m->pieceNum];
     squareT to   = m->to;
@@ -2158,11 +2313,13 @@
             //*c++ = 'n'; *c++ = 'u'; *c++ = 'l'; *c++ = 'l';
             *c++ = '-'; *c++ = '-';
         } else
-        if ((square_Fyle(from)==E_FYLE) && (square_Fyle(to)==G_FYLE)) {
-            *c++ = 'O'; *c++ = '-'; *c++ = 'O';
-        } else
-        if ((square_Fyle(from)==E_FYLE) && (square_Fyle(to)==C_FYLE)) {
-            *c++ = 'O'; *c++ = '-'; *c++ = 'O'; *c++ = '-'; *c++ = 'O';
+        if ( Board[to] == piece_Make(ToMove,ROOK) ) {
+            if (from < to) {
+                *c++ = 'O'; *c++ = '-'; *c++ = 'O';
+            }
+            else {
+                *c++ = 'O'; *c++ = '-'; *c++ = 'O'; *c++ = '-'; *c++ = 'O';
+            }
         } else {  // regular King move
             *c++ = 'K';
             if (Board[to] != EMPTY)  *c++ = 'x';
@@ -2430,9 +2587,22 @@
     // Here we handle piece moves, including castling
     if (token != TOKEN_Move_Piece) {  // Must be castling move
         ASSERT (token == TOKEN_Move_Castle_King  ||  token == TOKEN_Move_Castle_Queen);
-        from = (ToMove == WHITE ? E1 : E8);
-        if (GetKingSquare(ToMove) != from) { return ERROR_InvalidMove; }
-        to = (token == TOKEN_Move_Castle_King ? (from + 2) : (from - 2));
+
+        rankT kingrank;
+        from = GetKingSquare(ToMove);
+        kingrank = square_Rank(from);
+
+        int direction = ( token == TOKEN_Move_Castle_King ? 1 : -1 );
+
+        for (squareT sq = from + direction; square_Rank(sq) == kingrank; sq = sq + direction) {
+            if ( Board[sq] == piece_Make(ToMove, ROOK) ) {
+                to = sq;
+                break;
+            }
+        }
+
+        if (to == NS) { return ERROR_InvalidMove; }
+
         if (MatchKingMove (&mlist, to) != OK) {
             return ERROR_InvalidMove;
         } else {
@@ -3031,10 +3201,97 @@
         if (Castling == 0)  {
             *str++ = '-';
         } else {
-            if (GetCastling (WHITE, KSIDE))  { *str++ = 'K'; }
-            if (GetCastling (WHITE, QSIDE))  { *str++ = 'Q'; }
-            if (GetCastling (BLACK, KSIDE))  { *str++ = 'k'; }
-            if (GetCastling (BLACK, QSIDE))  { *str++ = 'q'; }
+            Game * thisgame = GetOwner();
+            Position * startpos = NULL;
+            if ( thisgame != NULL ) { startpos = thisgame->GetStartPos(); }
+
+            if ( startpos ) {
+                squareT wking_sq = GetKingSquare(WHITE);
+                squareT bking_sq = GetKingSquare(BLACK);
+
+                squareT orig_white_king_rook_sq = GetRookOrigSq(WHITE,1);
+                squareT orig_white_queen_rook_sq = GetRookOrigSq(WHITE,-1);
+                squareT orig_black_king_rook_sq = GetRookOrigSq(BLACK,1);
+                squareT orig_black_queen_rook_sq = GetRookOrigSq(BLACK,-1);
+
+                squareT white_king_outer_rook_sq = NS;
+                squareT white_king_inner_rook_sq = NS;
+                squareT white_queen_outer_rook_sq = NS;
+                squareT white_queen_inner_rook_sq = NS;
+                squareT black_king_outer_rook_sq = NS;
+                squareT black_king_inner_rook_sq = NS;
+                squareT black_queen_outer_rook_sq = NS;
+                squareT black_queen_inner_rook_sq = NS;
+
+                for (int i=0; i<8; i++) {
+                    int wsq = A1+i;
+                    int bsq = A8+i;
+                    if ( Board[wsq] == WR) {
+                        if ( wsq < wking_sq ) { //queenside
+                            if ( white_queen_outer_rook_sq == NS ) { 
+                                white_queen_outer_rook_sq = wsq; 
+                                white_queen_inner_rook_sq = wsq;
+                            }
+                            else { white_queen_inner_rook_sq = wsq; }
+                        }
+                        else { //kingside
+                            if ( white_king_inner_rook_sq == NS ) { 
+                                white_king_inner_rook_sq = wsq; 
+                                white_king_outer_rook_sq = wsq;
+                            }
+                            else { white_king_outer_rook_sq = wsq; }
+                        }
+                    }
+                    if ( Board[bsq] == BR ) {
+                        if ( bsq < bking_sq ) { //queenside
+                            if ( black_queen_outer_rook_sq == NS ) { 
+                                black_queen_outer_rook_sq = bsq; 
+                                black_queen_inner_rook_sq = bsq;
+                            }
+                            else { black_queen_inner_rook_sq = bsq; }
+                        }
+                        else { //kingside
+                            if ( black_king_inner_rook_sq == NS ) { 
+                                black_king_inner_rook_sq = bsq; 
+                                black_king_outer_rook_sq = bsq;
+                            }
+                            else { black_king_outer_rook_sq = bsq; }
+                        }
+                    }
+                }
+
+                bool something = false;
+
+                if ( GetCastling (WHITE, KSIDE) ) {
+                    if ( white_king_outer_rook_sq != orig_white_king_rook_sq )  { *str++ = square_Fyle(white_king_inner_rook_sq) + 'A'; }
+                    else { *str++ = 'K'; }
+                    something = true;
+                }
+                if ( GetCastling (WHITE, QSIDE) ) {
+                    if ( white_queen_outer_rook_sq != orig_white_queen_rook_sq )  { *str++ = square_Fyle(white_queen_inner_rook_sq) + 'A'; }
+                    else { *str++ = 'Q'; }
+                    something = true;
+                }
+                if ( GetCastling (BLACK, KSIDE) ) {
+                    if ( black_king_outer_rook_sq != orig_black_king_rook_sq )  { *str++ = square_Fyle(black_king_inner_rook_sq) + 'a'; }
+                    else { *str++ = 'k'; }
+                    something = true;
+                }
+                if ( GetCastling (BLACK, QSIDE) ) {
+                    if ( black_queen_outer_rook_sq != orig_black_queen_rook_sq )  { *str++ = square_Fyle(black_queen_inner_rook_sq) + 'a'; }
+                    else { *str++ = 'q'; }
+                    something = true;
+                }
+
+                if ( ! something ) { *str++ = '-'; }
+            }
+
+            else {
+                if (GetCastling (WHITE, KSIDE))  { *str++ = 'K'; }
+                if (GetCastling (WHITE, QSIDE))  { *str++ = 'Q'; }
+                if (GetCastling (BLACK, KSIDE))  { *str++ = 'k'; }
+                if (GetCastling (BLACK, QSIDE))  { *str++ = 'q'; }
+            }
         }
         *str++ = ' ';
 
Index: src/position.h
===================================================================
--- src/position.h	(revision 2575)
+++ src/position.h	(working copy)
@@ -24,6 +24,8 @@
 #include "sqset.h"
 #include "tokens.h"
 
+class Game;
+
 //////////////////////////////////////////////////////////////////////
 //  Position:  Constants
 
@@ -77,6 +79,8 @@
     //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     //  Position:  Data structures
 
+    Game *          Owner;
+
     pieceT          Board[66];      // the actual board + a color square
                                     // and a NULL square.
     uint            Count[2];       // count of pieces & pawns each
@@ -157,11 +161,12 @@
   }
 
 #endif
-    Position()   { Init(); }
+    Position()   { Init( NULL ); }
+    Position(Game * owner)   { Init( owner ); }
     Position(const Position& p);
     ~Position()  {}
 
-    void        Init();
+    void        Init(Game * owner);
     void        Clear();        // No pieces on board
     void        StdStart();     // Standard chess starting position
     bool        IsStdStart();
@@ -179,6 +184,11 @@
     ushort      GetPlyCounter ()         { return PlyCounter; }
     ushort      GetFullMoveCount ()      { return PlyCounter / 2 + 1; }
 
+    Game *      GetOwner()               { return Owner; }
+    void        SetOwner(Game * owner)   { Owner = owner; }
+
+    squareT     GetRookOrigSq( colorT color, int dir );
+
     // Methods to get the Board or piece lists -- used in game.cpp to
     // decode moves:
     squareT *   GetList (colorT c)    { return List[c]; }
Index: src/tkscid.cpp
===================================================================
--- src/tkscid.cpp	(revision 2575)
+++ src/tkscid.cpp	(working copy)
@@ -516,8 +516,8 @@
     clipbase->backupCache->SetPolicy (TREECACHE_Oldest);
 
     currentBase = 0;
-    scratchPos = new Position;
     scratchGame = new Game;
+    scratchPos = new Position(scratchGame);
     db = &(dbList[currentBase]);
 
 #ifndef TCL_ONLY
@@ -14947,6 +14947,7 @@
         char cboard [40];
         pos->PrintCompactStrFlipped (cboard);
         posFlip->ReadFromCompactStr ((byte *) cboard);
+        posFlip->SetOwner(db->game);
         hpSigFlip = posFlip->GetHPSig();
         msigFlip = matsig_Make (posFlip->GetMaterial());
     }
Index: tcl/edit.tcl
===================================================================
--- tcl/edit.tcl	(revision 2575)
+++ tcl/edit.tcl	(working copy)
@@ -63,6 +63,9 @@
       set fenStr "$s1 $s2 [lrange $fenStr 2 end]"
   }
 
+  # Handle Shredder fen's HAha type castling field
+  set fenStr [::chess960::convertToXFEN $fenStr]
+
   if {[catch {sc_game startBoard $fenStr}]} {
     # Trim length, and remove newlines for error dialog
     if {[string length $fenStr] > 80} {
@@ -322,6 +325,9 @@
 proc validateFEN {fen} {
   global setupFen
 
+  # Don't worry about validating castling in chess960
+  return $fen
+
   #### Do a sanity check on castling
   #    .. helpful because illegal FENs crash engines
   #    and we could also have one for enpassant
@@ -638,6 +644,20 @@
     makeSetupFen
   } -width 10
 
+  frame $sr.b.960
+
+  label $sr.b.960.text -text "960 code"
+  entry $sr.b.960.entry -width 4 -validate all -vcmd {string is int %P}
+  pack $sr.b.960.text $sr.b.960.entry -side left
+
+  bind  $sr.b.960.entry <Return> {
+    set SP [expr [.setup.r.b.960.entry get] %% 960]
+    if {$SP == 0} {set SP 960}
+    set setupFen  [::chess960::numberToFEN $SP]
+    sc_game tags set -extra [list {Variant "Fischerandom"} "StartingPosition \"$SP\""]
+    setSetupBoardToFen
+  }
+
  # Are these bullet-proof and correct ? 
 
   button $sr.b.swap -text {Swap Colours} -command {
@@ -695,6 +715,7 @@
   pack $sr.b		-side top -pady 10
   pack $sr.b.clear	-side top -padx 5 -pady 2
   pack $sr.b.initial	-side top -padx 5 -pady 2
+  pack $sr.b.960        -side top -expand yes -fill x
   pack [frame $sr.b.space -height 10] -side top
   pack $sr.b.swap	-side top -padx 5 -pady 2
   pack $sr.b.invert	-side top -padx 5 -pady 2
Index: tcl/main.tcl
===================================================================
--- tcl/main.tcl	(revision 2575)
+++ tcl/main.tcl	(working copy)
@@ -1296,6 +1296,7 @@
 #   piece from the user.
 #   If the optional parameter is "-animate", the move will be animated.
 
+#   sq1 == to, sq2 == from , but squares can also be selected in reverse order
 proc addMove { sq1 sq2 {animate ""}} {
   global EMPTY
 
@@ -1317,8 +1318,44 @@
     if {$k1 == "k"  &&  $k2 == "k"} {
       set nullmove 1
     } else {
-      return
-    }
+      # test/hack to see if we can translate old-style castling into 960 castling
+
+      set side [sc_pos side]
+      if {(($k1 == "k" && $k2 == ".") || ($k2 == "k" && $k1 == ".")) && [expr {abs ($sq1 - $sq2)}] == 2} {
+	  if {$k1 == "k"} {
+	    # test correct-side-to-move
+	    set king [string index $board $sq1]
+	    if {$side == "white" && $king == "k" || $side == "black" && $king == "K"} {return}
+
+	    set sign [expr {($sq2 - $sq1)/2}]
+            set sq2 [expr {$sq2 - $sign}] ; # to check neighbouring square
+            #incr sq2 till we hit a rook
+
+	    while {[string index $board $sq2] == "."} {
+	       incr sq2 $sign
+	    }
+            if {[string tolower [string index $board $sq2]] != "r"} {
+              return
+            }
+          } else {
+	    ### {$k2 == "k"}
+	    # test correct-side-to-move
+	    set king [string index $board $sq2]
+	    if {$side == "white" && $king == "k" || $side == "black" && $king == "K"} {return}
+
+	    set sign [expr {($sq1 - $sq2)/2}]
+            set sq1 [expr {$sq1 - $sign}]
+	    while {[string index $board $sq1] == "."} {
+	       incr sq1 $sign
+	    }
+            if {[string tolower [string index $board $sq1]] != "r"} {
+              return
+            }
+          }
+      } else {
+	return 
+      }
+    } 
   }
   if {$nullmove && [sc_pos isCheck]} {
       # dont add null move in check or mate
Index: tcl/misc/misc.tcl
===================================================================
--- tcl/misc/misc.tcl	(revision 2575)
+++ tcl/misc/misc.tcl	(working copy)
@@ -1093,4 +1093,187 @@
   unbusyCursor .  
 }
 
+namespace eval chess960 {}
+
+proc ::chess960::Outermost {side col} {
+	variable board	;# is array[2] of { LHS King RHS }
+
+	set index [expr {[lindex $board $side 1] ? 2 : 0}]
+	set c [lindex $board $side $index]
+
+	if {$c == 0 || ($index == 0 ? $col < $c : $c < $col)} {
+		lset board $side $index $col
+	}
+}
+
+
+proc ::chess960::Setup {str} {
+	variable board	;# is array[2] of { LHS King RHS }
+
+	set row 1
+	set col 1
+
+	foreach ch [split $str ""] {
+		if {[string is digit $ch]} {
+			incr col [expr {[scan $ch "%c"] - 48}] ;# "0" has ASCII 48
+		} else {
+			switch $ch {
+				"/" { incr row; set col 0 }
+				"R" { if {$row == 8} { Outermost 0 $col } }
+				"r" { if {$row == 1} { Outermost 1 $col } }
+				"K" { if {$row == 8} { lset board 0 1 $col } }
+				"k" { if {$row == 1} { lset board 1 1 $col } }
+			}
+
+			incr col
+		}
+	}
+
+	if {[lindex $board 0 1] == 0 && [lindex $board 1 1] == 0} {
+		return 0
+	}
+
+	return 1
+}
+
+
+proc ::chess960::MapPiece {side index ch} {
+	variable board	;# is array[2] of { LHS King RHS }
+
+	set col [lindex $board $side $index]
+	if {$col} {
+		return [format "%c" [expr {$col + ($side ? 96 : 64)}]] ;# 64 is 'A'-1; 96 is 'a'-1
+	}
+	return $ch
+}
+
+
+# Convert X-FEN to Shredder-FEN.
+#
+# This function expects a valid FEN, otherwise the result is undetermined.
+# It doesn't matter if the given FEN is already a Shredder-FEN.
+proc ::chess960::convertToShredder {fen} {
+	variable board	;# is array[2] of { LHS King RHS }
+
+	if {[llength $fen] < 3} {
+		return $fen
+	}
+
+	set board {{0 0 0} {0 0 0}}
+
+	if {![Setup [lindex $fen 0]]} {
+		return $fen
+	}
+
+	set rights ""
+
+	foreach ch [split [lindex $fen 2] ""] {
+		switch $ch {
+			"K" { append rights [MapPiece 0 2 "K"] }
+			"Q" { append rights [MapPiece 0 0 "Q"] }
+			"k" { append rights [MapPiece 1 2 "k"] }
+			"q" { append rights [MapPiece 1 0 "q"] }
+
+			default { append rights $ch }
+		}
+	}
+
+	lset fen 2 $rights
+	return $fen
+}
+
+
+# Convert Shredder-FEN to X-FEN.
+#
+# This function expects a valid FEN, otherwise the result is undetermined.
+# It doesn't matter if the given FEN is already a X-FEN.
+proc ::chess960::convertToXFEN {fen} {
+	variable board	;# is array[2] of { LHS King RHS }
+
+	if {[llength $fen] < 3} {
+		return $fen
+	}
+
+	set board {{0 0 0} {0 0 0}}
+
+	if {![Setup [lindex $fen 0]]} {
+		return $fen
+	}
+
+	set rights ""
+
+	foreach ch [split [lindex $fen 2] ""] {
+		if {[string is upper $ch]} {
+			set file [expr {[scan $ch "%c"] - 64}] ;# 64 is 'A'-1
+
+			if {$file == [lindex $board 0 0]} {
+				append rights "Q"
+			} elseif {$file == [lindex $board 0 2]} {
+				append rights "K"
+			} else {
+				append rights $ch
+			}
+		} elseif {[string is lower $ch]} {
+			set file [expr {[scan $ch "%c"] - 96}] ;# 96 is 'a'-1
+
+			if {$file == [lindex $board 1 0]} {
+				append rights "q"
+			} elseif {$file == [lindex $board 1 2]} {
+				append rights "k"
+			} else {
+				append rights $ch
+			}
+		} else {
+			append rights $ch
+		}
+	}
+
+	lset fen 2 $rights
+	return $fen
+}
+
+
+proc ::chess960::numberToFEN {number} {
+	set KRN {"NNRKR" "NRNKR" "NRKNR" "NRKRN" "RNNKR" "RNKNR" "RNKRN" "RKNNR" "RKNRN" "RKRNN"}
+	set pattern "XXXXXXXX"
+	set number [expr {$number%960}]
+
+	set r [expr {$number%4}]
+	set q [expr {$number/4}]
+	set m [expr {$r*2 + 1}]
+	set r [expr {$q%4}]
+	set q [expr {$q/4}]
+	set n [expr {$r*2}]
+	set r [expr {$q%6}]
+	set q [expr {$q/6}]
+
+	set pattern [string replace $pattern $m $m "B"]
+	set pattern [string replace $pattern $n $n "B"]
+
+	for {set i 0} {$i < 8} {incr i} {
+		set ch [string index $pattern $i]
+		if {$ch eq "X" && [incr r -1] == -1} {
+			break;
+		}
+	}
+	set pattern [string replace $pattern $i $i "Q"]
+
+	set n 0
+	set krn [lindex $KRN $q]
+	for {set i 0} {$i < 8} {incr i} {
+		set ch [string index $pattern $i]
+		if {$ch eq "X"} {
+			set pattern [string replace $pattern $i $i [string index $krn $n]]
+			incr n
+		}
+	}
+
+	append fen [string tolower $pattern]
+	append fen "/pppppppp/8/8/8/8/PPPPPPPP/"
+	append fen $pattern
+	append fen " w KQkq - 0 1"
+
+	return $fen
+}
+
 # end of misc.tcl
Index: tcl/start.tcl
===================================================================
--- tcl/start.tcl	(revision 2575)
+++ tcl/start.tcl	(working copy)
@@ -45,10 +45,10 @@
 
 if {![catch {tk windowingsystem} wsystem] && $wsystem == "aqua"} {
   set macOS 1
-  set scidName {Scid vs. Mac}
+  set scidName {Scid vs. Mac 360}
 } else {
   set macOS 0
-  set scidName {Scid vs. PC}
+  set scidName {Scid vs. 360}
 }
 
 # See if we're inside a Mac .app bundle.  This duplcates part of the command-line
Index: tcl/tools/analysis.tcl
===================================================================
--- tcl/tools/analysis.tcl	(revision 2575)
+++ tcl/tools/analysis.tcl	(working copy)
@@ -3639,6 +3639,7 @@
     # proc is called for any change in board position (including new games, and simple moves)
     set nonStdStart [sc_game startBoard]
     if {$nonStdStart} {
+      sendToEngine $n "setoption name UCI_Chess960 value true"
       set analysis(startpos$n) "fen [sc_game startPos]"
     } else {
       set analysis(startpos$n) startpos
Index: tcl/tools/fics.tcl
===================================================================
--- tcl/tools/fics.tcl	(revision 2575)
+++ tcl/tools/fics.tcl	(working copy)
@@ -2157,6 +2157,7 @@
       wm title $::dot_w "$::scidName: $white - $black (game $game: $::fics::timecontrol)"
       updateBoard -pgn -animate
     } else {
+puts "HMMMM \n$fen \n[sc_pos fen]"
       ### Game out of sync, probably due to player takeback request (or opponent take back 2).
       ### But also used to load observed games
       # After player takeback, game gets reconstructed, comments are zeroed. Opponents takeback is handled better elsewhere.
@@ -2564,12 +2565,18 @@
 
   proc checkAdd {} {
     if {$::fics::playing == 1 && [winfo exists .fics]}  {
-      set moveUCI [sc_game info previousMoveUCI]
-      if { [ string length $moveUCI ] == 5 } {
-        set promoLetter [ string tolower [ string index $moveUCI end ] ]
-        ::fics::writechan "promote $promoLetter"
+      # If just castled, send San move
+      set previousMove [sc_game info previousMove]
+      if {[string match O-O* $previousMove]} {
+	::fics::writechan $previousMove
+      } else {
+	set moveUCI [sc_game info previousMoveUCI]
+	if { [ string length $moveUCI ] == 5 } {
+	  set promoLetter [ string tolower [ string index $moveUCI end ] ]
+	  ::fics::writechan "promote $promoLetter"
+	}
+	::fics::writechan [string range $moveUCI 0 3 ]
       }
-      ::fics::writechan [string range $moveUCI 0 3 ]
 
       ### Stop clock
       if {[sc_pos side] == "white"} {
Index: tcl/tools/sergame.tcl
===================================================================
--- tcl/tools/sergame.tcl	(revision 2575)
+++ tcl/tools/sergame.tcl	(working copy)
@@ -325,6 +325,10 @@
       ::sergame::sendToEngine $n "setoption name Ponder value false"
     }
 
+    if {[sc_game startBoard]} {
+      sendToEngine $n "setoption name UCI_Chess960 value true"
+    }
+
     # if will follow a specific opening line
     if {$isOpening} {
       set fields [split [lindex $openingList $chosenOpening] ":"]
@@ -368,7 +372,10 @@
 
     if {$::uci::uciInfo(skill) != ""} {
       # hmm - no spaces allowed in tags (Skill Level)
-      sc_game tags set -extra [list "SkillLevel \"$::uci::uciInfo(skill)\""]
+      set extraTags [sc_game tag get -last Extra]
+      set extraTagsList [split $extraTags "\n"]
+      lappend extraTagsList "SkillLevel \"$::uci::uciInfo(skill)\""
+      sc_game tags set -extra $extraTagsList
     }
 
     updateBoard -pgn
