Gregor's tktext patch version 2017-feb

This patch inlines Gregor's awesome rewritten tk::text proc into Scid vs. PC.
It primarily speeds the text widget tag processing, but also fixes quite a few
bugs and introduces new features. Please see:
  http://scidb.sourceforge.net/tk/revised-text-widget.html
It is currently still beta, but should be included in mainline wish soon/when it is finalised.

Apply this patch, then re-run configure, and make install as normal
Note - debugging (using the flags "-DTRACE_BUG=1 -g") should (must) now be enabled.

S.A.

--- /dev/null	2017-02-19 15:00:07.862660076 +1000
+++ src/tktext/tkAlloc.h	2017-02-19 14:43:55.537761340 +1000
@@ -0,0 +1,45 @@
+/*
+ * tkAlloc.h --
+ *
+ *	This module provides an interface to memory allocation functions, this
+ *	is: malloc(), realloc(), free(). This has the following advantages:
+ *
+ *	1. The whole features of the very valuable tool Valgrind can be used,
+ *	   this requires to bypass the Tcl allocation functions.
+ *
+ *	2. Backport to version 8.5, this is important because the Mac version
+ *	   of wish8.6 is quite unstable.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TK_ALLOC
+#define _TK_ALLOC
+
+#ifndef _TK
+# include "tk.h"
+#endif
+
+#if TK_VALGRIND
+
+#include <stdlib.h>
+
+/* enables compiler check that these functions will not be used */
+# undef ckalloc
+# undef ckrealloc
+# undef ckfree
+
+#else /* if !TK_VALGRIND */
+
+/* the main reason for these definitions is portability to 8.5 */
+# define malloc(size)		((void *) ckalloc(size))
+# define realloc(ptr, size)	((void *) ckrealloc((char *) (ptr), size))
+# define free(ptr)		ckfree((char *) (ptr))
+
+#endif /* TK_VALGRIND */
+
+#endif /* _TK_ALLOC */
+/* vi:set ts=8 sw=4: */
--- /dev/null	2017-02-19 15:00:07.862660076 +1000
+++ src/tktext/tkBool.h	2017-02-19 14:43:04.978148000 +1000
@@ -0,0 +1,31 @@
+/*
+ * tkBool.h --
+ *
+ *	This module provides a boolean type, conform to C++.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TK_BOOL
+#define _TK_BOOL
+
+#ifdef __cplusplus
+extern "C" {
+# define bool TkBool
+#endif
+
+typedef int bool;
+
+#ifndef __cplusplus
+enum { true = (int) 1, false = (int) 0 };
+#endif
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _TK_BOOL */
+/* vi:set ts=8 sw=4: */
Index: Makefile.conf
===================================================================
--- Makefile.conf	(revision 2668)
+++ Makefile.conf	(working copy)
@@ -124,6 +124,24 @@
       src/universalchardet/nsSJISProber.o src/universalchardet/nsUniversalDetector.o \
       src/universalchardet/nsUTF8Prober.o
 
+TKTEXTOBJS= \
+		src/tktext/tkBitField.o \
+		src/tktext/tkIntSet.o \
+		src/tktext/tkMisc.o \
+		src/tktext/tkQTree.o \
+		src/tktext/tkRangeList.o \
+		src/tktext/tkTextBTree.o \
+		src/tktext/tkText.o \
+		src/tktext/tkTextDisp.o \
+		src/tktext/tkTextImage.o \
+		src/tktext/tkTextIndex.o \
+		src/tktext/tkTextLineBreak.o \
+		src/tktext/tkTextMark.o \
+		src/tktext/tkTextTag.o \
+		src/tktext/tkTextTagSet.o \
+		src/tktext/tkTextUndo.o \
+		src/tktext/tkTextWind.o
+
 ### ZLIBOBJS: object files in the zlib compression library.
 
 ZLIBOBJS= src/zlib/adler32.o src/zlib/compress.o src/zlib/crc32.o \
@@ -168,6 +186,7 @@
   tcl/search/search.tcl \
     tcl/search/board.tcl tcl/search/header.tcl tcl/search/material.tcl \
   tcl/contrib/ezsmtp/ezsmtp.tcl \
+  tcl/tktext/text.tcl \
     tcl/tools/email.tcl \
     tcl/tools/import.tcl \
     tcl/tools/optable.tcl tcl/tools/preport.tcl tcl/tools/pinfo.tcl \
@@ -301,7 +320,7 @@
 	fi
 
 clean:
-	rm -f game.* tkscid.so tkscid.dll position.* src/*.o src/universalchardet/*.o src/zlib/*.o src/zlib/*.a src/polyglot/*.o $(EXECS) scid $(SCRIPTS)
+	rm -f game.* tkscid.so tkscid.dll position.* src/*.o src/universalchardet/*.o src/tktext/*.o src/zlib/*.o src/zlib/*.a src/polyglot/*.o $(EXECS) scid $(SCRIPTS)
 	cd engines/phalanx/ && make clean && cd ../../
 	cd engines/toga/src/ && make clean && cd ../../../
 	cd src/tkdnd/ && make clean && cd ../..
@@ -397,9 +416,9 @@
 scidt: src/scidt.o $(OBJS) $(CHARSETCONVOBJS)
 	$(LINK) $(LDFLAGS) -o scidt src/scidt.o $(OBJS) $(CHARSETCONVOBJS) $(ZLIB) $(TCL_LIBRARY)
 
-tkscid: src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o src/spellchk.o \
+tkscid: src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) $(TKTEXTOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o src/spellchk.o \
         src/probe.o src/optable.o src/engine.o src/recog.o src/tkdnd/TkDND_XDND.o src/tk_selection.o
-	$(LINK) $(LDFLAGS) -o tkscid src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o \
+	$(LINK) $(LDFLAGS) -o tkscid src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) $(TKTEXTOBJS) src/tree.o \
         src/filter.o src/pbook.o src/crosstab.o src/spellchk.o src/probe.o src/optable.o \
         src/engine.o src/recog.o src/tkdnd/TkDND_XDND.o src/tk_selection.o $(ZLIB) $(TK_LIBRARY)
 
@@ -432,6 +451,16 @@
 %.o: %.cpp
 	$(BASH_ENV) $(CXX) $(CXXFLAGS) $(TCL_INCLUDE) -o $@ -c $<
 
+### Rule for compiling TkText source files:
+
+TKTEXT_CFLAGS  = $(WARNINGS) $(DEBUG)
+TKTEXT_CFLAGS += -Isrc/tktext/tcl$(TCL_VERSION) -Isrc/tktext/tk$(TCL_VERSION)
+TKTEXT_CFLAGS += -std=c99 -Wno-maybe-uninitialized -DMODULE_SCOPE=""
+TKTEXT_CFLAGS += -O -g # NOTE: currently only -O, and with debug code
+
+src/tktext/%.o: src/tktext/%.c
+	$(CC) $(TKTEXT_CFLAGS) -o $@ -c $<
+
 ### Rule for compiling zlib source files:
 
 src/zlib/%.o: src/zlib/%.c
Index: Makefile.conf.darwin
===================================================================
--- Makefile.conf.darwin	(revision 2668)
+++ Makefile.conf.darwin	(working copy)
@@ -122,6 +122,24 @@
       src/universalchardet/nsSJISProber.o src/universalchardet/nsUniversalDetector.o \
       src/universalchardet/nsUTF8Prober.o
 
+TKTEXTOBJS= \
+		src/tktext/tkBitField.o \
+		src/tktext/tkIntSet.o \
+		src/tktext/tkMisc.o \
+		src/tktext/tkQTree.o \
+		src/tktext/tkRangeList.o \
+		src/tktext/tkTextBTree.o \
+		src/tktext/tkText.o \
+		src/tktext/tkTextDisp.o \
+		src/tktext/tkTextImage.o \
+		src/tktext/tkTextIndex.o \
+		src/tktext/tkTextLineBreak.o \
+		src/tktext/tkTextMark.o \
+		src/tktext/tkTextTag.o \
+		src/tktext/tkTextTagSet.o \
+		src/tktext/tkTextUndo.o \
+		src/tktext/tkTextWind.o
+
 ### ZLIBOBJS: object files in the zlib compression library.
 
 ZLIBOBJS= src/zlib/adler32.o src/zlib/compress.o src/zlib/crc32.o \
@@ -165,6 +183,7 @@
   tcl/search/search.tcl \
     tcl/search/board.tcl tcl/search/header.tcl tcl/search/material.tcl \
   tcl/contrib/ezsmtp/ezsmtp.tcl \
+  tcl/tktext/text.tcl \
     tcl/tools/email.tcl \
     tcl/tools/import.tcl \
     tcl/tools/optable.tcl tcl/tools/preport.tcl tcl/tools/pinfo.tcl \
@@ -260,7 +279,7 @@
 	# They all exist in the one directory, and don't want to trash it by accident
 
 clean:
-	rm -f game.* tkscid.so position.* src/*.o src/universalchardet/*.o src/zlib/*.o src/zlib/*.a src/polyglot/*.o $(EXECS) scid $(SCRIPTS)
+	rm -f game.* tkscid.so position.* src/*.o src/universalchardet/*.o src/tktext/*.o src/zlib/*.o src/zlib/*.a src/polyglot/*.o $(EXECS) scid $(SCRIPTS)
 	cd engines/phalanx/ && make clean && cd ../../
 	cd engines/toga/src/ && make clean && cd ../../../
 
@@ -425,9 +444,9 @@
 scidt: src/scidt.o $(OBJS) $(CHARSETCONVOBJS)
 	$(LINK) $(LDFLAGS) -o scidt src/scidt.o $(OBJS) $(CHARSETCONVOBJS) $(ZLIB) $(TCL_LIBRARY)
 
-tkscid: src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o \
+tkscid: src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) $(TKTEXTOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o \
           src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o
-	$(LINK) $(LDFLAGS) -o tkscid src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o $(ZLIB) $(TK_LIBRARY)
+	$(LINK) $(LDFLAGS) -o tkscid src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) $(TKTEXTOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o $(ZLIB) $(TK_LIBRARY)
 
 tcscid: src/tcscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o \
           src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o
@@ -456,6 +475,17 @@
 %.o: %.cpp
 	$(BASH_ENV) $(CXX) $(CXXFLAGS) $(TCL_INCLUDE) -o $@ -c $<
 
+### Rule for compiling TkText source files:
+
+TKTEXT_CFLAGS  = $(WARNINGS) $(DEBUG)
+TKTEXT_CFLAGS += -Isrc/tktext/tcl$(TCL_VERSION) -Isrc/tktext/tk$(TCL_VERSION)
+TKTEXT_CFLAGS += -std=c99 -Wno-maybe-uninitialized -DMODULE_SCOPE=""
+TKTEXT_CFLAGS += -O -g # NOTE: currently only -O, and with debug code
+TKTEXT_CFLAGS += -DTK_LAYOUT_WITH_BASE_CHUNKS=1 -DTK_DRAW_IN_CONTEXT=1
+
+src/tktext/%.o: src/tktext/%.c
+	$(CC) $(TKTEXT_CFLAGS) -o $@ -c $<
+
 ### Rule for compiling zlib source files:
 
 src/zlib/%.o: src/zlib/%.c
Index: Makefile.mingwx
===================================================================
--- Makefile.mingwx	(revision 2668)
+++ Makefile.mingwx	(working copy)
@@ -103,6 +103,23 @@
       src/universalchardet/nsSJISProber.o src/universalchardet/nsUniversalDetector.o \
       src/universalchardet/nsUTF8Prober.o
 
+TKTEXTOBJS= \
+		src/tktext/tkBitField.o \
+		src/tktext/tkIntSet.o \
+		src/tktext/tkMisc.o \
+		src/tktext/tkQTree.o \
+		src/tktext/tkRangeList.o \
+		src/tktext/tkTextBTree.o \
+		src/tktext/tkText.o \
+		src/tktext/tkTextDisp.o \
+		src/tktext/tkTextImage.o \
+		src/tktext/tkTextIndex.o \
+		src/tktext/tkTextLineBreak.o \
+		src/tktext/tkTextMark.o \
+		src/tktext/tkTextTag.o \
+		src/tktext/tkTextTagSet.o \
+		src/tktext/tkTextUndo.o \
+		src/tktext/tkTextWind.o
 
 ### ZLIBOBJS: object files in the zlib compression library.
 
@@ -143,6 +160,7 @@
   tcl/search/search.tcl \
     tcl/search/board.tcl tcl/search/header.tcl tcl/search/material.tcl \
   tcl/contrib/ezsmtp/ezsmtp.tcl \
+  tcl/tktext/text.tcl \
     tcl/tools/email.tcl \
     tcl/tools/import.tcl \
     tcl/tools/optable.tcl tcl/tools/preport.tcl tcl/tools/pinfo.tcl \
@@ -175,10 +193,10 @@
 	$(LINK) $(LDFLAGS) -o scidlet.exe src/scidlet.o src/engine.o src/recog.o \
           src/misc.o src/position.o src/movelist.o src/dstring.o src/myassert.o
 
-scid.exe: src/scid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o \
+scid.exe: src/scid.o $(OBJS) $(CHARSETCONVOBJS) $(TKTEXTOBJS) src/tree.o src/filter.o \
             src/pbook.o src/crosstab.o src/spellchk.o src/probe.o \
             src/optable.o src/engine.o src/recog.o src/tkdnd/TkDND_OleDND.o src/tk_selection.o scid.res
-	$(LINK) $(LDFLAGS) -o scid.exe src/scid.o $(OBJS) $(CHARSETCONVOBJS) \
+	$(LINK) $(LDFLAGS) -o scid.exe src/scid.o $(OBJS) $(CHARSETCONVOBJS) $(TKTEXTOBJS) \
             src/tree.o src/filter.o src/pbook.o \
             src/crosstab.o src/spellchk.o src/probe.o \
             src/optable.o src/engine.o src/recog.o src/tkdnd/TkDND_OleDND.o src/tk_selection.o scid.res \
@@ -200,7 +218,7 @@
 	$(RC) $(RCFLAGS) -o scid.res scid.rc
 
 clean:
-	rm -f src/*.o src/zlib/*.o src/polyglot/*.o src/universalchardet/*.o $(EXECS) scid.gui scid.res
+	rm -f src/*.o src/zlib/*.o src/polyglot/*.o src/universalchardet/*.o src/tktext/*.o $(EXECS) scid.gui scid.res
 	$(MAKE) -C src/tkdnd/ -f Makefile.mingwx clean
 
 strip:
@@ -222,6 +240,24 @@
 src/probe.o: src/probe.cpp src/egtb/tbindex.cpp src/egtb/tbdecode.c
 	$(CXX) $(CXXFLAGS) -Wno-missing-braces $(TB) -c src/probe.cpp -o ./src/probe.o
 
+### Rule for compiling TkText source files:
+
+TKTEXT_CFLAGS  = $(WARNINGS) $(DEBUG)
+TKTEXT_CFLAGS += -Isrc/tktext/tcl$(TCL_VERSION) -Isrc/tktext/tk$(TCL_VERSION) -I$(TCL_DIR)/include
+TKTEXT_CFLAGS += -std=c99 -Wno-maybe-uninitialized -DMODULE_SCOPE=""
+TKTEXT_CFLAGS += -O # NOTE: currently only -O, and with debug code
+
+src/tktext/%.o: src/tktext/%.c
+	if ! [ -d src/tktext/tcl$(TCL_VERSION) ]; then \
+		(cd src/tktext; ln -s tcl8.5 tcl85);        \
+		(cd src/tktext; ln -s tcl8.6 tcl86);        \
+		(cd src/tktext; ln -s tk8.5 tk85);          \
+		(cd src/tktext; ln -s tk8.6 tk86);          \
+	fi
+	$(CC) $(TKTEXT_CFLAGS) -o $@ -c $<
+
+### End of rule for compiling TkText
+
 %.o: %.cpp
 	$(CXX) $(CXXFLAGS) -I$(TCL_DIR)/include -c $< -o ./$@
 
@@ -231,3 +267,5 @@
 src/tkdnd/TkDND_OleDND.o: src/tkdnd/win/TkDND_OleDND.cpp
 	$(MAKE) -C src/tkdnd/ -f Makefile.mingwx CC="$(CC)" LINK="$(LINK)" CXXFLAGS="$(CXXFLAGS)" \
               WIN_TARGET="$(WIN_TARGET)" TCL_VERSION="$(TCL_VERSION)" TCL_DIR="$(TCL_DIR)"
+
+### End of Makefile
Index: src/tkscid.cpp
===================================================================
--- src/tkscid.cpp	(revision 2668)
+++ src/tkscid.cpp	(working copy)
@@ -85,6 +85,8 @@
 int scid_InitTclTk (Tcl_Interp * interp);
 #endif
 
+extern "C" int Tk_TextObjCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]);
+
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // InvalidCommand():
 //    Given a Tcl Interpreter, a major command name (e.g. "sc_base") and
@@ -529,11 +531,16 @@
     db = &(dbList[currentBase]);
 
 #ifndef TCL_ONLY
+
 #ifndef __APPLE__
     // Drag and Drop init
     Tkdnd_Init (ti);
     Tk_Selection_Init (ti);
 #endif
+    // Revised Tk text widget
+    Tcl_PkgProvide(ti, "TkText", "1.0");
+    Tcl_CreateObjCommand(ti, "text", Tk_TextObjCmd, 0, 0);
+    Tcl_CreateObjCommand(ti, "::tk::text", Tk_TextObjCmd, 0, 0);
 #endif
 
     return TCL_OK;
Index: src/tktext/tcl8.5/tclInt.h
===================================================================
--- src/tktext/tcl8.5/tclInt.h	(revision 0)
+++ src/tktext/tcl8.5/tclInt.h	(working copy)
@@ -0,0 +1,3899 @@
+/*
+ * tclInt.h --
+ *
+ *	Declarations of things used internally by the Tcl interpreter.
+ *
+ * Copyright (c) 1987-1993 The Regents of the University of California.
+ * Copyright (c) 1993-1997 Lucent Technologies.
+ * Copyright (c) 1994-1998 Sun Microsystems, Inc.
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
+ * Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tclInt.h,v 1.362.2.5 2008/11/14 00:22:39 nijtmans Exp $
+ */
+
+#ifndef _TCLINT
+#define _TCLINT
+
+/*
+ * Some numerics configuration options
+ */
+
+#undef NO_WIDE_TYPE
+#undef ACCEPT_NAN
+
+/*
+ * Common include files needed by most of the Tcl source files are included
+ * here, so that system-dependent personalizations for the include files only
+ * have to be made in once place. This results in a few extra includes, but
+ * greater modularity. The order of the three groups of #includes is
+ * important. For example, stdio.h is needed by tcl.h, and the _ANSI_ARGS_
+ * declaration in tcl.h is needed by stdlib.h in some configurations.
+ */
+
+#ifdef HAVE_TCL_CONFIG_H
+#include "tclConfig.h"
+#endif
+#ifndef _TCL
+#include "tcl.h"
+#endif
+
+#include <stdio.h>
+
+#include <ctype.h>
+#ifdef NO_LIMITS_H
+#   include "../compat/limits.h"
+#else
+#   include <limits.h>
+#endif
+#ifdef NO_STDLIB_H
+#   include "../compat/stdlib.h"
+#else
+#   include <stdlib.h>
+#endif
+#ifdef NO_STRING_H
+#include "../compat/string.h"
+#else
+#include <string.h>
+#endif
+#ifdef STDC_HEADERS
+#include <stddef.h>
+#else
+typedef int ptrdiff_t;
+#endif
+
+/*
+ * Ensure WORDS_BIGENDIAN is defined correcly:
+ * Needs to happen here in addition to configure to work with fat compiles on
+ * Darwin (where configure runs only once for multiple architectures).
+ */
+
+#ifdef HAVE_SYS_TYPES_H
+#    include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#    include <sys/param.h>
+#endif
+#ifdef BYTE_ORDER
+#    ifdef BIG_ENDIAN
+#	 if BYTE_ORDER == BIG_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	     define WORDS_BIGENDIAN 1
+#	 endif
+#    endif
+#    ifdef LITTLE_ENDIAN
+#	 if BYTE_ORDER == LITTLE_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	 endif
+#    endif
+#endif
+
+/*
+ * Used to tag functions that are only to be visible within the module being
+ * built and not outside it (where this is supported by the linker).
+ */
+
+#ifndef MODULE_SCOPE
+#   ifdef __cplusplus
+#	define MODULE_SCOPE extern "C"
+#   else
+#	define MODULE_SCOPE extern
+#   endif
+#endif
+
+/*
+ * When Tcl_WideInt and long are the same type, there's no value in
+ * having a tclWideIntType separate from the tclIntType.
+ */
+#ifdef TCL_WIDE_INT_IS_LONG
+#define NO_WIDE_TYPE
+#endif
+
+/*
+ * Macros used to cast between pointers and integers (e.g. when storing an int
+ * in ClientData), on 64-bit architectures they avoid gcc warning about "cast
+ * to/from pointer from/to integer of different size".
+ */
+
+#if !defined(INT2PTR) && !defined(PTR2INT)
+#   if defined(HAVE_INTPTR_T) || defined(intptr_t)
+#	define INT2PTR(p) ((void*)(intptr_t)(p))
+#	define PTR2INT(p) ((int)(intptr_t)(p))
+#   else
+#	define INT2PTR(p) ((void*)(p))
+#	define PTR2INT(p) ((int)(p))
+#   endif
+#endif
+#if !defined(UINT2PTR) && !defined(PTR2UINT)
+#   if defined(HAVE_UINTPTR_T) || defined(uintptr_t)
+#	define UINT2PTR(p) ((void*)(uintptr_t)(p))
+#	define PTR2UINT(p) ((unsigned int)(uintptr_t)(p))
+#   else
+#	define UINT2PTR(p) ((void*)(p))
+#	define PTR2UINT(p) ((unsigned int)(p))
+#   endif
+#endif
+
+/*
+ * The following procedures allow namespaces to be customized to support
+ * special name resolution rules for commands/variables.
+ */
+
+struct Tcl_ResolvedVarInfo;
+
+typedef Tcl_Var (Tcl_ResolveRuntimeVarProc)(Tcl_Interp *interp,
+	struct Tcl_ResolvedVarInfo *vinfoPtr);
+
+typedef void (Tcl_ResolveVarDeleteProc)(struct Tcl_ResolvedVarInfo *vinfoPtr);
+
+/*
+ * The following structure encapsulates the routines needed to resolve a
+ * variable reference at runtime. Any variable specific state will typically
+ * be appended to this structure.
+ */
+
+typedef struct Tcl_ResolvedVarInfo {
+    Tcl_ResolveRuntimeVarProc *fetchProc;
+    Tcl_ResolveVarDeleteProc *deleteProc;
+} Tcl_ResolvedVarInfo;
+
+typedef int (Tcl_ResolveCompiledVarProc) (Tcl_Interp *interp,
+	CONST84 char *name, int length, Tcl_Namespace *context,
+	Tcl_ResolvedVarInfo **rPtr);
+
+typedef int (Tcl_ResolveVarProc) (Tcl_Interp *interp, CONST84 char *name,
+	Tcl_Namespace *context, int flags, Tcl_Var *rPtr);
+
+typedef int (Tcl_ResolveCmdProc) (Tcl_Interp *interp, CONST84 char *name,
+	Tcl_Namespace *context, int flags, Tcl_Command *rPtr);
+
+typedef struct Tcl_ResolverInfo {
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* Procedure handling command name
+				 * resolution. */
+    Tcl_ResolveVarProc *varResProc;
+				/* Procedure handling variable name resolution
+				 * for variables that can only be handled at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* Procedure handling variable name resolution
+				 * at compile time. */
+} Tcl_ResolverInfo;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to namespaces.
+ *----------------------------------------------------------------
+ */
+
+typedef struct Tcl_Ensemble Tcl_Ensemble;
+typedef struct NamespacePathEntry NamespacePathEntry;
+
+/*
+ * Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
+ * field added at the end: in this way variables can find their namespace
+ * without having to copy a pointer in their struct: they can access it via
+ * their hPtr->tablePtr.
+ */
+
+typedef struct TclVarHashTable {
+    Tcl_HashTable table;
+    struct Namespace *nsPtr;
+} TclVarHashTable;
+
+/*
+ * This is for itcl - it likes to search our varTables directly :(
+ */
+
+#define TclVarHashFindVar(tablePtr, key) \
+    TclVarHashCreateVar((tablePtr), (key), NULL)
+
+
+/*
+ * The structure below defines a namespace.
+ * Note: the first five fields must match exactly the fields in a
+ * Tcl_Namespace structure (see tcl.h). If you change one, be sure to change
+ * the other.
+ */
+
+typedef struct Namespace {
+    char *name;			/* The namespace's simple (unqualified) name.
+				 * This contains no ::'s. The name of the
+				 * global namespace is "" although "::" is an
+				 * synonym. */
+    char *fullName;		/* The namespace's fully qualified name. This
+				 * starts with ::. */
+    ClientData clientData;	/* An arbitrary value associated with this
+				 * namespace. */
+    Tcl_NamespaceDeleteProc *deleteProc;
+				/* Procedure invoked when deleting the
+				 * namespace to, e.g., free clientData. */
+    struct Namespace *parentPtr;/* Points to the namespace that contains this
+				 * one. NULL if this is the global
+				 * namespace. */
+    Tcl_HashTable childTable;	/* Contains any child namespaces. Indexed by
+				 * strings; values have type (Namespace *). */
+    long nsId;			/* Unique id for the namespace. */
+    Tcl_Interp *interp;		/* The interpreter containing this
+				 * namespace. */
+    int flags;			/* OR-ed combination of the namespace status
+				 * flags NS_DYING and NS_DEAD listed below. */
+    int activationCount;	/* Number of "activations" or active call
+				 * frames for this namespace that are on the
+				 * Tcl call stack. The namespace won't be
+				 * freed until activationCount becomes zero. */
+    int refCount;		/* Count of references by namespaceName
+				 * objects. The namespace can't be freed until
+				 * refCount becomes zero. */
+    Tcl_HashTable cmdTable;	/* Contains all the commands currently
+				 * registered in the namespace. Indexed by
+				 * strings; values have type (Command *).
+				 * Commands imported by Tcl_Import have
+				 * Command structures that point (via an
+				 * ImportedCmdRef structure) to the Command
+				 * structure in the source namespace's command
+				 * table. */
+    TclVarHashTable varTable;	/* Contains all the (global) variables
+				 * currently in this namespace. Indexed by
+				 * strings; values have type (Var *). */
+    char **exportArrayPtr;	/* Points to an array of string patterns
+				 * specifying which commands are exported. A
+				 * pattern may include "string match" style
+				 * wildcard characters to specify multiple
+				 * commands; however, no namespace qualifiers
+				 * are allowed. NULL if no export patterns are
+				 * registered. */
+    int numExportPatterns;	/* Number of export patterns currently
+				 * registered using "namespace export". */
+    int maxExportPatterns;	/* Mumber of export patterns for which space
+				 * is currently allocated. */
+    int cmdRefEpoch;		/* Incremented if a newly added command
+				 * shadows a command for which this namespace
+				 * has already cached a Command * pointer;
+				 * this causes all its cached Command*
+				 * pointers to be invalidated. */
+    int resolverEpoch;		/* Incremented whenever (a) the name
+				 * resolution rules change for this namespace
+				 * or (b) a newly added command shadows a
+				 * command that is compiled to bytecodes. This
+				 * invalidates all byte codes compiled in the
+				 * namespace, causing the code to be
+				 * recompiled under the new rules.*/
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* If non-null, this procedure overrides the
+				 * usual command resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * Tcl_FindCommand to resolve all command
+				 * references within the namespace. */
+    Tcl_ResolveVarProc *varResProc;
+				/* If non-null, this procedure overrides the
+				 * usual variable resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * Tcl_FindNamespaceVar to resolve all
+				 * variable references within the namespace at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* If non-null, this procedure overrides the
+				 * usual variable resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * LookupCompiledLocal to resolve variable
+				 * references within the namespace at compile
+				 * time. */
+    int exportLookupEpoch;	/* Incremented whenever a command is added to
+				 * a namespace, removed from a namespace or
+				 * the exports of a namespace are changed.
+				 * Allows TIP#112-driven command lists to be
+				 * validated efficiently. */
+    Tcl_Ensemble *ensembles;	/* List of structures that contain the details
+				 * of the ensembles that are implemented on
+				 * top of this namespace. */
+    Tcl_Obj *unknownHandlerPtr;	/* A script fragment to be used when command
+				 * resolution in this namespace fails. TIP
+				 * 181. */
+    int commandPathLength;	/* The length of the explicit path. */
+    NamespacePathEntry *commandPathArray;
+				/* The explicit path of the namespace as an
+				 * array. */
+    NamespacePathEntry *commandPathSourceList;
+				/* Linked list of path entries that point to
+				 * this namespace. */
+} Namespace;
+
+/*
+ * An entry on a namespace's command resolution path.
+ */
+
+struct NamespacePathEntry {
+    Namespace *nsPtr;		/* What does this path entry point to? If it
+				 * is NULL, this path entry points is
+				 * redundant and should be skipped. */
+    Namespace *creatorNsPtr;	/* Where does this path entry point from? This
+				 * allows for efficient invalidation of
+				 * references when the path entry's target
+				 * updates its current list of defined
+				 * commands. */
+    NamespacePathEntry *prevPtr, *nextPtr;
+				/* Linked list pointers or NULL at either end
+				 * of the list that hangs off Namespace's
+				 * commandPathSourceList field. */
+};
+
+/*
+ * Flags used to represent the status of a namespace:
+ *
+ * NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
+ *		namespace but there are still active call frames on the Tcl
+ *		stack that refer to the namespace. When the last call frame
+ *		referring to it has been popped, it's variables and command
+ *		will be destroyed and it will be marked "dead" (NS_DEAD). The
+ *		namespace can no longer be looked up by name.
+ * NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
+ *		namespace and no call frames still refer to it. Its variables
+ *		and command have already been destroyed. This bit allows the
+ *		namespace resolution code to recognize that the namespace is
+ *		"deleted". When the last namespaceName object in any byte code
+ *		unit that refers to the namespace has been freed (i.e., when
+ *		the namespace's refCount is 0), the namespace's storage will
+ *		be freed.
+ * NS_KILLED    1 means that TclTeardownNamespace has already been called on
+ *              this namespace and it should not be called again [Bug 1355942]
+ */
+
+#define NS_DYING	0x01
+#define NS_DEAD		0x02
+#define NS_KILLED       0x04
+
+/*
+ * Flags passed to TclGetNamespaceForQualName:
+ *
+ * TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
+ * TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
+ * TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
+ * TCL_FIND_ONLY_NS		- The name sought is a namespace name.
+ */
+
+#define TCL_CREATE_NS_IF_UNKNOWN	0x800
+#define TCL_FIND_ONLY_NS		0x1000
+
+/*
+ * The data cached in an ensemble subcommand's Tcl_Obj rep (reference in
+ * otherValuePtr field). This structure is not shared between Tcl_Objs
+ * referring to the same subcommand, even where one is a duplicate of another.
+ */
+
+typedef struct {
+    Namespace *nsPtr;		/* The namespace backing the ensemble which
+				 * this is a subcommand of. */
+    int epoch;			/* Used to confirm when the data in this
+				 * really structure matches up with the
+				 * ensemble. */
+    Tcl_Command token;		/* Reference to the comamnd for which this
+				 * structure is a cache of the resolution. */
+    char *fullSubcmdName;	/* The full (local) name of the subcommand,
+				 * allocated with ckalloc(). */
+    Tcl_Obj *realPrefixObj;	/* Object containing the prefix words of the
+				 * command that implements this ensemble
+				 * subcommand. */
+} EnsembleCmdRep;
+
+/*
+ * Flag to enable bytecode compilation of an ensemble.
+ */
+
+#define ENSEMBLE_COMPILE 0x4
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to variables. These are used primarily in tclVar.c
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The following structure defines a variable trace, which is used to invoke a
+ * specific C procedure whenever certain operations are performed on a
+ * variable.
+ */
+
+typedef struct VarTrace {
+    Tcl_VarTraceProc *traceProc;/* Procedure to call when operations given by
+				 * flags are performed on variable. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    int flags;			/* What events the trace procedure is
+				 * interested in: OR-ed combination of
+				 * TCL_TRACE_READS, TCL_TRACE_WRITES,
+				 * TCL_TRACE_UNSETS and TCL_TRACE_ARRAY. */
+    struct VarTrace *nextPtr;	/* Next in list of traces associated with a
+				 * particular variable. */
+} VarTrace;
+
+/*
+ * The following structure defines a command trace, which is used to invoke a
+ * specific C procedure whenever certain operations are performed on a
+ * command.
+ */
+
+typedef struct CommandTrace {
+    Tcl_CommandTraceProc *traceProc;
+				/* Procedure to call when operations given by
+				 * flags are performed on command. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    int flags;			/* What events the trace procedure is
+				 * interested in: OR-ed combination of
+				 * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
+    struct CommandTrace *nextPtr;
+				/* Next in list of traces associated with a
+				 * particular command. */
+    int refCount;		/* Used to ensure this structure is not
+				 * deleted too early. Keeps track of how many
+				 * pieces of code have a pointer to this
+				 * structure. */
+} CommandTrace;
+
+/*
+ * When a command trace is active (i.e. its associated procedure is executing)
+ * one of the following structures is linked into a list associated with the
+ * command's interpreter. The information in the structure is needed in order
+ * for Tcl to behave reasonably if traces are deleted while traces are active.
+ */
+
+typedef struct ActiveCommandTrace {
+    struct Command *cmdPtr;	/* Command that's being traced. */
+    struct ActiveCommandTrace *nextPtr;
+				/* Next in list of all active command traces
+				 * for the interpreter, or NULL if no more. */
+    CommandTrace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+    int reverseScan;		/* Boolean set true when traces are scanning
+				 * in reverse order. */
+} ActiveCommandTrace;
+
+/*
+ * When a variable trace is active (i.e. its associated procedure is
+ * executing) one of the following structures is linked into a list associated
+ * with the variable's interpreter. The information in the structure is needed
+ * in order for Tcl to behave reasonably if traces are deleted while traces
+ * are active.
+ */
+
+typedef struct ActiveVarTrace {
+    struct Var *varPtr;		/* Variable that's being traced. */
+    struct ActiveVarTrace *nextPtr;
+				/* Next in list of all active variable traces
+				 * for the interpreter, or NULL if no more. */
+    VarTrace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+} ActiveVarTrace;
+
+/*
+ * The following structure describes an enumerative search in progress on an
+ * array variable; this are invoked with options to the "array" command.
+ */
+
+typedef struct ArraySearch {
+    int id;			/* Integer id used to distinguish among
+				 * multiple concurrent searches for the same
+				 * array. */
+    struct Var *varPtr;		/* Pointer to array variable that's being
+				 * searched. */
+    Tcl_HashSearch search;	/* Info kept by the hash module about progress
+				 * through the array. */
+    Tcl_HashEntry *nextEntry;	/* Non-null means this is the next element to
+				 * be enumerated (it's leftover from the
+				 * Tcl_FirstHashEntry call or from an "array
+				 * anymore" command). NULL means must call
+				 * Tcl_NextHashEntry to get value to
+				 * return. */
+    struct ArraySearch *nextPtr;/* Next in list of all active searches for
+				 * this variable, or NULL if this is the last
+				 * one. */
+} ArraySearch;
+
+/*
+ * The structure below defines a variable, which associates a string name with
+ * a Tcl_Obj value. These structures are kept in procedure call frames (for
+ * local variables recognized by the compiler) or in the heap (for global
+ * variables and any variable not known to the compiler). For each Var
+ * structure in the heap, a hash table entry holds the variable name and a
+ * pointer to the Var structure.
+ */
+
+typedef struct Var {
+    int flags;			/* Miscellaneous bits of information about
+				 * variable. See below for definitions. */
+    union {
+	Tcl_Obj *objPtr;	/* The variable's object value. Used for
+				 * scalar variables and array elements. */
+	TclVarHashTable *tablePtr;/* For array variables, this points to
+				 * information about the hash table used to
+				 * implement the associative array. Points to
+				 * ckalloc-ed data. */
+	struct Var *linkPtr;	/* If this is a global variable being referred
+				 * to in a procedure, or a variable created by
+				 * "upvar", this field points to the
+				 * referenced variable's Var struct. */
+    } value;
+} Var;
+
+typedef struct VarInHash {
+    Var var;
+    int refCount;		/* Counts number of active uses of this
+				 * variable: 1 for the entry in the hash
+				 * table, 1 for each additional variable whose
+				 * linkPtr points here, 1 for each nested
+				 * trace active on variable, and 1 if the
+				 * variable is a namespace variable. This
+				 * record can't be deleted until refCount
+				 * becomes 0. */
+    Tcl_HashEntry entry;	/* The hash table entry that refers to this
+				 * variable. This is used to find the name of
+				 * the variable and to delete it from its
+				 * hashtable if it is no longer needed. It
+				 * also holds the variable's name. */
+} VarInHash;
+
+/*
+ * Flag bits for variables. The first two (VAR_ARRAY and VAR_LINK) are
+ * mutually exclusive and give the "type" of the variable. If none is set,
+ * this is a scalar variable.
+ *
+ * VAR_ARRAY -			1 means this is an array variable rather than
+ *				a scalar variable or link. The "tablePtr"
+ *				field points to the array's hashtable for its
+ *				elements.
+ * VAR_LINK -			1 means this Var structure contains a pointer
+ *				to another Var structure that either has the
+ *				real value or is itself another VAR_LINK
+ *				pointer. Variables like this come about
+ *				through "upvar" and "global" commands, or
+ *				through references to variables in enclosing
+ *				namespaces.
+ *
+ * Flags that indicate the type and status of storage; none is set for
+ * compiled local variables (Var structs).
+ *
+ * VAR_IN_HASHTABLE -		1 means this variable is in a hashtable and
+ *				the Var structure is malloced. 0 if it is a
+ *				local variable that was assigned a slot in a
+ *				procedure frame by the compiler so the Var
+ *				storage is part of the call frame.
+ * VAR_DEAD_HASH                1 means that this var's entry in the hashtable
+ *                              has already been deleted.
+ * VAR_ARRAY_ELEMENT -		1 means that this variable is an array
+ *				element, so it is not legal for it to be an
+ *				array itself (the VAR_ARRAY flag had better
+ *				not be set).
+ * VAR_NAMESPACE_VAR -		1 means that this variable was declared as a
+ *				namespace variable. This flag ensures it
+ *				persists until its namespace is destroyed or
+ *				until the variable is unset; it will persist
+ *				even if it has not been initialized and is
+ *				marked undefined. The variable's refCount is
+ *				incremented to reflect the "reference" from
+ *				its namespace.
+ *
+ * Flag values relating to the variable's trace and search status.
+ *
+ * VAR_TRACED_READ
+ * VAR_TRACED_WRITE
+ * VAR_TRACED_UNSET
+ * VAR_TRACED_ARRAY
+ * VAR_TRACE_ACTIVE -		1 means that trace processing is currently
+ *				underway for a read or write access, so new
+ *				read or write accesses should not cause trace
+ *				procedures to be called and the variable can't
+ *				be deleted.
+ * VAR_SEARCH_ACTIVE
+ *
+ * The following additional flags are used with the CompiledLocal type defined
+ * below:
+ *
+ * VAR_ARGUMENT -		1 means that this variable holds a procedure
+ *				argument.
+ * VAR_TEMPORARY -		1 if the local variable is an anonymous
+ *				temporary variable. Temporaries have a NULL
+ *				name.
+ * VAR_RESOLVED -		1 if name resolution has been done for this
+ *				variable.
+ * VAR_IS_ARGS                  1 if this variable is the last argument and is
+ *                              named "args".
+ */
+
+/*
+ * FLAGS RENUMBERED: everything breaks already, make things simpler.
+ *
+ * IMPORTANT: skip the values 0x10, 0x20, 0x40, 0x800 corresponding to
+ * TCL_TRACE_(READS/WRITES/UNSETS/ARRAY): makes code simpler in tclTrace.c
+ *
+ * Keep the flag values for VAR_ARGUMENT and VAR_TEMPORARY so that old values
+ * in precompiled scripts keep working.
+ */
+
+
+/* Type of value (0 is scalar) */
+#define VAR_ARRAY		0x1
+#define VAR_LINK		0x2
+
+/* Type of storage (0 is compiled local) */
+#define VAR_IN_HASHTABLE	0x4
+#define VAR_DEAD_HASH           0x8
+#define VAR_ARRAY_ELEMENT	0x1000
+#define VAR_NAMESPACE_VAR	0x80      /* KEEP OLD VALUE for Itcl */
+
+#define VAR_ALL_HASH \
+	(VAR_IN_HASHTABLE|VAR_DEAD_HASH|VAR_NAMESPACE_VAR|VAR_ARRAY_ELEMENT)
+
+/* Trace and search state */
+
+#define VAR_TRACED_READ        0x10       /* TCL_TRACE_READS  */
+#define VAR_TRACED_WRITE       0x20       /* TCL_TRACE_WRITES */
+#define VAR_TRACED_UNSET       0x40       /* TCL_TRACE_UNSETS */
+#define VAR_TRACED_ARRAY       0x800	  /* TCL_TRACE_ARRAY  */
+#define VAR_TRACE_ACTIVE       0x2000
+#define VAR_SEARCH_ACTIVE      0x4000
+#define VAR_ALL_TRACES \
+	(VAR_TRACED_READ|VAR_TRACED_WRITE|VAR_TRACED_ARRAY|VAR_TRACED_UNSET)
+
+
+/* Special handling on initialisation (only CompiledLocal) */
+#define VAR_ARGUMENT		0x100	  /* KEEP OLD VALUE! See tclProc.c */
+#define VAR_TEMPORARY		0x200	  /* KEEP OLD VALUE! See tclProc.c */
+#define VAR_IS_ARGS		0x400
+#define VAR_RESOLVED		0x8000
+
+/*
+ * Macros to ensure that various flag bits are set properly for variables.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclSetVarScalar(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarArray(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarLink(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarArrayElement(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarUndefined(Var *varPtr);
+ * MODULE_SCOPE void	TclClearVarUndefined(Var *varPtr);
+ */
+
+#define TclSetVarScalar(varPtr) \
+    (varPtr)->flags &= ~(VAR_ARRAY|VAR_LINK)
+
+#define TclSetVarArray(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_LINK) | VAR_ARRAY
+
+#define TclSetVarLink(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_LINK
+
+#define TclSetVarArrayElement(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_ARRAY_ELEMENT
+
+#define TclSetVarUndefined(varPtr) \
+    (varPtr)->flags &= ~(VAR_ARRAY|VAR_LINK);\
+    (varPtr)->value.objPtr = NULL
+
+#define TclClearVarUndefined(varPtr)
+
+#define TclSetVarTraceActive(varPtr) \
+    (varPtr)->flags |= VAR_TRACE_ACTIVE
+
+#define TclClearVarTraceActive(varPtr) \
+    (varPtr)->flags &= ~VAR_TRACE_ACTIVE
+
+#define TclSetVarNamespaceVar(varPtr) \
+    if (!TclIsVarNamespaceVar(varPtr)) {\
+	(varPtr)->flags |= VAR_NAMESPACE_VAR;\
+	((VarInHash *)(varPtr))->refCount++;\
+    }
+
+#define TclClearVarNamespaceVar(varPtr) \
+    if (TclIsVarNamespaceVar(varPtr)) {\
+	(varPtr)->flags &= ~VAR_NAMESPACE_VAR;\
+	((VarInHash *)(varPtr))->refCount--;\
+    }
+
+/*
+ * Macros to read various flag bits of variables.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE int	TclIsVarScalar(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarLink(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArray(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarUndefined(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArrayElement(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarTemporary(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArgument(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarResolved(Var *varPtr);
+ */
+
+#define TclIsVarScalar(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK))
+
+#define TclIsVarLink(varPtr) \
+    ((varPtr)->flags & VAR_LINK)
+
+#define TclIsVarArray(varPtr) \
+    ((varPtr)->flags & VAR_ARRAY)
+
+#define TclIsVarUndefined(varPtr) \
+    ((varPtr)->value.objPtr == NULL)
+
+#define TclIsVarArrayElement(varPtr) \
+    ((varPtr)->flags & VAR_ARRAY_ELEMENT)
+
+#define TclIsVarNamespaceVar(varPtr) \
+    ((varPtr)->flags & VAR_NAMESPACE_VAR)
+
+#define TclIsVarTemporary(varPtr) \
+    ((varPtr)->flags & VAR_TEMPORARY)
+
+#define TclIsVarArgument(varPtr) \
+    ((varPtr)->flags & VAR_ARGUMENT)
+
+#define TclIsVarResolved(varPtr) \
+    ((varPtr)->flags & VAR_RESOLVED)
+
+#define TclIsVarTraceActive(varPtr) \
+    ((varPtr)->flags & VAR_TRACE_ACTIVE)
+
+#define TclIsVarTraced(varPtr) \
+   ((varPtr)->flags & VAR_ALL_TRACES)
+
+#define TclIsVarInHash(varPtr) \
+    ((varPtr)->flags & VAR_IN_HASHTABLE)
+
+#define TclIsVarDeadHash(varPtr) \
+    ((varPtr)->flags & VAR_DEAD_HASH)
+
+#define TclGetVarNsPtr(varPtr) \
+    (TclIsVarInHash(varPtr) \
+         ? ((TclVarHashTable *) ((((VarInHash *) (varPtr))->entry.tablePtr)))->nsPtr \
+	 : NULL)
+
+#define VarHashRefCount(varPtr) \
+    ((VarInHash *) (varPtr))->refCount
+
+/*
+ * Macros for direct variable access by TEBC
+ */
+
+#define TclIsVarDirectReadable(varPtr) \
+    (   !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ)) \
+    &&  (varPtr)->value.objPtr)
+
+#define TclIsVarDirectWritable(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_WRITE|VAR_DEAD_HASH))
+
+#define TclIsVarDirectModifyable(varPtr) \
+    (   !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ|VAR_TRACED_WRITE)) \
+    &&  (varPtr)->value.objPtr)
+
+#define TclIsVarDirectReadable2(varPtr, arrayPtr) \
+    (TclIsVarDirectReadable(varPtr) &&\
+        (!(arrayPtr) || !((arrayPtr)->flags & VAR_TRACED_READ)))
+
+#define TclIsVarDirectWritable2(varPtr, arrayPtr) \
+    (TclIsVarDirectWritable(varPtr) &&\
+        (!(arrayPtr) || !((arrayPtr)->flags & VAR_TRACED_WRITE)))
+
+#define TclIsVarDirectModifyable2(varPtr, arrayPtr) \
+    (TclIsVarDirectModifyable(varPtr) &&\
+        (!(arrayPtr) || !((arrayPtr)->flags & (VAR_TRACED_READ|VAR_TRACED_WRITE))))
+
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to procedures. These are used primarily in
+ * tclProc.c, tclCompile.c, and tclExecute.c.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * Forward declaration to prevent an error when the forward reference to
+ * Command is encountered in the Proc and ImportRef types declared below.
+ */
+
+struct Command;
+
+/*
+ * The variable-length structure below describes a local variable of a
+ * procedure that was recognized by the compiler. These variables have a name,
+ * an element in the array of compiler-assigned local variables in the
+ * procedure's call frame, and various other items of information. If the
+ * local variable is a formal argument, it may also have a default value. The
+ * compiler can't recognize local variables whose names are expressions (these
+ * names are only known at runtime when the expressions are evaluated) or
+ * local variables that are created as a result of an "upvar" or "uplevel"
+ * command. These other local variables are kept separately in a hash table in
+ * the call frame.
+ */
+
+typedef struct CompiledLocal {
+    struct CompiledLocal *nextPtr;
+				/* Next compiler-recognized local variable for
+				 * this procedure, or NULL if this is the last
+				 * local. */
+    int nameLength;		/* The number of characters in local
+				 * variable's name. Used to speed up variable
+				 * lookups. */
+    int frameIndex;		/* Index in the array of compiler-assigned
+				 * variables in the procedure call frame. */
+    int flags;			/* Flag bits for the local variable. Same as
+				 * the flags for the Var structure above,
+				 * although only VAR_ARGUMENT, VAR_TEMPORARY,
+				 * and VAR_RESOLVED make sense. */
+    Tcl_Obj *defValuePtr;	/* Pointer to the default value of an
+				 * argument, if any. NULL if not an argument
+				 * or, if an argument, no default value. */
+    Tcl_ResolvedVarInfo *resolveInfo;
+				/* Customized variable resolution info
+				 * supplied by the Tcl_ResolveCompiledVarProc
+				 * associated with a namespace. Each variable
+				 * is marked by a unique ClientData tag during
+				 * compilation, and that same tag is used to
+				 * find the variable at runtime. */
+    char name[4];		/* Name of the local variable starts here. If
+				 * the name is NULL, this will just be '\0'.
+				 * The actual size of this field will be large
+				 * enough to hold the name. MUST BE THE LAST
+				 * FIELD IN THE STRUCTURE! */
+} CompiledLocal;
+
+/*
+ * The structure below defines a command procedure, which consists of a
+ * collection of Tcl commands plus information about arguments and other local
+ * variables recognized at compile time.
+ */
+
+typedef struct Proc {
+    struct Interp *iPtr;	/* Interpreter for which this command is
+				 * defined. */
+    int refCount;		/* Reference count: 1 if still present in
+				 * command table plus 1 for each call to the
+				 * procedure that is currently active. This
+				 * structure can be freed when refCount
+				 * becomes zero. */
+    struct Command *cmdPtr;	/* Points to the Command structure for this
+				 * procedure. This is used to get the
+				 * namespace in which to execute the
+				 * procedure. */
+    Tcl_Obj *bodyPtr;		/* Points to the ByteCode object for
+				 * procedure's body command. */
+    int numArgs;		/* Number of formal parameters. */
+    int numCompiledLocals;	/* Count of local variables recognized by the
+				 * compiler including arguments and
+				 * temporaries. */
+    CompiledLocal *firstLocalPtr;
+				/* Pointer to first of the procedure's
+				 * compiler-allocated local variables, or NULL
+				 * if none. The first numArgs entries in this
+				 * list describe the procedure's formal
+				 * arguments. */
+    CompiledLocal *lastLocalPtr;/* Pointer to the last allocated local
+				 * variable or NULL if none. This has frame
+				 * index (numCompiledLocals-1). */
+} Proc;
+
+/*
+ * The type of functions called to process errors found during the execution
+ * of a procedure (or lambda term or ...).
+ */
+
+typedef void (*ProcErrorProc)(Tcl_Interp *interp, Tcl_Obj *procNameObj);
+
+/*
+ * The structure below defines a command trace. This is used to allow Tcl
+ * clients to find out whenever a command is about to be executed.
+ */
+
+typedef struct Trace {
+    int level;			/* Only trace commands at nesting level less
+				 * than or equal to this. */
+    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
+    ClientData clientData;	/* Arbitrary value to pass to proc. */
+    struct Trace *nextPtr;	/* Next in list of traces for this interp. */
+    int flags;			/* Flags governing the trace - see
+				 * Tcl_CreateObjTrace for details */
+    Tcl_CmdObjTraceDeleteProc* delProc;
+				/* Procedure to call when trace is deleted */
+} Trace;
+
+/*
+ * When an interpreter trace is active (i.e. its associated procedure is
+ * executing), one of the following structures is linked into a list
+ * associated with the interpreter. The information in the structure is needed
+ * in order for Tcl to behave reasonably if traces are deleted while traces
+ * are active.
+ */
+
+typedef struct ActiveInterpTrace {
+    struct ActiveInterpTrace *nextPtr;
+				/* Next in list of all active command traces
+				 * for the interpreter, or NULL if no more. */
+    Trace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+    int reverseScan;		/* Boolean set true when traces are scanning
+				 * in reverse order. */
+} ActiveInterpTrace;
+
+/*
+ * Flag values designating types of execution traces. See tclTrace.c for
+ * related flag values.
+ *
+ * TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
+ * 				- passed to Tcl_CreateObjTrace to set up
+ *				  "enterstep" traces.
+ * TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
+ * 				- passed to Tcl_CreateObjTrace to set up
+ *				  "leavestep" traces.
+ *
+ */
+#define TCL_TRACE_ENTER_EXEC	1
+#define TCL_TRACE_LEAVE_EXEC	2
+
+/*
+ * The structure below defines an entry in the assocData hash table which is
+ * associated with an interpreter. The entry contains a pointer to a function
+ * to call when the interpreter is deleted, and a pointer to a user-defined
+ * piece of data.
+ */
+
+typedef struct AssocData {
+    Tcl_InterpDeleteProc *proc;	/* Proc to call when deleting. */
+    ClientData clientData;	/* Value to pass to proc. */
+} AssocData;
+
+/*
+ * The structure below defines a call frame. A call frame defines a naming
+ * context for a procedure call: its local naming scope (for local variables)
+ * and its global naming scope (a namespace, perhaps the global :: namespace).
+ * A call frame can also define the naming context for a namespace eval or
+ * namespace inscope command: the namespace in which the command's code should
+ * execute. The Tcl_CallFrame structures exist only while procedures or
+ * namespace eval/inscope's are being executed, and provide a kind of Tcl call
+ * stack.
+ *
+ * WARNING!! The structure definition must be kept consistent with the
+ * Tcl_CallFrame structure in tcl.h. If you change one, change the other.
+ */
+
+/*
+ * Will be grown to contain: pointers to the varnames (allocated at the end),
+ * plus the init values for each variable (suitable to be memcopied on init)
+ */
+
+typedef struct LocalCache {
+    int refCount;
+    int numVars;
+    Tcl_Obj *varName0;
+} LocalCache;
+
+#define localName(framePtr, i) \
+    ((&((framePtr)->localCachePtr->varName0))[(i)])
+
+MODULE_SCOPE void	TclFreeLocalCache(Tcl_Interp *interp,
+			    LocalCache *localCachePtr);
+
+typedef struct CallFrame {
+    Namespace *nsPtr;		/* Points to the namespace used to resolve
+				 * commands and global variables. */
+    int isProcCallFrame;	/* If 0, the frame was pushed to execute a
+				 * namespace command and var references are
+				 * treated as references to namespace vars;
+				 * varTablePtr and compiledLocals are ignored.
+				 * If FRAME_IS_PROC is set, the frame was
+				 * pushed to execute a Tcl procedure and may
+				 * have local vars. */
+    int objc;			/* This and objv below describe the arguments
+				 * for this procedure call. */
+    Tcl_Obj *const *objv;	/* Array of argument objects. */
+    struct CallFrame *callerPtr;
+				/* Value of interp->framePtr when this
+				 * procedure was invoked (i.e. next higher in
+				 * stack of all active procedures). */
+    struct CallFrame *callerVarPtr;
+				/* Value of interp->varFramePtr when this
+				 * procedure was invoked (i.e. determines
+				 * variable scoping within caller). Same as
+				 * callerPtr unless an "uplevel" command or
+				 * something equivalent was active in the
+				 * caller). */
+    int level;			/* Level of this procedure, for "uplevel"
+				 * purposes (i.e. corresponds to nesting of
+				 * callerVarPtr's, not callerPtr's). 1 for
+				 * outermost procedure, 0 for top-level. */
+    Proc *procPtr;		/* Points to the structure defining the called
+				 * procedure. Used to get information such as
+				 * the number of compiled local variables
+				 * (local variables assigned entries ["slots"]
+				 * in the compiledLocals array below). */
+    TclVarHashTable *varTablePtr;
+                                /* Hash table containing local variables not
+				 * recognized by the compiler, or created at
+				 * execution time through, e.g., upvar.
+				 * Initially NULL and created if needed. */
+    int numCompiledLocals;	/* Count of local variables recognized by the
+				 * compiler including arguments. */
+    Var *compiledLocals;	/* Points to the array of local variables
+				 * recognized by the compiler. The compiler
+				 * emits code that refers to these variables
+				 * using an index into this array. */
+    ClientData clientData;	/* Pointer to some context that is used by
+				 * object systems. The meaning of the contents
+				 * of this field is defined by the code that
+				 * sets it, and it should only ever be set by
+				 * the code that is pushing the frame. In that
+				 * case, the code that sets it should also
+				 * have some means of discovering what the
+				 * meaning of the value is, which we do not
+				 * specify. */
+    LocalCache *localCachePtr;
+} CallFrame;
+
+#define FRAME_IS_PROC   0x1
+#define FRAME_IS_LAMBDA 0x2
+
+/*
+ * TIP #280
+ * The structure below defines a command frame. A command frame provides
+ * location information for all commands executing a tcl script (source, eval,
+ * uplevel, procedure bodies, ...). The runtime structure essentially contains
+ * the stack trace as it would be if the currently executing command were to
+ * throw an error.
+ *
+ * For commands where it makes sense it refers to the associated CallFrame as
+ * well.
+ *
+ * The structures are chained in a single list, with the top of the stack
+ * anchored in the Interp structure.
+ *
+ * Instances can be allocated on the C stack, or the heap, the former making
+ * cleanup a bit simpler.
+ */
+
+typedef struct CmdFrame {
+    /*
+     * General data. Always available.
+     */
+
+    int type;			/* Values see below. */
+    int level;			/* #Frames in stack, prevent O(n) scan of
+				 * list. */
+    int *line;			/* Lines the words of the command start on. */
+    int nline;
+
+    CallFrame *framePtr;	/* Procedure activation record, may be
+				 * NULL. */
+    struct CmdFrame *nextPtr;	/* Link to calling frame */
+
+    /*
+     * Data needed for Eval vs TEBC
+     *
+     * EXECUTION CONTEXTS and usage of CmdFrame
+     *
+     * Field	  TEBC		  EvalEx	  EvalObjEx
+     * =======	  ====		  ======	  =========
+     * level	  yes		  yes		  yes
+     * type	  BC/PREBC	  SRC/EVAL	  EVAL_LIST
+     * line0	  yes		  yes		  yes
+     * framePtr	  yes		  yes		  yes
+     * =======	  ====		  ======	  =========
+     *
+     * =======	  ====		  ======	  ========= union data
+     * line1	  -		  yes		  -
+     * line3	  -		  yes		  -
+     * path	  -		  yes		  -
+     * -------	  ----		  ------	  ---------
+     * codePtr	  yes		  -		  -
+     * pc	  yes		  -		  -
+     * =======	  ====		  ======	  =========
+     *
+     * =======	  ====		  ======	  ========= | union cmd
+     * listPtr	  -		  -		  yes	    |
+     * -------	  ----		  ------	  --------- |
+     * cmd	  yes		  yes		  -	    |
+     * cmdlen	  yes		  yes		  -	    |
+     * -------	  ----		  ------	  --------- |
+     */
+
+    union {
+	struct {
+	    Tcl_Obj *path;	/* Path of the sourced file the command is
+				 * in. */
+	} eval;
+	struct {
+	    const void *codePtr;/* Byte code currently executed */
+	    const char *pc;	/* and instruction pointer. */
+	} tebc;
+    } data;
+    union {
+	struct {
+	    const char *cmd;	/* The executed command, if possible */
+	    int len;		/* And its length */
+	} str;
+	Tcl_Obj *listPtr;	/* Tcl_EvalObjEx, cmd list */
+    } cmd;
+} CmdFrame;
+
+typedef struct CFWord {
+    CmdFrame* framePtr;  /* CmdFrame to acess */
+    int       word;      /* Index of the word in the command */
+    int       refCount;  /* #times the word is on the stack */
+} CFWord;
+
+typedef struct ExtIndex {
+    Tcl_Obj* obj; /* Reference to the word */
+    int pc;   /* Instruction pointer of a command in ExtCmdLoc.loc[.] */
+    int word; /* Index of word in ExtCmdLoc.loc[cmd]->line[.] */
+} ExtIndex;
+
+
+typedef struct CFWordBC {
+    CmdFrame* framePtr;  /* CmdFrame to acess */
+    ExtIndex* eiPtr;     /* Word info: PC and index */
+    int       refCount;  /* #times the word is on the stack */
+} CFWordBC;
+
+/*
+ * The following macros define the allowed values for the type field of the
+ * CmdFrame structure above. Some of the values occur only in the extended
+ * location data referenced via the 'baseLocPtr'.
+ *
+ * TCL_LOCATION_EVAL	  : Frame is for a script evaluated by EvalEx.
+ * TCL_LOCATION_EVAL_LIST : Frame is for a script evaluated by the list
+ *			    optimization path of EvalObjEx.
+ * TCL_LOCATION_BC	  : Frame is for bytecode.
+ * TCL_LOCATION_PREBC	  : Frame is for precompiled bytecode.
+ * TCL_LOCATION_SOURCE	  : Frame is for a script evaluated by EvalEx, from a
+ *			    sourced file.
+ * TCL_LOCATION_PROC	  : Frame is for bytecode of a procedure.
+ *
+ * A TCL_LOCATION_BC type in a frame can be overridden by _SOURCE and _PROC
+ * types, per the context of the byte code in execution.
+ */
+
+#define TCL_LOCATION_EVAL      (0) /* Location in a dynamic eval script */
+#define TCL_LOCATION_EVAL_LIST (1) /* Location in a dynamic eval script,
+				    * list-path */
+#define TCL_LOCATION_BC	       (2) /* Location in byte code */
+#define TCL_LOCATION_PREBC     (3) /* Location in precompiled byte code, no
+				    * location */
+#define TCL_LOCATION_SOURCE    (4) /* Location in a file */
+#define TCL_LOCATION_PROC      (5) /* Location in a dynamic proc */
+
+#define TCL_LOCATION_LAST      (6) /* Number of values in the enum */
+
+/*
+ * Structure passed to describe procedure-like "procedures" that are not
+ * procedures (e.g. a lambda) so that their details can be reported correctly
+ * by [info frame]. Contains a sub-structure for each extra field.
+ */
+
+typedef Tcl_Obj *(*GetFrameInfoValueProc)(ClientData clientData);
+typedef struct {
+    const char *name;		/* Name of this field. */
+    GetFrameInfoValueProc proc;	/* Function to generate a Tcl_Obj* from the
+				 * clientData, or just use the clientData
+				 * directly (after casting) if NULL. */
+    ClientData clientData;	/* Context for above function, or Tcl_Obj* if
+				 * proc field is NULL. */
+} ExtraFrameInfoField;
+typedef struct {
+    int length;			/* Length of array. */
+    ExtraFrameInfoField fields[2];
+				/* Really as long as necessary, but this is
+				 * long enough for nearly anything. */
+} ExtraFrameInfo;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures and procedures related to TclHandles, which are a very
+ * lightweight method of preserving enough information to determine if an
+ * arbitrary malloc'd block has been deleted.
+ *----------------------------------------------------------------
+ */
+
+typedef void **TclHandle;
+
+/*
+ *----------------------------------------------------------------
+ * Experimental flag value passed to Tcl_GetRegExpFromObj. Intended for use
+ * only by Expect. It will probably go away in a later release.
+ *----------------------------------------------------------------
+ */
+
+#define TCL_REG_BOSONLY 002000	/* Prepend \A to pattern so it only matches at
+				 * the beginning of the string. */
+
+/*
+ * These are a thin layer over TclpThreadKeyDataGet and TclpThreadKeyDataSet
+ * when threads are used, or an emulation if there are no threads. These are
+ * really internal and Tcl clients should use Tcl_GetThreadData.
+ */
+
+MODULE_SCOPE void *	TclThreadDataKeyGet(Tcl_ThreadDataKey *keyPtr);
+MODULE_SCOPE void	TclThreadDataKeySet(Tcl_ThreadDataKey *keyPtr,
+			    void *data);
+
+/*
+ * This is a convenience macro used to initialize a thread local storage ptr.
+ */
+
+#define TCL_TSD_INIT(keyPtr) \
+  (ThreadSpecificData *)Tcl_GetThreadData((keyPtr), sizeof(ThreadSpecificData))
+
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to bytecode compilation and execution. These are
+ * used primarily in tclCompile.c, tclExecute.c, and tclBasic.c.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * Forward declaration to prevent errors when the forward references to
+ * Tcl_Parse and CompileEnv are encountered in the procedure type CompileProc
+ * declared below.
+ */
+
+struct CompileEnv;
+
+/*
+ * The type of procedures called by the Tcl bytecode compiler to compile
+ * commands. Pointers to these procedures are kept in the Command structure
+ * describing each command. The integer value returned by a CompileProc must
+ * be one of the following:
+ *
+ * TCL_OK		Compilation completed normally.
+ * TCL_ERROR 		Compilation could not be completed. This can be just a
+ * 			judgment by the CompileProc that the command is too
+ * 			complex to compile effectively, or it can indicate
+ * 			that in the current state of the interp, the command
+ * 			would raise an error. The bytecode compiler will not
+ * 			do any error reporting at compiler time. Error
+ * 			reporting is deferred until the actual runtime,
+ * 			because by then changes in the interp state may allow
+ * 			the command to be successfully evaluated.
+ * TCL_OUT_LINE_COMPILE	A source-compatible alias for TCL_ERROR, kept for the
+ * 			sake of old code only.
+ */
+
+#define TCL_OUT_LINE_COMPILE	TCL_ERROR
+
+typedef int (CompileProc) (Tcl_Interp *interp, Tcl_Parse *parsePtr,
+	struct Command *cmdPtr, struct CompileEnv *compEnvPtr);
+
+/*
+ * The type of procedure called from the compilation hook point in
+ * SetByteCodeFromAny.
+ */
+
+typedef int (CompileHookProc) (Tcl_Interp *interp,
+	struct CompileEnv *compEnvPtr, ClientData clientData);
+
+/*
+ * The data structure for a (linked list of) execution stacks.
+ */
+
+typedef struct ExecStack {
+    struct ExecStack *prevPtr;
+    struct ExecStack *nextPtr;
+    Tcl_Obj **markerPtr;
+    Tcl_Obj **endPtr;
+    Tcl_Obj **tosPtr;
+    Tcl_Obj *stackWords[1];
+} ExecStack;
+
+/*
+ * The data structure defining the execution environment for ByteCode's.
+ * There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
+ * stack that holds command operands and results. The stack grows towards
+ * increasing addresses. The member stackPtr points to the stackItems of the
+ * currently active execution stack.
+ */
+
+typedef struct ExecEnv {
+    ExecStack *execStackPtr;	/* Points to the first item in the evaluation
+				 * stack on the heap. */
+    Tcl_Obj *constants[2];	/* Pointers to constant "0" and "1" objs. */
+} ExecEnv;
+
+/*
+ * The definitions for the LiteralTable and LiteralEntry structures. Each
+ * interpreter contains a LiteralTable. It is used to reduce the storage
+ * needed for all the Tcl objects that hold the literals of scripts compiled
+ * by the interpreter. A literal's object is shared by all the ByteCodes that
+ * refer to the literal. Each distinct literal has one LiteralEntry entry in
+ * the LiteralTable. A literal table is a specialized hash table that is
+ * indexed by the literal's string representation, which may contain null
+ * characters.
+ *
+ * Note that we reduce the space needed for literals by sharing literal
+ * objects both within a ByteCode (each ByteCode contains a local
+ * LiteralTable) and across all an interpreter's ByteCodes (with the
+ * interpreter's global LiteralTable).
+ */
+
+typedef struct LiteralEntry {
+    struct LiteralEntry *nextPtr;
+				/* Points to next entry in this hash bucket or
+				 * NULL if end of chain. */
+    Tcl_Obj *objPtr;		/* Points to Tcl object that holds the
+				 * literal's bytes and length. */
+    int refCount;		/* If in an interpreter's global literal
+				 * table, the number of ByteCode structures
+				 * that share the literal object; the literal
+				 * entry can be freed when refCount drops to
+				 * 0. If in a local literal table, -1. */
+    Namespace *nsPtr;		/* Namespace in which this literal is used. We
+				 * try to avoid sharing literal non-FQ command
+				 * names among different namespaces to reduce
+				 * shimmering. */
+} LiteralEntry;
+
+typedef struct LiteralTable {
+    LiteralEntry **buckets;	/* Pointer to bucket array. Each element
+				 * points to first entry in bucket's hash
+				 * chain, or NULL. */
+    LiteralEntry *staticBuckets[TCL_SMALL_HASH_TABLE];
+				/* Bucket array used for small tables to avoid
+				 * mallocs and frees. */
+    int numBuckets;		/* Total number of buckets allocated at
+				 * **buckets. */
+    int numEntries;		/* Total number of entries present in
+				 * table. */
+    int rebuildSize;		/* Enlarge table when numEntries gets to be
+				 * this large. */
+    int mask;			/* Mask value used in hashing function. */
+} LiteralTable;
+
+/*
+ * The following structure defines for each Tcl interpreter various
+ * statistics-related information about the bytecode compiler and
+ * interpreter's operation in that interpreter.
+ */
+
+#ifdef TCL_COMPILE_STATS
+typedef struct ByteCodeStats {
+    long numExecutions;		/* Number of ByteCodes executed. */
+    long numCompilations;	/* Number of ByteCodes created. */
+    long numByteCodesFreed;	/* Number of ByteCodes destroyed. */
+    long instructionCount[256];	/* Number of times each instruction was
+				 * executed. */
+
+    double totalSrcBytes;	/* Total source bytes ever compiled. */
+    double totalByteCodeBytes;	/* Total bytes for all ByteCodes. */
+    double currentSrcBytes;	/* Src bytes for all current ByteCodes. */
+    double currentByteCodeBytes;/* Code bytes in all current ByteCodes. */
+
+    long srcCount[32];		/* Source size distribution: # of srcs of
+				 * size [2**(n-1)..2**n), n in [0..32). */
+    long byteCodeCount[32];	/* ByteCode size distribution. */
+    long lifetimeCount[32];	/* ByteCode lifetime distribution (ms). */
+
+    double currentInstBytes;	/* Instruction bytes-current ByteCodes. */
+    double currentLitBytes;	/* Current literal bytes. */
+    double currentExceptBytes;	/* Current exception table bytes. */
+    double currentAuxBytes;	/* Current auxiliary information bytes. */
+    double currentCmdMapBytes;	/* Current src<->code map bytes. */
+
+    long numLiteralsCreated;	/* Total literal objects ever compiled. */
+    double totalLitStringBytes;	/* Total string bytes in all literals. */
+    double currentLitStringBytes;
+				/* String bytes in current literals. */
+    long literalCount[32];	/* Distribution of literal string sizes. */
+} ByteCodeStats;
+#endif /* TCL_COMPILE_STATS */
+
+/*
+ * Structure used in implementation of those core ensembles which are
+ * partially compiled.
+ */
+
+typedef struct {
+    const char *name;		/* The name of the subcommand. */
+    Tcl_ObjCmdProc *proc;	/* The implementation of the subcommand. */
+    CompileProc *compileProc;	/* The compiler for the subcommand. */
+} EnsembleImplMap;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to commands.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * An imported command is created in an namespace when it imports a "real"
+ * command from another namespace. An imported command has a Command structure
+ * that points (via its ClientData value) to the "real" Command structure in
+ * the source namespace's command table. The real command records all the
+ * imported commands that refer to it in a list of ImportRef structures so
+ * that they can be deleted when the real command is deleted.
+ */
+
+typedef struct ImportRef {
+    struct Command *importedCmdPtr;
+				/* Points to the imported command created in
+				 * an importing namespace; this command
+				 * redirects its invocations to the "real"
+				 * command. */
+    struct ImportRef *nextPtr;	/* Next element on the linked list of imported
+				 * commands that refer to the "real" command.
+				 * The real command deletes these imported
+				 * commands on this list when it is
+				 * deleted. */
+} ImportRef;
+
+/*
+ * Data structure used as the ClientData of imported commands: commands
+ * created in an namespace when it imports a "real" command from another
+ * namespace.
+ */
+
+typedef struct ImportedCmdData {
+    struct Command *realCmdPtr;	/* "Real" command that this imported command
+				 * refers to. */
+    struct Command *selfPtr;	/* Pointer to this imported command. Needed
+				 * only when deleting it in order to remove it
+				 * from the real command's linked list of
+				 * imported commands that refer to it. */
+} ImportedCmdData;
+
+/*
+ * A Command structure exists for each command in a namespace. The Tcl_Command
+ * opaque type actually refers to these structures.
+ */
+
+typedef struct Command {
+    Tcl_HashEntry *hPtr;	/* Pointer to the hash table entry that refers
+				 * to this command. The hash table is either a
+				 * namespace's command table or an
+				 * interpreter's hidden command table. This
+				 * pointer is used to get a command's name
+				 * from its Tcl_Command handle. NULL means
+				 * that the hash table entry has been removed
+				 * already (this can happen if deleteProc
+				 * causes the command to be deleted or
+				 * recreated). */
+    Namespace *nsPtr;		/* Points to the namespace containing this
+				 * command. */
+    int refCount;		/* 1 if in command hashtable plus 1 for each
+				 * reference from a CmdName Tcl object
+				 * representing a command's name in a ByteCode
+				 * instruction sequence. This structure can be
+				 * freed when refCount becomes zero. */
+    int cmdEpoch;		/* Incremented to invalidate any references
+				 * that point to this command when it is
+				 * renamed, deleted, hidden, or exposed. */
+    CompileProc *compileProc;	/* Procedure called to compile command. NULL
+				 * if no compile proc exists for command. */
+    Tcl_ObjCmdProc *objProc;	/* Object-based command procedure. */
+    ClientData objClientData;	/* Arbitrary value passed to object proc. */
+    Tcl_CmdProc *proc;		/* String-based command procedure. */
+    ClientData clientData;	/* Arbitrary value passed to string proc. */
+    Tcl_CmdDeleteProc *deleteProc;
+				/* Procedure invoked when deleting command to,
+				 * e.g., free all client data. */
+    ClientData deleteData;	/* Arbitrary value passed to deleteProc. */
+    int flags;			/* Miscellaneous bits of information about
+				 * command. See below for definitions. */
+    ImportRef *importRefPtr;	/* List of each imported Command created in
+				 * another namespace when this command is
+				 * imported. These imported commands redirect
+				 * invocations back to this command. The list
+				 * is used to remove all those imported
+				 * commands when deleting this "real"
+				 * command. */
+    CommandTrace *tracePtr;	/* First in list of all traces set for this
+				 * command. */
+} Command;
+
+/*
+ * Flag bits for commands.
+ *
+ * CMD_IS_DELETED -		Means that the command is in the process of
+ *				being deleted (its deleteProc is currently
+ *				executing). Other attempts to delete the
+ *				command should be ignored.
+ * CMD_TRACE_ACTIVE -		1 means that trace processing is currently
+ *				underway for a rename/delete change. See the
+ *				two flags below for which is currently being
+ *				processed.
+ * CMD_HAS_EXEC_TRACES -	1 means that this command has at least one
+ *				execution trace (as opposed to simple
+ *				delete/rename traces) in its tracePtr list.
+ * TCL_TRACE_RENAME -		A rename trace is in progress. Further
+ *				recursive renames will not be traced.
+ * TCL_TRACE_DELETE -		A delete trace is in progress. Further
+ *				recursive deletes will not be traced.
+ * (these last two flags are defined in tcl.h)
+ */
+
+#define CMD_IS_DELETED		0x1
+#define CMD_TRACE_ACTIVE	0x2
+#define CMD_HAS_EXEC_TRACES	0x4
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to name resolution procedures.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The interpreter keeps a linked list of name resolution schemes. The scheme
+ * for a namespace is consulted first, followed by the list of schemes in an
+ * interpreter, followed by the default name resolution in Tcl. Schemes are
+ * added/removed from the interpreter's list by calling Tcl_AddInterpResolver
+ * and Tcl_RemoveInterpResolver.
+ */
+
+typedef struct ResolverScheme {
+    char *name;			/* Name identifying this scheme. */
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* Procedure handling command name
+				 * resolution. */
+    Tcl_ResolveVarProc *varResProc;
+				/* Procedure handling variable name resolution
+				 * for variables that can only be handled at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* Procedure handling variable name resolution
+				 * at compile time. */
+
+    struct ResolverScheme *nextPtr;
+				/* Pointer to next record in linked list. */
+} ResolverScheme;
+
+/*
+ * Forward declaration of the TIP#143 limit handler structure.
+ */
+
+typedef struct LimitHandler LimitHandler;
+
+/*
+ * TIP #268.
+ * Values for the selection mode, i.e the package require preferences.
+ */
+
+enum PkgPreferOptions {
+    PKG_PREFER_LATEST, PKG_PREFER_STABLE
+};
+
+/*
+ *----------------------------------------------------------------
+ * This structure defines an interpreter, which is a collection of commands
+ * plus other state information related to interpreting commands, such as
+ * variable storage. Primary responsibility for this data structure is in
+ * tclBasic.c, but almost every Tcl source file uses something in here.
+ *----------------------------------------------------------------
+ */
+
+typedef struct Interp {
+    /*
+     * Note: the first three fields must match exactly the fields in a
+     * Tcl_Interp struct (see tcl.h). If you change one, be sure to change the
+     * other.
+     *
+     * The interpreter's result is held in both the string and the
+     * objResultPtr fields. These fields hold, respectively, the result's
+     * string or object value. The interpreter's result is always in the
+     * result field if that is non-empty, otherwise it is in objResultPtr.
+     * The two fields are kept consistent unless some C code sets
+     * interp->result directly. Programs should not access result and
+     * objResultPtr directly; instead, they should always get and set the
+     * result using procedures such as Tcl_SetObjResult, Tcl_GetObjResult, and
+     * Tcl_GetStringResult. See the SetResult man page for details.
+     */
+
+    char *result;		/* If the last command returned a string
+				 * result, this points to it. Should not be
+				 * accessed directly; see comment above. */
+    Tcl_FreeProc *freeProc;	/* Zero means a string result is statically
+				 * allocated. TCL_DYNAMIC means string result
+				 * was allocated with ckalloc and should be
+				 * freed with ckfree. Other values give
+				 * address of procedure to invoke to free the
+				 * string result. Tcl_Eval must free it before
+				 * executing next command. */
+    int errorLine;		/* When TCL_ERROR is returned, this gives the
+				 * line number in the command where the error
+				 * occurred (1 means first line). */
+    struct TclStubs *stubTable;	/* Pointer to the exported Tcl stub table. On
+				 * previous versions of Tcl this is a pointer
+				 * to the objResultPtr or a pointer to a
+				 * buckets array in a hash table. We therefore
+				 * have to do some careful checking before we
+				 * can use this. */
+
+    TclHandle handle;		/* Handle used to keep track of when this
+				 * interp is deleted. */
+
+    Namespace *globalNsPtr;	/* The interpreter's global namespace. */
+    Tcl_HashTable *hiddenCmdTablePtr;
+				/* Hash table used by tclBasic.c to keep track
+				 * of hidden commands on a per-interp
+				 * basis. */
+    ClientData interpInfo;	/* Information used by tclInterp.c to keep
+				 * track of master/slave interps on a
+				 * per-interp basis. */
+    Tcl_HashTable unused2;	/* No longer used (was mathFuncTable) */
+
+    /*
+     * Information related to procedures and variables. See tclProc.c and
+     * tclVar.c for usage.
+     */
+
+    int numLevels;		/* Keeps track of how many nested calls to
+				 * Tcl_Eval are in progress for this
+				 * interpreter. It's used to delay deletion of
+				 * the table until all Tcl_Eval invocations
+				 * are completed. */
+    int maxNestingDepth;	/* If numLevels exceeds this value then Tcl
+				 * assumes that infinite recursion has
+				 * occurred and it generates an error. */
+    CallFrame *framePtr;	/* Points to top-most in stack of all nested
+				 * procedure invocations. */
+    CallFrame *varFramePtr;	/* Points to the call frame whose variables
+				 * are currently in use (same as framePtr
+				 * unless an "uplevel" command is
+				 * executing). */
+    ActiveVarTrace *activeVarTracePtr;
+				/* First in list of active traces for interp,
+				 * or NULL if no active traces. */
+    int returnCode;		/* [return -code] parameter */
+    CallFrame *rootFramePtr;	/* Global frame pointer for this interpreter */
+    Namespace *lookupNsPtr;	/* Namespace to use ONLY on the next
+				 * TCL_EVAL_INVOKE call to Tcl_EvalObjv */
+
+    /*
+     * Information used by Tcl_AppendResult to keep track of partial results.
+     * See Tcl_AppendResult code for details.
+     */
+
+    char *appendResult;		/* Storage space for results generated by
+				 * Tcl_AppendResult. Ckalloc-ed. NULL means
+				 * not yet allocated. */
+    int appendAvl;		/* Total amount of space available at
+				 * partialResult. */
+    int appendUsed;		/* Number of non-null bytes currently stored
+				 * at partialResult. */
+
+    /*
+     * Information about packages. Used only in tclPkg.c.
+     */
+
+    Tcl_HashTable packageTable;	/* Describes all of the packages loaded in or
+				 * available to this interpreter. Keys are
+				 * package names, values are (Package *)
+				 * pointers. */
+    char *packageUnknown;	/* Command to invoke during "package require"
+				 * commands for packages that aren't described
+				 * in packageTable. Ckalloc'ed, may be
+				 * NULL. */
+    /*
+     * Miscellaneous information:
+     */
+
+    int cmdCount;		/* Total number of times a command procedure
+				 * has been called for this interpreter. */
+    int evalFlags;		/* Flags to control next call to Tcl_Eval.
+				 * Normally zero, but may be set before
+				 * calling Tcl_Eval. See below for valid
+				 * values. */
+    int unused1;		/* No longer used (was termOffset) */
+    LiteralTable literalTable;	/* Contains LiteralEntry's describing all Tcl
+				 * objects holding literals of scripts
+				 * compiled by the interpreter. Indexed by the
+				 * string representations of literals. Used to
+				 * avoid creating duplicate objects. */
+    int compileEpoch;		/* Holds the current "compilation epoch" for
+				 * this interpreter. This is incremented to
+				 * invalidate existing ByteCodes when, e.g., a
+				 * command with a compile procedure is
+				 * redefined. */
+    Proc *compiledProcPtr;	/* If a procedure is being compiled, a pointer
+				 * to its Proc structure; otherwise, this is
+				 * NULL. Set by ObjInterpProc in tclProc.c and
+				 * used by tclCompile.c to process local
+				 * variables appropriately. */
+    ResolverScheme *resolverPtr;
+				/* Linked list of name resolution schemes
+				 * added to this interpreter. Schemes are
+				 * added and removed by calling
+				 * Tcl_AddInterpResolvers and
+				 * Tcl_RemoveInterpResolver respectively. */
+    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
+				 * command active; otherwise this points to
+				 * pathPtr of the file being sourced. */
+    int flags;			/* Various flag bits. See below. */
+    long randSeed;		/* Seed used for rand() function. */
+    Trace *tracePtr;		/* List of traces for this interpreter. */
+    Tcl_HashTable *assocData;	/* Hash table for associating data with this
+				 * interpreter. Cleaned up when this
+				 * interpreter is deleted. */
+    struct ExecEnv *execEnvPtr;	/* Execution environment for Tcl bytecode
+				 * execution. Contains a pointer to the Tcl
+				 * evaluation stack. */
+    Tcl_Obj *emptyObjPtr;	/* Points to an object holding an empty
+				 * string. Returned by Tcl_ObjSetVar2 when
+				 * variable traces change a variable in a
+				 * gross way. */
+    char resultSpace[TCL_RESULT_SIZE+1];
+				/* Static space holding small results. */
+    Tcl_Obj *objResultPtr;	/* If the last command returned an object
+				 * result, this points to it. Should not be
+				 * accessed directly; see comment above. */
+    Tcl_ThreadId threadId;	/* ID of thread that owns the interpreter */
+
+    ActiveCommandTrace *activeCmdTracePtr;
+				/* First in list of active command traces for
+				 * interp, or NULL if no active traces. */
+    ActiveInterpTrace *activeInterpTracePtr;
+				/* First in list of active traces for interp,
+				 * or NULL if no active traces. */
+
+    int tracesForbiddingInline; /* Count of traces (in the list headed by
+				 * tracePtr) that forbid inline bytecode
+				 * compilation */
+
+    /* Fields used to manage extensible return options (TIP 90) */
+    Tcl_Obj *returnOpts;	/* A dictionary holding the options to the
+				 * last [return] command */
+
+    Tcl_Obj *errorInfo;		/* errorInfo value (now as a Tcl_Obj) */
+    Tcl_Obj *eiVar;		/* cached ref to ::errorInfo variable */
+    Tcl_Obj *errorCode;		/* errorCode value (now as a Tcl_Obj) */
+    Tcl_Obj *ecVar;		/* cached ref to ::errorInfo variable */
+    int returnLevel;		/* [return -level] parameter */
+
+    /*
+     * Resource limiting framework support (TIP#143).
+     */
+
+    struct {
+	int active;		/* Flag values defining which limits have been
+				 * set. */
+	int granularityTicker;	/* Counter used to determine how often to
+				 * check the limits. */
+	int exceeded;		/* Which limits have been exceeded, described
+				 * as flag values the same as the 'active'
+				 * field. */
+
+	int cmdCount;		/* Limit for how many commands to execute in
+				 * the interpreter. */
+	LimitHandler *cmdHandlers;
+				/* Handlers to execute when the limit is
+				 * reached. */
+	int cmdGranularity;	/* Mod factor used to determine how often to
+				 * evaluate the limit check. */
+
+	Tcl_Time time;		/* Time limit for execution within the
+				 * interpreter. */
+	LimitHandler *timeHandlers;
+				/* Handlers to execute when the limit is
+				 * reached. */
+	int timeGranularity;	/* Mod factor used to determine how often to
+				 * evaluate the limit check. */
+	Tcl_TimerToken timeEvent;
+				/* Handle for a timer callback that will occur
+				 * when the time-limit is exceeded. */
+
+	Tcl_HashTable callbacks;/* Mapping from (interp,type) pair to data
+				 * used to install a limit handler callback to
+				 * run in _this_ interp when the limit is
+				 * exceeded. */
+    } limit;
+
+    /*
+     * Information for improved default error generation from ensembles
+     * (TIP#112).
+     */
+
+    struct {
+	Tcl_Obj *const *sourceObjs;
+				/* What arguments were actually input into the
+				 * *root* ensemble command? (Nested ensembles
+				 * don't rewrite this.) NULL if we're not
+				 * processing an ensemble. */
+	int numRemovedObjs;	/* How many arguments have been stripped off
+				 * because of ensemble processing. */
+	int numInsertedObjs;	/* How many of the current arguments were
+				 * inserted by an ensemble. */
+    } ensembleRewrite;
+
+    /*
+     * TIP #219 ... Global info for the I/O system ...
+     */
+
+    Tcl_Obj *chanMsg;		/* Error message set by channel drivers, for
+				 * the propagation of arbitrary Tcl errors.
+				 * This information, if present (chanMsg not
+				 * NULL), takes precedence over a POSIX error
+				 * code returned by a channel operation. */
+
+    /* TIP #280 */
+    CmdFrame *cmdFramePtr;	/* Points to the command frame containing
+				 * the location information for the current
+				 * command. */
+    const CmdFrame *invokeCmdFramePtr;
+				/* Points to the command frame which is the
+				 * invoking context of the bytecode compiler.
+				 * NULL when the byte code compiler is not
+				 * active */
+    int invokeWord;		/* Index of the word in the command which
+				 * is getting compiled. */
+    Tcl_HashTable *linePBodyPtr;/* This table remembers for each statically
+				 * defined procedure the location information
+				 * for its body. It is keyed by the address of
+				 * the Proc structure for a procedure. The
+				 * values are "struct CmdFrame*". */
+    Tcl_HashTable *lineBCPtr;	/* This table remembers for each ByteCode
+				 * object the location information for its
+				 * body. It is keyed by the address of the
+				 * Proc structure for a procedure. The values
+				 * are "struct ExtCmdLoc*" (See tclCompile.h) */
+    Tcl_HashTable* lineLABCPtr;
+    Tcl_HashTable* lineLAPtr;   /* This table remembers for each argument of a
+				 * command on the execution stack the index of
+				 * the argument in the command, and the
+				 * location data of the command. It is keyed
+				 * by the address of the Tcl_Obj containing
+				 * the argument. The values are "struct
+				 * CFWord*" (See tclBasic.c). This allows
+				 * commands like uplevel, eval, etc. to find
+				 * location information for their arguments,
+				 * if they are a proper literal argument to an
+				 * invoking command. Alt view: An index to the
+				 * CmdFrame stack keyed by command argument
+				 * holders. */
+    /*
+     * TIP #268. The currently active selection mode, i.e. the package require
+     * preferences.
+     */
+
+    int packagePrefer;		/* Current package selection mode. */
+
+    /*
+     * Hashtables for variable traces and searches
+     */
+
+    Tcl_HashTable varTraces;	/* Hashtable holding the start of a variable's
+				 * active trace list; varPtr is the key. */
+    Tcl_HashTable varSearches;	/* Hashtable holding the start of a variable's
+				 * active searches list; varPtr is the key */
+    /*
+     * The thread-specific data ekeko: cache pointers or values that
+     *  (a) do not change during the thread's lifetime
+     *  (b) require access to TSD to determine at runtime
+     *  (c) are accessed very often (e.g., at each command call)
+     *
+     * Note that these are the same for all interps in the same thread. They
+     * just have to be initialised for the thread's master interp, slaves
+     * inherit the value.
+     *
+     * They are used by the macros defined below.
+     */
+
+    void *allocCache;
+    void *pendingObjDataPtr;	/* Pointer to the Cache and PendingObjData
+				 * structs for this interp's thread; see
+				 * tclObj.c and tclThreadAlloc.c */
+    int *asyncReadyPtr;		/* Pointer to the asyncReady indicator for
+				 * this interp's thread; see tclAsync.c */
+    int *stackBound;		/* Pointer to the limit stack address
+				 * allowable for invoking a new command
+				 * without "risking" a C-stack overflow; see
+				 * TclpCheckStackSpace in the platform's
+				 * directory. */
+
+
+#ifdef TCL_COMPILE_STATS
+    /*
+     * Statistical information about the bytecode compiler and interpreter's
+     * operation.
+     */
+
+    ByteCodeStats stats;	/* Holds compilation and execution statistics
+				 * for this interpreter. */
+#endif /* TCL_COMPILE_STATS */
+} Interp;
+
+/*
+ * Macros that use the TSD-ekeko.
+ */
+
+#define TclAsyncReady(iPtr) \
+    *((iPtr)->asyncReadyPtr)
+
+
+/*
+ * General list of interpreters. Doubly linked for easier removal of items
+ * deep in the list.
+ */
+
+typedef struct InterpList {
+    Interp *interpPtr;
+    struct InterpList *prevPtr;
+    struct InterpList *nextPtr;
+} InterpList;
+
+/*
+ * Macros for splicing into and out of doubly linked lists. They assume
+ * existence of struct items 'prevPtr' and 'nextPtr'.
+ *
+ * a = element to add or remove.
+ * b = list head.
+ *
+ * TclSpliceIn adds to the head of the list.
+ */
+
+#define TclSpliceIn(a,b)			\
+    (a)->nextPtr = (b);				\
+    if ((b) != NULL) {				\
+	(b)->prevPtr = (a);			\
+    }						\
+    (a)->prevPtr = NULL, (b) = (a);
+
+#define TclSpliceOut(a,b)			\
+    if ((a)->prevPtr != NULL) {			\
+	(a)->prevPtr->nextPtr = (a)->nextPtr;	\
+    } else {					\
+	(b) = (a)->nextPtr;			\
+    }						\
+    if ((a)->nextPtr != NULL) {			\
+	(a)->nextPtr->prevPtr = (a)->prevPtr;	\
+    }
+
+/*
+ * EvalFlag bits for Interp structures:
+ *
+ * TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with a
+ *			code other than TCL_OK or TCL_ERROR; 0 means codes
+ *			other than these should be turned into errors.
+ */
+
+#define TCL_ALLOW_EXCEPTIONS	4
+#define TCL_EVAL_FILE             2
+#define TCL_EVAL_CTX              8
+
+/*
+ * Flag bits for Interp structures:
+ *
+ * DELETED:		Non-zero means the interpreter has been deleted:
+ *			don't process any more commands for it, and destroy
+ *			the structure as soon as all nested invocations of
+ *			Tcl_Eval are done.
+ * ERR_ALREADY_LOGGED:	Non-zero means information has already been logged in
+ *			iPtr->errorInfo for the current Tcl_Eval instance, so
+ *			Tcl_Eval needn't log it (used to implement the "error
+ *			message log" command).
+ * DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler should
+ *			not compile any commands into an inline sequence of
+ *			instructions. This is set 1, for example, when command
+ *			traces are requested.
+ * RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the interp
+ *			has not be initialized. This is set 1 when we first
+ *			use the rand() or srand() functions.
+ * SAFE_INTERP:		Non zero means that the current interp is a safe
+ *			interp (i.e. it has only the safe commands installed,
+ *			less priviledge than a regular interp).
+ * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
+ *			active; so no further trace callbacks should be
+ *			invoked.
+ * INTERP_ALTERNATE_WRONG_ARGS: Used for listing second and subsequent forms
+ *			of the wrong-num-args string in Tcl_WrongNumArgs.
+ *			Makes it append instead of replacing and uses
+ *			different intermediate text.
+ *
+ * WARNING: For the sake of some extensions that have made use of former
+ * internal values, do not re-use the flag values 2 (formerly ERR_IN_PROGRESS)
+ * or 8 (formerly ERROR_CODE_SET).
+ */
+
+#define DELETED				    1
+#define ERR_ALREADY_LOGGED		    4
+#define DONT_COMPILE_CMDS_INLINE	 0x20
+#define RAND_SEED_INITIALIZED		 0x40
+#define SAFE_INTERP			 0x80
+#define INTERP_TRACE_IN_PROGRESS	0x200
+#define INTERP_ALTERNATE_WRONG_ARGS	0x400
+#define ERR_LEGACY_COPY			0x800
+
+/*
+ * Maximum number of levels of nesting permitted in Tcl commands (used to
+ * catch infinite recursion).
+ */
+
+#define MAX_NESTING_DEPTH	1000
+
+/*
+ * TIP#143 limit handler internal representation.
+ */
+
+struct LimitHandler {
+    int flags;			/* The state of this particular handler. */
+    Tcl_LimitHandlerProc *handlerProc;
+				/* The handler callback. */
+    ClientData clientData;	/* Opaque argument to the handler callback. */
+    Tcl_LimitHandlerDeleteProc *deleteProc;
+				/* How to delete the clientData */
+    LimitHandler *prevPtr;	/* Previous item in linked list of handlers */
+    LimitHandler *nextPtr;	/* Next item in linked list of handlers */
+};
+
+/*
+ * Values for the LimitHandler flags field.
+ *	LIMIT_HANDLER_ACTIVE - Whether the handler is currently being
+ *		processed; handlers are never to be entered reentrantly.
+ *	LIMIT_HANDLER_DELETED - Whether the handler has been deleted. This
+ *		should not normally be observed because when a handler is
+ *		deleted it is also spliced out of the list of handlers, but
+ *		even so we will be careful.
+ */
+
+#define LIMIT_HANDLER_ACTIVE	0x01
+#define LIMIT_HANDLER_DELETED	0x02
+
+/*
+ * The macro below is used to modify a "char" value (e.g. by casting it to an
+ * unsigned character) so that it can be used safely with macros such as
+ * isspace.
+ */
+
+#define UCHAR(c) ((unsigned char) (c))
+
+/*
+ * This macro is used to properly align the memory allocated by Tcl, giving
+ * the same alignment as the native malloc
+ */
+
+#if defined(__APPLE__)
+#define TCL_ALLOCALIGN	16
+#else
+#define TCL_ALLOCALIGN	(2*sizeof(void *))
+#endif
+
+/*
+ * This macro is used to determine the offset needed to safely allocate any
+ * data structure in memory. Given a starting offset or size, it "rounds up"
+ * or "aligns" the offset to the next 8-byte boundary so that any data
+ * structure can be placed at the resulting offset without fear of an
+ * alignment error.
+ *
+ * WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce the
+ * wrong result on platforms that allocate addresses that are divisible by 4
+ * or 2. Only use it for offsets or sizes.
+ *
+ * This macro is only used by tclCompile.c in the core (Bug 926445). It
+ * however not be made file static, as extensions that touch bytecodes
+ * (notably tbcload) require it.
+ */
+
+#define TCL_ALIGN(x) (((int)(x) + 7) & ~7)
+
+
+/*
+ * The following enum values are used to specify the runtime platform setting
+ * of the tclPlatform variable.
+ */
+
+typedef enum {
+    TCL_PLATFORM_UNIX = 0,	/* Any Unix-like OS. */
+    TCL_PLATFORM_WINDOWS = 2	/* Any Microsoft Windows OS. */
+} TclPlatformType;
+
+/*
+ * The following enum values are used to indicate the translation of a Tcl
+ * channel. Declared here so that each platform can define
+ * TCL_PLATFORM_TRANSLATION to the native translation on that platform
+ */
+
+typedef enum TclEolTranslation {
+    TCL_TRANSLATE_AUTO,		/* Eol == \r, \n and \r\n. */
+    TCL_TRANSLATE_CR,		/* Eol == \r. */
+    TCL_TRANSLATE_LF,		/* Eol == \n. */
+    TCL_TRANSLATE_CRLF		/* Eol == \r\n. */
+} TclEolTranslation;
+
+/*
+ * Flags for TclInvoke:
+ *
+ * TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
+ *				an exposed command.
+ * TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
+ *				command to be invoked is not found. Only has
+ *				an effect if invoking an exposed command,
+ *				i.e. if TCL_INVOKE_HIDDEN is not also set.
+ * TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
+ *				invoked command returns an error. Used if the
+ *				caller plans on recording its own traceback
+ *				information.
+ */
+
+#define	TCL_INVOKE_HIDDEN	(1<<0)
+#define TCL_INVOKE_NO_UNKNOWN	(1<<1)
+#define TCL_INVOKE_NO_TRACEBACK	(1<<2)
+
+/*
+ * The structure used as the internal representation of Tcl list objects. This
+ * struct is grown (reallocated and copied) as necessary to hold all the
+ * list's element pointers. The struct might contain more slots than currently
+ * used to hold all element pointers. This is done to make append operations
+ * faster.
+ */
+
+typedef struct List {
+    int refCount;
+    int maxElemCount;		/* Total number of element array slots. */
+    int elemCount;		/* Current number of list elements. */
+    int canonicalFlag;		/* Set if the string representation was
+				 * derived from the list representation. May
+				 * be ignored if there is no string rep at
+				 * all.*/
+    Tcl_Obj *elements;		/* First list element; the struct is grown to
+				 * accomodate all elements. */
+} List;
+
+/*
+ * Macro used to get the elements of a list object.
+ */
+
+#define ListRepPtr(listPtr) \
+    ((List *) (listPtr)->internalRep.twoPtrValue.ptr1)
+
+#define ListObjGetElements(listPtr, objc, objv) \
+    ((objv) = &(ListRepPtr(listPtr)->elements), \
+     (objc) = ListRepPtr(listPtr)->elemCount)
+
+#define ListObjLength(listPtr, len) \
+    ((len) = ListRepPtr(listPtr)->elemCount)
+
+#define TclListObjGetElements(interp, listPtr, objcPtr, objvPtr) \
+    (((listPtr)->typePtr == &tclListType) \
+	    ? ((ListObjGetElements((listPtr), *(objcPtr), *(objvPtr))), TCL_OK)\
+	    : Tcl_ListObjGetElements((interp), (listPtr), (objcPtr), (objvPtr)))
+
+#define TclListObjLength(interp, listPtr, lenPtr) \
+    (((listPtr)->typePtr == &tclListType) \
+	    ? ((ListObjLength((listPtr), *(lenPtr))), TCL_OK)\
+	    : Tcl_ListObjLength((interp), (listPtr), (lenPtr)))
+
+/*
+ * Macros providing a faster path to integers: Tcl_GetLongFromObj everywhere,
+ * Tcl_GetIntFromObj and TclGetIntForIndex on platforms where longs are ints.
+ *
+ * WARNING: these macros eval their args more than once.
+ */
+
+#define TclGetLongFromObj(interp, objPtr, longPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(longPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : Tcl_GetLongFromObj((interp), (objPtr), (longPtr)))
+
+#if (LONG_MAX == INT_MAX)
+#define TclGetIntFromObj(interp, objPtr, intPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(intPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : Tcl_GetIntFromObj((interp), (objPtr), (intPtr)))
+#define TclGetIntForIndexM(interp, objPtr, endValue, idxPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(idxPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : TclGetIntForIndex((interp), (objPtr), (endValue), (idxPtr)))
+#else
+#define TclGetIntFromObj(interp, objPtr, intPtr) \
+    Tcl_GetIntFromObj((interp), (objPtr), (intPtr))
+#define TclGetIntForIndexM(interp, objPtr, ignore, idxPtr)	\
+    TclGetIntForIndex(interp, objPtr, ignore, idxPtr)
+#endif
+
+/*
+ * Flag values for TclTraceDictPath().
+ *
+ * DICT_PATH_READ indicates that all entries on the path must exist but no
+ * updates will be needed.
+ *
+ * DICT_PATH_UPDATE indicates that we are going to be doing an update at the
+ * tip of the path, so duplication of shared objects should be done along the
+ * way.
+ *
+ * DICT_PATH_EXISTS indicates that we are performing an existance test and a
+ * lookup failure should therefore not be an error. If (and only if) this flag
+ * is set, TclTraceDictPath() will return the special value
+ * DICT_PATH_NON_EXISTENT if the path is not traceable.
+ *
+ * DICT_PATH_CREATE (which also requires the DICT_PATH_UPDATE bit to be set)
+ * indicates that we are to create non-existant dictionaries on the path.
+ */
+
+#define DICT_PATH_READ		0
+#define DICT_PATH_UPDATE	1
+#define DICT_PATH_EXISTS	2
+#define DICT_PATH_CREATE	5
+
+#define DICT_PATH_NON_EXISTENT	((Tcl_Obj *) (void *) 1)
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to the filesystem internals
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The version_2 filesystem is private to Tcl. As and when these changes have
+ * been thoroughly tested and investigated a new public filesystem interface
+ * will be released. The aim is more versatile virtual filesystem interfaces,
+ * more efficiency in 'path' manipulation and usage, and cleaner filesystem
+ * code internally.
+ */
+
+#define TCL_FILESYSTEM_VERSION_2	((Tcl_FSVersion) 0x2)
+typedef ClientData (TclFSGetCwdProc2) (ClientData clientData);
+
+/*
+ * The following types are used for getting and storing platform-specific file
+ * attributes in tclFCmd.c and the various platform-versions of that file.
+ * This is done to have as much common code as possible in the file attributes
+ * code. For more information about the callbacks, see TclFileAttrsCmd in
+ * tclFCmd.c.
+ */
+
+typedef int (TclGetFileAttrProc) (Tcl_Interp *interp, int objIndex,
+	Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr);
+typedef int (TclSetFileAttrProc) (Tcl_Interp *interp, int objIndex,
+	Tcl_Obj *fileName, Tcl_Obj *attrObjPtr);
+
+typedef struct TclFileAttrProcs {
+    TclGetFileAttrProc *getProc;/* The procedure for getting attrs. */
+    TclSetFileAttrProc *setProc;/* The procedure for setting attrs. */
+} TclFileAttrProcs;
+
+/*
+ * Opaque handle used in pipeline routines to encapsulate platform-dependent
+ * state.
+ */
+
+typedef struct TclFile_ *TclFile;
+
+/*
+ * The "globParameters" argument of the function TclGlob is an or'ed
+ * combination of the following values:
+ */
+
+#define TCL_GLOBMODE_NO_COMPLAIN	1
+#define TCL_GLOBMODE_JOIN		2
+#define TCL_GLOBMODE_DIR		4
+#define TCL_GLOBMODE_TAILS		8
+
+typedef enum Tcl_PathPart {
+    TCL_PATH_DIRNAME,
+    TCL_PATH_TAIL,
+    TCL_PATH_EXTENSION,
+    TCL_PATH_ROOT
+} Tcl_PathPart;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to obsolete filesystem hooks
+ *----------------------------------------------------------------
+ */
+
+typedef int (TclStatProc_) (CONST char *path, struct stat *buf);
+typedef int (TclAccessProc_) (CONST char *path, int mode);
+typedef Tcl_Channel (TclOpenFileChannelProc_) (Tcl_Interp *interp,
+	CONST char *fileName, CONST char *modeString, int permissions);
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to procedures
+ *----------------------------------------------------------------
+ */
+
+typedef Tcl_CmdProc *TclCmdProcType;
+typedef Tcl_ObjCmdProc *TclObjCmdProcType;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures for process-global values.
+ *----------------------------------------------------------------
+ */
+
+typedef void (TclInitProcessGlobalValueProc) (char **valuePtr, int *lengthPtr,
+	Tcl_Encoding *encodingPtr);
+
+/*
+ * A ProcessGlobalValue struct exists for each internal value in Tcl that is
+ * to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
+ * the value, and the master is kept as a counted string, with epoch and mutex
+ * control. Each ProcessGlobalValue struct should be a static variable in some
+ * file.
+ */
+
+typedef struct ProcessGlobalValue {
+    int epoch;			/* Epoch counter to detect changes in the
+				 * master value. */
+    int numBytes;		/* Length of the master string. */
+    char *value;		/* The master string value. */
+    Tcl_Encoding encoding;	/* system encoding when master string was
+				 * initialized. */
+    TclInitProcessGlobalValueProc *proc;
+    				/* A procedure to initialize the master string
+				 * copy when a "get" request comes in before
+				 * any "set" request has been received. */
+    Tcl_Mutex mutex;		/* Enforce orderly access from multiple
+				 * threads. */
+    Tcl_ThreadDataKey key;	/* Key for per-thread data holding the
+				 * (Tcl_Obj) copy for each thread. */
+} ProcessGlobalValue;
+
+/*
+ *----------------------------------------------------------------------
+ * Flags for TclParseNumber
+ *----------------------------------------------------------------------
+ */
+
+#define TCL_PARSE_DECIMAL_ONLY		1
+				/* Leading zero doesn't denote octal or hex */
+#define TCL_PARSE_OCTAL_ONLY		2
+				/* Parse octal even without prefix */
+#define TCL_PARSE_HEXADECIMAL_ONLY	4
+				/* Parse hexadecimal even without prefix */
+#define TCL_PARSE_INTEGER_ONLY		8
+				/* Disable floating point parsing */
+#define TCL_PARSE_SCAN_PREFIXES		16
+				/* Use [scan] rules dealing with 0? prefixes */
+#define TCL_PARSE_NO_WHITESPACE		32
+				/* Reject leading/trailing whitespace */
+
+/*
+ *----------------------------------------------------------------------
+ * Type values TclGetNumberFromObj
+ *----------------------------------------------------------------------
+ */
+
+#define TCL_NUMBER_LONG		1
+#define TCL_NUMBER_WIDE		2
+#define TCL_NUMBER_BIG		3
+#define TCL_NUMBER_DOUBLE	4
+#define TCL_NUMBER_NAN		5
+
+/*
+ *----------------------------------------------------------------
+ * Variables shared among Tcl modules but not used by the outside world.
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE char *	tclNativeExecutableName;
+MODULE_SCOPE int	tclFindExecutableSearchDone;
+MODULE_SCOPE char *	tclMemDumpFileName;
+MODULE_SCOPE TclPlatformType tclPlatform;
+MODULE_SCOPE Tcl_NotifierProcs tclOriginalNotifier;
+
+/*
+ * TIP #233 (Virtualized Time)
+ * Data for the time hooks, if any.
+ */
+
+MODULE_SCOPE Tcl_GetTimeProc*   tclGetTimeProcPtr;
+MODULE_SCOPE Tcl_ScaleTimeProc* tclScaleTimeProcPtr;
+MODULE_SCOPE ClientData		tclTimeClientData;
+
+/*
+ * Variables denoting the Tcl object types defined in the core.
+ */
+
+MODULE_SCOPE Tcl_ObjType tclBignumType;
+MODULE_SCOPE Tcl_ObjType tclBooleanType;
+MODULE_SCOPE Tcl_ObjType tclByteArrayType;
+MODULE_SCOPE Tcl_ObjType tclByteCodeType;
+MODULE_SCOPE Tcl_ObjType tclDoubleType;
+MODULE_SCOPE Tcl_ObjType tclEndOffsetType;
+MODULE_SCOPE Tcl_ObjType tclIntType;
+MODULE_SCOPE Tcl_ObjType tclListType;
+MODULE_SCOPE Tcl_ObjType tclDictType;
+MODULE_SCOPE Tcl_ObjType tclProcBodyType;
+MODULE_SCOPE Tcl_ObjType tclStringType;
+MODULE_SCOPE Tcl_ObjType tclArraySearchType;
+MODULE_SCOPE Tcl_ObjType tclEnsembleCmdType;
+#ifndef NO_WIDE_TYPE
+MODULE_SCOPE Tcl_ObjType tclWideIntType;
+#endif
+MODULE_SCOPE Tcl_ObjType tclRegexpType;
+
+/*
+ * Variables denoting the hash key types defined in the core.
+ */
+
+MODULE_SCOPE Tcl_HashKeyType tclArrayHashKeyType;
+MODULE_SCOPE Tcl_HashKeyType tclOneWordHashKeyType;
+MODULE_SCOPE Tcl_HashKeyType tclStringHashKeyType;
+MODULE_SCOPE Tcl_HashKeyType tclObjHashKeyType;
+
+/*
+ * The head of the list of free Tcl objects, and the total number of Tcl
+ * objects ever allocated and freed.
+ */
+
+MODULE_SCOPE Tcl_Obj *	tclFreeObjList;
+
+#ifdef TCL_COMPILE_STATS
+MODULE_SCOPE long	tclObjsAlloced;
+MODULE_SCOPE long	tclObjsFreed;
+#define TCL_MAX_SHARED_OBJ_STATS 5
+MODULE_SCOPE long	tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
+#endif /* TCL_COMPILE_STATS */
+
+/*
+ * Pointer to a heap-allocated string of length zero that the Tcl core uses as
+ * the value of an empty string representation for an object. This value is
+ * shared by all new objects allocated by Tcl_NewObj.
+ */
+
+MODULE_SCOPE char *	tclEmptyStringRep;
+MODULE_SCOPE char	tclEmptyString;
+
+/*
+ *----------------------------------------------------------------
+ * Procedures shared among Tcl modules but not used by the outside world:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE void       TclAdvanceLines(int *line, const char *start,
+			    const char *end);
+MODULE_SCOPE void       TclArgumentEnter(Tcl_Interp* interp,
+			    Tcl_Obj* objv[], int objc, CmdFrame* cf);
+MODULE_SCOPE void       TclArgumentRelease(Tcl_Interp* interp,
+			    Tcl_Obj* objv[], int objc);
+MODULE_SCOPE void       TclArgumentGet(Tcl_Interp* interp, Tcl_Obj* obj,
+			    CmdFrame** cfPtrPtr, int* wordPtr);
+MODULE_SCOPE void       TclArgumentBCEnter(Tcl_Interp* interp,
+			    void* codePtr, CmdFrame* cfPtr);
+MODULE_SCOPE void       TclArgumentBCRelease(Tcl_Interp* interp,
+			    void* codePtr);
+MODULE_SCOPE int	TclArraySet(Tcl_Interp *interp,
+			    Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj);
+MODULE_SCOPE double	TclBignumToDouble(mp_int *bignum);
+MODULE_SCOPE int	TclByteArrayMatch(const unsigned char *string,
+			    int strLen, const unsigned char *pattern,
+			    int ptnLen, int flags);
+MODULE_SCOPE double	TclCeil(mp_int *a);
+MODULE_SCOPE int	TclCheckBadOctal(Tcl_Interp *interp,const char *value);
+MODULE_SCOPE int	TclChanCaughtErrorBypass(Tcl_Interp *interp,
+			    Tcl_Channel chan);
+MODULE_SCOPE void	TclCleanupLiteralTable(Tcl_Interp *interp,
+			    LiteralTable *tablePtr);
+MODULE_SCOPE int	TclDoubleDigits(char *buf, double value, int *signum);
+MODULE_SCOPE void       TclDeleteNamespaceVars(Namespace *nsPtr);
+/* TIP #280 - Modified token based evulation, with line information */
+MODULE_SCOPE int        TclEvalEx(Tcl_Interp *interp, const char *script,
+			    int numBytes, int flags, int line);
+MODULE_SCOPE int	TclFileAttrsCmd(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclFileCopyCmd(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclFileDeleteCmd(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclFileMakeDirsCmd(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclFileRenameCmd(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TclFinalizeAllocSubsystem(void);
+MODULE_SCOPE void	TclFinalizeAsync(void);
+MODULE_SCOPE void	TclFinalizeDoubleConversion(void);
+MODULE_SCOPE void	TclFinalizeEncodingSubsystem(void);
+MODULE_SCOPE void	TclFinalizeEnvironment(void);
+MODULE_SCOPE void	TclFinalizeExecution(void);
+MODULE_SCOPE void	TclFinalizeIOSubsystem(void);
+MODULE_SCOPE void	TclFinalizeFilesystem(void);
+MODULE_SCOPE void	TclResetFilesystem(void);
+MODULE_SCOPE void	TclFinalizeLoad(void);
+MODULE_SCOPE void	TclFinalizeLock(void);
+MODULE_SCOPE void	TclFinalizeMemorySubsystem(void);
+MODULE_SCOPE void	TclFinalizeNotifier(void);
+MODULE_SCOPE void	TclFinalizeObjects(void);
+MODULE_SCOPE void	TclFinalizePreserve(void);
+MODULE_SCOPE void	TclFinalizeSynchronization(void);
+MODULE_SCOPE void	TclFinalizeThreadAlloc(void);
+MODULE_SCOPE void	TclFinalizeThreadData(void);
+MODULE_SCOPE double	TclFloor(mp_int *a);
+MODULE_SCOPE void	TclFormatNaN(double value, char *buffer);
+MODULE_SCOPE int	TclFSFileAttrIndex(Tcl_Obj *pathPtr,
+			    const char *attributeName, int *indexPtr);
+MODULE_SCOPE void	TclFSUnloadTempFile(Tcl_LoadHandle loadHandle);
+MODULE_SCOPE int *      TclGetAsyncReadyPtr(void);
+MODULE_SCOPE Tcl_Obj *	TclGetBgErrorHandler(Tcl_Interp *interp);
+MODULE_SCOPE int	TclGetChannelFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *objPtr, Tcl_Channel *chanPtr,
+			    int *modePtr, int flags);
+MODULE_SCOPE int	TclGetNumberFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *objPtr, ClientData *clientDataPtr,
+			    int *typePtr);
+MODULE_SCOPE int	TclGetOpenModeEx(Tcl_Interp *interp,
+			    const char *modeString, int *seekFlagPtr,
+			    int *binaryPtr);
+MODULE_SCOPE Tcl_Obj *	TclGetProcessGlobalValue(ProcessGlobalValue *pgvPtr);
+MODULE_SCOPE const char *TclGetSrcInfoForCmd(Interp *iPtr, int *lenPtr);
+MODULE_SCOPE int	TclGlob(Tcl_Interp *interp, char *pattern,
+			    Tcl_Obj *unquotedPrefix, int globFlags,
+			    Tcl_GlobTypeData *types);
+MODULE_SCOPE int	TclIncrObj(Tcl_Interp *interp, Tcl_Obj *valuePtr,
+			    Tcl_Obj *incrPtr);
+MODULE_SCOPE Tcl_Obj *	TclIncrObjVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr, int flags);
+MODULE_SCOPE int	TclInfoExistsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Obj *	TclInfoFrame(Tcl_Interp *interp, CmdFrame *framePtr);
+MODULE_SCOPE int	TclInfoGlobalsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclInfoLocalsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclInfoVarsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TclInitAlloc(void);
+MODULE_SCOPE void	TclInitDbCkalloc(void);
+MODULE_SCOPE void	TclInitDoubleConversion(void);
+MODULE_SCOPE void	TclInitEmbeddedConfigurationInformation(
+			    Tcl_Interp *interp);
+MODULE_SCOPE void	TclInitEncodingSubsystem(void);
+MODULE_SCOPE void	TclInitIOSubsystem(void);
+MODULE_SCOPE void	TclInitLimitSupport(Tcl_Interp *interp);
+MODULE_SCOPE void	TclInitNamespaceSubsystem(void);
+MODULE_SCOPE void	TclInitNotifier(void);
+MODULE_SCOPE void	TclInitObjSubsystem(void);
+MODULE_SCOPE void	TclInitSubsystems(void);
+MODULE_SCOPE int	TclInterpReady(Tcl_Interp *interp);
+MODULE_SCOPE int	TclIsLocalScalar(const char *src, int len);
+MODULE_SCOPE int	TclJoinThread(Tcl_ThreadId id, int *result);
+MODULE_SCOPE void	TclLimitRemoveAllHandlers(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_Obj *	TclLindexList(Tcl_Interp *interp,
+			    Tcl_Obj *listPtr, Tcl_Obj *argPtr);
+MODULE_SCOPE Tcl_Obj *	TclLindexFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    int indexCount, Tcl_Obj *const indexArray[]);
+/* TIP #280 */
+MODULE_SCOPE void       TclListLines(const char *listStr, int line, int n,
+			    int *lines);
+MODULE_SCOPE Tcl_Obj *	TclListObjCopy(Tcl_Interp *interp, Tcl_Obj *listPtr);
+MODULE_SCOPE int	TclLoadFile(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    int symc, const char *symbols[],
+			    Tcl_PackageInitProc **procPtrs[],
+			    Tcl_LoadHandle *handlePtr,
+			    ClientData *clientDataPtr,
+			    Tcl_FSUnloadFileProc **unloadProcPtr);
+MODULE_SCOPE Tcl_Obj *	TclLsetList(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    Tcl_Obj *indexPtr, Tcl_Obj *valuePtr);
+MODULE_SCOPE Tcl_Obj *	TclLsetFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    int indexCount, Tcl_Obj *const indexArray[],
+			    Tcl_Obj *valuePtr);
+MODULE_SCOPE Tcl_Command TclMakeEnsemble(Tcl_Interp *interp, const char *name,
+			    const EnsembleImplMap map[]);
+MODULE_SCOPE int        TclMarkList(Tcl_Interp *interp, const char *list,
+			    const char *end, int *argcPtr,
+			    const int **argszPtr, const char ***argvPtr);
+MODULE_SCOPE int	TclMergeReturnOptions(Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[], Tcl_Obj **optionsPtrPtr,
+			    int *codePtr, int *levelPtr);
+MODULE_SCOPE int	TclNokia770Doubles();
+MODULE_SCOPE void       TclObjVarErrMsg(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
+	                    Tcl_Obj *part2Ptr, const char *operation,
+	                    const char *reason, int index);
+MODULE_SCOPE int	TclObjInvokeNamespace(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[],
+			    Tcl_Namespace *nsPtr, int flags);
+MODULE_SCOPE int	TclObjUnsetVar2(Tcl_Interp *interp,
+			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags);
+MODULE_SCOPE int	TclParseBackslash(const char *src,
+			    int numBytes, int *readPtr, char *dst);
+MODULE_SCOPE int	TclParseHex(const char *src, int numBytes,
+			    Tcl_UniChar *resultPtr);
+MODULE_SCOPE int	TclParseNumber(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    const char *expected, const char *bytes,
+			    int numBytes, const char **endPtrPtr, int flags);
+MODULE_SCOPE void	TclParseInit(Tcl_Interp *interp, const char *string,
+			    int numBytes, Tcl_Parse *parsePtr);
+MODULE_SCOPE int	TclParseAllWhiteSpace(const char *src, int numBytes);
+MODULE_SCOPE int	TclProcessReturn(Tcl_Interp *interp,
+			    int code, int level, Tcl_Obj *returnOpts);
+#ifndef TCL_NO_STACK_CHECK
+MODULE_SCOPE int        TclpGetCStackParams(int **stackBoundPtr);
+#endif
+MODULE_SCOPE int	TclpObjLstat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);
+MODULE_SCOPE Tcl_Obj *	TclpTempFileName(void);
+MODULE_SCOPE Tcl_Obj *	TclNewFSPathObj(Tcl_Obj *dirPtr, const char *addStrRep,
+			    int len);
+MODULE_SCOPE int	TclpDeleteFile(const char *path);
+MODULE_SCOPE void	TclpFinalizeCondition(Tcl_Condition *condPtr);
+MODULE_SCOPE void	TclpFinalizeMutex(Tcl_Mutex *mutexPtr);
+MODULE_SCOPE void	TclpFinalizePipes(void);
+MODULE_SCOPE void	TclpFinalizeSockets(void);
+MODULE_SCOPE int	TclpThreadCreate(Tcl_ThreadId *idPtr,
+			    Tcl_ThreadCreateProc proc, ClientData clientData,
+			    int stackSize, int flags);
+MODULE_SCOPE int	TclpFindVariable(const char *name, int *lengthPtr);
+MODULE_SCOPE void	TclpInitLibraryPath(char **valuePtr,
+			    int *lengthPtr, Tcl_Encoding *encodingPtr);
+MODULE_SCOPE void	TclpInitLock(void);
+MODULE_SCOPE void	TclpInitPlatform(void);
+MODULE_SCOPE void	TclpInitUnlock(void);
+MODULE_SCOPE int	TclpLoadFile(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    const char *sym1, const char *sym2,
+			    Tcl_PackageInitProc **proc1Ptr,
+			    Tcl_PackageInitProc **proc2Ptr,
+			    ClientData *clientDataPtr,
+			    Tcl_FSUnloadFileProc **unloadProcPtr);
+MODULE_SCOPE Tcl_Obj *	TclpObjListVolumes(void);
+MODULE_SCOPE void	TclpMasterLock(void);
+MODULE_SCOPE void	TclpMasterUnlock(void);
+MODULE_SCOPE int	TclpMatchFiles(Tcl_Interp *interp, char *separators,
+			    Tcl_DString *dirPtr, char *pattern, char *tail);
+MODULE_SCOPE int	TclpObjNormalizePath(Tcl_Interp *interp,
+			    Tcl_Obj *pathPtr, int nextCheckpoint);
+MODULE_SCOPE void	TclpNativeJoinPath(Tcl_Obj *prefix, char *joining);
+MODULE_SCOPE Tcl_Obj *	TclpNativeSplitPath(Tcl_Obj *pathPtr, int *lenPtr);
+MODULE_SCOPE Tcl_PathType TclpGetNativePathType(Tcl_Obj *pathPtr,
+			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef);
+MODULE_SCOPE int 	TclCrossFilesystemCopy(Tcl_Interp *interp,
+			    Tcl_Obj *source, Tcl_Obj *target);
+MODULE_SCOPE int	TclpMatchInDirectory(Tcl_Interp *interp,
+			    Tcl_Obj *resultPtr, Tcl_Obj *pathPtr,
+			    const char *pattern, Tcl_GlobTypeData *types);
+MODULE_SCOPE ClientData	TclpGetNativeCwd(ClientData clientData);
+MODULE_SCOPE Tcl_FSDupInternalRepProc TclNativeDupInternalRep;
+MODULE_SCOPE Tcl_Obj*	TclpObjLink(Tcl_Obj *pathPtr, Tcl_Obj *toPtr,
+			    int linkType);
+MODULE_SCOPE int	TclpObjChdir(Tcl_Obj *pathPtr);
+MODULE_SCOPE Tcl_Obj *	TclPathPart(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    Tcl_PathPart portion);
+MODULE_SCOPE void	TclpPanic(const char *format, ...);
+MODULE_SCOPE char *	TclpReadlink(const char *fileName,
+			    Tcl_DString *linkPtr);
+MODULE_SCOPE void	TclpReleaseFile(TclFile file);
+MODULE_SCOPE void	TclpSetInterfaces(void);
+MODULE_SCOPE void	TclpSetVariables(Tcl_Interp *interp);
+MODULE_SCOPE void	TclpUnloadFile(Tcl_LoadHandle loadHandle);
+MODULE_SCOPE void *	TclpThreadDataKeyGet(Tcl_ThreadDataKey *keyPtr);
+MODULE_SCOPE void	TclpThreadDataKeySet(Tcl_ThreadDataKey *keyPtr,
+			    void *data);
+MODULE_SCOPE void	TclpThreadExit(int status);
+MODULE_SCOPE size_t	TclpThreadGetStackSize(void);
+MODULE_SCOPE void	TclRememberCondition(Tcl_Condition *mutex);
+MODULE_SCOPE void	TclRememberJoinableThread(Tcl_ThreadId id);
+MODULE_SCOPE void	TclRememberMutex(Tcl_Mutex *mutex);
+MODULE_SCOPE void	TclRemoveScriptLimitCallbacks(Tcl_Interp *interp);
+MODULE_SCOPE int	TclReToGlob(Tcl_Interp *interp, const char *reStr,
+			    int reStrLen, Tcl_DString *dsPtr, int *flagsPtr);
+MODULE_SCOPE void	TclSetBgErrorHandler(Tcl_Interp *interp,
+			    Tcl_Obj *cmdPrefix);
+MODULE_SCOPE void	TclSetBignumIntRep(Tcl_Obj *objPtr,
+			    mp_int *bignumValue);
+MODULE_SCOPE void	TclSetCmdNameObj(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    Command *cmdPtr);
+MODULE_SCOPE void	TclSetProcessGlobalValue(ProcessGlobalValue *pgvPtr,
+			    Tcl_Obj *newValue, Tcl_Encoding encoding);
+MODULE_SCOPE void	TclSignalExitThread(Tcl_ThreadId id, int result);
+MODULE_SCOPE void *	TclStackRealloc(Tcl_Interp *interp, void *ptr,
+			    int numBytes);
+MODULE_SCOPE int	TclStringMatch(const char *str, int strLen,
+			    const char *pattern, int ptnLen, int flags);
+MODULE_SCOPE int	TclStringMatchObj(Tcl_Obj *stringObj,
+			    Tcl_Obj *patternObj, int flags);
+MODULE_SCOPE Tcl_Obj *	TclStringObjReverse(Tcl_Obj *objPtr);
+MODULE_SCOPE int	TclSubstTokens(Tcl_Interp *interp, Tcl_Token *tokenPtr,
+			    int count, int *tokensLeftPtr, int line);
+MODULE_SCOPE void	TclTransferResult(Tcl_Interp *sourceInterp, int result,
+			    Tcl_Interp *targetInterp);
+MODULE_SCOPE Tcl_Obj *	TclpNativeToNormalized(ClientData clientData);
+MODULE_SCOPE Tcl_Obj *	TclpFilesystemPathType(Tcl_Obj *pathPtr);
+MODULE_SCOPE Tcl_PackageInitProc *TclpFindSymbol(Tcl_Interp *interp,
+			    Tcl_LoadHandle loadHandle, const char *symbol);
+MODULE_SCOPE int	TclpDlopen(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    Tcl_LoadHandle *loadHandle,
+			    Tcl_FSUnloadFileProc **unloadProcPtr);
+MODULE_SCOPE int	TclpUtime(Tcl_Obj *pathPtr, struct utimbuf *tval);
+#ifdef TCL_LOAD_FROM_MEMORY
+MODULE_SCOPE void*	TclpLoadMemoryGetBuffer(Tcl_Interp *interp, int size);
+MODULE_SCOPE int	TclpLoadMemory(Tcl_Interp *interp, void *buffer,
+			    int size, int codeSize, Tcl_LoadHandle *loadHandle,
+			    Tcl_FSUnloadFileProc **unloadProcPtr);
+#endif
+MODULE_SCOPE void	TclInitThreadStorage(void);
+MODULE_SCOPE void	TclpFinalizeThreadDataThread(void);
+MODULE_SCOPE void	TclFinalizeThreadStorage(void);
+#ifdef TCL_WIDE_CLICKS
+MODULE_SCOPE Tcl_WideInt TclpGetWideClicks(void);
+MODULE_SCOPE double	TclpWideClicksToNanoseconds(Tcl_WideInt clicks);
+#endif
+MODULE_SCOPE Tcl_Obj *	TclDisassembleByteCodeObj(Tcl_Obj *objPtr);
+
+/*
+ *----------------------------------------------------------------
+ * Command procedures in the generic core:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE int	Tcl_AfterObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_AppendObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ApplyObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ArrayObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_BinaryObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_BreakObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CaseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CatchObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CdObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitChanCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclChanCreateObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclChanPostEventObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TclClockInit(Tcl_Interp *interp);
+MODULE_SCOPE int	TclClockOldscanObjCmd(
+			    ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CloseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ConcatObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ContinueObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_TimerToken TclCreateAbsoluteTimerHandler(
+			    Tcl_Time *timePtr, Tcl_TimerProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE int	TclDefaultBgErrorHandlerObjCmd(
+			    ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitDictCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_DisassembleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_EncodingObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_EofObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ErrorObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_EvalObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ExecObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ExitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ExprObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FblockedObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FconfigureObjCmd(
+			    ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FcopyObjCmd(ClientData dummy,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FileObjCmd(ClientData dummy,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FileEventObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FlushObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ForObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ForeachObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FormatObjCmd(ClientData dummy,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_GetsObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_GlobalObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_GlobObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_IfObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_IncrObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitInfoCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_InterpObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_JoinObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LappendObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LassignObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LindexObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LinsertObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LlengthObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ListObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LoadObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LrangeObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LrepeatObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LreplaceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LreverseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LsearchObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LsetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LsortObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_NamespaceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_OpenObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PackageObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PidObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PutsObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PwdObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ReadObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RegexpObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RegsubObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RenameObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ReturnObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ScanObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SeekObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SplitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SocketObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SourceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitStringCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_SubstObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SwitchObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TellObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TimeObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TraceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UnloadObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UnsetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UpdateObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UplevelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UpvarObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_VariableObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_VwaitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_WhileObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+
+/*
+ *----------------------------------------------------------------
+ * Compilation procedures for commands in the generic core:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE int	TclCompileAppendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileBreakCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileCatchCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileContinueCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictAppendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictForCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictGetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictIncrCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictLappendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictSetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictUpdateCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileEnsemble(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileExprCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileForCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileForeachCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileGlobalCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileIfCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoExistsCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileIncrCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLappendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLassignCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLindexCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileListCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLlengthCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLsetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceCmd(Tcl_Interp *interp,
+	                    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNoOp(Tcl_Interp *interp,
+	                    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileRegexpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileReturnCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileSetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringCmpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringEqualCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringIndexCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringLenCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringMatchCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileSwitchCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileUpvarCmd(Tcl_Interp *interp,
+	                    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileVariableCmd(Tcl_Interp *interp,
+	                    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileWhileCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+
+MODULE_SCOPE int	TclInvertOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileInvertOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclNotOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileNotOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclAddOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileAddOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclMulOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileMulOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclAndOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileAndOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclOrOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileOrOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclXorOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileXorOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclPowOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompilePowOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclLshiftOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileLshiftOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclRshiftOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileRshiftOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclModOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileModOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclNeqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileNeqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclStrneqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileStrneqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclInOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileInOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclNiOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileNiOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclMinusOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileMinusOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclDivOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileDivOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclLessOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileLessOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclLeqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileLeqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclGreaterOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileGreaterOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclGeqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileGeqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclEqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileEqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclStreqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileStreqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+
+/*
+ * Functions defined in generic/tclVar.c and currenttly exported only for use
+ * by the bytecode compiler and engine. Some of these could later be placed in
+ * the public interface.
+ */
+
+MODULE_SCOPE Var *	TclObjLookupVarEx(Tcl_Interp * interp,
+			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags,
+			    const char * msg, const int createPart1,
+			    const int createPart2, Var **arrayPtrPtr);
+MODULE_SCOPE Var *	TclLookupArrayElement(Tcl_Interp *interp,
+			    Tcl_Obj *arrayNamePtr, Tcl_Obj *elNamePtr,
+			    const int flags, const char *msg,
+			    const int createPart1, const int createPart2,
+			    Var *arrayPtr, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrGetVar(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, const int flags, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrSetVar(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr,
+			    const int flags, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrIncrObjVar(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr,
+			    const int flags, int index);
+MODULE_SCOPE int        TclPtrObjMakeUpvar(Tcl_Interp *interp, Var *otherPtr,
+	                    Tcl_Obj *myNamePtr, int myFlags, int index);
+MODULE_SCOPE void	TclInvalidateNsPath(Namespace *nsPtr);
+
+/*
+ * The new extended interface to the variable traces.
+ */
+
+MODULE_SCOPE int	TclObjCallVarTraces(Interp *iPtr, Var *arrayPtr,
+			    Var *varPtr, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr,
+			    int flags, int leaveErrMsg, int index);
+
+/*
+ * So tclObj.c and tclDictObj.c can share these implementations.
+ */
+
+MODULE_SCOPE int	TclCompareObjKeys(void *keyPtr, Tcl_HashEntry *hPtr);
+MODULE_SCOPE void	TclFreeObjEntry(Tcl_HashEntry *hPtr);
+MODULE_SCOPE unsigned	TclHashObjKey(Tcl_HashTable *tablePtr, void *keyPtr);
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to create and release Tcl objects.
+ * TclNewObj(objPtr) creates a new object denoting an empty string.
+ * TclDecrRefCount(objPtr) decrements the object's reference count, and frees
+ * the object if its reference count is zero. These macros are inline versions
+ * of Tcl_NewObj() and Tcl_DecrRefCount(). Notice that the names differ in not
+ * having a "_" after the "Tcl". Notice also that these macros reference their
+ * argument more than once, so you should avoid calling them with an
+ * expression that is expensive to compute or has side effects. The ANSI C
+ * "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclNewObj(Tcl_Obj *objPtr);
+ * MODULE_SCOPE void	TclDecrRefCount(Tcl_Obj *objPtr);
+ *
+ * These macros are defined in terms of two macros that depend on memory
+ * allocator in use: TclAllocObjStorage, TclFreeObjStorage. They are defined
+ * below.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * DTrace object allocation probe macros.
+ */
+
+#ifdef USE_DTRACE
+#include "tclDTrace.h"
+#define	TCL_DTRACE_OBJ_CREATE(objPtr)	TCL_OBJ_CREATE(objPtr)
+#define	TCL_DTRACE_OBJ_FREE(objPtr)	TCL_OBJ_FREE(objPtr)
+#else /* USE_DTRACE */
+#define	TCL_DTRACE_OBJ_CREATE(objPtr)	{}
+#define	TCL_DTRACE_OBJ_FREE(objPtr)	{}
+#endif /* USE_DTRACE */
+
+#ifdef TCL_COMPILE_STATS
+#  define TclIncrObjsAllocated() \
+    tclObjsAlloced++
+#  define TclIncrObjsFreed() \
+    tclObjsFreed++
+#else
+#  define TclIncrObjsAllocated()
+#  define TclIncrObjsFreed()
+#endif /* TCL_COMPILE_STATS */
+
+#ifndef TCL_MEM_DEBUG
+# define TclNewObj(objPtr) \
+    TclIncrObjsAllocated(); \
+    TclAllocObjStorage(objPtr); \
+    (objPtr)->refCount = 0; \
+    (objPtr)->bytes    = tclEmptyStringRep; \
+    (objPtr)->length   = 0; \
+    (objPtr)->typePtr  = NULL; \
+    TCL_DTRACE_OBJ_CREATE(objPtr)
+
+/*
+ * Invalidate the string rep first so we can use the bytes value for our
+ * pointer chain, and signal an obj deletion (as opposed to shimmering) with
+ * 'length == -1'.
+ * Use empty 'if ; else' to handle use in unbraced outer if/else conditions
+ */
+
+# define TclDecrRefCount(objPtr) \
+    if (--(objPtr)->refCount > 0) ; else { \
+	if (!(objPtr)->typePtr || !(objPtr)->typePtr->freeIntRepProc) { \
+	    TCL_DTRACE_OBJ_FREE(objPtr); \
+  	    if ((objPtr)->bytes \
+	            && ((objPtr)->bytes != tclEmptyStringRep)) { \
+	        ckfree((char *) (objPtr)->bytes); \
+	    } \
+            (objPtr)->length = -1; \
+	    TclFreeObjStorage(objPtr); \
+	    TclIncrObjsFreed(); \
+	} else { \
+	    TclFreeObj(objPtr); \
+	} \
+    }
+
+#if defined(PURIFY)
+
+/*
+ * The PURIFY mode is like the regular mode, but instead of doing block
+ * Tcl_Obj allocation and keeping a freed list for efficiency, it always
+ * allocates and frees a single Tcl_Obj so that tools like Purify can better
+ * track memory leaks
+ */
+
+#  define TclAllocObjStorage(objPtr) \
+	(objPtr) = (Tcl_Obj *) Tcl_Alloc(sizeof(Tcl_Obj))
+
+#  define TclFreeObjStorage(objPtr) \
+	ckfree((char *) (objPtr))
+
+#undef USE_THREAD_ALLOC
+#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)
+
+/*
+ * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's from
+ * per-thread caches.
+ */
+
+MODULE_SCOPE Tcl_Obj *	TclThreadAllocObj(void);
+MODULE_SCOPE void	TclThreadFreeObj(Tcl_Obj *);
+MODULE_SCOPE Tcl_Mutex *TclpNewAllocMutex(void);
+MODULE_SCOPE void	TclFreeAllocCache(void *);
+MODULE_SCOPE void *	TclpGetAllocCache(void);
+MODULE_SCOPE void	TclpSetAllocCache(void *);
+MODULE_SCOPE void	TclpFreeAllocMutex(Tcl_Mutex *mutex);
+MODULE_SCOPE void	TclpFreeAllocCache(void *);
+
+#  define TclAllocObjStorage(objPtr) \
+	(objPtr) = TclThreadAllocObj()
+
+#  define TclFreeObjStorage(objPtr) \
+	TclThreadFreeObj((objPtr))
+
+#else /* not PURIFY or USE_THREAD_ALLOC */
+
+#ifdef TCL_THREADS
+/* declared in tclObj.c */
+MODULE_SCOPE Tcl_Mutex	tclObjMutex;
+#endif
+
+#  define TclAllocObjStorage(objPtr) \
+	Tcl_MutexLock(&tclObjMutex); \
+	if (tclFreeObjList == NULL) { \
+	    TclAllocateFreeObjects(); \
+	} \
+	(objPtr) = tclFreeObjList; \
+	tclFreeObjList = (Tcl_Obj *) \
+		tclFreeObjList->internalRep.otherValuePtr; \
+	Tcl_MutexUnlock(&tclObjMutex)
+
+#  define TclFreeObjStorage(objPtr) \
+	Tcl_MutexLock(&tclObjMutex); \
+	(objPtr)->internalRep.otherValuePtr = (void *) tclFreeObjList; \
+	tclFreeObjList = (objPtr); \
+	Tcl_MutexUnlock(&tclObjMutex)
+#endif
+
+#else /* TCL_MEM_DEBUG */
+MODULE_SCOPE void	TclDbInitNewObj(Tcl_Obj *objPtr);
+
+# define TclDbNewObj(objPtr, file, line) \
+    TclIncrObjsAllocated(); \
+    (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \
+    TclDbInitNewObj(objPtr); \
+    TCL_DTRACE_OBJ_CREATE(objPtr)
+
+# define TclNewObj(objPtr) \
+    TclDbNewObj(objPtr, __FILE__, __LINE__);
+
+# define TclDecrRefCount(objPtr) \
+    Tcl_DbDecrRefCount(objPtr, __FILE__, __LINE__)
+
+# define TclNewListObjDirect(objc, objv) \
+    TclDbNewListObjDirect(objc, objv, __FILE__, __LINE__)
+
+#undef USE_THREAD_ALLOC
+#endif /* TCL_MEM_DEBUG */
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to set a Tcl_Obj's string representation to a
+ * copy of the "len" bytes starting at "bytePtr". This code works even if the
+ * byte array contains NULLs as long as the length is correct. Because "len"
+ * is referenced multiple times, it should be as simple an expression as
+ * possible. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void TclInitStringRep(Tcl_Obj *objPtr, char *bytePtr, int len);
+ *
+ * This macro should only be called on an unshared objPtr where
+ *  objPtr->typePtr->freeIntRepProc == NULL
+ *----------------------------------------------------------------
+ */
+
+#define TclInitStringRep(objPtr, bytePtr, len) \
+    if ((len) == 0) { \
+	(objPtr)->bytes	 = tclEmptyStringRep; \
+	(objPtr)->length = 0; \
+    } else { \
+	(objPtr)->bytes = (char *) ckalloc((unsigned) ((len) + 1)); \
+	memcpy((void *) (objPtr)->bytes, (void *) (bytePtr), \
+		(unsigned) (len)); \
+	(objPtr)->bytes[len] = '\0'; \
+	(objPtr)->length = (len); \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to get the string representation's byte array
+ * pointer from a Tcl_Obj. This is an inline version of Tcl_GetString(). The
+ * macro's expression result is the string rep's byte pointer which might be
+ * NULL. The bytes referenced by this pointer must not be modified by the
+ * caller. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE char *	TclGetString(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclGetString(objPtr) \
+    ((objPtr)->bytes? (objPtr)->bytes : Tcl_GetString((objPtr)))
+
+
+#define TclGetStringFromObj(objPtr, lenPtr) \
+    ((objPtr)->bytes \
+	    ? (*(lenPtr) = (objPtr)->length, (objPtr)->bytes)	\
+	    : Tcl_GetStringFromObj((objPtr), (lenPtr)))
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to clean out an object's internal
+ * representation. Does not actually reset the rep's bytes. The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclFreeIntRep(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclFreeIntRep(objPtr) \
+    if ((objPtr)->typePtr != NULL && \
+	    (objPtr)->typePtr->freeIntRepProc != NULL) { \
+	(objPtr)->typePtr->freeIntRepProc(objPtr); \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to clean out an object's string representation.
+ * The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclInvalidateStringRep(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclInvalidateStringRep(objPtr) \
+    if (objPtr->bytes != NULL) { \
+	if (objPtr->bytes != tclEmptyStringRep) {\
+	    ckfree((char *) objPtr->bytes);\
+	}\
+	objPtr->bytes = NULL;\
+    }\
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to grow Tcl_Token arrays.  They use
+ * the same growth algorithm as used in tclStringObj.c for growing
+ * strings.  The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclGrowTokenArray(Tcl_Token *tokenPtr, int used,
+ *				int available, int append,
+ *				Tcl_Token *staticPtr);
+ * MODULE_SCOPE void	TclGrowParseTokenArray(Tcl_Parse *parsePtr,
+ *				int append);
+ *----------------------------------------------------------------
+ */
+
+#define TCL_MIN_TOKEN_GROWTH 50
+#define TclGrowTokenArray(tokenPtr, used, available, append, staticPtr)	\
+{									\
+    int needed = (used) + (append);					\
+    if (needed > (available)) {						\
+	int allocated = 2 * needed;					\
+	Tcl_Token *oldPtr = (tokenPtr);					\
+	Tcl_Token *newPtr;						\
+	if (oldPtr == (staticPtr)) {					\
+	    oldPtr = NULL;						\
+	}								\
+	newPtr = (Tcl_Token *) attemptckrealloc( (char *) oldPtr,	\
+		(unsigned int) (allocated * sizeof(Tcl_Token)));	\
+	if (newPtr == NULL) {						\
+	    allocated = needed + (append) + TCL_MIN_TOKEN_GROWTH;	\
+	    newPtr = (Tcl_Token *) ckrealloc( (char *) oldPtr,		\
+		    (unsigned int) (allocated * sizeof(Tcl_Token)));	\
+	}								\
+	(available) = allocated;					\
+	if (oldPtr == NULL) {						\
+	    memcpy((VOID *) newPtr, (VOID *) staticPtr,			\
+		    (size_t) ((used) * sizeof(Tcl_Token)));		\
+	}								\
+	(tokenPtr) = newPtr;						\
+    }									\
+}
+
+#define TclGrowParseTokenArray(parsePtr, append)			\
+    TclGrowTokenArray((parsePtr)->tokenPtr, (parsePtr)->numTokens,	\
+	    (parsePtr)->tokensAvailable, (append),			\
+	    (parsePtr)->staticTokens)
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core get a unicode char from a utf string. It checks
+ * to see if we have a one-byte utf char before calling the real
+ * Tcl_UtfToUniChar, as this will save a lot of time for primarily ascii
+ * string handling. The macro's expression result is 1 for the 1-byte case or
+ * the result of Tcl_UtfToUniChar. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclUtfToUniChar(const char *string, Tcl_UniChar *ch);
+ *----------------------------------------------------------------
+ */
+
+#define TclUtfToUniChar(str, chPtr) \
+	((((unsigned char) *(str)) < 0xC0) ? \
+	    ((*(chPtr) = (Tcl_UniChar) *(str)), 1) \
+	    : Tcl_UtfToUniChar(str, chPtr))
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to compare Unicode strings. On big-endian
+ * systems we can use the more efficient memcmp, but this would not be
+ * lexically correct on little-endian systems. The ANSI C "prototype" for
+ * this macro is:
+ *
+ * MODULE_SCOPE int	TclUniCharNcmp(const Tcl_UniChar *cs,
+ *			    const Tcl_UniChar *ct, unsigned long n);
+ *----------------------------------------------------------------
+ */
+
+#ifdef WORDS_BIGENDIAN
+#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
+#else /* !WORDS_BIGENDIAN */
+#   define TclUniCharNcmp Tcl_UniCharNcmp
+#endif /* WORDS_BIGENDIAN */
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to increment a namespace's export export epoch
+ * counter. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclInvalidateNsCmdLookup(Namespace *nsPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclInvalidateNsCmdLookup(nsPtr) \
+    if ((nsPtr)->numExportPatterns) { \
+	(nsPtr)->exportLookupEpoch++; \
+    }
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Core procedures added to libtommath for bignum manipulation.
+ *
+ *----------------------------------------------------------------------
+ */
+
+MODULE_SCOPE int	TclTommath_Init(Tcl_Interp *interp);
+MODULE_SCOPE void	TclBNInitBignumFromLong(mp_int *bignum, long initVal);
+MODULE_SCOPE void	TclBNInitBignumFromWideInt(mp_int *bignum,
+			    Tcl_WideInt initVal);
+MODULE_SCOPE void	TclBNInitBignumFromWideUInt(mp_int *bignum,
+			    Tcl_WideUInt initVal);
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to check whether a pattern has any characters
+ * special to [string match]. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclMatchIsTrivial(const char *pattern);
+ *----------------------------------------------------------------
+ */
+
+#define TclMatchIsTrivial(pattern)	strpbrk((pattern), "*[?\\") == NULL
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to write the string rep of a long integer to a
+ * character buffer. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclFormatInt(char *buf, long n);
+ *----------------------------------------------------------------
+ */
+
+#define TclFormatInt(buf, n)		sprintf((buf), "%ld", (long)(n))
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to set a Tcl_Obj's numeric representation
+ * avoiding the corresponding function calls in time critical parts of the
+ * core. They should only be called on unshared objects. The ANSI C
+ * "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclSetIntObj(Tcl_Obj *objPtr, int intValue);
+ * MODULE_SCOPE void	TclSetLongObj(Tcl_Obj *objPtr, long longValue);
+ * MODULE_SCOPE void	TclSetBooleanObj(Tcl_Obj *objPtr, long boolValue);
+ * MODULE_SCOPE void	TclSetWideIntObj(Tcl_Obj *objPtr, Tcl_WideInt w);
+ * MODULE_SCOPE void	TclSetDoubleObj(Tcl_Obj *objPtr, double d);
+ *----------------------------------------------------------------
+ */
+
+#define TclSetIntObj(objPtr, i) \
+    TclInvalidateStringRep(objPtr);\
+    TclFreeIntRep(objPtr); \
+    (objPtr)->internalRep.longValue = (long)(i); \
+    (objPtr)->typePtr = &tclIntType
+
+#define TclSetLongObj(objPtr, l) \
+    TclSetIntObj((objPtr), (l))
+
+/*
+ * NOTE: There is to be no such thing as a "pure" boolean. Boolean values set
+ * programmatically go straight to being "int" Tcl_Obj's, with value 0 or 1.
+ * The only "boolean" Tcl_Obj's shall be those holding the cached boolean
+ * value of strings like: "yes", "no", "true", "false", "on", "off".
+ */
+
+#define TclSetBooleanObj(objPtr, b) \
+    TclSetIntObj((objPtr), ((b)? 1 : 0));
+
+#ifndef NO_WIDE_TYPE
+#define TclSetWideIntObj(objPtr, w) \
+    TclInvalidateStringRep(objPtr);\
+    TclFreeIntRep(objPtr); \
+    (objPtr)->internalRep.wideValue = (Tcl_WideInt)(w); \
+    (objPtr)->typePtr = &tclWideIntType
+#endif
+
+#define TclSetDoubleObj(objPtr, d) \
+    TclInvalidateStringRep(objPtr);\
+    TclFreeIntRep(objPtr); \
+    (objPtr)->internalRep.doubleValue = (double)(d); \
+    (objPtr)->typePtr = &tclDoubleType
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to create and initialise objects of standard
+ * types, avoiding the corresponding function calls in time critical parts of
+ * the core. The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclNewIntObj(Tcl_Obj *objPtr, int i);
+ * MODULE_SCOPE void	TclNewLongObj(Tcl_Obj *objPtr, long l);
+ * MODULE_SCOPE void	TclNewBooleanObj(Tcl_Obj *objPtr, int b);
+ * MODULE_SCOPE void	TclNewWideObj(Tcl_Obj *objPtr, Tcl_WideInt w);
+ * MODULE_SCOPE void	TclNewDoubleObj(Tcl_Obj *objPtr, double d);
+ * MODULE_SCOPE void	TclNewStringObj(Tcl_Obj *objPtr, char *s, int len);
+ * MODULE_SCOPE void	TclNewLiteralStringObj(Tcl_Obj*objPtr, char*sLiteral);
+ *
+ *----------------------------------------------------------------
+ */
+
+#ifndef TCL_MEM_DEBUG
+#define TclNewIntObj(objPtr, i) \
+    TclIncrObjsAllocated(); \
+    TclAllocObjStorage(objPtr); \
+    (objPtr)->refCount = 0; \
+    (objPtr)->bytes = NULL; \
+    (objPtr)->internalRep.longValue = (long)(i); \
+    (objPtr)->typePtr = &tclIntType; \
+    TCL_DTRACE_OBJ_CREATE(objPtr)
+
+#define TclNewLongObj(objPtr, l) \
+    TclNewIntObj((objPtr), (l))
+
+/*
+ * NOTE: There is to be no such thing as a "pure" boolean.
+ * See comment above TclSetBooleanObj macro above.
+ */
+#define TclNewBooleanObj(objPtr, b) \
+    TclNewIntObj((objPtr), ((b)? 1 : 0))
+
+#define TclNewDoubleObj(objPtr, d) \
+    TclIncrObjsAllocated(); \
+    TclAllocObjStorage(objPtr); \
+    (objPtr)->refCount = 0; \
+    (objPtr)->bytes = NULL; \
+    (objPtr)->internalRep.doubleValue = (double)(d); \
+    (objPtr)->typePtr = &tclDoubleType; \
+    TCL_DTRACE_OBJ_CREATE(objPtr)
+
+#define TclNewStringObj(objPtr, s, len) \
+    TclIncrObjsAllocated(); \
+    TclAllocObjStorage(objPtr); \
+    (objPtr)->refCount = 0; \
+    TclInitStringRep((objPtr), (s), (len));\
+    (objPtr)->typePtr = NULL; \
+    TCL_DTRACE_OBJ_CREATE(objPtr)
+
+#else /* TCL_MEM_DEBUG */
+#define TclNewIntObj(objPtr, i)   \
+    (objPtr) = Tcl_NewIntObj(i)
+
+#define TclNewLongObj(objPtr, l) \
+    (objPtr) = Tcl_NewLongObj(l)
+
+#define TclNewBooleanObj(objPtr, b) \
+    (objPtr) = Tcl_NewBooleanObj(b)
+
+#define TclNewDoubleObj(objPtr, d) \
+    (objPtr) = Tcl_NewDoubleObj(d)
+
+#define TclNewStringObj(objPtr, s, len) \
+    (objPtr) = Tcl_NewStringObj((s), (len))
+#endif /* TCL_MEM_DEBUG */
+
+/*
+ * The sLiteral argument *must* be a string literal; the incantation with
+ * sizeof(sLiteral "") will fail to compile otherwise.
+ */
+#define TclNewLiteralStringObj(objPtr, sLiteral) \
+    TclNewStringObj((objPtr), (sLiteral), (int) (sizeof(sLiteral "") - 1))
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to test for some special double values.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE int	TclIsInfinite(double d);
+ * MODULE_SCOPE int	TclIsNaN(double d);
+ */
+
+#ifdef _MSC_VER
+#    define TclIsInfinite(d)	( ! (_finite((d))) )
+#    define TclIsNaN(d)		(_isnan((d)))
+#else
+#    define TclIsInfinite(d)	( (d) > DBL_MAX || (d) < -DBL_MAX )
+#    ifdef NO_ISNAN
+#        define TclIsNaN(d)	((d) != (d))
+#    else
+#        define TclIsNaN(d)     (isnan(d))
+#    endif
+#endif
+
+/*
+ * ----------------------------------------------------------------------
+ * Macro to use to find the offset of a field in a structure.
+ * Computes number of bytes from beginning of structure to a given field.
+ */
+
+#ifdef offsetof
+#define TclOffset(type, field) ((int) offsetof(type, field))
+#else
+#define TclOffset(type, field) ((int) ((char *) &((type *) 0)->field))
+#endif
+
+/*
+ *----------------------------------------------------------------
+ * Inline version of Tcl_GetCurrentNamespace and Tcl_GetGlobalNamespace
+ */
+
+#define TclGetCurrentNamespace(interp) \
+    (Tcl_Namespace *) ((Interp *)(interp))->varFramePtr->nsPtr
+
+#define TclGetGlobalNamespace(interp) \
+    (Tcl_Namespace *) ((Interp *)(interp))->globalNsPtr
+
+/*
+ *----------------------------------------------------------------
+ * Inline version of TclCleanupCommand; still need the function as it is in
+ * the internal stubs, but the core can use the macro instead.
+ */
+
+#define TclCleanupCommandMacro(cmdPtr) \
+    if (--(cmdPtr)->refCount <= 0) { \
+	ckfree((char *) (cmdPtr));\
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Inline versions of Tcl_LimitReady() and Tcl_LimitExceeded to limit number
+ * of calls out of the critical path. Note that this code isn't particularly
+ * readable; the non-inline version (in tclInterp.c) is much easier to
+ * understand. Note also that these macros takes different args (iPtr->limit)
+ * to the non-inline version.
+ */
+
+#define TclLimitExceeded(limit) ((limit).exceeded != 0)
+
+#define TclLimitReady(limit)						\
+    (((limit).active == 0) ? 0 :					\
+    (++(limit).granularityTicker,					\
+    ((((limit).active & TCL_LIMIT_COMMANDS) &&				\
+	    (((limit).cmdGranularity == 1) ||				\
+	    ((limit).granularityTicker % (limit).cmdGranularity == 0)))	\
+	    ? 1 :							\
+    (((limit).active & TCL_LIMIT_TIME) &&				\
+	    (((limit).timeGranularity == 1) ||				\
+	    ((limit).granularityTicker % (limit).timeGranularity == 0)))\
+	    ? 1 : 0)))
+
+
+#include "tclPort.h"
+#include "tclIntDecls.h"
+#include "tclIntPlatDecls.h"
+#include "tclTomMathDecls.h"
+
+#endif /* _TCLINT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
Index: src/tktext/tcl8.5/tclIntDecls.h
===================================================================
--- src/tktext/tcl8.5/tclIntDecls.h	(revision 0)
+++ src/tktext/tcl8.5/tclIntDecls.h	(working copy)
@@ -0,0 +1,2101 @@
+/*
+ * tclIntDecls.h --
+ *
+ *	This file contains the declarations for all unsupported
+ *	functions that are exported by the Tcl library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tclIntDecls.h,v 1.112 2008/01/23 17:31:42 dgp Exp $
+ */
+
+#ifndef _TCLINTDECLS
+#define _TCLINTDECLS
+
+#include "tclPort.h"
+
+#undef TCL_STORAGE_CLASS
+#ifdef BUILD_tcl
+#   define TCL_STORAGE_CLASS DLLEXPORT
+#else
+#   ifdef USE_TCL_STUBS
+#      define TCL_STORAGE_CLASS
+#   else
+#      define TCL_STORAGE_CLASS DLLIMPORT
+#   endif
+#endif
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tclInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+/* Slot 0 is reserved */
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+#ifndef TclAllocateFreeObjects_TCL_DECLARED
+#define TclAllocateFreeObjects_TCL_DECLARED
+/* 3 */
+EXTERN void		TclAllocateFreeObjects (void);
+#endif
+/* Slot 4 is reserved */
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+#ifndef TclCleanupChildren_TCL_DECLARED
+#define TclCleanupChildren_TCL_DECLARED
+/* 5 */
+EXTERN int		TclCleanupChildren (Tcl_Interp * interp, int numPids, 
+				Tcl_Pid * pidPtr, Tcl_Channel errorChan);
+#endif
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+#ifndef TclCleanupChildren_TCL_DECLARED
+#define TclCleanupChildren_TCL_DECLARED
+/* 5 */
+EXTERN int		TclCleanupChildren (Tcl_Interp * interp, int numPids, 
+				Tcl_Pid * pidPtr, Tcl_Channel errorChan);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#ifndef TclCleanupChildren_TCL_DECLARED
+#define TclCleanupChildren_TCL_DECLARED
+/* 5 */
+EXTERN int		TclCleanupChildren (Tcl_Interp * interp, int numPids, 
+				Tcl_Pid * pidPtr, Tcl_Channel errorChan);
+#endif
+#endif /* MACOSX */
+#ifndef TclCleanupCommand_TCL_DECLARED
+#define TclCleanupCommand_TCL_DECLARED
+/* 6 */
+EXTERN void		TclCleanupCommand (Command * cmdPtr);
+#endif
+#ifndef TclCopyAndCollapse_TCL_DECLARED
+#define TclCopyAndCollapse_TCL_DECLARED
+/* 7 */
+EXTERN int		TclCopyAndCollapse (int count, CONST char * src, 
+				char * dst);
+#endif
+#ifndef TclCopyChannel_TCL_DECLARED
+#define TclCopyChannel_TCL_DECLARED
+/* 8 */
+EXTERN int		TclCopyChannel (Tcl_Interp * interp, 
+				Tcl_Channel inChan, Tcl_Channel outChan, 
+				int toRead, Tcl_Obj * cmdPtr);
+#endif
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+#ifndef TclCreatePipeline_TCL_DECLARED
+#define TclCreatePipeline_TCL_DECLARED
+/* 9 */
+EXTERN int		TclCreatePipeline (Tcl_Interp * interp, int argc, 
+				CONST char ** argv, Tcl_Pid ** pidArrayPtr, 
+				TclFile * inPipePtr, TclFile * outPipePtr, 
+				TclFile * errFilePtr);
+#endif
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+#ifndef TclCreatePipeline_TCL_DECLARED
+#define TclCreatePipeline_TCL_DECLARED
+/* 9 */
+EXTERN int		TclCreatePipeline (Tcl_Interp * interp, int argc, 
+				CONST char ** argv, Tcl_Pid ** pidArrayPtr, 
+				TclFile * inPipePtr, TclFile * outPipePtr, 
+				TclFile * errFilePtr);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#ifndef TclCreatePipeline_TCL_DECLARED
+#define TclCreatePipeline_TCL_DECLARED
+/* 9 */
+EXTERN int		TclCreatePipeline (Tcl_Interp * interp, int argc, 
+				CONST char ** argv, Tcl_Pid ** pidArrayPtr, 
+				TclFile * inPipePtr, TclFile * outPipePtr, 
+				TclFile * errFilePtr);
+#endif
+#endif /* MACOSX */
+#ifndef TclCreateProc_TCL_DECLARED
+#define TclCreateProc_TCL_DECLARED
+/* 10 */
+EXTERN int		TclCreateProc (Tcl_Interp * interp, 
+				Namespace * nsPtr, CONST char * procName, 
+				Tcl_Obj * argsPtr, Tcl_Obj * bodyPtr, 
+				Proc ** procPtrPtr);
+#endif
+#ifndef TclDeleteCompiledLocalVars_TCL_DECLARED
+#define TclDeleteCompiledLocalVars_TCL_DECLARED
+/* 11 */
+EXTERN void		TclDeleteCompiledLocalVars (Interp * iPtr, 
+				CallFrame * framePtr);
+#endif
+#ifndef TclDeleteVars_TCL_DECLARED
+#define TclDeleteVars_TCL_DECLARED
+/* 12 */
+EXTERN void		TclDeleteVars (Interp * iPtr, 
+				TclVarHashTable * tablePtr);
+#endif
+/* Slot 13 is reserved */
+#ifndef TclDumpMemoryInfo_TCL_DECLARED
+#define TclDumpMemoryInfo_TCL_DECLARED
+/* 14 */
+EXTERN void		TclDumpMemoryInfo (FILE * outFile);
+#endif
+/* Slot 15 is reserved */
+#ifndef TclExprFloatError_TCL_DECLARED
+#define TclExprFloatError_TCL_DECLARED
+/* 16 */
+EXTERN void		TclExprFloatError (Tcl_Interp * interp, double value);
+#endif
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+#ifndef TclFindElement_TCL_DECLARED
+#define TclFindElement_TCL_DECLARED
+/* 22 */
+EXTERN int		TclFindElement (Tcl_Interp * interp, 
+				CONST char * listStr, int listLength, 
+				CONST char ** elementPtr, 
+				CONST char ** nextPtr, int * sizePtr, 
+				int * bracePtr);
+#endif
+#ifndef TclFindProc_TCL_DECLARED
+#define TclFindProc_TCL_DECLARED
+/* 23 */
+EXTERN Proc *		TclFindProc (Interp * iPtr, CONST char * procName);
+#endif
+/* Slot 24 is reserved */
+#ifndef TclFreePackageInfo_TCL_DECLARED
+#define TclFreePackageInfo_TCL_DECLARED
+/* 25 */
+EXTERN void		TclFreePackageInfo (Interp * iPtr);
+#endif
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+#ifndef TclpGetDefaultStdChannel_TCL_DECLARED
+#define TclpGetDefaultStdChannel_TCL_DECLARED
+/* 28 */
+EXTERN Tcl_Channel	TclpGetDefaultStdChannel (int type);
+#endif
+/* Slot 29 is reserved */
+/* Slot 30 is reserved */
+#ifndef TclGetExtension_TCL_DECLARED
+#define TclGetExtension_TCL_DECLARED
+/* 31 */
+EXTERN CONST char *	TclGetExtension (CONST char * name);
+#endif
+#ifndef TclGetFrame_TCL_DECLARED
+#define TclGetFrame_TCL_DECLARED
+/* 32 */
+EXTERN int		TclGetFrame (Tcl_Interp * interp, CONST char * str, 
+				CallFrame ** framePtrPtr);
+#endif
+/* Slot 33 is reserved */
+#ifndef TclGetIntForIndex_TCL_DECLARED
+#define TclGetIntForIndex_TCL_DECLARED
+/* 34 */
+EXTERN int		TclGetIntForIndex (Tcl_Interp * interp, 
+				Tcl_Obj * objPtr, int endValue, 
+				int * indexPtr);
+#endif
+/* Slot 35 is reserved */
+#ifndef TclGetLong_TCL_DECLARED
+#define TclGetLong_TCL_DECLARED
+/* 36 */
+EXTERN int		TclGetLong (Tcl_Interp * interp, CONST char * str, 
+				long * longPtr);
+#endif
+#ifndef TclGetLoadedPackages_TCL_DECLARED
+#define TclGetLoadedPackages_TCL_DECLARED
+/* 37 */
+EXTERN int		TclGetLoadedPackages (Tcl_Interp * interp, 
+				char * targetName);
+#endif
+#ifndef TclGetNamespaceForQualName_TCL_DECLARED
+#define TclGetNamespaceForQualName_TCL_DECLARED
+/* 38 */
+EXTERN int		TclGetNamespaceForQualName (Tcl_Interp * interp, 
+				CONST char * qualName, Namespace * cxtNsPtr, 
+				int flags, Namespace ** nsPtrPtr, 
+				Namespace ** altNsPtrPtr, 
+				Namespace ** actualCxtPtrPtr, 
+				CONST char ** simpleNamePtr);
+#endif
+#ifndef TclGetObjInterpProc_TCL_DECLARED
+#define TclGetObjInterpProc_TCL_DECLARED
+/* 39 */
+EXTERN TclObjCmdProcType TclGetObjInterpProc (void);
+#endif
+#ifndef TclGetOpenMode_TCL_DECLARED
+#define TclGetOpenMode_TCL_DECLARED
+/* 40 */
+EXTERN int		TclGetOpenMode (Tcl_Interp * interp, 
+				CONST char * str, int * seekFlagPtr);
+#endif
+#ifndef TclGetOriginalCommand_TCL_DECLARED
+#define TclGetOriginalCommand_TCL_DECLARED
+/* 41 */
+EXTERN Tcl_Command	TclGetOriginalCommand (Tcl_Command command);
+#endif
+#ifndef TclpGetUserHome_TCL_DECLARED
+#define TclpGetUserHome_TCL_DECLARED
+/* 42 */
+EXTERN char *		TclpGetUserHome (CONST char * name, 
+				Tcl_DString * bufferPtr);
+#endif
+/* Slot 43 is reserved */
+#ifndef TclGuessPackageName_TCL_DECLARED
+#define TclGuessPackageName_TCL_DECLARED
+/* 44 */
+EXTERN int		TclGuessPackageName (CONST char * fileName, 
+				Tcl_DString * bufPtr);
+#endif
+#ifndef TclHideUnsafeCommands_TCL_DECLARED
+#define TclHideUnsafeCommands_TCL_DECLARED
+/* 45 */
+EXTERN int		TclHideUnsafeCommands (Tcl_Interp * interp);
+#endif
+#ifndef TclInExit_TCL_DECLARED
+#define TclInExit_TCL_DECLARED
+/* 46 */
+EXTERN int		TclInExit (void);
+#endif
+/* Slot 47 is reserved */
+/* Slot 48 is reserved */
+/* Slot 49 is reserved */
+#ifndef TclInitCompiledLocals_TCL_DECLARED
+#define TclInitCompiledLocals_TCL_DECLARED
+/* 50 */
+EXTERN void		TclInitCompiledLocals (Tcl_Interp * interp, 
+				CallFrame * framePtr, Namespace * nsPtr);
+#endif
+#ifndef TclInterpInit_TCL_DECLARED
+#define TclInterpInit_TCL_DECLARED
+/* 51 */
+EXTERN int		TclInterpInit (Tcl_Interp * interp);
+#endif
+/* Slot 52 is reserved */
+#ifndef TclInvokeObjectCommand_TCL_DECLARED
+#define TclInvokeObjectCommand_TCL_DECLARED
+/* 53 */
+EXTERN int		TclInvokeObjectCommand (ClientData clientData, 
+				Tcl_Interp * interp, int argc, 
+				CONST84 char ** argv);
+#endif
+#ifndef TclInvokeStringCommand_TCL_DECLARED
+#define TclInvokeStringCommand_TCL_DECLARED
+/* 54 */
+EXTERN int		TclInvokeStringCommand (ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]);
+#endif
+#ifndef TclIsProc_TCL_DECLARED
+#define TclIsProc_TCL_DECLARED
+/* 55 */
+EXTERN Proc *		TclIsProc (Command * cmdPtr);
+#endif
+/* Slot 56 is reserved */
+/* Slot 57 is reserved */
+#ifndef TclLookupVar_TCL_DECLARED
+#define TclLookupVar_TCL_DECLARED
+/* 58 */
+EXTERN Var *		TclLookupVar (Tcl_Interp * interp, 
+				CONST char * part1, CONST char * part2, 
+				int flags, CONST char * msg, int createPart1, 
+				int createPart2, Var ** arrayPtrPtr);
+#endif
+/* Slot 59 is reserved */
+#ifndef TclNeedSpace_TCL_DECLARED
+#define TclNeedSpace_TCL_DECLARED
+/* 60 */
+EXTERN int		TclNeedSpace (CONST char * start, CONST char * end);
+#endif
+#ifndef TclNewProcBodyObj_TCL_DECLARED
+#define TclNewProcBodyObj_TCL_DECLARED
+/* 61 */
+EXTERN Tcl_Obj *	TclNewProcBodyObj (Proc * procPtr);
+#endif
+#ifndef TclObjCommandComplete_TCL_DECLARED
+#define TclObjCommandComplete_TCL_DECLARED
+/* 62 */
+EXTERN int		TclObjCommandComplete (Tcl_Obj * cmdPtr);
+#endif
+#ifndef TclObjInterpProc_TCL_DECLARED
+#define TclObjInterpProc_TCL_DECLARED
+/* 63 */
+EXTERN int		TclObjInterpProc (ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]);
+#endif
+#ifndef TclObjInvoke_TCL_DECLARED
+#define TclObjInvoke_TCL_DECLARED
+/* 64 */
+EXTERN int		TclObjInvoke (Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[], int flags);
+#endif
+/* Slot 65 is reserved */
+/* Slot 66 is reserved */
+/* Slot 67 is reserved */
+/* Slot 68 is reserved */
+#ifndef TclpAlloc_TCL_DECLARED
+#define TclpAlloc_TCL_DECLARED
+/* 69 */
+EXTERN char *		TclpAlloc (unsigned int size);
+#endif
+/* Slot 70 is reserved */
+/* Slot 71 is reserved */
+/* Slot 72 is reserved */
+/* Slot 73 is reserved */
+#ifndef TclpFree_TCL_DECLARED
+#define TclpFree_TCL_DECLARED
+/* 74 */
+EXTERN void		TclpFree (char * ptr);
+#endif
+#ifndef TclpGetClicks_TCL_DECLARED
+#define TclpGetClicks_TCL_DECLARED
+/* 75 */
+EXTERN unsigned long	TclpGetClicks (void);
+#endif
+#ifndef TclpGetSeconds_TCL_DECLARED
+#define TclpGetSeconds_TCL_DECLARED
+/* 76 */
+EXTERN unsigned long	TclpGetSeconds (void);
+#endif
+#ifndef TclpGetTime_TCL_DECLARED
+#define TclpGetTime_TCL_DECLARED
+/* 77 */
+EXTERN void		TclpGetTime (Tcl_Time * time);
+#endif
+#ifndef TclpGetTimeZone_TCL_DECLARED
+#define TclpGetTimeZone_TCL_DECLARED
+/* 78 */
+EXTERN int		TclpGetTimeZone (unsigned long time);
+#endif
+/* Slot 79 is reserved */
+/* Slot 80 is reserved */
+#ifndef TclpRealloc_TCL_DECLARED
+#define TclpRealloc_TCL_DECLARED
+/* 81 */
+EXTERN char *		TclpRealloc (char * ptr, unsigned int size);
+#endif
+/* Slot 82 is reserved */
+/* Slot 83 is reserved */
+/* Slot 84 is reserved */
+/* Slot 85 is reserved */
+/* Slot 86 is reserved */
+/* Slot 87 is reserved */
+#ifndef TclPrecTraceProc_TCL_DECLARED
+#define TclPrecTraceProc_TCL_DECLARED
+/* 88 */
+EXTERN char *		TclPrecTraceProc (ClientData clientData, 
+				Tcl_Interp * interp, CONST char * name1, 
+				CONST char * name2, int flags);
+#endif
+#ifndef TclPreventAliasLoop_TCL_DECLARED
+#define TclPreventAliasLoop_TCL_DECLARED
+/* 89 */
+EXTERN int		TclPreventAliasLoop (Tcl_Interp * interp, 
+				Tcl_Interp * cmdInterp, Tcl_Command cmd);
+#endif
+/* Slot 90 is reserved */
+#ifndef TclProcCleanupProc_TCL_DECLARED
+#define TclProcCleanupProc_TCL_DECLARED
+/* 91 */
+EXTERN void		TclProcCleanupProc (Proc * procPtr);
+#endif
+#ifndef TclProcCompileProc_TCL_DECLARED
+#define TclProcCompileProc_TCL_DECLARED
+/* 92 */
+EXTERN int		TclProcCompileProc (Tcl_Interp * interp, 
+				Proc * procPtr, Tcl_Obj * bodyPtr, 
+				Namespace * nsPtr, CONST char * description, 
+				CONST char * procName);
+#endif
+#ifndef TclProcDeleteProc_TCL_DECLARED
+#define TclProcDeleteProc_TCL_DECLARED
+/* 93 */
+EXTERN void		TclProcDeleteProc (ClientData clientData);
+#endif
+/* Slot 94 is reserved */
+/* Slot 95 is reserved */
+#ifndef TclRenameCommand_TCL_DECLARED
+#define TclRenameCommand_TCL_DECLARED
+/* 96 */
+EXTERN int		TclRenameCommand (Tcl_Interp * interp, 
+				CONST char * oldName, CONST char * newName);
+#endif
+#ifndef TclResetShadowedCmdRefs_TCL_DECLARED
+#define TclResetShadowedCmdRefs_TCL_DECLARED
+/* 97 */
+EXTERN void		TclResetShadowedCmdRefs (Tcl_Interp * interp, 
+				Command * newCmdPtr);
+#endif
+#ifndef TclServiceIdle_TCL_DECLARED
+#define TclServiceIdle_TCL_DECLARED
+/* 98 */
+EXTERN int		TclServiceIdle (void);
+#endif
+/* Slot 99 is reserved */
+/* Slot 100 is reserved */
+#ifndef TclSetPreInitScript_TCL_DECLARED
+#define TclSetPreInitScript_TCL_DECLARED
+/* 101 */
+EXTERN char *		TclSetPreInitScript (char * string);
+#endif
+#ifndef TclSetupEnv_TCL_DECLARED
+#define TclSetupEnv_TCL_DECLARED
+/* 102 */
+EXTERN void		TclSetupEnv (Tcl_Interp * interp);
+#endif
+#ifndef TclSockGetPort_TCL_DECLARED
+#define TclSockGetPort_TCL_DECLARED
+/* 103 */
+EXTERN int		TclSockGetPort (Tcl_Interp * interp, 
+				CONST char * str, CONST char * proto, 
+				int * portPtr);
+#endif
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+#ifndef TclSockMinimumBuffers_TCL_DECLARED
+#define TclSockMinimumBuffers_TCL_DECLARED
+/* 104 */
+EXTERN int		TclSockMinimumBuffers (int sock, int size);
+#endif
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+#ifndef TclSockMinimumBuffers_TCL_DECLARED
+#define TclSockMinimumBuffers_TCL_DECLARED
+/* 104 */
+EXTERN int		TclSockMinimumBuffers (int sock, int size);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#ifndef TclSockMinimumBuffers_TCL_DECLARED
+#define TclSockMinimumBuffers_TCL_DECLARED
+/* 104 */
+EXTERN int		TclSockMinimumBuffers (int sock, int size);
+#endif
+#endif /* MACOSX */
+/* Slot 105 is reserved */
+/* Slot 106 is reserved */
+/* Slot 107 is reserved */
+#ifndef TclTeardownNamespace_TCL_DECLARED
+#define TclTeardownNamespace_TCL_DECLARED
+/* 108 */
+EXTERN void		TclTeardownNamespace (Namespace * nsPtr);
+#endif
+#ifndef TclUpdateReturnInfo_TCL_DECLARED
+#define TclUpdateReturnInfo_TCL_DECLARED
+/* 109 */
+EXTERN int		TclUpdateReturnInfo (Interp * iPtr);
+#endif
+/* Slot 110 is reserved */
+#ifndef Tcl_AddInterpResolvers_TCL_DECLARED
+#define Tcl_AddInterpResolvers_TCL_DECLARED
+/* 111 */
+EXTERN void		Tcl_AddInterpResolvers (Tcl_Interp * interp, 
+				CONST char * name, 
+				Tcl_ResolveCmdProc * cmdProc, 
+				Tcl_ResolveVarProc * varProc, 
+				Tcl_ResolveCompiledVarProc * compiledVarProc);
+#endif
+#ifndef Tcl_AppendExportList_TCL_DECLARED
+#define Tcl_AppendExportList_TCL_DECLARED
+/* 112 */
+EXTERN int		Tcl_AppendExportList (Tcl_Interp * interp, 
+				Tcl_Namespace * nsPtr, Tcl_Obj * objPtr);
+#endif
+#ifndef Tcl_CreateNamespace_TCL_DECLARED
+#define Tcl_CreateNamespace_TCL_DECLARED
+/* 113 */
+EXTERN Tcl_Namespace *	Tcl_CreateNamespace (Tcl_Interp * interp, 
+				CONST char * name, ClientData clientData, 
+				Tcl_NamespaceDeleteProc * deleteProc);
+#endif
+#ifndef Tcl_DeleteNamespace_TCL_DECLARED
+#define Tcl_DeleteNamespace_TCL_DECLARED
+/* 114 */
+EXTERN void		Tcl_DeleteNamespace (Tcl_Namespace * nsPtr);
+#endif
+#ifndef Tcl_Export_TCL_DECLARED
+#define Tcl_Export_TCL_DECLARED
+/* 115 */
+EXTERN int		Tcl_Export (Tcl_Interp * interp, 
+				Tcl_Namespace * nsPtr, CONST char * pattern, 
+				int resetListFirst);
+#endif
+#ifndef Tcl_FindCommand_TCL_DECLARED
+#define Tcl_FindCommand_TCL_DECLARED
+/* 116 */
+EXTERN Tcl_Command	Tcl_FindCommand (Tcl_Interp * interp, 
+				CONST char * name, 
+				Tcl_Namespace * contextNsPtr, int flags);
+#endif
+#ifndef Tcl_FindNamespace_TCL_DECLARED
+#define Tcl_FindNamespace_TCL_DECLARED
+/* 117 */
+EXTERN Tcl_Namespace *	Tcl_FindNamespace (Tcl_Interp * interp, 
+				CONST char * name, 
+				Tcl_Namespace * contextNsPtr, int flags);
+#endif
+#ifndef Tcl_GetInterpResolvers_TCL_DECLARED
+#define Tcl_GetInterpResolvers_TCL_DECLARED
+/* 118 */
+EXTERN int		Tcl_GetInterpResolvers (Tcl_Interp * interp, 
+				CONST char * name, 
+				Tcl_ResolverInfo * resInfo);
+#endif
+#ifndef Tcl_GetNamespaceResolvers_TCL_DECLARED
+#define Tcl_GetNamespaceResolvers_TCL_DECLARED
+/* 119 */
+EXTERN int		Tcl_GetNamespaceResolvers (
+				Tcl_Namespace * namespacePtr, 
+				Tcl_ResolverInfo * resInfo);
+#endif
+#ifndef Tcl_FindNamespaceVar_TCL_DECLARED
+#define Tcl_FindNamespaceVar_TCL_DECLARED
+/* 120 */
+EXTERN Tcl_Var		Tcl_FindNamespaceVar (Tcl_Interp * interp, 
+				CONST char * name, 
+				Tcl_Namespace * contextNsPtr, int flags);
+#endif
+#ifndef Tcl_ForgetImport_TCL_DECLARED
+#define Tcl_ForgetImport_TCL_DECLARED
+/* 121 */
+EXTERN int		Tcl_ForgetImport (Tcl_Interp * interp, 
+				Tcl_Namespace * nsPtr, CONST char * pattern);
+#endif
+#ifndef Tcl_GetCommandFromObj_TCL_DECLARED
+#define Tcl_GetCommandFromObj_TCL_DECLARED
+/* 122 */
+EXTERN Tcl_Command	Tcl_GetCommandFromObj (Tcl_Interp * interp, 
+				Tcl_Obj * objPtr);
+#endif
+#ifndef Tcl_GetCommandFullName_TCL_DECLARED
+#define Tcl_GetCommandFullName_TCL_DECLARED
+/* 123 */
+EXTERN void		Tcl_GetCommandFullName (Tcl_Interp * interp, 
+				Tcl_Command command, Tcl_Obj * objPtr);
+#endif
+#ifndef Tcl_GetCurrentNamespace_TCL_DECLARED
+#define Tcl_GetCurrentNamespace_TCL_DECLARED
+/* 124 */
+EXTERN Tcl_Namespace *	Tcl_GetCurrentNamespace (Tcl_Interp * interp);
+#endif
+#ifndef Tcl_GetGlobalNamespace_TCL_DECLARED
+#define Tcl_GetGlobalNamespace_TCL_DECLARED
+/* 125 */
+EXTERN Tcl_Namespace *	Tcl_GetGlobalNamespace (Tcl_Interp * interp);
+#endif
+#ifndef Tcl_GetVariableFullName_TCL_DECLARED
+#define Tcl_GetVariableFullName_TCL_DECLARED
+/* 126 */
+EXTERN void		Tcl_GetVariableFullName (Tcl_Interp * interp, 
+				Tcl_Var variable, Tcl_Obj * objPtr);
+#endif
+#ifndef Tcl_Import_TCL_DECLARED
+#define Tcl_Import_TCL_DECLARED
+/* 127 */
+EXTERN int		Tcl_Import (Tcl_Interp * interp, 
+				Tcl_Namespace * nsPtr, CONST char * pattern, 
+				int allowOverwrite);
+#endif
+#ifndef Tcl_PopCallFrame_TCL_DECLARED
+#define Tcl_PopCallFrame_TCL_DECLARED
+/* 128 */
+EXTERN void		Tcl_PopCallFrame (Tcl_Interp * interp);
+#endif
+#ifndef Tcl_PushCallFrame_TCL_DECLARED
+#define Tcl_PushCallFrame_TCL_DECLARED
+/* 129 */
+EXTERN int		Tcl_PushCallFrame (Tcl_Interp * interp, 
+				Tcl_CallFrame * framePtr, 
+				Tcl_Namespace * nsPtr, int isProcCallFrame);
+#endif
+#ifndef Tcl_RemoveInterpResolvers_TCL_DECLARED
+#define Tcl_RemoveInterpResolvers_TCL_DECLARED
+/* 130 */
+EXTERN int		Tcl_RemoveInterpResolvers (Tcl_Interp * interp, 
+				CONST char * name);
+#endif
+#ifndef Tcl_SetNamespaceResolvers_TCL_DECLARED
+#define Tcl_SetNamespaceResolvers_TCL_DECLARED
+/* 131 */
+EXTERN void		Tcl_SetNamespaceResolvers (
+				Tcl_Namespace * namespacePtr, 
+				Tcl_ResolveCmdProc * cmdProc, 
+				Tcl_ResolveVarProc * varProc, 
+				Tcl_ResolveCompiledVarProc * compiledVarProc);
+#endif
+#ifndef TclpHasSockets_TCL_DECLARED
+#define TclpHasSockets_TCL_DECLARED
+/* 132 */
+EXTERN int		TclpHasSockets (Tcl_Interp * interp);
+#endif
+#ifndef TclpGetDate_TCL_DECLARED
+#define TclpGetDate_TCL_DECLARED
+/* 133 */
+EXTERN struct tm *	TclpGetDate (CONST time_t * time, int useGMT);
+#endif
+/* Slot 134 is reserved */
+/* Slot 135 is reserved */
+/* Slot 136 is reserved */
+/* Slot 137 is reserved */
+#ifndef TclGetEnv_TCL_DECLARED
+#define TclGetEnv_TCL_DECLARED
+/* 138 */
+EXTERN CONST84_RETURN char * TclGetEnv (CONST char * name, 
+				Tcl_DString * valuePtr);
+#endif
+/* Slot 139 is reserved */
+/* Slot 140 is reserved */
+#ifndef TclpGetCwd_TCL_DECLARED
+#define TclpGetCwd_TCL_DECLARED
+/* 141 */
+EXTERN CONST84_RETURN char * TclpGetCwd (Tcl_Interp * interp, 
+				Tcl_DString * cwdPtr);
+#endif
+#ifndef TclSetByteCodeFromAny_TCL_DECLARED
+#define TclSetByteCodeFromAny_TCL_DECLARED
+/* 142 */
+EXTERN int		TclSetByteCodeFromAny (Tcl_Interp * interp, 
+				Tcl_Obj * objPtr, CompileHookProc * hookProc, 
+				ClientData clientData);
+#endif
+#ifndef TclAddLiteralObj_TCL_DECLARED
+#define TclAddLiteralObj_TCL_DECLARED
+/* 143 */
+EXTERN int		TclAddLiteralObj (struct CompileEnv * envPtr, 
+				Tcl_Obj * objPtr, LiteralEntry ** litPtrPtr);
+#endif
+#ifndef TclHideLiteral_TCL_DECLARED
+#define TclHideLiteral_TCL_DECLARED
+/* 144 */
+EXTERN void		TclHideLiteral (Tcl_Interp * interp, 
+				struct CompileEnv * envPtr, int index);
+#endif
+#ifndef TclGetAuxDataType_TCL_DECLARED
+#define TclGetAuxDataType_TCL_DECLARED
+/* 145 */
+EXTERN struct AuxDataType * TclGetAuxDataType (char * typeName);
+#endif
+#ifndef TclHandleCreate_TCL_DECLARED
+#define TclHandleCreate_TCL_DECLARED
+/* 146 */
+EXTERN TclHandle	TclHandleCreate (VOID * ptr);
+#endif
+#ifndef TclHandleFree_TCL_DECLARED
+#define TclHandleFree_TCL_DECLARED
+/* 147 */
+EXTERN void		TclHandleFree (TclHandle handle);
+#endif
+#ifndef TclHandlePreserve_TCL_DECLARED
+#define TclHandlePreserve_TCL_DECLARED
+/* 148 */
+EXTERN TclHandle	TclHandlePreserve (TclHandle handle);
+#endif
+#ifndef TclHandleRelease_TCL_DECLARED
+#define TclHandleRelease_TCL_DECLARED
+/* 149 */
+EXTERN void		TclHandleRelease (TclHandle handle);
+#endif
+#ifndef TclRegAbout_TCL_DECLARED
+#define TclRegAbout_TCL_DECLARED
+/* 150 */
+EXTERN int		TclRegAbout (Tcl_Interp * interp, Tcl_RegExp re);
+#endif
+#ifndef TclRegExpRangeUniChar_TCL_DECLARED
+#define TclRegExpRangeUniChar_TCL_DECLARED
+/* 151 */
+EXTERN void		TclRegExpRangeUniChar (Tcl_RegExp re, int index, 
+				int * startPtr, int * endPtr);
+#endif
+#ifndef TclSetLibraryPath_TCL_DECLARED
+#define TclSetLibraryPath_TCL_DECLARED
+/* 152 */
+EXTERN void		TclSetLibraryPath (Tcl_Obj * pathPtr);
+#endif
+#ifndef TclGetLibraryPath_TCL_DECLARED
+#define TclGetLibraryPath_TCL_DECLARED
+/* 153 */
+EXTERN Tcl_Obj *	TclGetLibraryPath (void);
+#endif
+/* Slot 154 is reserved */
+/* Slot 155 is reserved */
+#ifndef TclRegError_TCL_DECLARED
+#define TclRegError_TCL_DECLARED
+/* 156 */
+EXTERN void		TclRegError (Tcl_Interp * interp, CONST char * msg, 
+				int status);
+#endif
+#ifndef TclVarTraceExists_TCL_DECLARED
+#define TclVarTraceExists_TCL_DECLARED
+/* 157 */
+EXTERN Var *		TclVarTraceExists (Tcl_Interp * interp, 
+				CONST char * varName);
+#endif
+#ifndef TclSetStartupScriptFileName_TCL_DECLARED
+#define TclSetStartupScriptFileName_TCL_DECLARED
+/* 158 */
+EXTERN void		TclSetStartupScriptFileName (CONST char * filename);
+#endif
+#ifndef TclGetStartupScriptFileName_TCL_DECLARED
+#define TclGetStartupScriptFileName_TCL_DECLARED
+/* 159 */
+EXTERN CONST84_RETURN char * TclGetStartupScriptFileName (void);
+#endif
+/* Slot 160 is reserved */
+#ifndef TclChannelTransform_TCL_DECLARED
+#define TclChannelTransform_TCL_DECLARED
+/* 161 */
+EXTERN int		TclChannelTransform (Tcl_Interp * interp, 
+				Tcl_Channel chan, Tcl_Obj * cmdObjPtr);
+#endif
+#ifndef TclChannelEventScriptInvoker_TCL_DECLARED
+#define TclChannelEventScriptInvoker_TCL_DECLARED
+/* 162 */
+EXTERN void		TclChannelEventScriptInvoker (ClientData clientData, 
+				int flags);
+#endif
+#ifndef TclGetInstructionTable_TCL_DECLARED
+#define TclGetInstructionTable_TCL_DECLARED
+/* 163 */
+EXTERN void *		TclGetInstructionTable (void);
+#endif
+#ifndef TclExpandCodeArray_TCL_DECLARED
+#define TclExpandCodeArray_TCL_DECLARED
+/* 164 */
+EXTERN void		TclExpandCodeArray (void * envPtr);
+#endif
+#ifndef TclpSetInitialEncodings_TCL_DECLARED
+#define TclpSetInitialEncodings_TCL_DECLARED
+/* 165 */
+EXTERN void		TclpSetInitialEncodings (void);
+#endif
+#ifndef TclListObjSetElement_TCL_DECLARED
+#define TclListObjSetElement_TCL_DECLARED
+/* 166 */
+EXTERN int		TclListObjSetElement (Tcl_Interp * interp, 
+				Tcl_Obj * listPtr, int index, 
+				Tcl_Obj * valuePtr);
+#endif
+#ifndef TclSetStartupScriptPath_TCL_DECLARED
+#define TclSetStartupScriptPath_TCL_DECLARED
+/* 167 */
+EXTERN void		TclSetStartupScriptPath (Tcl_Obj * pathPtr);
+#endif
+#ifndef TclGetStartupScriptPath_TCL_DECLARED
+#define TclGetStartupScriptPath_TCL_DECLARED
+/* 168 */
+EXTERN Tcl_Obj *	TclGetStartupScriptPath (void);
+#endif
+#ifndef TclpUtfNcmp2_TCL_DECLARED
+#define TclpUtfNcmp2_TCL_DECLARED
+/* 169 */
+EXTERN int		TclpUtfNcmp2 (CONST char * s1, CONST char * s2, 
+				unsigned long n);
+#endif
+#ifndef TclCheckInterpTraces_TCL_DECLARED
+#define TclCheckInterpTraces_TCL_DECLARED
+/* 170 */
+EXTERN int		TclCheckInterpTraces (Tcl_Interp * interp, 
+				CONST char * command, int numChars, 
+				Command * cmdPtr, int result, int traceFlags, 
+				int objc, Tcl_Obj *CONST objv[]);
+#endif
+#ifndef TclCheckExecutionTraces_TCL_DECLARED
+#define TclCheckExecutionTraces_TCL_DECLARED
+/* 171 */
+EXTERN int		TclCheckExecutionTraces (Tcl_Interp * interp, 
+				CONST char * command, int numChars, 
+				Command * cmdPtr, int result, int traceFlags, 
+				int objc, Tcl_Obj *CONST objv[]);
+#endif
+#ifndef TclInThreadExit_TCL_DECLARED
+#define TclInThreadExit_TCL_DECLARED
+/* 172 */
+EXTERN int		TclInThreadExit (void);
+#endif
+#ifndef TclUniCharMatch_TCL_DECLARED
+#define TclUniCharMatch_TCL_DECLARED
+/* 173 */
+EXTERN int		TclUniCharMatch (CONST Tcl_UniChar * string, 
+				int strLen, CONST Tcl_UniChar * pattern, 
+				int ptnLen, int flags);
+#endif
+/* Slot 174 is reserved */
+#ifndef TclCallVarTraces_TCL_DECLARED
+#define TclCallVarTraces_TCL_DECLARED
+/* 175 */
+EXTERN int		TclCallVarTraces (Interp * iPtr, Var * arrayPtr, 
+				Var * varPtr, CONST char * part1, 
+				CONST char * part2, int flags, 
+				int leaveErrMsg);
+#endif
+#ifndef TclCleanupVar_TCL_DECLARED
+#define TclCleanupVar_TCL_DECLARED
+/* 176 */
+EXTERN void		TclCleanupVar (Var * varPtr, Var * arrayPtr);
+#endif
+#ifndef TclVarErrMsg_TCL_DECLARED
+#define TclVarErrMsg_TCL_DECLARED
+/* 177 */
+EXTERN void		TclVarErrMsg (Tcl_Interp * interp, 
+				CONST char * part1, CONST char * part2, 
+				CONST char * operation, CONST char * reason);
+#endif
+#ifndef Tcl_SetStartupScript_TCL_DECLARED
+#define Tcl_SetStartupScript_TCL_DECLARED
+/* 178 */
+EXTERN void		Tcl_SetStartupScript (Tcl_Obj * pathPtr, 
+				CONST char* encodingName);
+#endif
+#ifndef Tcl_GetStartupScript_TCL_DECLARED
+#define Tcl_GetStartupScript_TCL_DECLARED
+/* 179 */
+EXTERN Tcl_Obj *	Tcl_GetStartupScript (CONST char ** encodingNamePtr);
+#endif
+/* Slot 180 is reserved */
+/* Slot 181 is reserved */
+#ifndef TclpLocaltime_TCL_DECLARED
+#define TclpLocaltime_TCL_DECLARED
+/* 182 */
+EXTERN struct tm *	TclpLocaltime (CONST time_t * clock);
+#endif
+#ifndef TclpGmtime_TCL_DECLARED
+#define TclpGmtime_TCL_DECLARED
+/* 183 */
+EXTERN struct tm *	TclpGmtime (CONST time_t * clock);
+#endif
+/* Slot 184 is reserved */
+/* Slot 185 is reserved */
+/* Slot 186 is reserved */
+/* Slot 187 is reserved */
+/* Slot 188 is reserved */
+/* Slot 189 is reserved */
+/* Slot 190 is reserved */
+/* Slot 191 is reserved */
+/* Slot 192 is reserved */
+/* Slot 193 is reserved */
+/* Slot 194 is reserved */
+/* Slot 195 is reserved */
+/* Slot 196 is reserved */
+/* Slot 197 is reserved */
+#ifndef TclObjGetFrame_TCL_DECLARED
+#define TclObjGetFrame_TCL_DECLARED
+/* 198 */
+EXTERN int		TclObjGetFrame (Tcl_Interp * interp, 
+				Tcl_Obj * objPtr, CallFrame ** framePtrPtr);
+#endif
+/* Slot 199 is reserved */
+#ifndef TclpObjRemoveDirectory_TCL_DECLARED
+#define TclpObjRemoveDirectory_TCL_DECLARED
+/* 200 */
+EXTERN int		TclpObjRemoveDirectory (Tcl_Obj * pathPtr, 
+				int recursive, Tcl_Obj ** errorPtr);
+#endif
+#ifndef TclpObjCopyDirectory_TCL_DECLARED
+#define TclpObjCopyDirectory_TCL_DECLARED
+/* 201 */
+EXTERN int		TclpObjCopyDirectory (Tcl_Obj * srcPathPtr, 
+				Tcl_Obj * destPathPtr, Tcl_Obj ** errorPtr);
+#endif
+#ifndef TclpObjCreateDirectory_TCL_DECLARED
+#define TclpObjCreateDirectory_TCL_DECLARED
+/* 202 */
+EXTERN int		TclpObjCreateDirectory (Tcl_Obj * pathPtr);
+#endif
+#ifndef TclpObjDeleteFile_TCL_DECLARED
+#define TclpObjDeleteFile_TCL_DECLARED
+/* 203 */
+EXTERN int		TclpObjDeleteFile (Tcl_Obj * pathPtr);
+#endif
+#ifndef TclpObjCopyFile_TCL_DECLARED
+#define TclpObjCopyFile_TCL_DECLARED
+/* 204 */
+EXTERN int		TclpObjCopyFile (Tcl_Obj * srcPathPtr, 
+				Tcl_Obj * destPathPtr);
+#endif
+#ifndef TclpObjRenameFile_TCL_DECLARED
+#define TclpObjRenameFile_TCL_DECLARED
+/* 205 */
+EXTERN int		TclpObjRenameFile (Tcl_Obj * srcPathPtr, 
+				Tcl_Obj * destPathPtr);
+#endif
+#ifndef TclpObjStat_TCL_DECLARED
+#define TclpObjStat_TCL_DECLARED
+/* 206 */
+EXTERN int		TclpObjStat (Tcl_Obj * pathPtr, Tcl_StatBuf * buf);
+#endif
+#ifndef TclpObjAccess_TCL_DECLARED
+#define TclpObjAccess_TCL_DECLARED
+/* 207 */
+EXTERN int		TclpObjAccess (Tcl_Obj * pathPtr, int mode);
+#endif
+#ifndef TclpOpenFileChannel_TCL_DECLARED
+#define TclpOpenFileChannel_TCL_DECLARED
+/* 208 */
+EXTERN Tcl_Channel	TclpOpenFileChannel (Tcl_Interp * interp, 
+				Tcl_Obj * pathPtr, int mode, int permissions);
+#endif
+/* Slot 209 is reserved */
+/* Slot 210 is reserved */
+/* Slot 211 is reserved */
+#ifndef TclpFindExecutable_TCL_DECLARED
+#define TclpFindExecutable_TCL_DECLARED
+/* 212 */
+EXTERN void		TclpFindExecutable (CONST char * argv0);
+#endif
+#ifndef TclGetObjNameOfExecutable_TCL_DECLARED
+#define TclGetObjNameOfExecutable_TCL_DECLARED
+/* 213 */
+EXTERN Tcl_Obj *	TclGetObjNameOfExecutable (void);
+#endif
+#ifndef TclSetObjNameOfExecutable_TCL_DECLARED
+#define TclSetObjNameOfExecutable_TCL_DECLARED
+/* 214 */
+EXTERN void		TclSetObjNameOfExecutable (Tcl_Obj * name, 
+				Tcl_Encoding encoding);
+#endif
+#ifndef TclStackAlloc_TCL_DECLARED
+#define TclStackAlloc_TCL_DECLARED
+/* 215 */
+EXTERN void *		TclStackAlloc (Tcl_Interp * interp, int numBytes);
+#endif
+#ifndef TclStackFree_TCL_DECLARED
+#define TclStackFree_TCL_DECLARED
+/* 216 */
+EXTERN void		TclStackFree (Tcl_Interp * interp, void * freePtr);
+#endif
+#ifndef TclPushStackFrame_TCL_DECLARED
+#define TclPushStackFrame_TCL_DECLARED
+/* 217 */
+EXTERN int		TclPushStackFrame (Tcl_Interp * interp, 
+				Tcl_CallFrame ** framePtrPtr, 
+				Tcl_Namespace * namespacePtr, 
+				int isProcCallFrame);
+#endif
+#ifndef TclPopStackFrame_TCL_DECLARED
+#define TclPopStackFrame_TCL_DECLARED
+/* 218 */
+EXTERN void		TclPopStackFrame (Tcl_Interp * interp);
+#endif
+/* Slot 219 is reserved */
+/* Slot 220 is reserved */
+/* Slot 221 is reserved */
+/* Slot 222 is reserved */
+/* Slot 223 is reserved */
+#ifndef TclGetPlatform_TCL_DECLARED
+#define TclGetPlatform_TCL_DECLARED
+/* 224 */
+EXTERN TclPlatformType * TclGetPlatform (void);
+#endif
+#ifndef TclTraceDictPath_TCL_DECLARED
+#define TclTraceDictPath_TCL_DECLARED
+/* 225 */
+EXTERN Tcl_Obj *	TclTraceDictPath (Tcl_Interp * interp, 
+				Tcl_Obj * rootPtr, int keyc, 
+				Tcl_Obj *CONST keyv[], int flags);
+#endif
+#ifndef TclObjBeingDeleted_TCL_DECLARED
+#define TclObjBeingDeleted_TCL_DECLARED
+/* 226 */
+EXTERN int		TclObjBeingDeleted (Tcl_Obj * objPtr);
+#endif
+#ifndef TclSetNsPath_TCL_DECLARED
+#define TclSetNsPath_TCL_DECLARED
+/* 227 */
+EXTERN void		TclSetNsPath (Namespace * nsPtr, int pathLength, 
+				Tcl_Namespace * pathAry[]);
+#endif
+#ifndef TclObjInterpProcCore_TCL_DECLARED
+#define TclObjInterpProcCore_TCL_DECLARED
+/* 228 */
+EXTERN int		TclObjInterpProcCore (register Tcl_Interp * interp, 
+				Tcl_Obj * procNameObj, int skip, 
+				ProcErrorProc errorProc);
+#endif
+#ifndef TclPtrMakeUpvar_TCL_DECLARED
+#define TclPtrMakeUpvar_TCL_DECLARED
+/* 229 */
+EXTERN int		TclPtrMakeUpvar (Tcl_Interp * interp, 
+				Var * otherP1Ptr, CONST char * myName, 
+				int myFlags, int index);
+#endif
+#ifndef TclObjLookupVar_TCL_DECLARED
+#define TclObjLookupVar_TCL_DECLARED
+/* 230 */
+EXTERN Var *		TclObjLookupVar (Tcl_Interp * interp, 
+				Tcl_Obj * part1Ptr, CONST char * part2, 
+				int flags, CONST char * msg, 
+				CONST int createPart1, CONST int createPart2, 
+				Var ** arrayPtrPtr);
+#endif
+#ifndef TclGetNamespaceFromObj_TCL_DECLARED
+#define TclGetNamespaceFromObj_TCL_DECLARED
+/* 231 */
+EXTERN int		TclGetNamespaceFromObj (Tcl_Interp * interp, 
+				Tcl_Obj * objPtr, Tcl_Namespace ** nsPtrPtr);
+#endif
+#ifndef TclEvalObjEx_TCL_DECLARED
+#define TclEvalObjEx_TCL_DECLARED
+/* 232 */
+EXTERN int		TclEvalObjEx (Tcl_Interp * interp, Tcl_Obj * objPtr, 
+				int flags, const CmdFrame * invoker, 
+				int word);
+#endif
+#ifndef TclGetSrcInfoForPc_TCL_DECLARED
+#define TclGetSrcInfoForPc_TCL_DECLARED
+/* 233 */
+EXTERN void		TclGetSrcInfoForPc (CmdFrame * contextPtr);
+#endif
+#ifndef TclVarHashCreateVar_TCL_DECLARED
+#define TclVarHashCreateVar_TCL_DECLARED
+/* 234 */
+EXTERN Var *		TclVarHashCreateVar (TclVarHashTable * tablePtr, 
+				const char * key, int * newPtr);
+#endif
+#ifndef TclInitVarHashTable_TCL_DECLARED
+#define TclInitVarHashTable_TCL_DECLARED
+/* 235 */
+EXTERN void		TclInitVarHashTable (TclVarHashTable * tablePtr, 
+				Namespace * nsPtr);
+#endif
+#ifndef TclBackgroundException_TCL_DECLARED
+#define TclBackgroundException_TCL_DECLARED
+/* 236 */
+EXTERN void		TclBackgroundException (Tcl_Interp * interp, 
+				int code);
+#endif
+
+typedef struct TclIntStubs {
+    int magic;
+    struct TclIntStubHooks *hooks;
+
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+    void (*tclAllocateFreeObjects) (void); /* 3 */
+    void *reserved4;
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+    int (*tclCleanupChildren) (Tcl_Interp * interp, int numPids, Tcl_Pid * pidPtr, Tcl_Channel errorChan); /* 5 */
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+    int (*tclCleanupChildren) (Tcl_Interp * interp, int numPids, Tcl_Pid * pidPtr, Tcl_Channel errorChan); /* 5 */
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+    int (*tclCleanupChildren) (Tcl_Interp * interp, int numPids, Tcl_Pid * pidPtr, Tcl_Channel errorChan); /* 5 */
+#endif /* MACOSX */
+    void (*tclCleanupCommand) (Command * cmdPtr); /* 6 */
+    int (*tclCopyAndCollapse) (int count, CONST char * src, char * dst); /* 7 */
+    int (*tclCopyChannel) (Tcl_Interp * interp, Tcl_Channel inChan, Tcl_Channel outChan, int toRead, Tcl_Obj * cmdPtr); /* 8 */
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+    int (*tclCreatePipeline) (Tcl_Interp * interp, int argc, CONST char ** argv, Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, TclFile * outPipePtr, TclFile * errFilePtr); /* 9 */
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+    int (*tclCreatePipeline) (Tcl_Interp * interp, int argc, CONST char ** argv, Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, TclFile * outPipePtr, TclFile * errFilePtr); /* 9 */
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+    int (*tclCreatePipeline) (Tcl_Interp * interp, int argc, CONST char ** argv, Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, TclFile * outPipePtr, TclFile * errFilePtr); /* 9 */
+#endif /* MACOSX */
+    int (*tclCreateProc) (Tcl_Interp * interp, Namespace * nsPtr, CONST char * procName, Tcl_Obj * argsPtr, Tcl_Obj * bodyPtr, Proc ** procPtrPtr); /* 10 */
+    void (*tclDeleteCompiledLocalVars) (Interp * iPtr, CallFrame * framePtr); /* 11 */
+    void (*tclDeleteVars) (Interp * iPtr, TclVarHashTable * tablePtr); /* 12 */
+    void *reserved13;
+    void (*tclDumpMemoryInfo) (FILE * outFile); /* 14 */
+    void *reserved15;
+    void (*tclExprFloatError) (Tcl_Interp * interp, double value); /* 16 */
+    void *reserved17;
+    void *reserved18;
+    void *reserved19;
+    void *reserved20;
+    void *reserved21;
+    int (*tclFindElement) (Tcl_Interp * interp, CONST char * listStr, int listLength, CONST char ** elementPtr, CONST char ** nextPtr, int * sizePtr, int * bracePtr); /* 22 */
+    Proc * (*tclFindProc) (Interp * iPtr, CONST char * procName); /* 23 */
+    void *reserved24;
+    void (*tclFreePackageInfo) (Interp * iPtr); /* 25 */
+    void *reserved26;
+    void *reserved27;
+    Tcl_Channel (*tclpGetDefaultStdChannel) (int type); /* 28 */
+    void *reserved29;
+    void *reserved30;
+    CONST char * (*tclGetExtension) (CONST char * name); /* 31 */
+    int (*tclGetFrame) (Tcl_Interp * interp, CONST char * str, CallFrame ** framePtrPtr); /* 32 */
+    void *reserved33;
+    int (*tclGetIntForIndex) (Tcl_Interp * interp, Tcl_Obj * objPtr, int endValue, int * indexPtr); /* 34 */
+    void *reserved35;
+    int (*tclGetLong) (Tcl_Interp * interp, CONST char * str, long * longPtr); /* 36 */
+    int (*tclGetLoadedPackages) (Tcl_Interp * interp, char * targetName); /* 37 */
+    int (*tclGetNamespaceForQualName) (Tcl_Interp * interp, CONST char * qualName, Namespace * cxtNsPtr, int flags, Namespace ** nsPtrPtr, Namespace ** altNsPtrPtr, Namespace ** actualCxtPtrPtr, CONST char ** simpleNamePtr); /* 38 */
+    TclObjCmdProcType (*tclGetObjInterpProc) (void); /* 39 */
+    int (*tclGetOpenMode) (Tcl_Interp * interp, CONST char * str, int * seekFlagPtr); /* 40 */
+    Tcl_Command (*tclGetOriginalCommand) (Tcl_Command command); /* 41 */
+    char * (*tclpGetUserHome) (CONST char * name, Tcl_DString * bufferPtr); /* 42 */
+    void *reserved43;
+    int (*tclGuessPackageName) (CONST char * fileName, Tcl_DString * bufPtr); /* 44 */
+    int (*tclHideUnsafeCommands) (Tcl_Interp * interp); /* 45 */
+    int (*tclInExit) (void); /* 46 */
+    void *reserved47;
+    void *reserved48;
+    void *reserved49;
+    void (*tclInitCompiledLocals) (Tcl_Interp * interp, CallFrame * framePtr, Namespace * nsPtr); /* 50 */
+    int (*tclInterpInit) (Tcl_Interp * interp); /* 51 */
+    void *reserved52;
+    int (*tclInvokeObjectCommand) (ClientData clientData, Tcl_Interp * interp, int argc, CONST84 char ** argv); /* 53 */
+    int (*tclInvokeStringCommand) (ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[]); /* 54 */
+    Proc * (*tclIsProc) (Command * cmdPtr); /* 55 */
+    void *reserved56;
+    void *reserved57;
+    Var * (*tclLookupVar) (Tcl_Interp * interp, CONST char * part1, CONST char * part2, int flags, CONST char * msg, int createPart1, int createPart2, Var ** arrayPtrPtr); /* 58 */
+    void *reserved59;
+    int (*tclNeedSpace) (CONST char * start, CONST char * end); /* 60 */
+    Tcl_Obj * (*tclNewProcBodyObj) (Proc * procPtr); /* 61 */
+    int (*tclObjCommandComplete) (Tcl_Obj * cmdPtr); /* 62 */
+    int (*tclObjInterpProc) (ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[]); /* 63 */
+    int (*tclObjInvoke) (Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], int flags); /* 64 */
+    void *reserved65;
+    void *reserved66;
+    void *reserved67;
+    void *reserved68;
+    char * (*tclpAlloc) (unsigned int size); /* 69 */
+    void *reserved70;
+    void *reserved71;
+    void *reserved72;
+    void *reserved73;
+    void (*tclpFree) (char * ptr); /* 74 */
+    unsigned long (*tclpGetClicks) (void); /* 75 */
+    unsigned long (*tclpGetSeconds) (void); /* 76 */
+    void (*tclpGetTime) (Tcl_Time * time); /* 77 */
+    int (*tclpGetTimeZone) (unsigned long time); /* 78 */
+    void *reserved79;
+    void *reserved80;
+    char * (*tclpRealloc) (char * ptr, unsigned int size); /* 81 */
+    void *reserved82;
+    void *reserved83;
+    void *reserved84;
+    void *reserved85;
+    void *reserved86;
+    void *reserved87;
+    char * (*tclPrecTraceProc) (ClientData clientData, Tcl_Interp * interp, CONST char * name1, CONST char * name2, int flags); /* 88 */
+    int (*tclPreventAliasLoop) (Tcl_Interp * interp, Tcl_Interp * cmdInterp, Tcl_Command cmd); /* 89 */
+    void *reserved90;
+    void (*tclProcCleanupProc) (Proc * procPtr); /* 91 */
+    int (*tclProcCompileProc) (Tcl_Interp * interp, Proc * procPtr, Tcl_Obj * bodyPtr, Namespace * nsPtr, CONST char * description, CONST char * procName); /* 92 */
+    void (*tclProcDeleteProc) (ClientData clientData); /* 93 */
+    void *reserved94;
+    void *reserved95;
+    int (*tclRenameCommand) (Tcl_Interp * interp, CONST char * oldName, CONST char * newName); /* 96 */
+    void (*tclResetShadowedCmdRefs) (Tcl_Interp * interp, Command * newCmdPtr); /* 97 */
+    int (*tclServiceIdle) (void); /* 98 */
+    void *reserved99;
+    void *reserved100;
+    char * (*tclSetPreInitScript) (char * string); /* 101 */
+    void (*tclSetupEnv) (Tcl_Interp * interp); /* 102 */
+    int (*tclSockGetPort) (Tcl_Interp * interp, CONST char * str, CONST char * proto, int * portPtr); /* 103 */
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+    int (*tclSockMinimumBuffers) (int sock, int size); /* 104 */
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+    int (*tclSockMinimumBuffers) (int sock, int size); /* 104 */
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+    int (*tclSockMinimumBuffers) (int sock, int size); /* 104 */
+#endif /* MACOSX */
+    void *reserved105;
+    void *reserved106;
+    void *reserved107;
+    void (*tclTeardownNamespace) (Namespace * nsPtr); /* 108 */
+    int (*tclUpdateReturnInfo) (Interp * iPtr); /* 109 */
+    void *reserved110;
+    void (*tcl_AddInterpResolvers) (Tcl_Interp * interp, CONST char * name, Tcl_ResolveCmdProc * cmdProc, Tcl_ResolveVarProc * varProc, Tcl_ResolveCompiledVarProc * compiledVarProc); /* 111 */
+    int (*tcl_AppendExportList) (Tcl_Interp * interp, Tcl_Namespace * nsPtr, Tcl_Obj * objPtr); /* 112 */
+    Tcl_Namespace * (*tcl_CreateNamespace) (Tcl_Interp * interp, CONST char * name, ClientData clientData, Tcl_NamespaceDeleteProc * deleteProc); /* 113 */
+    void (*tcl_DeleteNamespace) (Tcl_Namespace * nsPtr); /* 114 */
+    int (*tcl_Export) (Tcl_Interp * interp, Tcl_Namespace * nsPtr, CONST char * pattern, int resetListFirst); /* 115 */
+    Tcl_Command (*tcl_FindCommand) (Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNsPtr, int flags); /* 116 */
+    Tcl_Namespace * (*tcl_FindNamespace) (Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNsPtr, int flags); /* 117 */
+    int (*tcl_GetInterpResolvers) (Tcl_Interp * interp, CONST char * name, Tcl_ResolverInfo * resInfo); /* 118 */
+    int (*tcl_GetNamespaceResolvers) (Tcl_Namespace * namespacePtr, Tcl_ResolverInfo * resInfo); /* 119 */
+    Tcl_Var (*tcl_FindNamespaceVar) (Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNsPtr, int flags); /* 120 */
+    int (*tcl_ForgetImport) (Tcl_Interp * interp, Tcl_Namespace * nsPtr, CONST char * pattern); /* 121 */
+    Tcl_Command (*tcl_GetCommandFromObj) (Tcl_Interp * interp, Tcl_Obj * objPtr); /* 122 */
+    void (*tcl_GetCommandFullName) (Tcl_Interp * interp, Tcl_Command command, Tcl_Obj * objPtr); /* 123 */
+    Tcl_Namespace * (*tcl_GetCurrentNamespace) (Tcl_Interp * interp); /* 124 */
+    Tcl_Namespace * (*tcl_GetGlobalNamespace) (Tcl_Interp * interp); /* 125 */
+    void (*tcl_GetVariableFullName) (Tcl_Interp * interp, Tcl_Var variable, Tcl_Obj * objPtr); /* 126 */
+    int (*tcl_Import) (Tcl_Interp * interp, Tcl_Namespace * nsPtr, CONST char * pattern, int allowOverwrite); /* 127 */
+    void (*tcl_PopCallFrame) (Tcl_Interp * interp); /* 128 */
+    int (*tcl_PushCallFrame) (Tcl_Interp * interp, Tcl_CallFrame * framePtr, Tcl_Namespace * nsPtr, int isProcCallFrame); /* 129 */
+    int (*tcl_RemoveInterpResolvers) (Tcl_Interp * interp, CONST char * name); /* 130 */
+    void (*tcl_SetNamespaceResolvers) (Tcl_Namespace * namespacePtr, Tcl_ResolveCmdProc * cmdProc, Tcl_ResolveVarProc * varProc, Tcl_ResolveCompiledVarProc * compiledVarProc); /* 131 */
+    int (*tclpHasSockets) (Tcl_Interp * interp); /* 132 */
+    struct tm * (*tclpGetDate) (CONST time_t * time, int useGMT); /* 133 */
+    void *reserved134;
+    void *reserved135;
+    void *reserved136;
+    void *reserved137;
+    CONST84_RETURN char * (*tclGetEnv) (CONST char * name, Tcl_DString * valuePtr); /* 138 */
+    void *reserved139;
+    void *reserved140;
+    CONST84_RETURN char * (*tclpGetCwd) (Tcl_Interp * interp, Tcl_DString * cwdPtr); /* 141 */
+    int (*tclSetByteCodeFromAny) (Tcl_Interp * interp, Tcl_Obj * objPtr, CompileHookProc * hookProc, ClientData clientData); /* 142 */
+    int (*tclAddLiteralObj) (struct CompileEnv * envPtr, Tcl_Obj * objPtr, LiteralEntry ** litPtrPtr); /* 143 */
+    void (*tclHideLiteral) (Tcl_Interp * interp, struct CompileEnv * envPtr, int index); /* 144 */
+    struct AuxDataType * (*tclGetAuxDataType) (char * typeName); /* 145 */
+    TclHandle (*tclHandleCreate) (VOID * ptr); /* 146 */
+    void (*tclHandleFree) (TclHandle handle); /* 147 */
+    TclHandle (*tclHandlePreserve) (TclHandle handle); /* 148 */
+    void (*tclHandleRelease) (TclHandle handle); /* 149 */
+    int (*tclRegAbout) (Tcl_Interp * interp, Tcl_RegExp re); /* 150 */
+    void (*tclRegExpRangeUniChar) (Tcl_RegExp re, int index, int * startPtr, int * endPtr); /* 151 */
+    void (*tclSetLibraryPath) (Tcl_Obj * pathPtr); /* 152 */
+    Tcl_Obj * (*tclGetLibraryPath) (void); /* 153 */
+    void *reserved154;
+    void *reserved155;
+    void (*tclRegError) (Tcl_Interp * interp, CONST char * msg, int status); /* 156 */
+    Var * (*tclVarTraceExists) (Tcl_Interp * interp, CONST char * varName); /* 157 */
+    void (*tclSetStartupScriptFileName) (CONST char * filename); /* 158 */
+    CONST84_RETURN char * (*tclGetStartupScriptFileName) (void); /* 159 */
+    void *reserved160;
+    int (*tclChannelTransform) (Tcl_Interp * interp, Tcl_Channel chan, Tcl_Obj * cmdObjPtr); /* 161 */
+    void (*tclChannelEventScriptInvoker) (ClientData clientData, int flags); /* 162 */
+    void * (*tclGetInstructionTable) (void); /* 163 */
+    void (*tclExpandCodeArray) (void * envPtr); /* 164 */
+    void (*tclpSetInitialEncodings) (void); /* 165 */
+    int (*tclListObjSetElement) (Tcl_Interp * interp, Tcl_Obj * listPtr, int index, Tcl_Obj * valuePtr); /* 166 */
+    void (*tclSetStartupScriptPath) (Tcl_Obj * pathPtr); /* 167 */
+    Tcl_Obj * (*tclGetStartupScriptPath) (void); /* 168 */
+    int (*tclpUtfNcmp2) (CONST char * s1, CONST char * s2, unsigned long n); /* 169 */
+    int (*tclCheckInterpTraces) (Tcl_Interp * interp, CONST char * command, int numChars, Command * cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *CONST objv[]); /* 170 */
+    int (*tclCheckExecutionTraces) (Tcl_Interp * interp, CONST char * command, int numChars, Command * cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *CONST objv[]); /* 171 */
+    int (*tclInThreadExit) (void); /* 172 */
+    int (*tclUniCharMatch) (CONST Tcl_UniChar * string, int strLen, CONST Tcl_UniChar * pattern, int ptnLen, int flags); /* 173 */
+    void *reserved174;
+    int (*tclCallVarTraces) (Interp * iPtr, Var * arrayPtr, Var * varPtr, CONST char * part1, CONST char * part2, int flags, int leaveErrMsg); /* 175 */
+    void (*tclCleanupVar) (Var * varPtr, Var * arrayPtr); /* 176 */
+    void (*tclVarErrMsg) (Tcl_Interp * interp, CONST char * part1, CONST char * part2, CONST char * operation, CONST char * reason); /* 177 */
+    void (*tcl_SetStartupScript) (Tcl_Obj * pathPtr, CONST char* encodingName); /* 178 */
+    Tcl_Obj * (*tcl_GetStartupScript) (CONST char ** encodingNamePtr); /* 179 */
+    void *reserved180;
+    void *reserved181;
+    struct tm * (*tclpLocaltime) (CONST time_t * clock); /* 182 */
+    struct tm * (*tclpGmtime) (CONST time_t * clock); /* 183 */
+    void *reserved184;
+    void *reserved185;
+    void *reserved186;
+    void *reserved187;
+    void *reserved188;
+    void *reserved189;
+    void *reserved190;
+    void *reserved191;
+    void *reserved192;
+    void *reserved193;
+    void *reserved194;
+    void *reserved195;
+    void *reserved196;
+    void *reserved197;
+    int (*tclObjGetFrame) (Tcl_Interp * interp, Tcl_Obj * objPtr, CallFrame ** framePtrPtr); /* 198 */
+    void *reserved199;
+    int (*tclpObjRemoveDirectory) (Tcl_Obj * pathPtr, int recursive, Tcl_Obj ** errorPtr); /* 200 */
+    int (*tclpObjCopyDirectory) (Tcl_Obj * srcPathPtr, Tcl_Obj * destPathPtr, Tcl_Obj ** errorPtr); /* 201 */
+    int (*tclpObjCreateDirectory) (Tcl_Obj * pathPtr); /* 202 */
+    int (*tclpObjDeleteFile) (Tcl_Obj * pathPtr); /* 203 */
+    int (*tclpObjCopyFile) (Tcl_Obj * srcPathPtr, Tcl_Obj * destPathPtr); /* 204 */
+    int (*tclpObjRenameFile) (Tcl_Obj * srcPathPtr, Tcl_Obj * destPathPtr); /* 205 */
+    int (*tclpObjStat) (Tcl_Obj * pathPtr, Tcl_StatBuf * buf); /* 206 */
+    int (*tclpObjAccess) (Tcl_Obj * pathPtr, int mode); /* 207 */
+    Tcl_Channel (*tclpOpenFileChannel) (Tcl_Interp * interp, Tcl_Obj * pathPtr, int mode, int permissions); /* 208 */
+    void *reserved209;
+    void *reserved210;
+    void *reserved211;
+    void (*tclpFindExecutable) (CONST char * argv0); /* 212 */
+    Tcl_Obj * (*tclGetObjNameOfExecutable) (void); /* 213 */
+    void (*tclSetObjNameOfExecutable) (Tcl_Obj * name, Tcl_Encoding encoding); /* 214 */
+    void * (*tclStackAlloc) (Tcl_Interp * interp, int numBytes); /* 215 */
+    void (*tclStackFree) (Tcl_Interp * interp, void * freePtr); /* 216 */
+    int (*tclPushStackFrame) (Tcl_Interp * interp, Tcl_CallFrame ** framePtrPtr, Tcl_Namespace * namespacePtr, int isProcCallFrame); /* 217 */
+    void (*tclPopStackFrame) (Tcl_Interp * interp); /* 218 */
+    void *reserved219;
+    void *reserved220;
+    void *reserved221;
+    void *reserved222;
+    void *reserved223;
+    TclPlatformType * (*tclGetPlatform) (void); /* 224 */
+    Tcl_Obj * (*tclTraceDictPath) (Tcl_Interp * interp, Tcl_Obj * rootPtr, int keyc, Tcl_Obj *CONST keyv[], int flags); /* 225 */
+    int (*tclObjBeingDeleted) (Tcl_Obj * objPtr); /* 226 */
+    void (*tclSetNsPath) (Namespace * nsPtr, int pathLength, Tcl_Namespace * pathAry[]); /* 227 */
+    int (*tclObjInterpProcCore) (register Tcl_Interp * interp, Tcl_Obj * procNameObj, int skip, ProcErrorProc errorProc); /* 228 */
+    int (*tclPtrMakeUpvar) (Tcl_Interp * interp, Var * otherP1Ptr, CONST char * myName, int myFlags, int index); /* 229 */
+    Var * (*tclObjLookupVar) (Tcl_Interp * interp, Tcl_Obj * part1Ptr, CONST char * part2, int flags, CONST char * msg, CONST int createPart1, CONST int createPart2, Var ** arrayPtrPtr); /* 230 */
+    int (*tclGetNamespaceFromObj) (Tcl_Interp * interp, Tcl_Obj * objPtr, Tcl_Namespace ** nsPtrPtr); /* 231 */
+    int (*tclEvalObjEx) (Tcl_Interp * interp, Tcl_Obj * objPtr, int flags, const CmdFrame * invoker, int word); /* 232 */
+    void (*tclGetSrcInfoForPc) (CmdFrame * contextPtr); /* 233 */
+    Var * (*tclVarHashCreateVar) (TclVarHashTable * tablePtr, const char * key, int * newPtr); /* 234 */
+    void (*tclInitVarHashTable) (TclVarHashTable * tablePtr, Namespace * nsPtr); /* 235 */
+    void (*tclBackgroundException) (Tcl_Interp * interp, int code); /* 236 */
+} TclIntStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern TclIntStubs *tclIntStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)
+
+/*
+ * Inline function declarations:
+ */
+
+/* Slot 0 is reserved */
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+#ifndef TclAllocateFreeObjects
+#define TclAllocateFreeObjects \
+	(tclIntStubsPtr->tclAllocateFreeObjects) /* 3 */
+#endif
+/* Slot 4 is reserved */
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+#ifndef TclCleanupChildren
+#define TclCleanupChildren \
+	(tclIntStubsPtr->tclCleanupChildren) /* 5 */
+#endif
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+#ifndef TclCleanupChildren
+#define TclCleanupChildren \
+	(tclIntStubsPtr->tclCleanupChildren) /* 5 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#ifndef TclCleanupChildren
+#define TclCleanupChildren \
+	(tclIntStubsPtr->tclCleanupChildren) /* 5 */
+#endif
+#endif /* MACOSX */
+#ifndef TclCleanupCommand
+#define TclCleanupCommand \
+	(tclIntStubsPtr->tclCleanupCommand) /* 6 */
+#endif
+#ifndef TclCopyAndCollapse
+#define TclCopyAndCollapse \
+	(tclIntStubsPtr->tclCopyAndCollapse) /* 7 */
+#endif
+#ifndef TclCopyChannel
+#define TclCopyChannel \
+	(tclIntStubsPtr->tclCopyChannel) /* 8 */
+#endif
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+#ifndef TclCreatePipeline
+#define TclCreatePipeline \
+	(tclIntStubsPtr->tclCreatePipeline) /* 9 */
+#endif
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+#ifndef TclCreatePipeline
+#define TclCreatePipeline \
+	(tclIntStubsPtr->tclCreatePipeline) /* 9 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#ifndef TclCreatePipeline
+#define TclCreatePipeline \
+	(tclIntStubsPtr->tclCreatePipeline) /* 9 */
+#endif
+#endif /* MACOSX */
+#ifndef TclCreateProc
+#define TclCreateProc \
+	(tclIntStubsPtr->tclCreateProc) /* 10 */
+#endif
+#ifndef TclDeleteCompiledLocalVars
+#define TclDeleteCompiledLocalVars \
+	(tclIntStubsPtr->tclDeleteCompiledLocalVars) /* 11 */
+#endif
+#ifndef TclDeleteVars
+#define TclDeleteVars \
+	(tclIntStubsPtr->tclDeleteVars) /* 12 */
+#endif
+/* Slot 13 is reserved */
+#ifndef TclDumpMemoryInfo
+#define TclDumpMemoryInfo \
+	(tclIntStubsPtr->tclDumpMemoryInfo) /* 14 */
+#endif
+/* Slot 15 is reserved */
+#ifndef TclExprFloatError
+#define TclExprFloatError \
+	(tclIntStubsPtr->tclExprFloatError) /* 16 */
+#endif
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+#ifndef TclFindElement
+#define TclFindElement \
+	(tclIntStubsPtr->tclFindElement) /* 22 */
+#endif
+#ifndef TclFindProc
+#define TclFindProc \
+	(tclIntStubsPtr->tclFindProc) /* 23 */
+#endif
+/* Slot 24 is reserved */
+#ifndef TclFreePackageInfo
+#define TclFreePackageInfo \
+	(tclIntStubsPtr->tclFreePackageInfo) /* 25 */
+#endif
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+#ifndef TclpGetDefaultStdChannel
+#define TclpGetDefaultStdChannel \
+	(tclIntStubsPtr->tclpGetDefaultStdChannel) /* 28 */
+#endif
+/* Slot 29 is reserved */
+/* Slot 30 is reserved */
+#ifndef TclGetExtension
+#define TclGetExtension \
+	(tclIntStubsPtr->tclGetExtension) /* 31 */
+#endif
+#ifndef TclGetFrame
+#define TclGetFrame \
+	(tclIntStubsPtr->tclGetFrame) /* 32 */
+#endif
+/* Slot 33 is reserved */
+#ifndef TclGetIntForIndex
+#define TclGetIntForIndex \
+	(tclIntStubsPtr->tclGetIntForIndex) /* 34 */
+#endif
+/* Slot 35 is reserved */
+#ifndef TclGetLong
+#define TclGetLong \
+	(tclIntStubsPtr->tclGetLong) /* 36 */
+#endif
+#ifndef TclGetLoadedPackages
+#define TclGetLoadedPackages \
+	(tclIntStubsPtr->tclGetLoadedPackages) /* 37 */
+#endif
+#ifndef TclGetNamespaceForQualName
+#define TclGetNamespaceForQualName \
+	(tclIntStubsPtr->tclGetNamespaceForQualName) /* 38 */
+#endif
+#ifndef TclGetObjInterpProc
+#define TclGetObjInterpProc \
+	(tclIntStubsPtr->tclGetObjInterpProc) /* 39 */
+#endif
+#ifndef TclGetOpenMode
+#define TclGetOpenMode \
+	(tclIntStubsPtr->tclGetOpenMode) /* 40 */
+#endif
+#ifndef TclGetOriginalCommand
+#define TclGetOriginalCommand \
+	(tclIntStubsPtr->tclGetOriginalCommand) /* 41 */
+#endif
+#ifndef TclpGetUserHome
+#define TclpGetUserHome \
+	(tclIntStubsPtr->tclpGetUserHome) /* 42 */
+#endif
+/* Slot 43 is reserved */
+#ifndef TclGuessPackageName
+#define TclGuessPackageName \
+	(tclIntStubsPtr->tclGuessPackageName) /* 44 */
+#endif
+#ifndef TclHideUnsafeCommands
+#define TclHideUnsafeCommands \
+	(tclIntStubsPtr->tclHideUnsafeCommands) /* 45 */
+#endif
+#ifndef TclInExit
+#define TclInExit \
+	(tclIntStubsPtr->tclInExit) /* 46 */
+#endif
+/* Slot 47 is reserved */
+/* Slot 48 is reserved */
+/* Slot 49 is reserved */
+#ifndef TclInitCompiledLocals
+#define TclInitCompiledLocals \
+	(tclIntStubsPtr->tclInitCompiledLocals) /* 50 */
+#endif
+#ifndef TclInterpInit
+#define TclInterpInit \
+	(tclIntStubsPtr->tclInterpInit) /* 51 */
+#endif
+/* Slot 52 is reserved */
+#ifndef TclInvokeObjectCommand
+#define TclInvokeObjectCommand \
+	(tclIntStubsPtr->tclInvokeObjectCommand) /* 53 */
+#endif
+#ifndef TclInvokeStringCommand
+#define TclInvokeStringCommand \
+	(tclIntStubsPtr->tclInvokeStringCommand) /* 54 */
+#endif
+#ifndef TclIsProc
+#define TclIsProc \
+	(tclIntStubsPtr->tclIsProc) /* 55 */
+#endif
+/* Slot 56 is reserved */
+/* Slot 57 is reserved */
+#ifndef TclLookupVar
+#define TclLookupVar \
+	(tclIntStubsPtr->tclLookupVar) /* 58 */
+#endif
+/* Slot 59 is reserved */
+#ifndef TclNeedSpace
+#define TclNeedSpace \
+	(tclIntStubsPtr->tclNeedSpace) /* 60 */
+#endif
+#ifndef TclNewProcBodyObj
+#define TclNewProcBodyObj \
+	(tclIntStubsPtr->tclNewProcBodyObj) /* 61 */
+#endif
+#ifndef TclObjCommandComplete
+#define TclObjCommandComplete \
+	(tclIntStubsPtr->tclObjCommandComplete) /* 62 */
+#endif
+#ifndef TclObjInterpProc
+#define TclObjInterpProc \
+	(tclIntStubsPtr->tclObjInterpProc) /* 63 */
+#endif
+#ifndef TclObjInvoke
+#define TclObjInvoke \
+	(tclIntStubsPtr->tclObjInvoke) /* 64 */
+#endif
+/* Slot 65 is reserved */
+/* Slot 66 is reserved */
+/* Slot 67 is reserved */
+/* Slot 68 is reserved */
+#ifndef TclpAlloc
+#define TclpAlloc \
+	(tclIntStubsPtr->tclpAlloc) /* 69 */
+#endif
+/* Slot 70 is reserved */
+/* Slot 71 is reserved */
+/* Slot 72 is reserved */
+/* Slot 73 is reserved */
+#ifndef TclpFree
+#define TclpFree \
+	(tclIntStubsPtr->tclpFree) /* 74 */
+#endif
+#ifndef TclpGetClicks
+#define TclpGetClicks \
+	(tclIntStubsPtr->tclpGetClicks) /* 75 */
+#endif
+#ifndef TclpGetSeconds
+#define TclpGetSeconds \
+	(tclIntStubsPtr->tclpGetSeconds) /* 76 */
+#endif
+#ifndef TclpGetTime
+#define TclpGetTime \
+	(tclIntStubsPtr->tclpGetTime) /* 77 */
+#endif
+#ifndef TclpGetTimeZone
+#define TclpGetTimeZone \
+	(tclIntStubsPtr->tclpGetTimeZone) /* 78 */
+#endif
+/* Slot 79 is reserved */
+/* Slot 80 is reserved */
+#ifndef TclpRealloc
+#define TclpRealloc \
+	(tclIntStubsPtr->tclpRealloc) /* 81 */
+#endif
+/* Slot 82 is reserved */
+/* Slot 83 is reserved */
+/* Slot 84 is reserved */
+/* Slot 85 is reserved */
+/* Slot 86 is reserved */
+/* Slot 87 is reserved */
+#ifndef TclPrecTraceProc
+#define TclPrecTraceProc \
+	(tclIntStubsPtr->tclPrecTraceProc) /* 88 */
+#endif
+#ifndef TclPreventAliasLoop
+#define TclPreventAliasLoop \
+	(tclIntStubsPtr->tclPreventAliasLoop) /* 89 */
+#endif
+/* Slot 90 is reserved */
+#ifndef TclProcCleanupProc
+#define TclProcCleanupProc \
+	(tclIntStubsPtr->tclProcCleanupProc) /* 91 */
+#endif
+#ifndef TclProcCompileProc
+#define TclProcCompileProc \
+	(tclIntStubsPtr->tclProcCompileProc) /* 92 */
+#endif
+#ifndef TclProcDeleteProc
+#define TclProcDeleteProc \
+	(tclIntStubsPtr->tclProcDeleteProc) /* 93 */
+#endif
+/* Slot 94 is reserved */
+/* Slot 95 is reserved */
+#ifndef TclRenameCommand
+#define TclRenameCommand \
+	(tclIntStubsPtr->tclRenameCommand) /* 96 */
+#endif
+#ifndef TclResetShadowedCmdRefs
+#define TclResetShadowedCmdRefs \
+	(tclIntStubsPtr->tclResetShadowedCmdRefs) /* 97 */
+#endif
+#ifndef TclServiceIdle
+#define TclServiceIdle \
+	(tclIntStubsPtr->tclServiceIdle) /* 98 */
+#endif
+/* Slot 99 is reserved */
+/* Slot 100 is reserved */
+#ifndef TclSetPreInitScript
+#define TclSetPreInitScript \
+	(tclIntStubsPtr->tclSetPreInitScript) /* 101 */
+#endif
+#ifndef TclSetupEnv
+#define TclSetupEnv \
+	(tclIntStubsPtr->tclSetupEnv) /* 102 */
+#endif
+#ifndef TclSockGetPort
+#define TclSockGetPort \
+	(tclIntStubsPtr->tclSockGetPort) /* 103 */
+#endif
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+#ifndef TclSockMinimumBuffers
+#define TclSockMinimumBuffers \
+	(tclIntStubsPtr->tclSockMinimumBuffers) /* 104 */
+#endif
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+#ifndef TclSockMinimumBuffers
+#define TclSockMinimumBuffers \
+	(tclIntStubsPtr->tclSockMinimumBuffers) /* 104 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#ifndef TclSockMinimumBuffers
+#define TclSockMinimumBuffers \
+	(tclIntStubsPtr->tclSockMinimumBuffers) /* 104 */
+#endif
+#endif /* MACOSX */
+/* Slot 105 is reserved */
+/* Slot 106 is reserved */
+/* Slot 107 is reserved */
+#ifndef TclTeardownNamespace
+#define TclTeardownNamespace \
+	(tclIntStubsPtr->tclTeardownNamespace) /* 108 */
+#endif
+#ifndef TclUpdateReturnInfo
+#define TclUpdateReturnInfo \
+	(tclIntStubsPtr->tclUpdateReturnInfo) /* 109 */
+#endif
+/* Slot 110 is reserved */
+#ifndef Tcl_AddInterpResolvers
+#define Tcl_AddInterpResolvers \
+	(tclIntStubsPtr->tcl_AddInterpResolvers) /* 111 */
+#endif
+#ifndef Tcl_AppendExportList
+#define Tcl_AppendExportList \
+	(tclIntStubsPtr->tcl_AppendExportList) /* 112 */
+#endif
+#ifndef Tcl_CreateNamespace
+#define Tcl_CreateNamespace \
+	(tclIntStubsPtr->tcl_CreateNamespace) /* 113 */
+#endif
+#ifndef Tcl_DeleteNamespace
+#define Tcl_DeleteNamespace \
+	(tclIntStubsPtr->tcl_DeleteNamespace) /* 114 */
+#endif
+#ifndef Tcl_Export
+#define Tcl_Export \
+	(tclIntStubsPtr->tcl_Export) /* 115 */
+#endif
+#ifndef Tcl_FindCommand
+#define Tcl_FindCommand \
+	(tclIntStubsPtr->tcl_FindCommand) /* 116 */
+#endif
+#ifndef Tcl_FindNamespace
+#define Tcl_FindNamespace \
+	(tclIntStubsPtr->tcl_FindNamespace) /* 117 */
+#endif
+#ifndef Tcl_GetInterpResolvers
+#define Tcl_GetInterpResolvers \
+	(tclIntStubsPtr->tcl_GetInterpResolvers) /* 118 */
+#endif
+#ifndef Tcl_GetNamespaceResolvers
+#define Tcl_GetNamespaceResolvers \
+	(tclIntStubsPtr->tcl_GetNamespaceResolvers) /* 119 */
+#endif
+#ifndef Tcl_FindNamespaceVar
+#define Tcl_FindNamespaceVar \
+	(tclIntStubsPtr->tcl_FindNamespaceVar) /* 120 */
+#endif
+#ifndef Tcl_ForgetImport
+#define Tcl_ForgetImport \
+	(tclIntStubsPtr->tcl_ForgetImport) /* 121 */
+#endif
+#ifndef Tcl_GetCommandFromObj
+#define Tcl_GetCommandFromObj \
+	(tclIntStubsPtr->tcl_GetCommandFromObj) /* 122 */
+#endif
+#ifndef Tcl_GetCommandFullName
+#define Tcl_GetCommandFullName \
+	(tclIntStubsPtr->tcl_GetCommandFullName) /* 123 */
+#endif
+#ifndef Tcl_GetCurrentNamespace
+#define Tcl_GetCurrentNamespace \
+	(tclIntStubsPtr->tcl_GetCurrentNamespace) /* 124 */
+#endif
+#ifndef Tcl_GetGlobalNamespace
+#define Tcl_GetGlobalNamespace \
+	(tclIntStubsPtr->tcl_GetGlobalNamespace) /* 125 */
+#endif
+#ifndef Tcl_GetVariableFullName
+#define Tcl_GetVariableFullName \
+	(tclIntStubsPtr->tcl_GetVariableFullName) /* 126 */
+#endif
+#ifndef Tcl_Import
+#define Tcl_Import \
+	(tclIntStubsPtr->tcl_Import) /* 127 */
+#endif
+#ifndef Tcl_PopCallFrame
+#define Tcl_PopCallFrame \
+	(tclIntStubsPtr->tcl_PopCallFrame) /* 128 */
+#endif
+#ifndef Tcl_PushCallFrame
+#define Tcl_PushCallFrame \
+	(tclIntStubsPtr->tcl_PushCallFrame) /* 129 */
+#endif
+#ifndef Tcl_RemoveInterpResolvers
+#define Tcl_RemoveInterpResolvers \
+	(tclIntStubsPtr->tcl_RemoveInterpResolvers) /* 130 */
+#endif
+#ifndef Tcl_SetNamespaceResolvers
+#define Tcl_SetNamespaceResolvers \
+	(tclIntStubsPtr->tcl_SetNamespaceResolvers) /* 131 */
+#endif
+#ifndef TclpHasSockets
+#define TclpHasSockets \
+	(tclIntStubsPtr->tclpHasSockets) /* 132 */
+#endif
+#ifndef TclpGetDate
+#define TclpGetDate \
+	(tclIntStubsPtr->tclpGetDate) /* 133 */
+#endif
+/* Slot 134 is reserved */
+/* Slot 135 is reserved */
+/* Slot 136 is reserved */
+/* Slot 137 is reserved */
+#ifndef TclGetEnv
+#define TclGetEnv \
+	(tclIntStubsPtr->tclGetEnv) /* 138 */
+#endif
+/* Slot 139 is reserved */
+/* Slot 140 is reserved */
+#ifndef TclpGetCwd
+#define TclpGetCwd \
+	(tclIntStubsPtr->tclpGetCwd) /* 141 */
+#endif
+#ifndef TclSetByteCodeFromAny
+#define TclSetByteCodeFromAny \
+	(tclIntStubsPtr->tclSetByteCodeFromAny) /* 142 */
+#endif
+#ifndef TclAddLiteralObj
+#define TclAddLiteralObj \
+	(tclIntStubsPtr->tclAddLiteralObj) /* 143 */
+#endif
+#ifndef TclHideLiteral
+#define TclHideLiteral \
+	(tclIntStubsPtr->tclHideLiteral) /* 144 */
+#endif
+#ifndef TclGetAuxDataType
+#define TclGetAuxDataType \
+	(tclIntStubsPtr->tclGetAuxDataType) /* 145 */
+#endif
+#ifndef TclHandleCreate
+#define TclHandleCreate \
+	(tclIntStubsPtr->tclHandleCreate) /* 146 */
+#endif
+#ifndef TclHandleFree
+#define TclHandleFree \
+	(tclIntStubsPtr->tclHandleFree) /* 147 */
+#endif
+#ifndef TclHandlePreserve
+#define TclHandlePreserve \
+	(tclIntStubsPtr->tclHandlePreserve) /* 148 */
+#endif
+#ifndef TclHandleRelease
+#define TclHandleRelease \
+	(tclIntStubsPtr->tclHandleRelease) /* 149 */
+#endif
+#ifndef TclRegAbout
+#define TclRegAbout \
+	(tclIntStubsPtr->tclRegAbout) /* 150 */
+#endif
+#ifndef TclRegExpRangeUniChar
+#define TclRegExpRangeUniChar \
+	(tclIntStubsPtr->tclRegExpRangeUniChar) /* 151 */
+#endif
+#ifndef TclSetLibraryPath
+#define TclSetLibraryPath \
+	(tclIntStubsPtr->tclSetLibraryPath) /* 152 */
+#endif
+#ifndef TclGetLibraryPath
+#define TclGetLibraryPath \
+	(tclIntStubsPtr->tclGetLibraryPath) /* 153 */
+#endif
+/* Slot 154 is reserved */
+/* Slot 155 is reserved */
+#ifndef TclRegError
+#define TclRegError \
+	(tclIntStubsPtr->tclRegError) /* 156 */
+#endif
+#ifndef TclVarTraceExists
+#define TclVarTraceExists \
+	(tclIntStubsPtr->tclVarTraceExists) /* 157 */
+#endif
+#ifndef TclSetStartupScriptFileName
+#define TclSetStartupScriptFileName \
+	(tclIntStubsPtr->tclSetStartupScriptFileName) /* 158 */
+#endif
+#ifndef TclGetStartupScriptFileName
+#define TclGetStartupScriptFileName \
+	(tclIntStubsPtr->tclGetStartupScriptFileName) /* 159 */
+#endif
+/* Slot 160 is reserved */
+#ifndef TclChannelTransform
+#define TclChannelTransform \
+	(tclIntStubsPtr->tclChannelTransform) /* 161 */
+#endif
+#ifndef TclChannelEventScriptInvoker
+#define TclChannelEventScriptInvoker \
+	(tclIntStubsPtr->tclChannelEventScriptInvoker) /* 162 */
+#endif
+#ifndef TclGetInstructionTable
+#define TclGetInstructionTable \
+	(tclIntStubsPtr->tclGetInstructionTable) /* 163 */
+#endif
+#ifndef TclExpandCodeArray
+#define TclExpandCodeArray \
+	(tclIntStubsPtr->tclExpandCodeArray) /* 164 */
+#endif
+#ifndef TclpSetInitialEncodings
+#define TclpSetInitialEncodings \
+	(tclIntStubsPtr->tclpSetInitialEncodings) /* 165 */
+#endif
+#ifndef TclListObjSetElement
+#define TclListObjSetElement \
+	(tclIntStubsPtr->tclListObjSetElement) /* 166 */
+#endif
+#ifndef TclSetStartupScriptPath
+#define TclSetStartupScriptPath \
+	(tclIntStubsPtr->tclSetStartupScriptPath) /* 167 */
+#endif
+#ifndef TclGetStartupScriptPath
+#define TclGetStartupScriptPath \
+	(tclIntStubsPtr->tclGetStartupScriptPath) /* 168 */
+#endif
+#ifndef TclpUtfNcmp2
+#define TclpUtfNcmp2 \
+	(tclIntStubsPtr->tclpUtfNcmp2) /* 169 */
+#endif
+#ifndef TclCheckInterpTraces
+#define TclCheckInterpTraces \
+	(tclIntStubsPtr->tclCheckInterpTraces) /* 170 */
+#endif
+#ifndef TclCheckExecutionTraces
+#define TclCheckExecutionTraces \
+	(tclIntStubsPtr->tclCheckExecutionTraces) /* 171 */
+#endif
+#ifndef TclInThreadExit
+#define TclInThreadExit \
+	(tclIntStubsPtr->tclInThreadExit) /* 172 */
+#endif
+#ifndef TclUniCharMatch
+#define TclUniCharMatch \
+	(tclIntStubsPtr->tclUniCharMatch) /* 173 */
+#endif
+/* Slot 174 is reserved */
+#ifndef TclCallVarTraces
+#define TclCallVarTraces \
+	(tclIntStubsPtr->tclCallVarTraces) /* 175 */
+#endif
+#ifndef TclCleanupVar
+#define TclCleanupVar \
+	(tclIntStubsPtr->tclCleanupVar) /* 176 */
+#endif
+#ifndef TclVarErrMsg
+#define TclVarErrMsg \
+	(tclIntStubsPtr->tclVarErrMsg) /* 177 */
+#endif
+#ifndef Tcl_SetStartupScript
+#define Tcl_SetStartupScript \
+	(tclIntStubsPtr->tcl_SetStartupScript) /* 178 */
+#endif
+#ifndef Tcl_GetStartupScript
+#define Tcl_GetStartupScript \
+	(tclIntStubsPtr->tcl_GetStartupScript) /* 179 */
+#endif
+/* Slot 180 is reserved */
+/* Slot 181 is reserved */
+#ifndef TclpLocaltime
+#define TclpLocaltime \
+	(tclIntStubsPtr->tclpLocaltime) /* 182 */
+#endif
+#ifndef TclpGmtime
+#define TclpGmtime \
+	(tclIntStubsPtr->tclpGmtime) /* 183 */
+#endif
+/* Slot 184 is reserved */
+/* Slot 185 is reserved */
+/* Slot 186 is reserved */
+/* Slot 187 is reserved */
+/* Slot 188 is reserved */
+/* Slot 189 is reserved */
+/* Slot 190 is reserved */
+/* Slot 191 is reserved */
+/* Slot 192 is reserved */
+/* Slot 193 is reserved */
+/* Slot 194 is reserved */
+/* Slot 195 is reserved */
+/* Slot 196 is reserved */
+/* Slot 197 is reserved */
+#ifndef TclObjGetFrame
+#define TclObjGetFrame \
+	(tclIntStubsPtr->tclObjGetFrame) /* 198 */
+#endif
+/* Slot 199 is reserved */
+#ifndef TclpObjRemoveDirectory
+#define TclpObjRemoveDirectory \
+	(tclIntStubsPtr->tclpObjRemoveDirectory) /* 200 */
+#endif
+#ifndef TclpObjCopyDirectory
+#define TclpObjCopyDirectory \
+	(tclIntStubsPtr->tclpObjCopyDirectory) /* 201 */
+#endif
+#ifndef TclpObjCreateDirectory
+#define TclpObjCreateDirectory \
+	(tclIntStubsPtr->tclpObjCreateDirectory) /* 202 */
+#endif
+#ifndef TclpObjDeleteFile
+#define TclpObjDeleteFile \
+	(tclIntStubsPtr->tclpObjDeleteFile) /* 203 */
+#endif
+#ifndef TclpObjCopyFile
+#define TclpObjCopyFile \
+	(tclIntStubsPtr->tclpObjCopyFile) /* 204 */
+#endif
+#ifndef TclpObjRenameFile
+#define TclpObjRenameFile \
+	(tclIntStubsPtr->tclpObjRenameFile) /* 205 */
+#endif
+#ifndef TclpObjStat
+#define TclpObjStat \
+	(tclIntStubsPtr->tclpObjStat) /* 206 */
+#endif
+#ifndef TclpObjAccess
+#define TclpObjAccess \
+	(tclIntStubsPtr->tclpObjAccess) /* 207 */
+#endif
+#ifndef TclpOpenFileChannel
+#define TclpOpenFileChannel \
+	(tclIntStubsPtr->tclpOpenFileChannel) /* 208 */
+#endif
+/* Slot 209 is reserved */
+/* Slot 210 is reserved */
+/* Slot 211 is reserved */
+#ifndef TclpFindExecutable
+#define TclpFindExecutable \
+	(tclIntStubsPtr->tclpFindExecutable) /* 212 */
+#endif
+#ifndef TclGetObjNameOfExecutable
+#define TclGetObjNameOfExecutable \
+	(tclIntStubsPtr->tclGetObjNameOfExecutable) /* 213 */
+#endif
+#ifndef TclSetObjNameOfExecutable
+#define TclSetObjNameOfExecutable \
+	(tclIntStubsPtr->tclSetObjNameOfExecutable) /* 214 */
+#endif
+#ifndef TclStackAlloc
+#define TclStackAlloc \
+	(tclIntStubsPtr->tclStackAlloc) /* 215 */
+#endif
+#ifndef TclStackFree
+#define TclStackFree \
+	(tclIntStubsPtr->tclStackFree) /* 216 */
+#endif
+#ifndef TclPushStackFrame
+#define TclPushStackFrame \
+	(tclIntStubsPtr->tclPushStackFrame) /* 217 */
+#endif
+#ifndef TclPopStackFrame
+#define TclPopStackFrame \
+	(tclIntStubsPtr->tclPopStackFrame) /* 218 */
+#endif
+/* Slot 219 is reserved */
+/* Slot 220 is reserved */
+/* Slot 221 is reserved */
+/* Slot 222 is reserved */
+/* Slot 223 is reserved */
+#ifndef TclGetPlatform
+#define TclGetPlatform \
+	(tclIntStubsPtr->tclGetPlatform) /* 224 */
+#endif
+#ifndef TclTraceDictPath
+#define TclTraceDictPath \
+	(tclIntStubsPtr->tclTraceDictPath) /* 225 */
+#endif
+#ifndef TclObjBeingDeleted
+#define TclObjBeingDeleted \
+	(tclIntStubsPtr->tclObjBeingDeleted) /* 226 */
+#endif
+#ifndef TclSetNsPath
+#define TclSetNsPath \
+	(tclIntStubsPtr->tclSetNsPath) /* 227 */
+#endif
+#ifndef TclObjInterpProcCore
+#define TclObjInterpProcCore \
+	(tclIntStubsPtr->tclObjInterpProcCore) /* 228 */
+#endif
+#ifndef TclPtrMakeUpvar
+#define TclPtrMakeUpvar \
+	(tclIntStubsPtr->tclPtrMakeUpvar) /* 229 */
+#endif
+#ifndef TclObjLookupVar
+#define TclObjLookupVar \
+	(tclIntStubsPtr->tclObjLookupVar) /* 230 */
+#endif
+#ifndef TclGetNamespaceFromObj
+#define TclGetNamespaceFromObj \
+	(tclIntStubsPtr->tclGetNamespaceFromObj) /* 231 */
+#endif
+#ifndef TclEvalObjEx
+#define TclEvalObjEx \
+	(tclIntStubsPtr->tclEvalObjEx) /* 232 */
+#endif
+#ifndef TclGetSrcInfoForPc
+#define TclGetSrcInfoForPc \
+	(tclIntStubsPtr->tclGetSrcInfoForPc) /* 233 */
+#endif
+#ifndef TclVarHashCreateVar
+#define TclVarHashCreateVar \
+	(tclIntStubsPtr->tclVarHashCreateVar) /* 234 */
+#endif
+#ifndef TclInitVarHashTable
+#define TclInitVarHashTable \
+	(tclIntStubsPtr->tclInitVarHashTable) /* 235 */
+#endif
+#ifndef TclBackgroundException
+#define TclBackgroundException \
+	(tclIntStubsPtr->tclBackgroundException) /* 236 */
+#endif
+
+#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TCLINTDECLS */
Index: src/tktext/tcl8.5/tclIntPlatDecls.h
===================================================================
--- src/tktext/tcl8.5/tclIntPlatDecls.h	(revision 0)
+++ src/tktext/tcl8.5/tclIntPlatDecls.h	(working copy)
@@ -0,0 +1,709 @@
+/*
+ * tclIntPlatDecls.h --
+ *
+ *	This file contains the declarations for all platform dependent
+ *	unsupported functions that are exported by the Tcl library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ * All rights reserved.
+ *
+ * RCS: @(#) $Id: tclIntPlatDecls.h,v 1.32 2007/12/13 15:23:18 dgp Exp $
+ */
+
+#ifndef _TCLINTPLATDECLS
+#define _TCLINTPLATDECLS
+
+#undef TCL_STORAGE_CLASS
+#ifdef BUILD_tcl
+#   define TCL_STORAGE_CLASS DLLEXPORT
+#else
+#   ifdef USE_TCL_STUBS
+#      define TCL_STORAGE_CLASS
+#   else
+#      define TCL_STORAGE_CLASS DLLIMPORT
+#   endif
+#endif
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tclInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+#ifndef TclGetAndDetachPids_TCL_DECLARED
+#define TclGetAndDetachPids_TCL_DECLARED
+/* 0 */
+EXTERN void		TclGetAndDetachPids (Tcl_Interp * interp, 
+				Tcl_Channel chan);
+#endif
+#ifndef TclpCloseFile_TCL_DECLARED
+#define TclpCloseFile_TCL_DECLARED
+/* 1 */
+EXTERN int		TclpCloseFile (TclFile file);
+#endif
+#ifndef TclpCreateCommandChannel_TCL_DECLARED
+#define TclpCreateCommandChannel_TCL_DECLARED
+/* 2 */
+EXTERN Tcl_Channel	TclpCreateCommandChannel (TclFile readFile, 
+				TclFile writeFile, TclFile errorFile, 
+				int numPids, Tcl_Pid * pidPtr);
+#endif
+#ifndef TclpCreatePipe_TCL_DECLARED
+#define TclpCreatePipe_TCL_DECLARED
+/* 3 */
+EXTERN int		TclpCreatePipe (TclFile * readPipe, 
+				TclFile * writePipe);
+#endif
+#ifndef TclpCreateProcess_TCL_DECLARED
+#define TclpCreateProcess_TCL_DECLARED
+/* 4 */
+EXTERN int		TclpCreateProcess (Tcl_Interp * interp, int argc, 
+				CONST char ** argv, TclFile inputFile, 
+				TclFile outputFile, TclFile errorFile, 
+				Tcl_Pid * pidPtr);
+#endif
+/* Slot 5 is reserved */
+#ifndef TclpMakeFile_TCL_DECLARED
+#define TclpMakeFile_TCL_DECLARED
+/* 6 */
+EXTERN TclFile		TclpMakeFile (Tcl_Channel channel, int direction);
+#endif
+#ifndef TclpOpenFile_TCL_DECLARED
+#define TclpOpenFile_TCL_DECLARED
+/* 7 */
+EXTERN TclFile		TclpOpenFile (CONST char * fname, int mode);
+#endif
+#ifndef TclUnixWaitForFile_TCL_DECLARED
+#define TclUnixWaitForFile_TCL_DECLARED
+/* 8 */
+EXTERN int		TclUnixWaitForFile (int fd, int mask, int timeout);
+#endif
+#ifndef TclpCreateTempFile_TCL_DECLARED
+#define TclpCreateTempFile_TCL_DECLARED
+/* 9 */
+EXTERN TclFile		TclpCreateTempFile (CONST char * contents);
+#endif
+#ifndef TclpReaddir_TCL_DECLARED
+#define TclpReaddir_TCL_DECLARED
+/* 10 */
+EXTERN Tcl_DirEntry *	TclpReaddir (DIR * dir);
+#endif
+#ifndef TclpLocaltime_unix_TCL_DECLARED
+#define TclpLocaltime_unix_TCL_DECLARED
+/* 11 */
+EXTERN struct tm *	TclpLocaltime_unix (CONST time_t * clock);
+#endif
+#ifndef TclpGmtime_unix_TCL_DECLARED
+#define TclpGmtime_unix_TCL_DECLARED
+/* 12 */
+EXTERN struct tm *	TclpGmtime_unix (CONST time_t * clock);
+#endif
+#ifndef TclpInetNtoa_TCL_DECLARED
+#define TclpInetNtoa_TCL_DECLARED
+/* 13 */
+EXTERN char *		TclpInetNtoa (struct in_addr addr);
+#endif
+#ifndef TclUnixCopyFile_TCL_DECLARED
+#define TclUnixCopyFile_TCL_DECLARED
+/* 14 */
+EXTERN int		TclUnixCopyFile (CONST char * src, CONST char * dst, 
+				CONST Tcl_StatBuf * statBufPtr, 
+				int dontCopyAtts);
+#endif
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+#ifndef TclWinConvertError_TCL_DECLARED
+#define TclWinConvertError_TCL_DECLARED
+/* 0 */
+EXTERN void		TclWinConvertError (DWORD errCode);
+#endif
+#ifndef TclWinConvertWSAError_TCL_DECLARED
+#define TclWinConvertWSAError_TCL_DECLARED
+/* 1 */
+EXTERN void		TclWinConvertWSAError (DWORD errCode);
+#endif
+#ifndef TclWinGetServByName_TCL_DECLARED
+#define TclWinGetServByName_TCL_DECLARED
+/* 2 */
+EXTERN struct servent *	 TclWinGetServByName (CONST char * nm, 
+				CONST char * proto);
+#endif
+#ifndef TclWinGetSockOpt_TCL_DECLARED
+#define TclWinGetSockOpt_TCL_DECLARED
+/* 3 */
+EXTERN int		TclWinGetSockOpt (int s, int level, int optname, 
+				char FAR * optval, int FAR * optlen);
+#endif
+#ifndef TclWinGetTclInstance_TCL_DECLARED
+#define TclWinGetTclInstance_TCL_DECLARED
+/* 4 */
+EXTERN HINSTANCE	TclWinGetTclInstance (void);
+#endif
+/* Slot 5 is reserved */
+#ifndef TclWinNToHS_TCL_DECLARED
+#define TclWinNToHS_TCL_DECLARED
+/* 6 */
+EXTERN u_short		TclWinNToHS (u_short ns);
+#endif
+#ifndef TclWinSetSockOpt_TCL_DECLARED
+#define TclWinSetSockOpt_TCL_DECLARED
+/* 7 */
+EXTERN int		TclWinSetSockOpt (int s, int level, int optname, 
+				CONST char FAR * optval, int optlen);
+#endif
+#ifndef TclpGetPid_TCL_DECLARED
+#define TclpGetPid_TCL_DECLARED
+/* 8 */
+EXTERN unsigned long	TclpGetPid (Tcl_Pid pid);
+#endif
+#ifndef TclWinGetPlatformId_TCL_DECLARED
+#define TclWinGetPlatformId_TCL_DECLARED
+/* 9 */
+EXTERN int		TclWinGetPlatformId (void);
+#endif
+/* Slot 10 is reserved */
+#ifndef TclGetAndDetachPids_TCL_DECLARED
+#define TclGetAndDetachPids_TCL_DECLARED
+/* 11 */
+EXTERN void		TclGetAndDetachPids (Tcl_Interp * interp, 
+				Tcl_Channel chan);
+#endif
+#ifndef TclpCloseFile_TCL_DECLARED
+#define TclpCloseFile_TCL_DECLARED
+/* 12 */
+EXTERN int		TclpCloseFile (TclFile file);
+#endif
+#ifndef TclpCreateCommandChannel_TCL_DECLARED
+#define TclpCreateCommandChannel_TCL_DECLARED
+/* 13 */
+EXTERN Tcl_Channel	TclpCreateCommandChannel (TclFile readFile, 
+				TclFile writeFile, TclFile errorFile, 
+				int numPids, Tcl_Pid * pidPtr);
+#endif
+#ifndef TclpCreatePipe_TCL_DECLARED
+#define TclpCreatePipe_TCL_DECLARED
+/* 14 */
+EXTERN int		TclpCreatePipe (TclFile * readPipe, 
+				TclFile * writePipe);
+#endif
+#ifndef TclpCreateProcess_TCL_DECLARED
+#define TclpCreateProcess_TCL_DECLARED
+/* 15 */
+EXTERN int		TclpCreateProcess (Tcl_Interp * interp, int argc, 
+				CONST char ** argv, TclFile inputFile, 
+				TclFile outputFile, TclFile errorFile, 
+				Tcl_Pid * pidPtr);
+#endif
+/* Slot 16 is reserved */
+/* Slot 17 is reserved */
+#ifndef TclpMakeFile_TCL_DECLARED
+#define TclpMakeFile_TCL_DECLARED
+/* 18 */
+EXTERN TclFile		TclpMakeFile (Tcl_Channel channel, int direction);
+#endif
+#ifndef TclpOpenFile_TCL_DECLARED
+#define TclpOpenFile_TCL_DECLARED
+/* 19 */
+EXTERN TclFile		TclpOpenFile (CONST char * fname, int mode);
+#endif
+#ifndef TclWinAddProcess_TCL_DECLARED
+#define TclWinAddProcess_TCL_DECLARED
+/* 20 */
+EXTERN void		TclWinAddProcess (HANDLE hProcess, DWORD id);
+#endif
+/* Slot 21 is reserved */
+#ifndef TclpCreateTempFile_TCL_DECLARED
+#define TclpCreateTempFile_TCL_DECLARED
+/* 22 */
+EXTERN TclFile		TclpCreateTempFile (CONST char * contents);
+#endif
+#ifndef TclpGetTZName_TCL_DECLARED
+#define TclpGetTZName_TCL_DECLARED
+/* 23 */
+EXTERN char *		TclpGetTZName (int isdst);
+#endif
+#ifndef TclWinNoBackslash_TCL_DECLARED
+#define TclWinNoBackslash_TCL_DECLARED
+/* 24 */
+EXTERN char *		TclWinNoBackslash (char * path);
+#endif
+/* Slot 25 is reserved */
+#ifndef TclWinSetInterfaces_TCL_DECLARED
+#define TclWinSetInterfaces_TCL_DECLARED
+/* 26 */
+EXTERN void		TclWinSetInterfaces (int wide);
+#endif
+#ifndef TclWinFlushDirtyChannels_TCL_DECLARED
+#define TclWinFlushDirtyChannels_TCL_DECLARED
+/* 27 */
+EXTERN void		TclWinFlushDirtyChannels (void);
+#endif
+#ifndef TclWinResetInterfaces_TCL_DECLARED
+#define TclWinResetInterfaces_TCL_DECLARED
+/* 28 */
+EXTERN void		TclWinResetInterfaces (void);
+#endif
+#ifndef TclWinCPUID_TCL_DECLARED
+#define TclWinCPUID_TCL_DECLARED
+/* 29 */
+EXTERN int		TclWinCPUID (unsigned int index, unsigned int * regs);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#ifndef TclGetAndDetachPids_TCL_DECLARED
+#define TclGetAndDetachPids_TCL_DECLARED
+/* 0 */
+EXTERN void		TclGetAndDetachPids (Tcl_Interp * interp, 
+				Tcl_Channel chan);
+#endif
+#ifndef TclpCloseFile_TCL_DECLARED
+#define TclpCloseFile_TCL_DECLARED
+/* 1 */
+EXTERN int		TclpCloseFile (TclFile file);
+#endif
+#ifndef TclpCreateCommandChannel_TCL_DECLARED
+#define TclpCreateCommandChannel_TCL_DECLARED
+/* 2 */
+EXTERN Tcl_Channel	TclpCreateCommandChannel (TclFile readFile, 
+				TclFile writeFile, TclFile errorFile, 
+				int numPids, Tcl_Pid * pidPtr);
+#endif
+#ifndef TclpCreatePipe_TCL_DECLARED
+#define TclpCreatePipe_TCL_DECLARED
+/* 3 */
+EXTERN int		TclpCreatePipe (TclFile * readPipe, 
+				TclFile * writePipe);
+#endif
+#ifndef TclpCreateProcess_TCL_DECLARED
+#define TclpCreateProcess_TCL_DECLARED
+/* 4 */
+EXTERN int		TclpCreateProcess (Tcl_Interp * interp, int argc, 
+				CONST char ** argv, TclFile inputFile, 
+				TclFile outputFile, TclFile errorFile, 
+				Tcl_Pid * pidPtr);
+#endif
+/* Slot 5 is reserved */
+#ifndef TclpMakeFile_TCL_DECLARED
+#define TclpMakeFile_TCL_DECLARED
+/* 6 */
+EXTERN TclFile		TclpMakeFile (Tcl_Channel channel, int direction);
+#endif
+#ifndef TclpOpenFile_TCL_DECLARED
+#define TclpOpenFile_TCL_DECLARED
+/* 7 */
+EXTERN TclFile		TclpOpenFile (CONST char * fname, int mode);
+#endif
+#ifndef TclUnixWaitForFile_TCL_DECLARED
+#define TclUnixWaitForFile_TCL_DECLARED
+/* 8 */
+EXTERN int		TclUnixWaitForFile (int fd, int mask, int timeout);
+#endif
+#ifndef TclpCreateTempFile_TCL_DECLARED
+#define TclpCreateTempFile_TCL_DECLARED
+/* 9 */
+EXTERN TclFile		TclpCreateTempFile (CONST char * contents);
+#endif
+#ifndef TclpReaddir_TCL_DECLARED
+#define TclpReaddir_TCL_DECLARED
+/* 10 */
+EXTERN Tcl_DirEntry *	TclpReaddir (DIR * dir);
+#endif
+#ifndef TclpLocaltime_unix_TCL_DECLARED
+#define TclpLocaltime_unix_TCL_DECLARED
+/* 11 */
+EXTERN struct tm *	TclpLocaltime_unix (CONST time_t * clock);
+#endif
+#ifndef TclpGmtime_unix_TCL_DECLARED
+#define TclpGmtime_unix_TCL_DECLARED
+/* 12 */
+EXTERN struct tm *	TclpGmtime_unix (CONST time_t * clock);
+#endif
+#ifndef TclpInetNtoa_TCL_DECLARED
+#define TclpInetNtoa_TCL_DECLARED
+/* 13 */
+EXTERN char *		TclpInetNtoa (struct in_addr addr);
+#endif
+#ifndef TclUnixCopyFile_TCL_DECLARED
+#define TclUnixCopyFile_TCL_DECLARED
+/* 14 */
+EXTERN int		TclUnixCopyFile (CONST char * src, CONST char * dst, 
+				CONST Tcl_StatBuf * statBufPtr, 
+				int dontCopyAtts);
+#endif
+#ifndef TclMacOSXGetFileAttribute_TCL_DECLARED
+#define TclMacOSXGetFileAttribute_TCL_DECLARED
+/* 15 */
+EXTERN int		TclMacOSXGetFileAttribute (Tcl_Interp * interp, 
+				int objIndex, Tcl_Obj * fileName, 
+				Tcl_Obj ** attributePtrPtr);
+#endif
+#ifndef TclMacOSXSetFileAttribute_TCL_DECLARED
+#define TclMacOSXSetFileAttribute_TCL_DECLARED
+/* 16 */
+EXTERN int		TclMacOSXSetFileAttribute (Tcl_Interp * interp, 
+				int objIndex, Tcl_Obj * fileName, 
+				Tcl_Obj * attributePtr);
+#endif
+#ifndef TclMacOSXCopyFileAttributes_TCL_DECLARED
+#define TclMacOSXCopyFileAttributes_TCL_DECLARED
+/* 17 */
+EXTERN int		TclMacOSXCopyFileAttributes (CONST char * src, 
+				CONST char * dst, 
+				CONST Tcl_StatBuf * statBufPtr);
+#endif
+#ifndef TclMacOSXMatchType_TCL_DECLARED
+#define TclMacOSXMatchType_TCL_DECLARED
+/* 18 */
+EXTERN int		TclMacOSXMatchType (Tcl_Interp * interp, 
+				CONST char * pathName, CONST char * fileName, 
+				Tcl_StatBuf * statBufPtr, 
+				Tcl_GlobTypeData * types);
+#endif
+#endif /* MACOSX */
+
+typedef struct TclIntPlatStubs {
+    int magic;
+    struct TclIntPlatStubHooks *hooks;
+
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+    void (*tclGetAndDetachPids) (Tcl_Interp * interp, Tcl_Channel chan); /* 0 */
+    int (*tclpCloseFile) (TclFile file); /* 1 */
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid * pidPtr); /* 2 */
+    int (*tclpCreatePipe) (TclFile * readPipe, TclFile * writePipe); /* 3 */
+    int (*tclpCreateProcess) (Tcl_Interp * interp, int argc, CONST char ** argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid * pidPtr); /* 4 */
+    void *reserved5;
+    TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 6 */
+    TclFile (*tclpOpenFile) (CONST char * fname, int mode); /* 7 */
+    int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 8 */
+    TclFile (*tclpCreateTempFile) (CONST char * contents); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (DIR * dir); /* 10 */
+    struct tm * (*tclpLocaltime_unix) (CONST time_t * clock); /* 11 */
+    struct tm * (*tclpGmtime_unix) (CONST time_t * clock); /* 12 */
+    char * (*tclpInetNtoa) (struct in_addr addr); /* 13 */
+    int (*tclUnixCopyFile) (CONST char * src, CONST char * dst, CONST Tcl_StatBuf * statBufPtr, int dontCopyAtts); /* 14 */
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+    void (*tclWinConvertError) (DWORD errCode); /* 0 */
+    void (*tclWinConvertWSAError) (DWORD errCode); /* 1 */
+    struct servent * (*tclWinGetServByName) (CONST char * nm, CONST char * proto); /* 2 */
+    int (*tclWinGetSockOpt) (int s, int level, int optname, char FAR * optval, int FAR * optlen); /* 3 */
+    HINSTANCE (*tclWinGetTclInstance) (void); /* 4 */
+    void *reserved5;
+    u_short (*tclWinNToHS) (u_short ns); /* 6 */
+    int (*tclWinSetSockOpt) (int s, int level, int optname, CONST char FAR * optval, int optlen); /* 7 */
+    unsigned long (*tclpGetPid) (Tcl_Pid pid); /* 8 */
+    int (*tclWinGetPlatformId) (void); /* 9 */
+    void *reserved10;
+    void (*tclGetAndDetachPids) (Tcl_Interp * interp, Tcl_Channel chan); /* 11 */
+    int (*tclpCloseFile) (TclFile file); /* 12 */
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid * pidPtr); /* 13 */
+    int (*tclpCreatePipe) (TclFile * readPipe, TclFile * writePipe); /* 14 */
+    int (*tclpCreateProcess) (Tcl_Interp * interp, int argc, CONST char ** argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid * pidPtr); /* 15 */
+    void *reserved16;
+    void *reserved17;
+    TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 18 */
+    TclFile (*tclpOpenFile) (CONST char * fname, int mode); /* 19 */
+    void (*tclWinAddProcess) (HANDLE hProcess, DWORD id); /* 20 */
+    void *reserved21;
+    TclFile (*tclpCreateTempFile) (CONST char * contents); /* 22 */
+    char * (*tclpGetTZName) (int isdst); /* 23 */
+    char * (*tclWinNoBackslash) (char * path); /* 24 */
+    void *reserved25;
+    void (*tclWinSetInterfaces) (int wide); /* 26 */
+    void (*tclWinFlushDirtyChannels) (void); /* 27 */
+    void (*tclWinResetInterfaces) (void); /* 28 */
+    int (*tclWinCPUID) (unsigned int index, unsigned int * regs); /* 29 */
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+    void (*tclGetAndDetachPids) (Tcl_Interp * interp, Tcl_Channel chan); /* 0 */
+    int (*tclpCloseFile) (TclFile file); /* 1 */
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid * pidPtr); /* 2 */
+    int (*tclpCreatePipe) (TclFile * readPipe, TclFile * writePipe); /* 3 */
+    int (*tclpCreateProcess) (Tcl_Interp * interp, int argc, CONST char ** argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid * pidPtr); /* 4 */
+    void *reserved5;
+    TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 6 */
+    TclFile (*tclpOpenFile) (CONST char * fname, int mode); /* 7 */
+    int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 8 */
+    TclFile (*tclpCreateTempFile) (CONST char * contents); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (DIR * dir); /* 10 */
+    struct tm * (*tclpLocaltime_unix) (CONST time_t * clock); /* 11 */
+    struct tm * (*tclpGmtime_unix) (CONST time_t * clock); /* 12 */
+    char * (*tclpInetNtoa) (struct in_addr addr); /* 13 */
+    int (*tclUnixCopyFile) (CONST char * src, CONST char * dst, CONST Tcl_StatBuf * statBufPtr, int dontCopyAtts); /* 14 */
+    int (*tclMacOSXGetFileAttribute) (Tcl_Interp * interp, int objIndex, Tcl_Obj * fileName, Tcl_Obj ** attributePtrPtr); /* 15 */
+    int (*tclMacOSXSetFileAttribute) (Tcl_Interp * interp, int objIndex, Tcl_Obj * fileName, Tcl_Obj * attributePtr); /* 16 */
+    int (*tclMacOSXCopyFileAttributes) (CONST char * src, CONST char * dst, CONST Tcl_StatBuf * statBufPtr); /* 17 */
+    int (*tclMacOSXMatchType) (Tcl_Interp * interp, CONST char * pathName, CONST char * fileName, Tcl_StatBuf * statBufPtr, Tcl_GlobTypeData * types); /* 18 */
+#endif /* MACOSX */
+} TclIntPlatStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern TclIntPlatStubs *tclIntPlatStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)
+
+/*
+ * Inline function declarations:
+ */
+
+#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
+#ifndef TclGetAndDetachPids
+#define TclGetAndDetachPids \
+	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 0 */
+#endif
+#ifndef TclpCloseFile
+#define TclpCloseFile \
+	(tclIntPlatStubsPtr->tclpCloseFile) /* 1 */
+#endif
+#ifndef TclpCreateCommandChannel
+#define TclpCreateCommandChannel \
+	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 2 */
+#endif
+#ifndef TclpCreatePipe
+#define TclpCreatePipe \
+	(tclIntPlatStubsPtr->tclpCreatePipe) /* 3 */
+#endif
+#ifndef TclpCreateProcess
+#define TclpCreateProcess \
+	(tclIntPlatStubsPtr->tclpCreateProcess) /* 4 */
+#endif
+/* Slot 5 is reserved */
+#ifndef TclpMakeFile
+#define TclpMakeFile \
+	(tclIntPlatStubsPtr->tclpMakeFile) /* 6 */
+#endif
+#ifndef TclpOpenFile
+#define TclpOpenFile \
+	(tclIntPlatStubsPtr->tclpOpenFile) /* 7 */
+#endif
+#ifndef TclUnixWaitForFile
+#define TclUnixWaitForFile \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile) /* 8 */
+#endif
+#ifndef TclpCreateTempFile
+#define TclpCreateTempFile \
+	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 9 */
+#endif
+#ifndef TclpReaddir
+#define TclpReaddir \
+	(tclIntPlatStubsPtr->tclpReaddir) /* 10 */
+#endif
+#ifndef TclpLocaltime_unix
+#define TclpLocaltime_unix \
+	(tclIntPlatStubsPtr->tclpLocaltime_unix) /* 11 */
+#endif
+#ifndef TclpGmtime_unix
+#define TclpGmtime_unix \
+	(tclIntPlatStubsPtr->tclpGmtime_unix) /* 12 */
+#endif
+#ifndef TclpInetNtoa
+#define TclpInetNtoa \
+	(tclIntPlatStubsPtr->tclpInetNtoa) /* 13 */
+#endif
+#ifndef TclUnixCopyFile
+#define TclUnixCopyFile \
+	(tclIntPlatStubsPtr->tclUnixCopyFile) /* 14 */
+#endif
+#endif /* UNIX */
+#ifdef __WIN32__ /* WIN */
+#ifndef TclWinConvertError
+#define TclWinConvertError \
+	(tclIntPlatStubsPtr->tclWinConvertError) /* 0 */
+#endif
+#ifndef TclWinConvertWSAError
+#define TclWinConvertWSAError \
+	(tclIntPlatStubsPtr->tclWinConvertWSAError) /* 1 */
+#endif
+#ifndef TclWinGetServByName
+#define TclWinGetServByName \
+	(tclIntPlatStubsPtr->tclWinGetServByName) /* 2 */
+#endif
+#ifndef TclWinGetSockOpt
+#define TclWinGetSockOpt \
+	(tclIntPlatStubsPtr->tclWinGetSockOpt) /* 3 */
+#endif
+#ifndef TclWinGetTclInstance
+#define TclWinGetTclInstance \
+	(tclIntPlatStubsPtr->tclWinGetTclInstance) /* 4 */
+#endif
+/* Slot 5 is reserved */
+#ifndef TclWinNToHS
+#define TclWinNToHS \
+	(tclIntPlatStubsPtr->tclWinNToHS) /* 6 */
+#endif
+#ifndef TclWinSetSockOpt
+#define TclWinSetSockOpt \
+	(tclIntPlatStubsPtr->tclWinSetSockOpt) /* 7 */
+#endif
+#ifndef TclpGetPid
+#define TclpGetPid \
+	(tclIntPlatStubsPtr->tclpGetPid) /* 8 */
+#endif
+#ifndef TclWinGetPlatformId
+#define TclWinGetPlatformId \
+	(tclIntPlatStubsPtr->tclWinGetPlatformId) /* 9 */
+#endif
+/* Slot 10 is reserved */
+#ifndef TclGetAndDetachPids
+#define TclGetAndDetachPids \
+	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 11 */
+#endif
+#ifndef TclpCloseFile
+#define TclpCloseFile \
+	(tclIntPlatStubsPtr->tclpCloseFile) /* 12 */
+#endif
+#ifndef TclpCreateCommandChannel
+#define TclpCreateCommandChannel \
+	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 13 */
+#endif
+#ifndef TclpCreatePipe
+#define TclpCreatePipe \
+	(tclIntPlatStubsPtr->tclpCreatePipe) /* 14 */
+#endif
+#ifndef TclpCreateProcess
+#define TclpCreateProcess \
+	(tclIntPlatStubsPtr->tclpCreateProcess) /* 15 */
+#endif
+/* Slot 16 is reserved */
+/* Slot 17 is reserved */
+#ifndef TclpMakeFile
+#define TclpMakeFile \
+	(tclIntPlatStubsPtr->tclpMakeFile) /* 18 */
+#endif
+#ifndef TclpOpenFile
+#define TclpOpenFile \
+	(tclIntPlatStubsPtr->tclpOpenFile) /* 19 */
+#endif
+#ifndef TclWinAddProcess
+#define TclWinAddProcess \
+	(tclIntPlatStubsPtr->tclWinAddProcess) /* 20 */
+#endif
+/* Slot 21 is reserved */
+#ifndef TclpCreateTempFile
+#define TclpCreateTempFile \
+	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 22 */
+#endif
+#ifndef TclpGetTZName
+#define TclpGetTZName \
+	(tclIntPlatStubsPtr->tclpGetTZName) /* 23 */
+#endif
+#ifndef TclWinNoBackslash
+#define TclWinNoBackslash \
+	(tclIntPlatStubsPtr->tclWinNoBackslash) /* 24 */
+#endif
+/* Slot 25 is reserved */
+#ifndef TclWinSetInterfaces
+#define TclWinSetInterfaces \
+	(tclIntPlatStubsPtr->tclWinSetInterfaces) /* 26 */
+#endif
+#ifndef TclWinFlushDirtyChannels
+#define TclWinFlushDirtyChannels \
+	(tclIntPlatStubsPtr->tclWinFlushDirtyChannels) /* 27 */
+#endif
+#ifndef TclWinResetInterfaces
+#define TclWinResetInterfaces \
+	(tclIntPlatStubsPtr->tclWinResetInterfaces) /* 28 */
+#endif
+#ifndef TclWinCPUID
+#define TclWinCPUID \
+	(tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#ifndef TclGetAndDetachPids
+#define TclGetAndDetachPids \
+	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 0 */
+#endif
+#ifndef TclpCloseFile
+#define TclpCloseFile \
+	(tclIntPlatStubsPtr->tclpCloseFile) /* 1 */
+#endif
+#ifndef TclpCreateCommandChannel
+#define TclpCreateCommandChannel \
+	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 2 */
+#endif
+#ifndef TclpCreatePipe
+#define TclpCreatePipe \
+	(tclIntPlatStubsPtr->tclpCreatePipe) /* 3 */
+#endif
+#ifndef TclpCreateProcess
+#define TclpCreateProcess \
+	(tclIntPlatStubsPtr->tclpCreateProcess) /* 4 */
+#endif
+/* Slot 5 is reserved */
+#ifndef TclpMakeFile
+#define TclpMakeFile \
+	(tclIntPlatStubsPtr->tclpMakeFile) /* 6 */
+#endif
+#ifndef TclpOpenFile
+#define TclpOpenFile \
+	(tclIntPlatStubsPtr->tclpOpenFile) /* 7 */
+#endif
+#ifndef TclUnixWaitForFile
+#define TclUnixWaitForFile \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile) /* 8 */
+#endif
+#ifndef TclpCreateTempFile
+#define TclpCreateTempFile \
+	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 9 */
+#endif
+#ifndef TclpReaddir
+#define TclpReaddir \
+	(tclIntPlatStubsPtr->tclpReaddir) /* 10 */
+#endif
+#ifndef TclpLocaltime_unix
+#define TclpLocaltime_unix \
+	(tclIntPlatStubsPtr->tclpLocaltime_unix) /* 11 */
+#endif
+#ifndef TclpGmtime_unix
+#define TclpGmtime_unix \
+	(tclIntPlatStubsPtr->tclpGmtime_unix) /* 12 */
+#endif
+#ifndef TclpInetNtoa
+#define TclpInetNtoa \
+	(tclIntPlatStubsPtr->tclpInetNtoa) /* 13 */
+#endif
+#ifndef TclUnixCopyFile
+#define TclUnixCopyFile \
+	(tclIntPlatStubsPtr->tclUnixCopyFile) /* 14 */
+#endif
+#ifndef TclMacOSXGetFileAttribute
+#define TclMacOSXGetFileAttribute \
+	(tclIntPlatStubsPtr->tclMacOSXGetFileAttribute) /* 15 */
+#endif
+#ifndef TclMacOSXSetFileAttribute
+#define TclMacOSXSetFileAttribute \
+	(tclIntPlatStubsPtr->tclMacOSXSetFileAttribute) /* 16 */
+#endif
+#ifndef TclMacOSXCopyFileAttributes
+#define TclMacOSXCopyFileAttributes \
+	(tclIntPlatStubsPtr->tclMacOSXCopyFileAttributes) /* 17 */
+#endif
+#ifndef TclMacOSXMatchType
+#define TclMacOSXMatchType \
+	(tclIntPlatStubsPtr->tclMacOSXMatchType) /* 18 */
+#endif
+#endif /* MACOSX */
+
+#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TCLINTPLATDECLS */
Index: src/tktext/tcl8.5/tclPort.h
===================================================================
--- src/tktext/tcl8.5/tclPort.h	(revision 0)
+++ src/tktext/tcl8.5/tclPort.h	(working copy)
@@ -0,0 +1,46 @@
+/*
+ * tclPort.h --
+ *
+ *	This header file handles porting issues that occur because
+ *	of differences between systems.  It reads in platform specific
+ *	portability files.
+ *
+ * Copyright (c) 1994-1995 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tclPort.h,v 1.15.10.1 2008/11/04 23:56:59 hobbs Exp $
+ */
+
+#ifndef _TCLPORT
+#define _TCLPORT
+
+#ifdef HAVE_TCL_CONFIG_H
+#include "tclConfig.h"
+#endif
+#include "tcl.h"
+
+#if defined(__WIN32__)
+#   include "tclWinPort.h"
+#else
+#   include "tclUnixPort.h"
+#endif
+
+#if !defined(LLONG_MIN)
+#   ifdef TCL_WIDE_INT_IS_LONG
+#      define LLONG_MIN LONG_MIN
+#   else
+#      ifdef LLONG_BIT
+#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<(LLONG_BIT-1)))
+#      else
+/* Assume we're on a system with a 64-bit 'long long' type */
+#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<63))
+#      endif
+#   endif
+/* Assume that if LLONG_MIN is undefined, then so is LLONG_MAX */
+#   define LLONG_MAX (~LLONG_MIN)
+#endif
+
+
+#endif /* _TCLPORT */
Index: src/tktext/tcl8.5/tclUnixPort.h
===================================================================
--- src/tktext/tcl8.5/tclUnixPort.h	(revision 0)
+++ src/tktext/tcl8.5/tclUnixPort.h	(working copy)
@@ -0,0 +1,643 @@
+/*
+ * tclUnixPort.h --
+ *
+ *	This header file handles porting issues that occur because
+ *	of differences between systems.  It reads in UNIX-related
+ *	header files and sets up UNIX-related macros for Tcl's UNIX
+ *	core.  It should be the only file that contains #ifdefs to
+ *	handle different flavors of UNIX.  This file sets up the
+ *	union of all UNIX-related things needed by any of the Tcl
+ *	core files.  This file depends on configuration #defines such
+ *	as NO_DIRENT_H that are set up by the "configure" script.
+ *
+ *	Much of the material in this file was originally contributed
+ *	by Karl Lehenbauer, Mark Diekhans and Peter da Silva.
+ *
+ * Copyright (c) 1991-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tclUnixPort.h,v 1.65 2008/03/11 22:26:27 das Exp $
+ */
+
+#ifndef _TCLUNIXPORT
+#define _TCLUNIXPORT
+
+#ifndef MODULE_SCOPE
+#define MODULE_SCOPE extern
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The following sets of #includes and #ifdefs are required to get Tcl to
+ * compile under the various flavors of unix.
+ *---------------------------------------------------------------------------
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_NET_ERRNO_H
+#   include <net/errno.h>
+#endif
+#include <pwd.h>
+#include <signal.h>
+#ifdef HAVE_SYS_PARAM_H
+#   include <sys/param.h>
+#endif
+#include <sys/types.h>
+#ifdef USE_DIRENT2_H
+#   include "../compat/dirent2.h"
+#else
+#ifdef NO_DIRENT_H
+#   include "../compat/dirent.h"
+#else
+#   include <dirent.h>
+#endif
+#endif
+
+#ifdef HAVE_STRUCT_DIRENT64
+typedef struct dirent64	Tcl_DirEntry;
+#   define TclOSreaddir		readdir64
+#else
+typedef struct dirent	Tcl_DirEntry;
+#   define TclOSreaddir		readdir
+#endif
+
+#ifdef HAVE_TYPE_OFF64_T
+typedef off64_t		Tcl_SeekOffset;
+#   define TclOSseek		lseek64
+#   define TclOSopen		open64
+#else
+typedef off_t		Tcl_SeekOffset;
+#   define TclOSseek		lseek
+#   define TclOSopen		open
+#endif
+
+#ifdef HAVE_STRUCT_STAT64
+#   define TclOSstat		stat64
+#   define TclOSlstat		lstat64
+#else
+#   define TclOSstat		stat
+#   define TclOSlstat		lstat
+#endif
+
+#include <sys/file.h>
+#ifdef HAVE_SYS_SELECT_H
+#   include <sys/select.h>
+#endif
+#include <sys/stat.h>
+#if TIME_WITH_SYS_TIME
+#   include <sys/time.h>
+#   include <time.h>
+#else
+#if HAVE_SYS_TIME_H
+#   include <sys/time.h>
+#else
+#   include <time.h>
+#endif
+#endif
+#ifndef NO_SYS_WAIT_H
+#   include <sys/wait.h>
+#endif
+#if HAVE_INTTYPES_H
+#   include <inttypes.h>
+#endif
+#if HAVE_STDINT_H
+#   include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#   include <unistd.h>
+#else
+#   include "../compat/unistd.h"
+#endif
+
+MODULE_SCOPE int TclUnixSetBlockingMode(int fd, int mode);
+
+#include <utime.h>
+
+/*
+ * Socket support stuff: This likely needs more work to parameterize for
+ * each system.
+ */
+#include <sys/socket.h>		/* struct sockaddr, SOCK_STREAM, ... */
+#ifndef NO_UNAME
+#   include <sys/utsname.h>	/* uname system call. */
+#endif
+#include <netinet/in.h>		/* struct in_addr, struct sockaddr_in */
+#include <arpa/inet.h>		/* inet_ntoa() */
+#include <netdb.h>		/* gethostbyname() */
+
+/*
+ * Some platforms (e.g. SunOS) don't define FLT_MAX and FLT_MIN, so we
+ * look for an alternative definition.  If no other alternative is available
+ * we use a reasonable guess.
+ */
+
+#ifndef NO_FLOAT_H
+#   include <float.h>
+#else
+#ifndef NO_VALUES_H
+#   include <values.h>
+#endif
+#endif
+
+#ifndef FLT_MAX
+#   ifdef MAXFLOAT
+#	define FLT_MAX MAXFLOAT
+#   else
+#	define FLT_MAX 3.402823466E+38F
+#   endif
+#endif
+#ifndef FLT_MIN
+#   ifdef MINFLOAT
+#	define FLT_MIN MINFLOAT
+#   else
+#	define FLT_MIN 1.175494351E-38F
+#   endif
+#endif
+
+/*
+ * NeXT doesn't define O_NONBLOCK, so #define it here if necessary.
+ */
+
+#ifndef O_NONBLOCK
+#   define O_NONBLOCK 0x80
+#endif
+
+/*
+ * The type of the status returned by wait varies from UNIX system
+ * to UNIX system.  The macro below defines it:
+ */
+
+#ifdef _AIX
+#   define WAIT_STATUS_TYPE pid_t
+#else
+#ifndef NO_UNION_WAIT
+#   define WAIT_STATUS_TYPE union wait
+#else
+#   define WAIT_STATUS_TYPE int
+#endif
+#endif
+
+/*
+ * Supply definitions for macros to query wait status, if not already
+ * defined in header files above.
+ */
+
+#ifndef WIFEXITED
+#   define WIFEXITED(stat)  (((*((int *) &(stat))) & 0xff) == 0)
+#endif
+
+#ifndef WEXITSTATUS
+#   define WEXITSTATUS(stat) (((*((int *) &(stat))) >> 8) & 0xff)
+#endif
+
+#ifndef WIFSIGNALED
+#   define WIFSIGNALED(stat) (((*((int *) &(stat)))) && ((*((int *) &(stat))) == ((*((int *) &(stat))) & 0x00ff)))
+#endif
+
+#ifndef WTERMSIG
+#   define WTERMSIG(stat)    ((*((int *) &(stat))) & 0x7f)
+#endif
+
+#ifndef WIFSTOPPED
+#   define WIFSTOPPED(stat)  (((*((int *) &(stat))) & 0xff) == 0177)
+#endif
+
+#ifndef WSTOPSIG
+#   define WSTOPSIG(stat)    (((*((int *) &(stat))) >> 8) & 0xff)
+#endif
+
+/*
+ * Define constants for waitpid() system call if they aren't defined
+ * by a system header file.
+ */
+
+#ifndef WNOHANG
+#   define WNOHANG 1
+#endif
+#ifndef WUNTRACED
+#   define WUNTRACED 2
+#endif
+
+/*
+ * Supply macros for seek offsets, if they're not already provided by
+ * an include file.
+ */
+
+#ifndef SEEK_SET
+#   define SEEK_SET 0
+#endif
+#ifndef SEEK_CUR
+#   define SEEK_CUR 1
+#endif
+#ifndef SEEK_END
+#   define SEEK_END 2
+#endif
+
+/*
+ * The stuff below is needed by the "time" command.  If this system has no
+ * gettimeofday call, then must use times() instead.
+ */
+
+#ifdef NO_GETTOD
+#   include <sys/times.h>
+#else
+#   ifdef HAVE_BSDGETTIMEOFDAY
+#	define gettimeofday BSDgettimeofday
+#   endif
+#endif
+
+#ifdef GETTOD_NOT_DECLARED
+EXTERN int		gettimeofday _ANSI_ARGS_((struct timeval *tp,
+			    struct timezone *tzp));
+#endif
+
+/*
+ * Define access mode constants if they aren't already defined.
+ */
+
+#ifndef F_OK
+#    define F_OK 00
+#endif
+#ifndef X_OK
+#    define X_OK 01
+#endif
+#ifndef W_OK
+#    define W_OK 02
+#endif
+#ifndef R_OK
+#    define R_OK 04
+#endif
+
+/*
+ * Define FD_CLOEEXEC (the close-on-exec flag bit) if it isn't
+ * already defined.
+ */
+
+#ifndef FD_CLOEXEC
+#   define FD_CLOEXEC 1
+#endif
+
+/*
+ * On systems without symbolic links (i.e. S_IFLNK isn't defined)
+ * define "lstat" to use "stat" instead.
+ */
+
+#ifndef S_IFLNK
+#   undef TclOSlstat
+#   define lstat	stat
+#   define lstat64	stat64
+#   define TclOSlstat	TclOSstat
+#endif
+
+/*
+ * Define macros to query file type bits, if they're not already
+ * defined.
+ */
+
+#ifndef S_ISREG
+#   ifdef S_IFREG
+#       define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+#   else
+#       define S_ISREG(m) 0
+#   endif
+#endif /* !S_ISREG */
+#ifndef S_ISDIR
+#   ifdef S_IFDIR
+#       define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+#   else
+#       define S_ISDIR(m) 0
+#   endif
+#endif /* !S_ISDIR */
+#ifndef S_ISCHR
+#   ifdef S_IFCHR
+#       define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+#   else
+#       define S_ISCHR(m) 0
+#   endif
+#endif /* !S_ISCHR */
+#ifndef S_ISBLK
+#   ifdef S_IFBLK
+#       define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
+#   else
+#       define S_ISBLK(m) 0
+#   endif
+#endif /* !S_ISBLK */
+#ifndef S_ISFIFO
+#   ifdef S_IFIFO
+#       define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
+#   else
+#       define S_ISFIFO(m) 0
+#   endif
+#endif /* !S_ISFIFO */
+#ifndef S_ISLNK
+#   ifdef S_IFLNK
+#       define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#   else
+#       define S_ISLNK(m) 0
+#   endif
+#endif /* !S_ISLNK */
+#ifndef S_ISSOCK
+#   ifdef S_IFSOCK
+#       define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+#   else
+#       define S_ISSOCK(m) 0
+#   endif
+#endif /* !S_ISSOCK */
+
+/*
+ * Make sure that MAXPATHLEN and MAXNAMLEN are defined.
+ */
+
+#ifndef MAXPATHLEN
+#   ifdef PATH_MAX
+#       define MAXPATHLEN PATH_MAX
+#   else
+#       define MAXPATHLEN 2048
+#   endif
+#endif
+
+#ifndef MAXNAMLEN
+#   ifdef NAME_MAX
+#	define MAXNAMLEN NAME_MAX
+#   else
+#	define MAXNAMLEN 255
+#   endif
+#endif
+
+/*
+ * Make sure that L_tmpnam is defined.
+ */
+
+#ifndef L_tmpnam
+#   define L_tmpnam 100
+#endif
+
+/*
+ * The following macro defines the type of the mask arguments to
+ * select:
+ */
+
+#ifndef NO_FD_SET
+#   define SELECT_MASK fd_set
+#else /* NO_FD_SET */
+#   ifndef _AIX
+	typedef long fd_mask;
+#   endif /* !AIX */
+#   if defined(_IBMR2)
+#	define SELECT_MASK void
+#   else /* !defined(_IBMR2) */
+#	define SELECT_MASK int
+#   endif /* defined(_IBMR2) */
+#endif /* !NO_FD_SET */
+
+/*
+ * Define "NBBY" (number of bits per byte) if it's not already defined.
+ */
+
+#ifndef NBBY
+#   define NBBY 8
+#endif
+
+/*
+ * The following macro defines the number of fd_masks in an fd_set:
+ */
+
+#ifndef FD_SETSIZE
+#   ifdef OPEN_MAX
+#	define FD_SETSIZE OPEN_MAX
+#   else
+#	define FD_SETSIZE 256
+#   endif
+#endif /* FD_SETSIZE */
+#if !defined(howmany)
+#   define howmany(x, y) (((x)+((y)-1))/(y))
+#endif /* !defined(howmany) */
+#ifndef NFDBITS
+#   define NFDBITS NBBY*sizeof(fd_mask)
+#endif /* NFDBITS */
+#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)
+
+/*
+ * Not all systems declare the errno variable in errno.h. so this
+ * file does it explicitly.  The list of system error messages also
+ * isn't generally declared in a header file anywhere.
+ */
+
+#ifdef NO_ERRNO
+extern int errno;
+#endif /* NO_ERRNO */
+
+/*
+ * Not all systems declare all the errors that Tcl uses!  Provide some
+ * work-arounds...
+ */
+
+#ifndef EOVERFLOW
+#   ifdef EFBIG
+#	define EOVERFLOW EFBIG
+#   else /* !EFBIG */
+#	define EOVERFLOW EINVAL
+#   endif /* EFBIG */
+#endif /* EOVERFLOW */
+
+/*
+ * Variables provided by the C library:
+ */
+
+#if defined(__APPLE__) && defined(__DYNAMIC__)
+#   include <crt_externs.h>
+#   define environ (*_NSGetEnviron())
+#   define USE_PUTENV 1
+#else
+#   if defined(_sgi) || defined(__sgi)
+#       define environ _environ
+#   endif
+extern char **environ;
+#endif
+
+/*
+ * There is no platform-specific panic routine for Unix in the Tcl internals.
+ */
+
+#define TclpPanic ((Tcl_PanicProc *) NULL)
+
+/*
+ * Darwin specifc configure overrides.
+ */
+
+#ifdef __APPLE__
+/*
+ * Support for fat compiles: configure runs only once for multiple architectures
+ */
+#   if defined(__LP64__) && defined (NO_COREFOUNDATION_64)
+#       undef HAVE_COREFOUNDATION
+#    endif /* __LP64__ && NO_COREFOUNDATION_64 */
+#   include <sys/cdefs.h>
+#   ifdef __DARWIN_UNIX03
+#       if __DARWIN_UNIX03
+#           undef HAVE_PUTENV_THAT_COPIES
+#       else
+#           define HAVE_PUTENV_THAT_COPIES 1
+#       endif
+#   endif /* __DARWIN_UNIX03 */
+/*
+ * The termios configure test program relies on the configure script being run
+ * from a terminal, which is not the case e.g. when configuring from Xcode.
+ * Since termios is known to be present on all Mac OS X releases since 10.0,
+ * override the configure defines for serial API here. [Bug 497147]
+ */
+#   define USE_TERMIOS 1
+#   undef  USE_TERMIO
+#   undef  USE_SGTTY
+/*
+ * Include AvailabilityMacros.h here (when available) to ensure any symbolic
+ * MAC_OS_X_VERSION_* constants passed on the command line are translated.
+ */
+#   ifdef HAVE_AVAILABILITYMACROS_H
+#       include <AvailabilityMacros.h>
+#   endif
+/*
+ * Support for weak import.
+ */
+#   ifdef HAVE_WEAK_IMPORT
+#       if !defined(HAVE_AVAILABILITYMACROS_H) || !defined(MAC_OS_X_VERSION_MIN_REQUIRED)
+#           undef HAVE_WEAK_IMPORT
+#       else
+#           ifndef WEAK_IMPORT_ATTRIBUTE
+#               define WEAK_IMPORT_ATTRIBUTE __attribute__((weak_import))
+#           endif
+#       endif
+#   endif /* HAVE_WEAK_IMPORT */
+/*
+ * Support for MAC_OS_X_VERSION_MAX_ALLOWED define from AvailabilityMacros.h:
+ * only use API available in the indicated OS version or earlier.
+ */
+#   ifdef MAC_OS_X_VERSION_MAX_ALLOWED
+#       if MAC_OS_X_VERSION_MAX_ALLOWED < 1050 && defined(__LP64__)
+#           undef HAVE_COREFOUNDATION
+#       endif
+#       if MAC_OS_X_VERSION_MAX_ALLOWED < 1040
+#           undef HAVE_OSSPINLOCKLOCK
+#           undef HAVE_PTHREAD_ATFORK
+#           undef HAVE_COPYFILE
+#       endif
+#       if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
+#           ifdef TCL_THREADS
+		/* prior to 10.3, realpath is not threadsafe, c.f. bug 711232 */
+#               define NO_REALPATH 1
+#           endif
+#           undef HAVE_LANGINFO
+#       endif
+#   endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#   if defined(HAVE_COREFOUNDATION) && defined(__LP64__) && \
+	    defined(HAVE_WEAK_IMPORT) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
+#       warning "Weak import of 64-bit CoreFoundation is not supported, will not run on Mac OS X < 10.5."
+#   endif
+/*
+ * At present, using vfork() instead of fork() causes execve() to fail
+ * intermittently on Darwin x86_64. rdar://4685553
+ */
+#   if defined(__x86_64__) && !defined(FIXED_RDAR_4685553)
+#       undef USE_VFORK
+#   endif /* __x86_64__ */
+/* Workaround problems with vfork() when building with llvm-gcc-4.2 */
+#   if defined (__llvm__) && \
+	    (__GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ > 2 || \
+	    (__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ > 0))))
+#       undef USE_VFORK
+#   endif /* __llvm__ */
+#endif /* __APPLE__ */
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macros and declarations represent the interface between 
+ * generic and unix-specific parts of Tcl.  Some of the macros may override 
+ * functions declared in tclInt.h.
+ *---------------------------------------------------------------------------
+ */
+
+/*
+ * The default platform eol translation on Unix is TCL_TRANSLATE_LF.
+ */
+
+#ifdef DJGPP
+#define	TCL_PLATFORM_TRANSLATION	TCL_TRANSLATE_CRLF
+typedef int socklen_t;
+#else
+#define	TCL_PLATFORM_TRANSLATION	TCL_TRANSLATE_LF
+#endif
+
+/*
+ * The following macros have trivial definitions, allowing generic code to 
+ * address platform-specific issues.
+ */
+
+#define TclpGetPid(pid)		((unsigned long) (pid))
+#define TclpReleaseFile(file)	/* Nothing. */
+
+/*
+ * The following defines wrap the system memory allocation routines.
+ */
+
+#define TclpSysAlloc(size, isBin)	malloc((size_t)size)
+#define TclpSysFree(ptr)		free((char*)ptr)
+#define TclpSysRealloc(ptr, size)	realloc((char*)ptr, (size_t)size)
+
+/*
+ * The following macros and declaration wrap the C runtime library
+ * functions.
+ */
+
+#define TclpExit		exit
+
+#ifdef TCL_THREADS
+EXTERN struct tm *     	TclpLocaltime(CONST time_t *);
+EXTERN struct tm *     	TclpGmtime(CONST time_t *);
+EXTERN char *          	TclpInetNtoa(struct in_addr);
+/* #define localtime(x)	TclpLocaltime(x)
+ * #define gmtime(x)	TclpGmtime(x)    */
+#   undef inet_ntoa
+#   define inet_ntoa(x)	TclpInetNtoa(x)
+#   ifdef HAVE_PTHREAD_ATTR_GET_NP
+#	define TclpPthreadGetAttrs	pthread_attr_get_np
+#	ifdef ATTRGETNP_NOT_DECLARED
+/*
+ * Assume it is in pthread_np.h if it isn't in pthread.h. [Bug 1064882]
+ * We might need to revisit this in the future. :^(
+ */
+#	    include <pthread.h>
+#	    include <pthread_np.h>
+#	endif
+#   else
+#	ifdef HAVE_PTHREAD_GETATTR_NP
+#	    define TclpPthreadGetAttrs	pthread_getattr_np
+#	    ifdef GETATTRNP_NOT_DECLARED
+EXTERN int pthread_getattr_np _ANSI_ARGS_((pthread_t, pthread_attr_t *));
+#	    endif
+#	endif /* HAVE_PTHREAD_GETATTR_NP */
+#   endif /* HAVE_PTHREAD_ATTR_GET_NP */
+#endif /* TCL_THREADS */
+
+/*
+ * Set of MT-safe implementations of some
+ * known-to-be-MT-unsafe library calls.
+ * Instead of returning pointers to the
+ * static storage, those return pointers
+ * to the TSD data. 
+ */
+
+#include <pwd.h>
+#include <grp.h>
+
+MODULE_SCOPE struct passwd*  TclpGetPwNam(const char *name);
+MODULE_SCOPE struct group*   TclpGetGrNam(const char *name);
+MODULE_SCOPE struct passwd*  TclpGetPwUid(uid_t uid);
+MODULE_SCOPE struct group*   TclpGetGrGid(gid_t gid);
+MODULE_SCOPE struct hostent* TclpGetHostByName(const char *name);
+MODULE_SCOPE struct hostent* TclpGetHostByAddr(const char *addr, int length, int type);
+
+#endif /* _TCLUNIXPORT */
Index: src/tktext/tcl8.6/tclInt.h
===================================================================
--- src/tktext/tcl8.6/tclInt.h	(revision 0)
+++ src/tktext/tcl8.6/tclInt.h	(working copy)
@@ -0,0 +1,4837 @@
+/*
+ * tclInt.h --
+ *
+ *	Declarations of things used internally by the Tcl interpreter.
+ *
+ * Copyright (c) 1987-1993 The Regents of the University of California.
+ * Copyright (c) 1993-1997 Lucent Technologies.
+ * Copyright (c) 1994-1998 Sun Microsystems, Inc.
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
+ * Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
+ * Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
+ * Copyright (c) 2008 by Miguel Sofer. All rights reserved.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLINT
+#define _TCLINT
+
+/*
+ * Some numerics configuration options.
+ */
+
+#undef NO_WIDE_TYPE
+#undef ACCEPT_NAN
+
+/*
+ * Common include files needed by most of the Tcl source files are included
+ * here, so that system-dependent personalizations for the include files only
+ * have to be made in once place. This results in a few extra includes, but
+ * greater modularity. The order of the three groups of #includes is
+ * important. For example, stdio.h is needed by tcl.h, and the _ANSI_ARGS_
+ * declaration in tcl.h is needed by stdlib.h in some configurations.
+ */
+
+#include "tclPort.h"
+
+#include <stdio.h>
+
+#include <ctype.h>
+#ifdef NO_STDLIB_H
+#   include "../compat/stdlib.h"
+#else
+#   include <stdlib.h>
+#endif
+#ifdef NO_STRING_H
+#include "../compat/string.h"
+#else
+#include <string.h>
+#endif
+#ifdef STDC_HEADERS
+#include <stddef.h>
+#else
+typedef int ptrdiff_t;
+#endif
+
+/*
+ * Ensure WORDS_BIGENDIAN is defined correctly:
+ * Needs to happen here in addition to configure to work with fat compiles on
+ * Darwin (where configure runs only once for multiple architectures).
+ */
+
+#ifdef HAVE_SYS_TYPES_H
+#    include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#    include <sys/param.h>
+#endif
+#ifdef BYTE_ORDER
+#    ifdef BIG_ENDIAN
+#	 if BYTE_ORDER == BIG_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	     define WORDS_BIGENDIAN 1
+#	 endif
+#    endif
+#    ifdef LITTLE_ENDIAN
+#	 if BYTE_ORDER == LITTLE_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	 endif
+#    endif
+#endif
+
+/*
+ * Used to tag functions that are only to be visible within the module being
+ * built and not outside it (where this is supported by the linker).
+ */
+
+#ifndef MODULE_SCOPE
+#   ifdef __cplusplus
+#	define MODULE_SCOPE extern "C"
+#   else
+#	define MODULE_SCOPE extern
+#   endif
+#endif
+
+/*
+ * When Tcl_WideInt and long are the same type, there's no value in
+ * having a tclWideIntType separate from the tclIntType.
+ */
+#ifdef TCL_WIDE_INT_IS_LONG
+#define NO_WIDE_TYPE
+#endif
+
+/*
+ * Macros used to cast between pointers and integers (e.g. when storing an int
+ * in ClientData), on 64-bit architectures they avoid gcc warning about "cast
+ * to/from pointer from/to integer of different size".
+ */
+
+#if !defined(INT2PTR) && !defined(PTR2INT)
+#   if defined(HAVE_INTPTR_T) || defined(intptr_t)
+#	define INT2PTR(p) ((void *)(intptr_t)(p))
+#	define PTR2INT(p) ((int)(intptr_t)(p))
+#   else
+#	define INT2PTR(p) ((void *)(p))
+#	define PTR2INT(p) ((int)(p))
+#   endif
+#endif
+#if !defined(UINT2PTR) && !defined(PTR2UINT)
+#   if defined(HAVE_UINTPTR_T) || defined(uintptr_t)
+#	define UINT2PTR(p) ((void *)(uintptr_t)(p))
+#	define PTR2UINT(p) ((unsigned int)(uintptr_t)(p))
+#   else
+#	define UINT2PTR(p) ((void *)(p))
+#	define PTR2UINT(p) ((unsigned int)(p))
+#   endif
+#endif
+
+/*
+ * The following procedures allow namespaces to be customized to support
+ * special name resolution rules for commands/variables.
+ */
+
+struct Tcl_ResolvedVarInfo;
+
+typedef Tcl_Var (Tcl_ResolveRuntimeVarProc)(Tcl_Interp *interp,
+	struct Tcl_ResolvedVarInfo *vinfoPtr);
+
+typedef void (Tcl_ResolveVarDeleteProc)(struct Tcl_ResolvedVarInfo *vinfoPtr);
+
+/*
+ * The following structure encapsulates the routines needed to resolve a
+ * variable reference at runtime. Any variable specific state will typically
+ * be appended to this structure.
+ */
+
+typedef struct Tcl_ResolvedVarInfo {
+    Tcl_ResolveRuntimeVarProc *fetchProc;
+    Tcl_ResolveVarDeleteProc *deleteProc;
+} Tcl_ResolvedVarInfo;
+
+typedef int (Tcl_ResolveCompiledVarProc)(Tcl_Interp *interp,
+	CONST84 char *name, int length, Tcl_Namespace *context,
+	Tcl_ResolvedVarInfo **rPtr);
+
+typedef int (Tcl_ResolveVarProc)(Tcl_Interp *interp, CONST84 char *name,
+	Tcl_Namespace *context, int flags, Tcl_Var *rPtr);
+
+typedef int (Tcl_ResolveCmdProc)(Tcl_Interp *interp, CONST84 char *name,
+	Tcl_Namespace *context, int flags, Tcl_Command *rPtr);
+
+typedef struct Tcl_ResolverInfo {
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* Procedure handling command name
+				 * resolution. */
+    Tcl_ResolveVarProc *varResProc;
+				/* Procedure handling variable name resolution
+				 * for variables that can only be handled at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* Procedure handling variable name resolution
+				 * at compile time. */
+} Tcl_ResolverInfo;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to namespaces.
+ *----------------------------------------------------------------
+ */
+
+typedef struct Tcl_Ensemble Tcl_Ensemble;
+typedef struct NamespacePathEntry NamespacePathEntry;
+
+/*
+ * Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
+ * field added at the end: in this way variables can find their namespace
+ * without having to copy a pointer in their struct: they can access it via
+ * their hPtr->tablePtr.
+ */
+
+typedef struct TclVarHashTable {
+    Tcl_HashTable table;
+    struct Namespace *nsPtr;
+} TclVarHashTable;
+
+/*
+ * This is for itcl - it likes to search our varTables directly :(
+ */
+
+#define TclVarHashFindVar(tablePtr, key) \
+    TclVarHashCreateVar((tablePtr), (key), NULL)
+
+/*
+ * Define this to reduce the amount of space that the average namespace
+ * consumes by only allocating the table of child namespaces when necessary.
+ * Defining it breaks compatibility for Tcl extensions (e.g., itcl) which
+ * reach directly into the Namespace structure.
+ */
+
+#undef BREAK_NAMESPACE_COMPAT
+
+/*
+ * The structure below defines a namespace.
+ * Note: the first five fields must match exactly the fields in a
+ * Tcl_Namespace structure (see tcl.h). If you change one, be sure to change
+ * the other.
+ */
+
+typedef struct Namespace {
+    char *name;			/* The namespace's simple (unqualified) name.
+				 * This contains no ::'s. The name of the
+				 * global namespace is "" although "::" is an
+				 * synonym. */
+    char *fullName;		/* The namespace's fully qualified name. This
+				 * starts with ::. */
+    ClientData clientData;	/* An arbitrary value associated with this
+				 * namespace. */
+    Tcl_NamespaceDeleteProc *deleteProc;
+				/* Procedure invoked when deleting the
+				 * namespace to, e.g., free clientData. */
+    struct Namespace *parentPtr;/* Points to the namespace that contains this
+				 * one. NULL if this is the global
+				 * namespace. */
+#ifndef BREAK_NAMESPACE_COMPAT
+    Tcl_HashTable childTable;	/* Contains any child namespaces. Indexed by
+				 * strings; values have type (Namespace *). */
+#else
+    Tcl_HashTable *childTablePtr;
+				/* Contains any child namespaces. Indexed by
+				 * strings; values have type (Namespace *). If
+				 * NULL, there are no children. */
+#endif
+    long nsId;			/* Unique id for the namespace. */
+    Tcl_Interp *interp;		/* The interpreter containing this
+				 * namespace. */
+    int flags;			/* OR-ed combination of the namespace status
+				 * flags NS_DYING and NS_DEAD listed below. */
+    int activationCount;	/* Number of "activations" or active call
+				 * frames for this namespace that are on the
+				 * Tcl call stack. The namespace won't be
+				 * freed until activationCount becomes zero. */
+    int refCount;		/* Count of references by namespaceName
+				 * objects. The namespace can't be freed until
+				 * refCount becomes zero. */
+    Tcl_HashTable cmdTable;	/* Contains all the commands currently
+				 * registered in the namespace. Indexed by
+				 * strings; values have type (Command *).
+				 * Commands imported by Tcl_Import have
+				 * Command structures that point (via an
+				 * ImportedCmdRef structure) to the Command
+				 * structure in the source namespace's command
+				 * table. */
+    TclVarHashTable varTable;	/* Contains all the (global) variables
+				 * currently in this namespace. Indexed by
+				 * strings; values have type (Var *). */
+    char **exportArrayPtr;	/* Points to an array of string patterns
+				 * specifying which commands are exported. A
+				 * pattern may include "string match" style
+				 * wildcard characters to specify multiple
+				 * commands; however, no namespace qualifiers
+				 * are allowed. NULL if no export patterns are
+				 * registered. */
+    int numExportPatterns;	/* Number of export patterns currently
+				 * registered using "namespace export". */
+    int maxExportPatterns;	/* Mumber of export patterns for which space
+				 * is currently allocated. */
+    int cmdRefEpoch;		/* Incremented if a newly added command
+				 * shadows a command for which this namespace
+				 * has already cached a Command* pointer; this
+				 * causes all its cached Command* pointers to
+				 * be invalidated. */
+    int resolverEpoch;		/* Incremented whenever (a) the name
+				 * resolution rules change for this namespace
+				 * or (b) a newly added command shadows a
+				 * command that is compiled to bytecodes. This
+				 * invalidates all byte codes compiled in the
+				 * namespace, causing the code to be
+				 * recompiled under the new rules.*/
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* If non-null, this procedure overrides the
+				 * usual command resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * Tcl_FindCommand to resolve all command
+				 * references within the namespace. */
+    Tcl_ResolveVarProc *varResProc;
+				/* If non-null, this procedure overrides the
+				 * usual variable resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * Tcl_FindNamespaceVar to resolve all
+				 * variable references within the namespace at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* If non-null, this procedure overrides the
+				 * usual variable resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * LookupCompiledLocal to resolve variable
+				 * references within the namespace at compile
+				 * time. */
+    int exportLookupEpoch;	/* Incremented whenever a command is added to
+				 * a namespace, removed from a namespace or
+				 * the exports of a namespace are changed.
+				 * Allows TIP#112-driven command lists to be
+				 * validated efficiently. */
+    Tcl_Ensemble *ensembles;	/* List of structures that contain the details
+				 * of the ensembles that are implemented on
+				 * top of this namespace. */
+    Tcl_Obj *unknownHandlerPtr;	/* A script fragment to be used when command
+				 * resolution in this namespace fails. TIP
+				 * 181. */
+    int commandPathLength;	/* The length of the explicit path. */
+    NamespacePathEntry *commandPathArray;
+				/* The explicit path of the namespace as an
+				 * array. */
+    NamespacePathEntry *commandPathSourceList;
+				/* Linked list of path entries that point to
+				 * this namespace. */
+    Tcl_NamespaceDeleteProc *earlyDeleteProc;
+				/* Just like the deleteProc field (and called
+				 * with the same clientData) but called at the
+				 * start of the deletion process, so there is
+				 * a chance for code to do stuff inside the
+				 * namespace before deletion completes. */
+} Namespace;
+
+/*
+ * An entry on a namespace's command resolution path.
+ */
+
+struct NamespacePathEntry {
+    Namespace *nsPtr;		/* What does this path entry point to? If it
+				 * is NULL, this path entry points is
+				 * redundant and should be skipped. */
+    Namespace *creatorNsPtr;	/* Where does this path entry point from? This
+				 * allows for efficient invalidation of
+				 * references when the path entry's target
+				 * updates its current list of defined
+				 * commands. */
+    NamespacePathEntry *prevPtr, *nextPtr;
+				/* Linked list pointers or NULL at either end
+				 * of the list that hangs off Namespace's
+				 * commandPathSourceList field. */
+};
+
+/*
+ * Flags used to represent the status of a namespace:
+ *
+ * NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
+ *		namespace but there are still active call frames on the Tcl
+ *		stack that refer to the namespace. When the last call frame
+ *		referring to it has been popped, it's variables and command
+ *		will be destroyed and it will be marked "dead" (NS_DEAD). The
+ *		namespace can no longer be looked up by name.
+ * NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
+ *		namespace and no call frames still refer to it. Its variables
+ *		and command have already been destroyed. This bit allows the
+ *		namespace resolution code to recognize that the namespace is
+ *		"deleted". When the last namespaceName object in any byte code
+ *		unit that refers to the namespace has been freed (i.e., when
+ *		the namespace's refCount is 0), the namespace's storage will
+ *		be freed.
+ * NS_KILLED -	1 means that TclTeardownNamespace has already been called on
+ *		this namespace and it should not be called again [Bug 1355942]
+ * NS_SUPPRESS_COMPILATION -
+ *		Marks the commands in this namespace for not being compiled,
+ *		forcing them to be looked up every time.
+ */
+
+#define NS_DYING	0x01
+#define NS_DEAD		0x02
+#define NS_KILLED	0x04
+#define NS_SUPPRESS_COMPILATION	0x08
+
+/*
+ * Flags passed to TclGetNamespaceForQualName:
+ *
+ * TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
+ * TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
+ * TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
+ * TCL_FIND_ONLY_NS		- The name sought is a namespace name.
+ */
+
+#define TCL_CREATE_NS_IF_UNKNOWN	0x800
+#define TCL_FIND_ONLY_NS		0x1000
+
+/*
+ * The data cached in an ensemble subcommand's Tcl_Obj rep (reference in
+ * otherValuePtr field). This structure is not shared between Tcl_Objs
+ * referring to the same subcommand, even where one is a duplicate of another.
+ */
+
+typedef struct {
+    Namespace *nsPtr;		/* The namespace backing the ensemble which
+				 * this is a subcommand of. */
+    int epoch;			/* Used to confirm when the data in this
+				 * really structure matches up with the
+				 * ensemble. */
+    Tcl_Command token;		/* Reference to the comamnd for which this
+				 * structure is a cache of the resolution. */
+    char *fullSubcmdName;	/* The full (local) name of the subcommand,
+				 * allocated with ckalloc(). */
+    Tcl_Obj *realPrefixObj;	/* Object containing the prefix words of the
+				 * command that implements this ensemble
+				 * subcommand. */
+} EnsembleCmdRep;
+
+/*
+ * The client data for an ensemble command. This consists of the table of
+ * commands that are actually exported by the namespace, and an epoch counter
+ * that, combined with the exportLookupEpoch field of the namespace structure,
+ * defines whether the table contains valid data or will need to be recomputed
+ * next time the ensemble command is called.
+ */
+
+typedef struct EnsembleConfig {
+    Namespace *nsPtr;		/* The namspace backing this ensemble up. */
+    Tcl_Command token;		/* The token for the command that provides
+				 * ensemble support for the namespace, or NULL
+				 * if the command has been deleted (or never
+				 * existed; the global namespace never has an
+				 * ensemble command.) */
+    int epoch;			/* The epoch at which this ensemble's table of
+				 * exported commands is valid. */
+    char **subcommandArrayPtr;	/* Array of ensemble subcommand names. At all
+				 * consistent points, this will have the same
+				 * number of entries as there are entries in
+				 * the subcommandTable hash. */
+    Tcl_HashTable subcommandTable;
+				/* Hash table of ensemble subcommand names,
+				 * which are its keys so this also provides
+				 * the storage management for those subcommand
+				 * names. The contents of the entry values are
+				 * object version the prefix lists to use when
+				 * substituting for the command/subcommand to
+				 * build the ensemble implementation command.
+				 * Has to be stored here as well as in
+				 * subcommandDict because that field is NULL
+				 * when we are deriving the ensemble from the
+				 * namespace exports list. FUTURE WORK: use
+				 * object hash table here. */
+    struct EnsembleConfig *next;/* The next ensemble in the linked list of
+				 * ensembles associated with a namespace. If
+				 * this field points to this ensemble, the
+				 * structure has already been unlinked from
+				 * all lists, and cannot be found by scanning
+				 * the list from the namespace's ensemble
+				 * field. */
+    int flags;			/* ORed combo of TCL_ENSEMBLE_PREFIX,
+				 * ENSEMBLE_DEAD and ENSEMBLE_COMPILE. */
+
+    /* OBJECT FIELDS FOR ENSEMBLE CONFIGURATION */
+
+    Tcl_Obj *subcommandDict;	/* Dictionary providing mapping from
+				 * subcommands to their implementing command
+				 * prefixes, or NULL if we are to build the
+				 * map automatically from the namespace
+				 * exports. */
+    Tcl_Obj *subcmdList;	/* List of commands that this ensemble
+				 * actually provides, and whose implementation
+				 * will be built using the subcommandDict (if
+				 * present and defined) and by simple mapping
+				 * to the namespace otherwise. If NULL,
+				 * indicates that we are using the (dynamic)
+				 * list of currently exported commands. */
+    Tcl_Obj *unknownHandler;	/* Script prefix used to handle the case when
+				 * no match is found (according to the rule
+				 * defined by flag bit TCL_ENSEMBLE_PREFIX) or
+				 * NULL to use the default error-generating
+				 * behaviour. The script execution gets all
+				 * the arguments to the ensemble command
+				 * (including objv[0]) and will have the
+				 * results passed directly back to the caller
+				 * (including the error code) unless the code
+				 * is TCL_CONTINUE in which case the
+				 * subcommand will be reparsed by the ensemble
+				 * core, presumably because the ensemble
+				 * itself has been updated. */
+    Tcl_Obj *parameterList;	/* List of ensemble parameter names. */
+    int numParameters;		/* Cached number of parameters. This is either
+				 * 0 (if the parameterList field is NULL) or
+				 * the length of the list in the parameterList
+				 * field. */
+} EnsembleConfig;
+
+/*
+ * Various bits for the EnsembleConfig.flags field.
+ */
+
+#define ENSEMBLE_DEAD	0x1	/* Flag value to say that the ensemble is dead
+				 * and on its way out. */
+#define ENSEMBLE_COMPILE 0x4	/* Flag to enable bytecode compilation of an
+				 * ensemble. */
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to variables. These are used primarily in tclVar.c
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The following structure defines a variable trace, which is used to invoke a
+ * specific C procedure whenever certain operations are performed on a
+ * variable.
+ */
+
+typedef struct VarTrace {
+    Tcl_VarTraceProc *traceProc;/* Procedure to call when operations given by
+				 * flags are performed on variable. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    int flags;			/* What events the trace procedure is
+				 * interested in: OR-ed combination of
+				 * TCL_TRACE_READS, TCL_TRACE_WRITES,
+				 * TCL_TRACE_UNSETS and TCL_TRACE_ARRAY. */
+    struct VarTrace *nextPtr;	/* Next in list of traces associated with a
+				 * particular variable. */
+} VarTrace;
+
+/*
+ * The following structure defines a command trace, which is used to invoke a
+ * specific C procedure whenever certain operations are performed on a
+ * command.
+ */
+
+typedef struct CommandTrace {
+    Tcl_CommandTraceProc *traceProc;
+				/* Procedure to call when operations given by
+				 * flags are performed on command. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    int flags;			/* What events the trace procedure is
+				 * interested in: OR-ed combination of
+				 * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
+    struct CommandTrace *nextPtr;
+				/* Next in list of traces associated with a
+				 * particular command. */
+    int refCount;		/* Used to ensure this structure is not
+				 * deleted too early. Keeps track of how many
+				 * pieces of code have a pointer to this
+				 * structure. */
+} CommandTrace;
+
+/*
+ * When a command trace is active (i.e. its associated procedure is executing)
+ * one of the following structures is linked into a list associated with the
+ * command's interpreter. The information in the structure is needed in order
+ * for Tcl to behave reasonably if traces are deleted while traces are active.
+ */
+
+typedef struct ActiveCommandTrace {
+    struct Command *cmdPtr;	/* Command that's being traced. */
+    struct ActiveCommandTrace *nextPtr;
+				/* Next in list of all active command traces
+				 * for the interpreter, or NULL if no more. */
+    CommandTrace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+    int reverseScan;		/* Boolean set true when traces are scanning
+				 * in reverse order. */
+} ActiveCommandTrace;
+
+/*
+ * When a variable trace is active (i.e. its associated procedure is
+ * executing) one of the following structures is linked into a list associated
+ * with the variable's interpreter. The information in the structure is needed
+ * in order for Tcl to behave reasonably if traces are deleted while traces
+ * are active.
+ */
+
+typedef struct ActiveVarTrace {
+    struct Var *varPtr;		/* Variable that's being traced. */
+    struct ActiveVarTrace *nextPtr;
+				/* Next in list of all active variable traces
+				 * for the interpreter, or NULL if no more. */
+    VarTrace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+} ActiveVarTrace;
+
+/*
+ * The following structure describes an enumerative search in progress on an
+ * array variable; this are invoked with options to the "array" command.
+ */
+
+typedef struct ArraySearch {
+    int id;			/* Integer id used to distinguish among
+				 * multiple concurrent searches for the same
+				 * array. */
+    struct Var *varPtr;		/* Pointer to array variable that's being
+				 * searched. */
+    Tcl_HashSearch search;	/* Info kept by the hash module about progress
+				 * through the array. */
+    Tcl_HashEntry *nextEntry;	/* Non-null means this is the next element to
+				 * be enumerated (it's leftover from the
+				 * Tcl_FirstHashEntry call or from an "array
+				 * anymore" command). NULL means must call
+				 * Tcl_NextHashEntry to get value to
+				 * return. */
+    struct ArraySearch *nextPtr;/* Next in list of all active searches for
+				 * this variable, or NULL if this is the last
+				 * one. */
+} ArraySearch;
+
+/*
+ * The structure below defines a variable, which associates a string name with
+ * a Tcl_Obj value. These structures are kept in procedure call frames (for
+ * local variables recognized by the compiler) or in the heap (for global
+ * variables and any variable not known to the compiler). For each Var
+ * structure in the heap, a hash table entry holds the variable name and a
+ * pointer to the Var structure.
+ */
+
+typedef struct Var {
+    int flags;			/* Miscellaneous bits of information about
+				 * variable. See below for definitions. */
+    union {
+	Tcl_Obj *objPtr;	/* The variable's object value. Used for
+				 * scalar variables and array elements. */
+	TclVarHashTable *tablePtr;/* For array variables, this points to
+				 * information about the hash table used to
+				 * implement the associative array. Points to
+				 * ckalloc-ed data. */
+	struct Var *linkPtr;	/* If this is a global variable being referred
+				 * to in a procedure, or a variable created by
+				 * "upvar", this field points to the
+				 * referenced variable's Var struct. */
+    } value;
+} Var;
+
+typedef struct VarInHash {
+    Var var;
+    int refCount;		/* Counts number of active uses of this
+				 * variable: 1 for the entry in the hash
+				 * table, 1 for each additional variable whose
+				 * linkPtr points here, 1 for each nested
+				 * trace active on variable, and 1 if the
+				 * variable is a namespace variable. This
+				 * record can't be deleted until refCount
+				 * becomes 0. */
+    Tcl_HashEntry entry;	/* The hash table entry that refers to this
+				 * variable. This is used to find the name of
+				 * the variable and to delete it from its
+				 * hashtable if it is no longer needed. It
+				 * also holds the variable's name. */
+} VarInHash;
+
+/*
+ * Flag bits for variables. The first two (VAR_ARRAY and VAR_LINK) are
+ * mutually exclusive and give the "type" of the variable. If none is set,
+ * this is a scalar variable.
+ *
+ * VAR_ARRAY -			1 means this is an array variable rather than
+ *				a scalar variable or link. The "tablePtr"
+ *				field points to the array's hashtable for its
+ *				elements.
+ * VAR_LINK -			1 means this Var structure contains a pointer
+ *				to another Var structure that either has the
+ *				real value or is itself another VAR_LINK
+ *				pointer. Variables like this come about
+ *				through "upvar" and "global" commands, or
+ *				through references to variables in enclosing
+ *				namespaces.
+ *
+ * Flags that indicate the type and status of storage; none is set for
+ * compiled local variables (Var structs).
+ *
+ * VAR_IN_HASHTABLE -		1 means this variable is in a hashtable and
+ *				the Var structure is malloced. 0 if it is a
+ *				local variable that was assigned a slot in a
+ *				procedure frame by the compiler so the Var
+ *				storage is part of the call frame.
+ * VAR_DEAD_HASH		1 means that this var's entry in the hashtable
+ *				has already been deleted.
+ * VAR_ARRAY_ELEMENT -		1 means that this variable is an array
+ *				element, so it is not legal for it to be an
+ *				array itself (the VAR_ARRAY flag had better
+ *				not be set).
+ * VAR_NAMESPACE_VAR -		1 means that this variable was declared as a
+ *				namespace variable. This flag ensures it
+ *				persists until its namespace is destroyed or
+ *				until the variable is unset; it will persist
+ *				even if it has not been initialized and is
+ *				marked undefined. The variable's refCount is
+ *				incremented to reflect the "reference" from
+ *				its namespace.
+ *
+ * Flag values relating to the variable's trace and search status.
+ *
+ * VAR_TRACED_READ
+ * VAR_TRACED_WRITE
+ * VAR_TRACED_UNSET
+ * VAR_TRACED_ARRAY
+ * VAR_TRACE_ACTIVE -		1 means that trace processing is currently
+ *				underway for a read or write access, so new
+ *				read or write accesses should not cause trace
+ *				procedures to be called and the variable can't
+ *				be deleted.
+ * VAR_SEARCH_ACTIVE
+ *
+ * The following additional flags are used with the CompiledLocal type defined
+ * below:
+ *
+ * VAR_ARGUMENT -		1 means that this variable holds a procedure
+ *				argument.
+ * VAR_TEMPORARY -		1 if the local variable is an anonymous
+ *				temporary variable. Temporaries have a NULL
+ *				name.
+ * VAR_RESOLVED -		1 if name resolution has been done for this
+ *				variable.
+ * VAR_IS_ARGS			1 if this variable is the last argument and is
+ *				named "args".
+ */
+
+/*
+ * FLAGS RENUMBERED: everything breaks already, make things simpler.
+ *
+ * IMPORTANT: skip the values 0x10, 0x20, 0x40, 0x800 corresponding to
+ * TCL_TRACE_(READS/WRITES/UNSETS/ARRAY): makes code simpler in tclTrace.c
+ *
+ * Keep the flag values for VAR_ARGUMENT and VAR_TEMPORARY so that old values
+ * in precompiled scripts keep working.
+ */
+
+/* Type of value (0 is scalar) */
+#define VAR_ARRAY		0x1
+#define VAR_LINK		0x2
+
+/* Type of storage (0 is compiled local) */
+#define VAR_IN_HASHTABLE	0x4
+#define VAR_DEAD_HASH		0x8
+#define VAR_ARRAY_ELEMENT	0x1000
+#define VAR_NAMESPACE_VAR	0x80	/* KEEP OLD VALUE for Itcl */
+
+#define VAR_ALL_HASH \
+	(VAR_IN_HASHTABLE|VAR_DEAD_HASH|VAR_NAMESPACE_VAR|VAR_ARRAY_ELEMENT)
+
+/* Trace and search state. */
+
+#define VAR_TRACED_READ		0x10	/* TCL_TRACE_READS */
+#define VAR_TRACED_WRITE	0x20	/* TCL_TRACE_WRITES */
+#define VAR_TRACED_UNSET	0x40	/* TCL_TRACE_UNSETS */
+#define VAR_TRACED_ARRAY	0x800	/* TCL_TRACE_ARRAY */
+#define VAR_TRACE_ACTIVE	0x2000
+#define VAR_SEARCH_ACTIVE	0x4000
+#define VAR_ALL_TRACES \
+	(VAR_TRACED_READ|VAR_TRACED_WRITE|VAR_TRACED_ARRAY|VAR_TRACED_UNSET)
+
+/* Special handling on initialisation (only CompiledLocal). */
+#define VAR_ARGUMENT		0x100	/* KEEP OLD VALUE! See tclProc.c */
+#define VAR_TEMPORARY		0x200	/* KEEP OLD VALUE! See tclProc.c */
+#define VAR_IS_ARGS		0x400
+#define VAR_RESOLVED		0x8000
+
+/*
+ * Macros to ensure that various flag bits are set properly for variables.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclSetVarScalar(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarArray(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarLink(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarArrayElement(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarUndefined(Var *varPtr);
+ * MODULE_SCOPE void	TclClearVarUndefined(Var *varPtr);
+ */
+
+#define TclSetVarScalar(varPtr) \
+    (varPtr)->flags &= ~(VAR_ARRAY|VAR_LINK)
+
+#define TclSetVarArray(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_LINK) | VAR_ARRAY
+
+#define TclSetVarLink(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_LINK
+
+#define TclSetVarArrayElement(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_ARRAY_ELEMENT
+
+#define TclSetVarUndefined(varPtr) \
+    (varPtr)->flags &= ~(VAR_ARRAY|VAR_LINK);\
+    (varPtr)->value.objPtr = NULL
+
+#define TclClearVarUndefined(varPtr)
+
+#define TclSetVarTraceActive(varPtr) \
+    (varPtr)->flags |= VAR_TRACE_ACTIVE
+
+#define TclClearVarTraceActive(varPtr) \
+    (varPtr)->flags &= ~VAR_TRACE_ACTIVE
+
+#define TclSetVarNamespaceVar(varPtr) \
+    if (!TclIsVarNamespaceVar(varPtr)) {\
+	(varPtr)->flags |= VAR_NAMESPACE_VAR;\
+	if (TclIsVarInHash(varPtr)) {\
+	    ((VarInHash *)(varPtr))->refCount++;\
+	}\
+    }
+
+#define TclClearVarNamespaceVar(varPtr) \
+    if (TclIsVarNamespaceVar(varPtr)) {\
+	(varPtr)->flags &= ~VAR_NAMESPACE_VAR;\
+	if (TclIsVarInHash(varPtr)) {\
+	    ((VarInHash *)(varPtr))->refCount--;\
+	}\
+    }
+
+/*
+ * Macros to read various flag bits of variables.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE int	TclIsVarScalar(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarLink(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArray(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarUndefined(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArrayElement(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarTemporary(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArgument(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarResolved(Var *varPtr);
+ */
+
+#define TclIsVarScalar(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK))
+
+#define TclIsVarLink(varPtr) \
+    ((varPtr)->flags & VAR_LINK)
+
+#define TclIsVarArray(varPtr) \
+    ((varPtr)->flags & VAR_ARRAY)
+
+#define TclIsVarUndefined(varPtr) \
+    ((varPtr)->value.objPtr == NULL)
+
+#define TclIsVarArrayElement(varPtr) \
+    ((varPtr)->flags & VAR_ARRAY_ELEMENT)
+
+#define TclIsVarNamespaceVar(varPtr) \
+    ((varPtr)->flags & VAR_NAMESPACE_VAR)
+
+#define TclIsVarTemporary(varPtr) \
+    ((varPtr)->flags & VAR_TEMPORARY)
+
+#define TclIsVarArgument(varPtr) \
+    ((varPtr)->flags & VAR_ARGUMENT)
+
+#define TclIsVarResolved(varPtr) \
+    ((varPtr)->flags & VAR_RESOLVED)
+
+#define TclIsVarTraceActive(varPtr) \
+    ((varPtr)->flags & VAR_TRACE_ACTIVE)
+
+#define TclIsVarTraced(varPtr) \
+    ((varPtr)->flags & VAR_ALL_TRACES)
+
+#define TclIsVarInHash(varPtr) \
+    ((varPtr)->flags & VAR_IN_HASHTABLE)
+
+#define TclIsVarDeadHash(varPtr) \
+    ((varPtr)->flags & VAR_DEAD_HASH)
+
+#define TclGetVarNsPtr(varPtr) \
+    (TclIsVarInHash(varPtr) \
+	? ((TclVarHashTable *) ((((VarInHash *) (varPtr))->entry.tablePtr)))->nsPtr \
+	: NULL)
+
+#define VarHashRefCount(varPtr) \
+    ((VarInHash *) (varPtr))->refCount
+
+/*
+ * Macros for direct variable access by TEBC.
+ */
+
+#define TclIsVarDirectReadable(varPtr) \
+    (   !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ)) \
+    &&  (varPtr)->value.objPtr)
+
+#define TclIsVarDirectWritable(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_WRITE|VAR_DEAD_HASH))
+
+#define TclIsVarDirectUnsettable(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ|VAR_TRACED_WRITE|VAR_TRACED_UNSET|VAR_DEAD_HASH))
+
+#define TclIsVarDirectModifyable(varPtr) \
+    (   !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ|VAR_TRACED_WRITE)) \
+    &&  (varPtr)->value.objPtr)
+
+#define TclIsVarDirectReadable2(varPtr, arrayPtr) \
+    (TclIsVarDirectReadable(varPtr) &&\
+	(!(arrayPtr) || !((arrayPtr)->flags & VAR_TRACED_READ)))
+
+#define TclIsVarDirectWritable2(varPtr, arrayPtr) \
+    (TclIsVarDirectWritable(varPtr) &&\
+	(!(arrayPtr) || !((arrayPtr)->flags & VAR_TRACED_WRITE)))
+
+#define TclIsVarDirectModifyable2(varPtr, arrayPtr) \
+    (TclIsVarDirectModifyable(varPtr) &&\
+	(!(arrayPtr) || !((arrayPtr)->flags & (VAR_TRACED_READ|VAR_TRACED_WRITE))))
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to procedures. These are used primarily in
+ * tclProc.c, tclCompile.c, and tclExecute.c.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * Forward declaration to prevent an error when the forward reference to
+ * Command is encountered in the Proc and ImportRef types declared below.
+ */
+
+struct Command;
+
+/*
+ * The variable-length structure below describes a local variable of a
+ * procedure that was recognized by the compiler. These variables have a name,
+ * an element in the array of compiler-assigned local variables in the
+ * procedure's call frame, and various other items of information. If the
+ * local variable is a formal argument, it may also have a default value. The
+ * compiler can't recognize local variables whose names are expressions (these
+ * names are only known at runtime when the expressions are evaluated) or
+ * local variables that are created as a result of an "upvar" or "uplevel"
+ * command. These other local variables are kept separately in a hash table in
+ * the call frame.
+ */
+
+typedef struct CompiledLocal {
+    struct CompiledLocal *nextPtr;
+				/* Next compiler-recognized local variable for
+				 * this procedure, or NULL if this is the last
+				 * local. */
+    int nameLength;		/* The number of characters in local
+				 * variable's name. Used to speed up variable
+				 * lookups. */
+    int frameIndex;		/* Index in the array of compiler-assigned
+				 * variables in the procedure call frame. */
+    int flags;			/* Flag bits for the local variable. Same as
+				 * the flags for the Var structure above,
+				 * although only VAR_ARGUMENT, VAR_TEMPORARY,
+				 * and VAR_RESOLVED make sense. */
+    Tcl_Obj *defValuePtr;	/* Pointer to the default value of an
+				 * argument, if any. NULL if not an argument
+				 * or, if an argument, no default value. */
+    Tcl_ResolvedVarInfo *resolveInfo;
+				/* Customized variable resolution info
+				 * supplied by the Tcl_ResolveCompiledVarProc
+				 * associated with a namespace. Each variable
+				 * is marked by a unique ClientData tag during
+				 * compilation, and that same tag is used to
+				 * find the variable at runtime. */
+    char name[1];		/* Name of the local variable starts here. If
+				 * the name is NULL, this will just be '\0'.
+				 * The actual size of this field will be large
+				 * enough to hold the name. MUST BE THE LAST
+				 * FIELD IN THE STRUCTURE! */
+} CompiledLocal;
+
+/*
+ * The structure below defines a command procedure, which consists of a
+ * collection of Tcl commands plus information about arguments and other local
+ * variables recognized at compile time.
+ */
+
+typedef struct Proc {
+    struct Interp *iPtr;	/* Interpreter for which this command is
+				 * defined. */
+    int refCount;		/* Reference count: 1 if still present in
+				 * command table plus 1 for each call to the
+				 * procedure that is currently active. This
+				 * structure can be freed when refCount
+				 * becomes zero. */
+    struct Command *cmdPtr;	/* Points to the Command structure for this
+				 * procedure. This is used to get the
+				 * namespace in which to execute the
+				 * procedure. */
+    Tcl_Obj *bodyPtr;		/* Points to the ByteCode object for
+				 * procedure's body command. */
+    int numArgs;		/* Number of formal parameters. */
+    int numCompiledLocals;	/* Count of local variables recognized by the
+				 * compiler including arguments and
+				 * temporaries. */
+    CompiledLocal *firstLocalPtr;
+				/* Pointer to first of the procedure's
+				 * compiler-allocated local variables, or NULL
+				 * if none. The first numArgs entries in this
+				 * list describe the procedure's formal
+				 * arguments. */
+    CompiledLocal *lastLocalPtr;/* Pointer to the last allocated local
+				 * variable or NULL if none. This has frame
+				 * index (numCompiledLocals-1). */
+} Proc;
+
+/*
+ * The type of functions called to process errors found during the execution
+ * of a procedure (or lambda term or ...).
+ */
+
+typedef void (ProcErrorProc)(Tcl_Interp *interp, Tcl_Obj *procNameObj);
+
+/*
+ * The structure below defines a command trace. This is used to allow Tcl
+ * clients to find out whenever a command is about to be executed.
+ */
+
+typedef struct Trace {
+    int level;			/* Only trace commands at nesting level less
+				 * than or equal to this. */
+    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
+    ClientData clientData;	/* Arbitrary value to pass to proc. */
+    struct Trace *nextPtr;	/* Next in list of traces for this interp. */
+    int flags;			/* Flags governing the trace - see
+				 * Tcl_CreateObjTrace for details. */
+    Tcl_CmdObjTraceDeleteProc *delProc;
+				/* Procedure to call when trace is deleted. */
+} Trace;
+
+/*
+ * When an interpreter trace is active (i.e. its associated procedure is
+ * executing), one of the following structures is linked into a list
+ * associated with the interpreter. The information in the structure is needed
+ * in order for Tcl to behave reasonably if traces are deleted while traces
+ * are active.
+ */
+
+typedef struct ActiveInterpTrace {
+    struct ActiveInterpTrace *nextPtr;
+				/* Next in list of all active command traces
+				 * for the interpreter, or NULL if no more. */
+    Trace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+    int reverseScan;		/* Boolean set true when traces are scanning
+				 * in reverse order. */
+} ActiveInterpTrace;
+
+/*
+ * Flag values designating types of execution traces. See tclTrace.c for
+ * related flag values.
+ *
+ * TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
+ * 				- passed to Tcl_CreateObjTrace to set up
+ *				  "enterstep" traces.
+ * TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
+ * 				- passed to Tcl_CreateObjTrace to set up
+ *				  "leavestep" traces.
+ */
+
+#define TCL_TRACE_ENTER_EXEC	1
+#define TCL_TRACE_LEAVE_EXEC	2
+
+/*
+ * The structure below defines an entry in the assocData hash table which is
+ * associated with an interpreter. The entry contains a pointer to a function
+ * to call when the interpreter is deleted, and a pointer to a user-defined
+ * piece of data.
+ */
+
+typedef struct AssocData {
+    Tcl_InterpDeleteProc *proc;	/* Proc to call when deleting. */
+    ClientData clientData;	/* Value to pass to proc. */
+} AssocData;
+
+/*
+ * The structure below defines a call frame. A call frame defines a naming
+ * context for a procedure call: its local naming scope (for local variables)
+ * and its global naming scope (a namespace, perhaps the global :: namespace).
+ * A call frame can also define the naming context for a namespace eval or
+ * namespace inscope command: the namespace in which the command's code should
+ * execute. The Tcl_CallFrame structures exist only while procedures or
+ * namespace eval/inscope's are being executed, and provide a kind of Tcl call
+ * stack.
+ *
+ * WARNING!! The structure definition must be kept consistent with the
+ * Tcl_CallFrame structure in tcl.h. If you change one, change the other.
+ */
+
+/*
+ * Will be grown to contain: pointers to the varnames (allocated at the end),
+ * plus the init values for each variable (suitable to be memcopied on init)
+ */
+
+typedef struct LocalCache {
+    int refCount;
+    int numVars;
+    Tcl_Obj *varName0;
+} LocalCache;
+
+#define localName(framePtr, i) \
+    ((&((framePtr)->localCachePtr->varName0))[(i)])
+
+MODULE_SCOPE void	TclFreeLocalCache(Tcl_Interp *interp,
+			    LocalCache *localCachePtr);
+
+typedef struct CallFrame {
+    Namespace *nsPtr;		/* Points to the namespace used to resolve
+				 * commands and global variables. */
+    int isProcCallFrame;	/* If 0, the frame was pushed to execute a
+				 * namespace command and var references are
+				 * treated as references to namespace vars;
+				 * varTablePtr and compiledLocals are ignored.
+				 * If FRAME_IS_PROC is set, the frame was
+				 * pushed to execute a Tcl procedure and may
+				 * have local vars. */
+    int objc;			/* This and objv below describe the arguments
+				 * for this procedure call. */
+    Tcl_Obj *const *objv;	/* Array of argument objects. */
+    struct CallFrame *callerPtr;
+				/* Value of interp->framePtr when this
+				 * procedure was invoked (i.e. next higher in
+				 * stack of all active procedures). */
+    struct CallFrame *callerVarPtr;
+				/* Value of interp->varFramePtr when this
+				 * procedure was invoked (i.e. determines
+				 * variable scoping within caller). Same as
+				 * callerPtr unless an "uplevel" command or
+				 * something equivalent was active in the
+				 * caller). */
+    int level;			/* Level of this procedure, for "uplevel"
+				 * purposes (i.e. corresponds to nesting of
+				 * callerVarPtr's, not callerPtr's). 1 for
+				 * outermost procedure, 0 for top-level. */
+    Proc *procPtr;		/* Points to the structure defining the called
+				 * procedure. Used to get information such as
+				 * the number of compiled local variables
+				 * (local variables assigned entries ["slots"]
+				 * in the compiledLocals array below). */
+    TclVarHashTable *varTablePtr;
+				/* Hash table containing local variables not
+				 * recognized by the compiler, or created at
+				 * execution time through, e.g., upvar.
+				 * Initially NULL and created if needed. */
+    int numCompiledLocals;	/* Count of local variables recognized by the
+				 * compiler including arguments. */
+    Var *compiledLocals;	/* Points to the array of local variables
+				 * recognized by the compiler. The compiler
+				 * emits code that refers to these variables
+				 * using an index into this array. */
+    ClientData clientData;	/* Pointer to some context that is used by
+				 * object systems. The meaning of the contents
+				 * of this field is defined by the code that
+				 * sets it, and it should only ever be set by
+				 * the code that is pushing the frame. In that
+				 * case, the code that sets it should also
+				 * have some means of discovering what the
+				 * meaning of the value is, which we do not
+				 * specify. */
+    LocalCache *localCachePtr;
+    struct NRE_callback *tailcallPtr;
+				/* NULL if no tailcall is scheduled */
+} CallFrame;
+
+#define FRAME_IS_PROC	0x1
+#define FRAME_IS_LAMBDA 0x2
+#define FRAME_IS_METHOD	0x4	/* The frame is a method body, and the frame's
+				 * clientData field contains a CallContext
+				 * reference. Part of TIP#257. */
+#define FRAME_IS_OO_DEFINE 0x8	/* The frame is part of the inside workings of
+				 * the [oo::define] command; the clientData
+				 * field contains an Object reference that has
+				 * been confirmed to refer to a class. Part of
+				 * TIP#257. */
+
+/*
+ * TIP #280
+ * The structure below defines a command frame. A command frame provides
+ * location information for all commands executing a tcl script (source, eval,
+ * uplevel, procedure bodies, ...). The runtime structure essentially contains
+ * the stack trace as it would be if the currently executing command were to
+ * throw an error.
+ *
+ * For commands where it makes sense it refers to the associated CallFrame as
+ * well.
+ *
+ * The structures are chained in a single list, with the top of the stack
+ * anchored in the Interp structure.
+ *
+ * Instances can be allocated on the C stack, or the heap, the former making
+ * cleanup a bit simpler.
+ */
+
+typedef struct CmdFrame {
+    /*
+     * General data. Always available.
+     */
+
+    int type;			/* Values see below. */
+    int level;			/* Number of frames in stack, prevent O(n)
+				 * scan of list. */
+    int *line;			/* Lines the words of the command start on. */
+    int nline;
+    CallFrame *framePtr;	/* Procedure activation record, may be
+				 * NULL. */
+    struct CmdFrame *nextPtr;	/* Link to calling frame. */
+    /*
+     * Data needed for Eval vs TEBC
+     *
+     * EXECUTION CONTEXTS and usage of CmdFrame
+     *
+     * Field	  TEBC		  EvalEx	  EvalObjEx
+     * =======	  ====		  ======	  =========
+     * level	  yes		  yes		  yes
+     * type	  BC/PREBC	  SRC/EVAL	  EVAL_LIST
+     * line0	  yes		  yes		  yes
+     * framePtr	  yes		  yes		  yes
+     * =======	  ====		  ======	  =========
+     *
+     * =======	  ====		  ======	  ========= union data
+     * line1	  -		  yes		  -
+     * line3	  -		  yes		  -
+     * path	  -		  yes		  -
+     * -------	  ----		  ------	  ---------
+     * codePtr	  yes		  -		  -
+     * pc	  yes		  -		  -
+     * =======	  ====		  ======	  =========
+     *
+     * =======	  ====		  ======	  ========= | union cmd
+     * listPtr	  -		  -		  yes	    |
+     * -------	  ----		  ------	  --------- |
+     * cmd	  yes		  yes		  -	    |
+     * cmdlen	  yes		  yes		  -	    |
+     * -------	  ----		  ------	  --------- |
+     */
+
+    union {
+	struct {
+	    Tcl_Obj *path;	/* Path of the sourced file the command is
+				 * in. */
+	} eval;
+	struct {
+	    const void *codePtr;/* Byte code currently executed... */
+	    const char *pc;	/* ... and instruction pointer. */
+	} tebc;
+    } data;
+    union {
+	struct {
+	    const char *cmd;	/* The executed command, if possible... */
+	    int len;		/* ... and its length. */
+	} str;
+	Tcl_Obj *listPtr;	/* Tcl_EvalObjEx, cmd list. */
+    } cmd;
+    int numLevels;		/* Value of interp's numLevels when the frame
+				 * was pushed. */
+    const struct CFWordBC *litarg;
+				/* Link to set of literal arguments which have
+				 * ben pushed on the lineLABCPtr stack by
+				 * TclArgumentBCEnter(). These will be removed
+				 * by TclArgumentBCRelease. */
+} CmdFrame;
+
+typedef struct CFWord {
+    CmdFrame *framePtr;		/* CmdFrame to access. */
+    int word;			/* Index of the word in the command. */
+    int refCount;		/* Number of times the word is on the
+				 * stack. */
+} CFWord;
+
+typedef struct CFWordBC {
+    CmdFrame *framePtr;		/* CmdFrame to access. */
+    int pc;			/* Instruction pointer of a command in
+				 * ExtCmdLoc.loc[.] */
+    int word;			/* Index of word in
+				 * ExtCmdLoc.loc[cmd]->line[.] */
+    struct CFWordBC *prevPtr;	/* Previous entry in stack for same Tcl_Obj. */
+    struct CFWordBC *nextPtr;	/* Next entry for same command call. See
+				 * CmdFrame litarg field for the list start. */
+    Tcl_Obj *obj;		/* Back reference to hashtable key */
+} CFWordBC;
+
+/*
+ * Structure to record the locations of invisible continuation lines in
+ * literal scripts, as character offset from the beginning of the script. Both
+ * compiler and direct evaluator use this information to adjust their line
+ * counters when tracking through the script, because when it is invoked the
+ * continuation line marker as a whole has been removed already, meaning that
+ * the \n which was part of it is gone as well, breaking regular line
+ * tracking.
+ *
+ * These structures are allocated and filled by both the function
+ * TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
+ * file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
+ * file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
+ * TclCompileScript(), both found in the file "tclCompile.c". Their memory is
+ * released by the function TclFreeObj(), in the file "tclObj.c", and also by
+ * the function TclThreadFinalizeObjects(), in the same file.
+ */
+
+#define CLL_END		(-1)
+
+typedef struct ContLineLoc {
+    int num;			/* Number of entries in loc, not counting the
+				 * final -1 marker entry. */
+    int loc[1];			/* Table of locations, as character offsets.
+				 * The table is allocated as part of the
+				 * structure, extending behind the nominal end
+				 * of the structure. An entry containing the
+				 * value -1 is put after the last location, as
+				 * end-marker/sentinel. */
+} ContLineLoc;
+
+/*
+ * The following macros define the allowed values for the type field of the
+ * CmdFrame structure above. Some of the values occur only in the extended
+ * location data referenced via the 'baseLocPtr'.
+ *
+ * TCL_LOCATION_EVAL	  : Frame is for a script evaluated by EvalEx.
+ * TCL_LOCATION_EVAL_LIST : Frame is for a script evaluated by the list
+ *			    optimization path of EvalObjEx.
+ * TCL_LOCATION_BC	  : Frame is for bytecode.
+ * TCL_LOCATION_PREBC	  : Frame is for precompiled bytecode.
+ * TCL_LOCATION_SOURCE	  : Frame is for a script evaluated by EvalEx, from a
+ *			    sourced file.
+ * TCL_LOCATION_PROC	  : Frame is for bytecode of a procedure.
+ *
+ * A TCL_LOCATION_BC type in a frame can be overridden by _SOURCE and _PROC
+ * types, per the context of the byte code in execution.
+ */
+
+#define TCL_LOCATION_EVAL	(0) /* Location in a dynamic eval script. */
+#define TCL_LOCATION_EVAL_LIST	(1) /* Location in a dynamic eval script,
+				     * list-path. */
+#define TCL_LOCATION_BC		(2) /* Location in byte code. */
+#define TCL_LOCATION_PREBC	(3) /* Location in precompiled byte code, no
+				     * location. */
+#define TCL_LOCATION_SOURCE	(4) /* Location in a file. */
+#define TCL_LOCATION_PROC	(5) /* Location in a dynamic proc. */
+#define TCL_LOCATION_LAST	(6) /* Number of values in the enum. */
+
+/*
+ * Structure passed to describe procedure-like "procedures" that are not
+ * procedures (e.g. a lambda) so that their details can be reported correctly
+ * by [info frame]. Contains a sub-structure for each extra field.
+ */
+
+typedef Tcl_Obj * (GetFrameInfoValueProc)(ClientData clientData);
+typedef struct {
+    const char *name;		/* Name of this field. */
+    GetFrameInfoValueProc *proc;	/* Function to generate a Tcl_Obj* from the
+				 * clientData, or just use the clientData
+				 * directly (after casting) if NULL. */
+    ClientData clientData;	/* Context for above function, or Tcl_Obj* if
+				 * proc field is NULL. */
+} ExtraFrameInfoField;
+typedef struct {
+    int length;			/* Length of array. */
+    ExtraFrameInfoField fields[2];
+				/* Really as long as necessary, but this is
+				 * long enough for nearly anything. */
+} ExtraFrameInfo;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures and procedures related to TclHandles, which are a very
+ * lightweight method of preserving enough information to determine if an
+ * arbitrary malloc'd block has been deleted.
+ *----------------------------------------------------------------
+ */
+
+typedef void **TclHandle;
+
+/*
+ *----------------------------------------------------------------
+ * Experimental flag value passed to Tcl_GetRegExpFromObj. Intended for use
+ * only by Expect. It will probably go away in a later release.
+ *----------------------------------------------------------------
+ */
+
+#define TCL_REG_BOSONLY 002000	/* Prepend \A to pattern so it only matches at
+				 * the beginning of the string. */
+
+/*
+ * These are a thin layer over TclpThreadKeyDataGet and TclpThreadKeyDataSet
+ * when threads are used, or an emulation if there are no threads. These are
+ * really internal and Tcl clients should use Tcl_GetThreadData.
+ */
+
+MODULE_SCOPE void *	TclThreadDataKeyGet(Tcl_ThreadDataKey *keyPtr);
+MODULE_SCOPE void	TclThreadDataKeySet(Tcl_ThreadDataKey *keyPtr,
+			    void *data);
+
+/*
+ * This is a convenience macro used to initialize a thread local storage ptr.
+ */
+
+#define TCL_TSD_INIT(keyPtr) \
+  (ThreadSpecificData *)Tcl_GetThreadData((keyPtr), sizeof(ThreadSpecificData))
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to bytecode compilation and execution. These are
+ * used primarily in tclCompile.c, tclExecute.c, and tclBasic.c.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * Forward declaration to prevent errors when the forward references to
+ * Tcl_Parse and CompileEnv are encountered in the procedure type CompileProc
+ * declared below.
+ */
+
+struct CompileEnv;
+
+/*
+ * The type of procedures called by the Tcl bytecode compiler to compile
+ * commands. Pointers to these procedures are kept in the Command structure
+ * describing each command. The integer value returned by a CompileProc must
+ * be one of the following:
+ *
+ * TCL_OK		Compilation completed normally.
+ * TCL_ERROR 		Compilation could not be completed. This can be just a
+ * 			judgment by the CompileProc that the command is too
+ * 			complex to compile effectively, or it can indicate
+ * 			that in the current state of the interp, the command
+ * 			would raise an error. The bytecode compiler will not
+ * 			do any error reporting at compiler time. Error
+ * 			reporting is deferred until the actual runtime,
+ * 			because by then changes in the interp state may allow
+ * 			the command to be successfully evaluated.
+ * TCL_OUT_LINE_COMPILE	A source-compatible alias for TCL_ERROR, kept for the
+ * 			sake of old code only.
+ */
+
+#define TCL_OUT_LINE_COMPILE	TCL_ERROR
+
+typedef int (CompileProc)(Tcl_Interp *interp, Tcl_Parse *parsePtr,
+	struct Command *cmdPtr, struct CompileEnv *compEnvPtr);
+
+/*
+ * The type of procedure called from the compilation hook point in
+ * SetByteCodeFromAny.
+ */
+
+typedef int (CompileHookProc)(Tcl_Interp *interp,
+	struct CompileEnv *compEnvPtr, ClientData clientData);
+
+/*
+ * The data structure for a (linked list of) execution stacks.
+ */
+
+typedef struct ExecStack {
+    struct ExecStack *prevPtr;
+    struct ExecStack *nextPtr;
+    Tcl_Obj **markerPtr;
+    Tcl_Obj **endPtr;
+    Tcl_Obj **tosPtr;
+    Tcl_Obj *stackWords[1];
+} ExecStack;
+
+/*
+ * The data structure defining the execution environment for ByteCode's.
+ * There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
+ * stack that holds command operands and results. The stack grows towards
+ * increasing addresses. The member stackPtr points to the stackItems of the
+ * currently active execution stack.
+ */
+
+typedef struct CorContext {
+    struct CallFrame *framePtr;
+    struct CallFrame *varFramePtr;
+    struct CmdFrame *cmdFramePtr;  /* See Interp.cmdFramePtr */
+    Tcl_HashTable *lineLABCPtr;    /* See Interp.lineLABCPtr */
+} CorContext;
+
+typedef struct CoroutineData {
+    struct Command *cmdPtr;	/* The command handle for the coroutine. */
+    struct ExecEnv *eePtr;	/* The special execution environment (stacks,
+				 * etc.) for the coroutine. */
+    struct ExecEnv *callerEEPtr;/* The execution environment for the caller of
+				 * the coroutine, which might be the
+				 * interpreter global environment or another
+				 * coroutine. */
+    CorContext caller;
+    CorContext running;
+    Tcl_HashTable *lineLABCPtr;    /* See Interp.lineLABCPtr */
+    void *stackLevel;
+    int auxNumLevels;		/* While the coroutine is running the
+				 * numLevels of the create/resume command is
+				 * stored here; for suspended coroutines it
+				 * holds the nesting numLevels at yield. */
+    int nargs;                  /* Number of args required for resuming this
+				 * coroutine; -2 means "0 or 1" (default), -1
+				 * means "any" */
+} CoroutineData;
+
+typedef struct ExecEnv {
+    ExecStack *execStackPtr;	/* Points to the first item in the evaluation
+				 * stack on the heap. */
+    Tcl_Obj *constants[2];	/* Pointers to constant "0" and "1" objs. */
+    struct Tcl_Interp *interp;
+    struct NRE_callback *callbackPtr;
+				/* Top callback in NRE's stack. */
+    struct CoroutineData *corPtr;
+    int rewind;
+} ExecEnv;
+
+#define COR_IS_SUSPENDED(corPtr) \
+    ((corPtr)->stackLevel == NULL)
+
+/*
+ * The definitions for the LiteralTable and LiteralEntry structures. Each
+ * interpreter contains a LiteralTable. It is used to reduce the storage
+ * needed for all the Tcl objects that hold the literals of scripts compiled
+ * by the interpreter. A literal's object is shared by all the ByteCodes that
+ * refer to the literal. Each distinct literal has one LiteralEntry entry in
+ * the LiteralTable. A literal table is a specialized hash table that is
+ * indexed by the literal's string representation, which may contain null
+ * characters.
+ *
+ * Note that we reduce the space needed for literals by sharing literal
+ * objects both within a ByteCode (each ByteCode contains a local
+ * LiteralTable) and across all an interpreter's ByteCodes (with the
+ * interpreter's global LiteralTable).
+ */
+
+typedef struct LiteralEntry {
+    struct LiteralEntry *nextPtr;
+				/* Points to next entry in this hash bucket or
+				 * NULL if end of chain. */
+    Tcl_Obj *objPtr;		/* Points to Tcl object that holds the
+				 * literal's bytes and length. */
+    int refCount;		/* If in an interpreter's global literal
+				 * table, the number of ByteCode structures
+				 * that share the literal object; the literal
+				 * entry can be freed when refCount drops to
+				 * 0. If in a local literal table, -1. */
+    Namespace *nsPtr;		/* Namespace in which this literal is used. We
+				 * try to avoid sharing literal non-FQ command
+				 * names among different namespaces to reduce
+				 * shimmering. */
+} LiteralEntry;
+
+typedef struct LiteralTable {
+    LiteralEntry **buckets;	/* Pointer to bucket array. Each element
+				 * points to first entry in bucket's hash
+				 * chain, or NULL. */
+    LiteralEntry *staticBuckets[TCL_SMALL_HASH_TABLE];
+				/* Bucket array used for small tables to avoid
+				 * mallocs and frees. */
+    int numBuckets;		/* Total number of buckets allocated at
+				 * **buckets. */
+    int numEntries;		/* Total number of entries present in
+				 * table. */
+    int rebuildSize;		/* Enlarge table when numEntries gets to be
+				 * this large. */
+    int mask;			/* Mask value used in hashing function. */
+} LiteralTable;
+
+/*
+ * The following structure defines for each Tcl interpreter various
+ * statistics-related information about the bytecode compiler and
+ * interpreter's operation in that interpreter.
+ */
+
+#ifdef TCL_COMPILE_STATS
+typedef struct ByteCodeStats {
+    long numExecutions;		/* Number of ByteCodes executed. */
+    long numCompilations;	/* Number of ByteCodes created. */
+    long numByteCodesFreed;	/* Number of ByteCodes destroyed. */
+    long instructionCount[256];	/* Number of times each instruction was
+				 * executed. */
+
+    double totalSrcBytes;	/* Total source bytes ever compiled. */
+    double totalByteCodeBytes;	/* Total bytes for all ByteCodes. */
+    double currentSrcBytes;	/* Src bytes for all current ByteCodes. */
+    double currentByteCodeBytes;/* Code bytes in all current ByteCodes. */
+
+    long srcCount[32];		/* Source size distribution: # of srcs of
+				 * size [2**(n-1)..2**n), n in [0..32). */
+    long byteCodeCount[32];	/* ByteCode size distribution. */
+    long lifetimeCount[32];	/* ByteCode lifetime distribution (ms). */
+
+    double currentInstBytes;	/* Instruction bytes-current ByteCodes. */
+    double currentLitBytes;	/* Current literal bytes. */
+    double currentExceptBytes;	/* Current exception table bytes. */
+    double currentAuxBytes;	/* Current auxiliary information bytes. */
+    double currentCmdMapBytes;	/* Current src<->code map bytes. */
+
+    long numLiteralsCreated;	/* Total literal objects ever compiled. */
+    double totalLitStringBytes;	/* Total string bytes in all literals. */
+    double currentLitStringBytes;
+				/* String bytes in current literals. */
+    long literalCount[32];	/* Distribution of literal string sizes. */
+} ByteCodeStats;
+#endif /* TCL_COMPILE_STATS */
+
+/*
+ * Structure used in implementation of those core ensembles which are
+ * partially compiled. Used as an array of these, with a terminating field
+ * whose 'name' is NULL.
+ */
+
+typedef struct {
+    const char *name;		/* The name of the subcommand. */
+    Tcl_ObjCmdProc *proc;	/* The implementation of the subcommand. */
+    CompileProc *compileProc;	/* The compiler for the subcommand. */
+    Tcl_ObjCmdProc *nreProc;	/* NRE implementation of this command. */
+    ClientData clientData;	/* Any clientData to give the command. */
+    int unsafe;			/* Whether this command is to be hidden by
+				 * default in a safe interpreter. */
+} EnsembleImplMap;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to commands.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * An imported command is created in an namespace when it imports a "real"
+ * command from another namespace. An imported command has a Command structure
+ * that points (via its ClientData value) to the "real" Command structure in
+ * the source namespace's command table. The real command records all the
+ * imported commands that refer to it in a list of ImportRef structures so
+ * that they can be deleted when the real command is deleted.
+ */
+
+typedef struct ImportRef {
+    struct Command *importedCmdPtr;
+				/* Points to the imported command created in
+				 * an importing namespace; this command
+				 * redirects its invocations to the "real"
+				 * command. */
+    struct ImportRef *nextPtr;	/* Next element on the linked list of imported
+				 * commands that refer to the "real" command.
+				 * The real command deletes these imported
+				 * commands on this list when it is
+				 * deleted. */
+} ImportRef;
+
+/*
+ * Data structure used as the ClientData of imported commands: commands
+ * created in an namespace when it imports a "real" command from another
+ * namespace.
+ */
+
+typedef struct ImportedCmdData {
+    struct Command *realCmdPtr;	/* "Real" command that this imported command
+				 * refers to. */
+    struct Command *selfPtr;	/* Pointer to this imported command. Needed
+				 * only when deleting it in order to remove it
+				 * from the real command's linked list of
+				 * imported commands that refer to it. */
+} ImportedCmdData;
+
+/*
+ * A Command structure exists for each command in a namespace. The Tcl_Command
+ * opaque type actually refers to these structures.
+ */
+
+typedef struct Command {
+    Tcl_HashEntry *hPtr;	/* Pointer to the hash table entry that refers
+				 * to this command. The hash table is either a
+				 * namespace's command table or an
+				 * interpreter's hidden command table. This
+				 * pointer is used to get a command's name
+				 * from its Tcl_Command handle. NULL means
+				 * that the hash table entry has been removed
+				 * already (this can happen if deleteProc
+				 * causes the command to be deleted or
+				 * recreated). */
+    Namespace *nsPtr;		/* Points to the namespace containing this
+				 * command. */
+    int refCount;		/* 1 if in command hashtable plus 1 for each
+				 * reference from a CmdName Tcl object
+				 * representing a command's name in a ByteCode
+				 * instruction sequence. This structure can be
+				 * freed when refCount becomes zero. */
+    int cmdEpoch;		/* Incremented to invalidate any references
+				 * that point to this command when it is
+				 * renamed, deleted, hidden, or exposed. */
+    CompileProc *compileProc;	/* Procedure called to compile command. NULL
+				 * if no compile proc exists for command. */
+    Tcl_ObjCmdProc *objProc;	/* Object-based command procedure. */
+    ClientData objClientData;	/* Arbitrary value passed to object proc. */
+    Tcl_CmdProc *proc;		/* String-based command procedure. */
+    ClientData clientData;	/* Arbitrary value passed to string proc. */
+    Tcl_CmdDeleteProc *deleteProc;
+				/* Procedure invoked when deleting command to,
+				 * e.g., free all client data. */
+    ClientData deleteData;	/* Arbitrary value passed to deleteProc. */
+    int flags;			/* Miscellaneous bits of information about
+				 * command. See below for definitions. */
+    ImportRef *importRefPtr;	/* List of each imported Command created in
+				 * another namespace when this command is
+				 * imported. These imported commands redirect
+				 * invocations back to this command. The list
+				 * is used to remove all those imported
+				 * commands when deleting this "real"
+				 * command. */
+    CommandTrace *tracePtr;	/* First in list of all traces set for this
+				 * command. */
+    Tcl_ObjCmdProc *nreProc;	/* NRE implementation of this command. */
+} Command;
+
+/*
+ * Flag bits for commands.
+ *
+ * CMD_IS_DELETED -		Means that the command is in the process of
+ *				being deleted (its deleteProc is currently
+ *				executing). Other attempts to delete the
+ *				command should be ignored.
+ * CMD_TRACE_ACTIVE -		1 means that trace processing is currently
+ *				underway for a rename/delete change. See the
+ *				two flags below for which is currently being
+ *				processed.
+ * CMD_HAS_EXEC_TRACES -	1 means that this command has at least one
+ *				execution trace (as opposed to simple
+ *				delete/rename traces) in its tracePtr list.
+ * TCL_TRACE_RENAME -		A rename trace is in progress. Further
+ *				recursive renames will not be traced.
+ * TCL_TRACE_DELETE -		A delete trace is in progress. Further
+ *				recursive deletes will not be traced.
+ * (these last two flags are defined in tcl.h)
+ */
+
+#define CMD_IS_DELETED		    0x1
+#define CMD_TRACE_ACTIVE	    0x2
+#define CMD_HAS_EXEC_TRACES	    0x4
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to name resolution procedures.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The interpreter keeps a linked list of name resolution schemes. The scheme
+ * for a namespace is consulted first, followed by the list of schemes in an
+ * interpreter, followed by the default name resolution in Tcl. Schemes are
+ * added/removed from the interpreter's list by calling Tcl_AddInterpResolver
+ * and Tcl_RemoveInterpResolver.
+ */
+
+typedef struct ResolverScheme {
+    char *name;			/* Name identifying this scheme. */
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* Procedure handling command name
+				 * resolution. */
+    Tcl_ResolveVarProc *varResProc;
+				/* Procedure handling variable name resolution
+				 * for variables that can only be handled at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* Procedure handling variable name resolution
+				 * at compile time. */
+
+    struct ResolverScheme *nextPtr;
+				/* Pointer to next record in linked list. */
+} ResolverScheme;
+
+/*
+ * Forward declaration of the TIP#143 limit handler structure.
+ */
+
+typedef struct LimitHandler LimitHandler;
+
+/*
+ * TIP #268.
+ * Values for the selection mode, i.e the package require preferences.
+ */
+
+enum PkgPreferOptions {
+    PKG_PREFER_LATEST, PKG_PREFER_STABLE
+};
+
+/*
+ *----------------------------------------------------------------
+ * This structure shadows the first few fields of the memory cache for the
+ * allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
+ * definition there.
+ * Some macros require knowledge of some fields in the struct in order to
+ * avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
+ * to the relevant fields is kept in the objCache field in struct Interp.
+ *----------------------------------------------------------------
+ */
+
+typedef struct AllocCache {
+    struct Cache *nextPtr;	/* Linked list of cache entries. */
+    Tcl_ThreadId owner;		/* Which thread's cache is this? */
+    Tcl_Obj *firstObjPtr;	/* List of free objects for thread. */
+    int numObjects;		/* Number of objects for thread. */
+} AllocCache;
+
+/*
+ *----------------------------------------------------------------
+ * This structure defines an interpreter, which is a collection of commands
+ * plus other state information related to interpreting commands, such as
+ * variable storage. Primary responsibility for this data structure is in
+ * tclBasic.c, but almost every Tcl source file uses something in here.
+ *----------------------------------------------------------------
+ */
+
+typedef struct Interp {
+    /*
+     * Note: the first three fields must match exactly the fields in a
+     * Tcl_Interp struct (see tcl.h). If you change one, be sure to change the
+     * other.
+     *
+     * The interpreter's result is held in both the string and the
+     * objResultPtr fields. These fields hold, respectively, the result's
+     * string or object value. The interpreter's result is always in the
+     * result field if that is non-empty, otherwise it is in objResultPtr.
+     * The two fields are kept consistent unless some C code sets
+     * interp->result directly. Programs should not access result and
+     * objResultPtr directly; instead, they should always get and set the
+     * result using procedures such as Tcl_SetObjResult, Tcl_GetObjResult, and
+     * Tcl_GetStringResult. See the SetResult man page for details.
+     */
+
+    char *result;		/* If the last command returned a string
+				 * result, this points to it. Should not be
+				 * accessed directly; see comment above. */
+    Tcl_FreeProc *freeProc;	/* Zero means a string result is statically
+				 * allocated. TCL_DYNAMIC means string result
+				 * was allocated with ckalloc and should be
+				 * freed with ckfree. Other values give
+				 * address of procedure to invoke to free the
+				 * string result. Tcl_Eval must free it before
+				 * executing next command. */
+    int errorLine;		/* When TCL_ERROR is returned, this gives the
+				 * line number in the command where the error
+				 * occurred (1 means first line). */
+    const struct TclStubs *stubTable;
+				/* Pointer to the exported Tcl stub table. On
+				 * previous versions of Tcl this is a pointer
+				 * to the objResultPtr or a pointer to a
+				 * buckets array in a hash table. We therefore
+				 * have to do some careful checking before we
+				 * can use this. */
+
+    TclHandle handle;		/* Handle used to keep track of when this
+				 * interp is deleted. */
+
+    Namespace *globalNsPtr;	/* The interpreter's global namespace. */
+    Tcl_HashTable *hiddenCmdTablePtr;
+				/* Hash table used by tclBasic.c to keep track
+				 * of hidden commands on a per-interp
+				 * basis. */
+    ClientData interpInfo;	/* Information used by tclInterp.c to keep
+				 * track of master/slave interps on a
+				 * per-interp basis. */
+    Tcl_HashTable unused2;	/* No longer used (was mathFuncTable) */
+
+    /*
+     * Information related to procedures and variables. See tclProc.c and
+     * tclVar.c for usage.
+     */
+
+    int numLevels;		/* Keeps track of how many nested calls to
+				 * Tcl_Eval are in progress for this
+				 * interpreter. It's used to delay deletion of
+				 * the table until all Tcl_Eval invocations
+				 * are completed. */
+    int maxNestingDepth;	/* If numLevels exceeds this value then Tcl
+				 * assumes that infinite recursion has
+				 * occurred and it generates an error. */
+    CallFrame *framePtr;	/* Points to top-most in stack of all nested
+				 * procedure invocations. */
+    CallFrame *varFramePtr;	/* Points to the call frame whose variables
+				 * are currently in use (same as framePtr
+				 * unless an "uplevel" command is
+				 * executing). */
+    ActiveVarTrace *activeVarTracePtr;
+				/* First in list of active traces for interp,
+				 * or NULL if no active traces. */
+    int returnCode;		/* [return -code] parameter. */
+    CallFrame *rootFramePtr;	/* Global frame pointer for this
+				 * interpreter. */
+    Namespace *lookupNsPtr;	/* Namespace to use ONLY on the next
+				 * TCL_EVAL_INVOKE call to Tcl_EvalObjv. */
+
+    /*
+     * Information used by Tcl_AppendResult to keep track of partial results.
+     * See Tcl_AppendResult code for details.
+     */
+
+    char *appendResult;		/* Storage space for results generated by
+				 * Tcl_AppendResult. Ckalloc-ed. NULL means
+				 * not yet allocated. */
+    int appendAvl;		/* Total amount of space available at
+				 * partialResult. */
+    int appendUsed;		/* Number of non-null bytes currently stored
+				 * at partialResult. */
+
+    /*
+     * Information about packages. Used only in tclPkg.c.
+     */
+
+    Tcl_HashTable packageTable;	/* Describes all of the packages loaded in or
+				 * available to this interpreter. Keys are
+				 * package names, values are (Package *)
+				 * pointers. */
+    char *packageUnknown;	/* Command to invoke during "package require"
+				 * commands for packages that aren't described
+				 * in packageTable. Ckalloc'ed, may be
+				 * NULL. */
+    /*
+     * Miscellaneous information:
+     */
+
+    int cmdCount;		/* Total number of times a command procedure
+				 * has been called for this interpreter. */
+    int evalFlags;		/* Flags to control next call to Tcl_Eval.
+				 * Normally zero, but may be set before
+				 * calling Tcl_Eval. See below for valid
+				 * values. */
+    int unused1;		/* No longer used (was termOffset) */
+    LiteralTable literalTable;	/* Contains LiteralEntry's describing all Tcl
+				 * objects holding literals of scripts
+				 * compiled by the interpreter. Indexed by the
+				 * string representations of literals. Used to
+				 * avoid creating duplicate objects. */
+    int compileEpoch;		/* Holds the current "compilation epoch" for
+				 * this interpreter. This is incremented to
+				 * invalidate existing ByteCodes when, e.g., a
+				 * command with a compile procedure is
+				 * redefined. */
+    Proc *compiledProcPtr;	/* If a procedure is being compiled, a pointer
+				 * to its Proc structure; otherwise, this is
+				 * NULL. Set by ObjInterpProc in tclProc.c and
+				 * used by tclCompile.c to process local
+				 * variables appropriately. */
+    ResolverScheme *resolverPtr;
+				/* Linked list of name resolution schemes
+				 * added to this interpreter. Schemes are
+				 * added and removed by calling
+				 * Tcl_AddInterpResolvers and
+				 * Tcl_RemoveInterpResolver respectively. */
+    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
+				 * command active; otherwise this points to
+				 * pathPtr of the file being sourced. */
+    int flags;			/* Various flag bits. See below. */
+    long randSeed;		/* Seed used for rand() function. */
+    Trace *tracePtr;		/* List of traces for this interpreter. */
+    Tcl_HashTable *assocData;	/* Hash table for associating data with this
+				 * interpreter. Cleaned up when this
+				 * interpreter is deleted. */
+    struct ExecEnv *execEnvPtr;	/* Execution environment for Tcl bytecode
+				 * execution. Contains a pointer to the Tcl
+				 * evaluation stack. */
+    Tcl_Obj *emptyObjPtr;	/* Points to an object holding an empty
+				 * string. Returned by Tcl_ObjSetVar2 when
+				 * variable traces change a variable in a
+				 * gross way. */
+    char resultSpace[TCL_RESULT_SIZE+1];
+				/* Static space holding small results. */
+    Tcl_Obj *objResultPtr;	/* If the last command returned an object
+				 * result, this points to it. Should not be
+				 * accessed directly; see comment above. */
+    Tcl_ThreadId threadId;	/* ID of thread that owns the interpreter. */
+
+    ActiveCommandTrace *activeCmdTracePtr;
+				/* First in list of active command traces for
+				 * interp, or NULL if no active traces. */
+    ActiveInterpTrace *activeInterpTracePtr;
+				/* First in list of active traces for interp,
+				 * or NULL if no active traces. */
+
+    int tracesForbiddingInline;	/* Count of traces (in the list headed by
+				 * tracePtr) that forbid inline bytecode
+				 * compilation. */
+
+    /*
+     * Fields used to manage extensible return options (TIP 90).
+     */
+
+    Tcl_Obj *returnOpts;	/* A dictionary holding the options to the
+				 * last [return] command. */
+
+    Tcl_Obj *errorInfo;		/* errorInfo value (now as a Tcl_Obj). */
+    Tcl_Obj *eiVar;		/* cached ref to ::errorInfo variable. */
+    Tcl_Obj *errorCode;		/* errorCode value (now as a Tcl_Obj). */
+    Tcl_Obj *ecVar;		/* cached ref to ::errorInfo variable. */
+    int returnLevel;		/* [return -level] parameter. */
+
+    /*
+     * Resource limiting framework support (TIP#143).
+     */
+
+    struct {
+	int active;		/* Flag values defining which limits have been
+				 * set. */
+	int granularityTicker;	/* Counter used to determine how often to
+				 * check the limits. */
+	int exceeded;		/* Which limits have been exceeded, described
+				 * as flag values the same as the 'active'
+				 * field. */
+
+	int cmdCount;		/* Limit for how many commands to execute in
+				 * the interpreter. */
+	LimitHandler *cmdHandlers;
+				/* Handlers to execute when the limit is
+				 * reached. */
+	int cmdGranularity;	/* Mod factor used to determine how often to
+				 * evaluate the limit check. */
+
+	Tcl_Time time;		/* Time limit for execution within the
+				 * interpreter. */
+	LimitHandler *timeHandlers;
+				/* Handlers to execute when the limit is
+				 * reached. */
+	int timeGranularity;	/* Mod factor used to determine how often to
+				 * evaluate the limit check. */
+	Tcl_TimerToken timeEvent;
+				/* Handle for a timer callback that will occur
+				 * when the time-limit is exceeded. */
+
+	Tcl_HashTable callbacks;/* Mapping from (interp,type) pair to data
+				 * used to install a limit handler callback to
+				 * run in _this_ interp when the limit is
+				 * exceeded. */
+    } limit;
+
+    /*
+     * Information for improved default error generation from ensembles
+     * (TIP#112).
+     */
+
+    struct {
+	Tcl_Obj *const *sourceObjs;
+				/* What arguments were actually input into the
+				 * *root* ensemble command? (Nested ensembles
+				 * don't rewrite this.) NULL if we're not
+				 * processing an ensemble. */
+	int numRemovedObjs;	/* How many arguments have been stripped off
+				 * because of ensemble processing. */
+	int numInsertedObjs;	/* How many of the current arguments were
+				 * inserted by an ensemble. */
+    } ensembleRewrite;
+
+    /*
+     * TIP #219: Global info for the I/O system.
+     */
+
+    Tcl_Obj *chanMsg;		/* Error message set by channel drivers, for
+				 * the propagation of arbitrary Tcl errors.
+				 * This information, if present (chanMsg not
+				 * NULL), takes precedence over a POSIX error
+				 * code returned by a channel operation. */
+
+    /*
+     * Source code origin information (TIP #280).
+     */
+
+    CmdFrame *cmdFramePtr;	/* Points to the command frame containing the
+				 * location information for the current
+				 * command. */
+    const CmdFrame *invokeCmdFramePtr;
+				/* Points to the command frame which is the
+				 * invoking context of the bytecode compiler.
+				 * NULL when the byte code compiler is not
+				 * active. */
+    int invokeWord;		/* Index of the word in the command which
+				 * is getting compiled. */
+    Tcl_HashTable *linePBodyPtr;/* This table remembers for each statically
+				 * defined procedure the location information
+				 * for its body. It is keyed by the address of
+				 * the Proc structure for a procedure. The
+				 * values are "struct CmdFrame*". */
+    Tcl_HashTable *lineBCPtr;	/* This table remembers for each ByteCode
+				 * object the location information for its
+				 * body. It is keyed by the address of the
+				 * Proc structure for a procedure. The values
+				 * are "struct ExtCmdLoc*". (See
+				 * tclCompile.h) */
+    Tcl_HashTable *lineLABCPtr;
+    Tcl_HashTable *lineLAPtr;	/* This table remembers for each argument of a
+				 * command on the execution stack the index of
+				 * the argument in the command, and the
+				 * location data of the command. It is keyed
+				 * by the address of the Tcl_Obj containing
+				 * the argument. The values are "struct
+				 * CFWord*" (See tclBasic.c). This allows
+				 * commands like uplevel, eval, etc. to find
+				 * location information for their arguments,
+				 * if they are a proper literal argument to an
+				 * invoking command. Alt view: An index to the
+				 * CmdFrame stack keyed by command argument
+				 * holders. */
+    ContLineLoc *scriptCLLocPtr;/* This table points to the location data for
+				 * invisible continuation lines in the script,
+				 * if any. This pointer is set by the function
+				 * TclEvalObjEx() in file "tclBasic.c", and
+				 * used by function ...() in the same file.
+				 * It does for the eval/direct path of script
+				 * execution what CompileEnv.clLoc does for
+				 * the bytecode compiler.
+				 */
+    /*
+     * TIP #268. The currently active selection mode, i.e. the package require
+     * preferences.
+     */
+
+    int packagePrefer;		/* Current package selection mode. */
+
+    /*
+     * Hashtables for variable traces and searches.
+     */
+
+    Tcl_HashTable varTraces;	/* Hashtable holding the start of a variable's
+				 * active trace list; varPtr is the key. */
+    Tcl_HashTable varSearches;	/* Hashtable holding the start of a variable's
+				 * active searches list; varPtr is the key. */
+    /*
+     * The thread-specific data ekeko: cache pointers or values that
+     *  (a) do not change during the thread's lifetime
+     *  (b) require access to TSD to determine at runtime
+     *  (c) are accessed very often (e.g., at each command call)
+     *
+     * Note that these are the same for all interps in the same thread. They
+     * just have to be initialised for the thread's master interp, slaves
+     * inherit the value.
+     *
+     * They are used by the macros defined below.
+     */
+
+    AllocCache *allocCache;
+    void *pendingObjDataPtr;	/* Pointer to the Cache and PendingObjData
+				 * structs for this interp's thread; see
+				 * tclObj.c and tclThreadAlloc.c */
+    int *asyncReadyPtr;		/* Pointer to the asyncReady indicator for
+				 * this interp's thread; see tclAsync.c */
+    /*
+     * The pointer to the object system root ekeko. c.f. TIP #257.
+     */
+    void *objectFoundation;	/* Pointer to the Foundation structure of the
+				 * object system, which contains things like
+				 * references to key namespaces. See
+				 * tclOOInt.h and tclOO.c for real definition
+				 * and setup. */
+
+    struct NRE_callback *deferredCallbacks;
+				/* Callbacks that are set previous to a call
+				 * to some Eval function but that actually
+				 * belong to the command that is about to be
+				 * called - i.e., they should be run *before*
+				 * any tailcall is invoked. */
+
+    /*
+     * TIP #285, Script cancellation support.
+     */
+
+    Tcl_AsyncHandler asyncCancel;
+				/* Async handler token for Tcl_CancelEval. */
+    Tcl_Obj *asyncCancelMsg;	/* Error message set by async cancel handler
+				 * for the propagation of arbitrary Tcl
+				 * errors. This information, if present
+				 * (asyncCancelMsg not NULL), takes precedence
+				 * over the default error messages returned by
+				 * a script cancellation operation. */
+
+	/*
+	 * TIP #348 IMPLEMENTATION  -  Substituted error stack
+	 */
+    Tcl_Obj *errorStack;	/* [info errorstack] value (as a Tcl_Obj). */
+    Tcl_Obj *upLiteral;		/* "UP" literal for [info errorstack] */
+    Tcl_Obj *callLiteral;	/* "CALL" literal for [info errorstack] */
+    Tcl_Obj *innerLiteral;	/* "INNER" literal for [info errorstack] */
+    Tcl_Obj *innerContext;	/* cached list for fast reallocation */
+    int resetErrorStack;        /* controls cleaning up of ::errorStack */
+
+#ifdef TCL_COMPILE_STATS
+    /*
+     * Statistical information about the bytecode compiler and interpreter's
+     * operation. This should be the last field of Interp.
+     */
+
+    ByteCodeStats stats;	/* Holds compilation and execution statistics
+				 * for this interpreter. */
+#endif /* TCL_COMPILE_STATS */
+} Interp;
+
+/*
+ * Macros that use the TSD-ekeko.
+ */
+
+#define TclAsyncReady(iPtr) \
+    *((iPtr)->asyncReadyPtr)
+
+/*
+ * Macros for script cancellation support (TIP #285).
+ */
+
+#define TclCanceled(iPtr) \
+    (((iPtr)->flags & CANCELED) || ((iPtr)->flags & TCL_CANCEL_UNWIND))
+
+#define TclSetCancelFlags(iPtr, cancelFlags)   \
+    (iPtr)->flags |= CANCELED;                 \
+    if ((cancelFlags) & TCL_CANCEL_UNWIND) {   \
+        (iPtr)->flags |= TCL_CANCEL_UNWIND;    \
+    }
+
+#define TclUnsetCancelFlags(iPtr) \
+    (iPtr)->flags &= (~(CANCELED | TCL_CANCEL_UNWIND))
+
+/*
+ * General list of interpreters. Doubly linked for easier removal of items
+ * deep in the list.
+ */
+
+typedef struct InterpList {
+    Interp *interpPtr;
+    struct InterpList *prevPtr;
+    struct InterpList *nextPtr;
+} InterpList;
+
+/*
+ * Macros for splicing into and out of doubly linked lists. They assume
+ * existence of struct items 'prevPtr' and 'nextPtr'.
+ *
+ * a = element to add or remove.
+ * b = list head.
+ *
+ * TclSpliceIn adds to the head of the list.
+ */
+
+#define TclSpliceIn(a,b)			\
+    (a)->nextPtr = (b);				\
+    if ((b) != NULL) {				\
+	(b)->prevPtr = (a);			\
+    }						\
+    (a)->prevPtr = NULL, (b) = (a);
+
+#define TclSpliceOut(a,b)			\
+    if ((a)->prevPtr != NULL) {			\
+	(a)->prevPtr->nextPtr = (a)->nextPtr;	\
+    } else {					\
+	(b) = (a)->nextPtr;			\
+    }						\
+    if ((a)->nextPtr != NULL) {			\
+	(a)->nextPtr->prevPtr = (a)->prevPtr;	\
+    }
+
+/*
+ * EvalFlag bits for Interp structures:
+ *
+ * TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with a
+ *			code other than TCL_OK or TCL_ERROR; 0 means codes
+ *			other than these should be turned into errors.
+ */
+
+#define TCL_ALLOW_EXCEPTIONS	4
+#define TCL_EVAL_FILE		2
+#define TCL_EVAL_CTX		8
+#define TCL_EVAL_REDIRECT	16
+
+/*
+ * Flag bits for Interp structures:
+ *
+ * DELETED:		Non-zero means the interpreter has been deleted:
+ *			don't process any more commands for it, and destroy
+ *			the structure as soon as all nested invocations of
+ *			Tcl_Eval are done.
+ * ERR_ALREADY_LOGGED:	Non-zero means information has already been logged in
+ *			iPtr->errorInfo for the current Tcl_Eval instance, so
+ *			Tcl_Eval needn't log it (used to implement the "error
+ *			message log" command).
+ * DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler should
+ *			not compile any commands into an inline sequence of
+ *			instructions. This is set 1, for example, when command
+ *			traces are requested.
+ * RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the interp
+ *			has not be initialized. This is set 1 when we first
+ *			use the rand() or srand() functions.
+ * SAFE_INTERP:		Non zero means that the current interp is a safe
+ *			interp (i.e. it has only the safe commands installed,
+ *			less priviledge than a regular interp).
+ * INTERP_DEBUG_FRAME:	Used for switching on various extra interpreter
+ *			debug/info mechanisms (e.g. info frame eval/uplevel
+ *			tracing) which are performance intensive.
+ * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
+ *			active; so no further trace callbacks should be
+ *			invoked.
+ * INTERP_ALTERNATE_WRONG_ARGS: Used for listing second and subsequent forms
+ *			of the wrong-num-args string in Tcl_WrongNumArgs.
+ *			Makes it append instead of replacing and uses
+ *			different intermediate text.
+ * CANCELED:		Non-zero means that the script in progress should be
+ *			canceled as soon as possible. This can be checked by
+ *			extensions (and the core itself) by calling
+ *			Tcl_Canceled and checking if TCL_ERROR is returned.
+ *			This is a one-shot flag that is reset immediately upon
+ *			being detected; however, if the TCL_CANCEL_UNWIND flag
+ *			is set Tcl_Canceled will continue to report that the
+ *			script in progress has been canceled thereby allowing
+ *			the evaluation stack for the interp to be fully
+ *			unwound.
+ *
+ * WARNING: For the sake of some extensions that have made use of former
+ * internal values, do not re-use the flag values 2 (formerly ERR_IN_PROGRESS)
+ * or 8 (formerly ERROR_CODE_SET).
+ */
+
+#define DELETED				     1
+#define ERR_ALREADY_LOGGED		     4
+#define INTERP_DEBUG_FRAME		  0x10
+#define DONT_COMPILE_CMDS_INLINE	  0x20
+#define RAND_SEED_INITIALIZED		  0x40
+#define SAFE_INTERP			  0x80
+#define INTERP_TRACE_IN_PROGRESS	 0x200
+#define INTERP_ALTERNATE_WRONG_ARGS	 0x400
+#define ERR_LEGACY_COPY			 0x800
+#define CANCELED			0x1000
+
+/*
+ * Maximum number of levels of nesting permitted in Tcl commands (used to
+ * catch infinite recursion).
+ */
+
+#define MAX_NESTING_DEPTH	1000
+
+/*
+ * TIP#143 limit handler internal representation.
+ */
+
+struct LimitHandler {
+    int flags;			/* The state of this particular handler. */
+    Tcl_LimitHandlerProc *handlerProc;
+				/* The handler callback. */
+    ClientData clientData;	/* Opaque argument to the handler callback. */
+    Tcl_LimitHandlerDeleteProc *deleteProc;
+				/* How to delete the clientData. */
+    LimitHandler *prevPtr;	/* Previous item in linked list of
+				 * handlers. */
+    LimitHandler *nextPtr;	/* Next item in linked list of handlers. */
+};
+
+/*
+ * Values for the LimitHandler flags field.
+ *	LIMIT_HANDLER_ACTIVE - Whether the handler is currently being
+ *		processed; handlers are never to be entered reentrantly.
+ *	LIMIT_HANDLER_DELETED - Whether the handler has been deleted. This
+ *		should not normally be observed because when a handler is
+ *		deleted it is also spliced out of the list of handlers, but
+ *		even so we will be careful.
+ */
+
+#define LIMIT_HANDLER_ACTIVE	0x01
+#define LIMIT_HANDLER_DELETED	0x02
+
+/*
+ * The macro below is used to modify a "char" value (e.g. by casting it to an
+ * unsigned character) so that it can be used safely with macros such as
+ * isspace.
+ */
+
+#define UCHAR(c) ((unsigned char) (c))
+
+/*
+ * This macro is used to properly align the memory allocated by Tcl, giving
+ * the same alignment as the native malloc.
+ */
+
+#if defined(__APPLE__)
+#define TCL_ALLOCALIGN	16
+#else
+#define TCL_ALLOCALIGN	(2*sizeof(void *))
+#endif
+
+/*
+ * This macro is used to determine the offset needed to safely allocate any
+ * data structure in memory. Given a starting offset or size, it "rounds up"
+ * or "aligns" the offset to the next 8-byte boundary so that any data
+ * structure can be placed at the resulting offset without fear of an
+ * alignment error.
+ *
+ * WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce the
+ * wrong result on platforms that allocate addresses that are divisible by 4
+ * or 2. Only use it for offsets or sizes.
+ *
+ * This macro is only used by tclCompile.c in the core (Bug 926445). It
+ * however not be made file static, as extensions that touch bytecodes
+ * (notably tbcload) require it.
+ */
+
+#define TCL_ALIGN(x) (((int)(x) + 7) & ~7)
+
+/*
+ * The following enum values are used to specify the runtime platform setting
+ * of the tclPlatform variable.
+ */
+
+typedef enum {
+    TCL_PLATFORM_UNIX = 0,	/* Any Unix-like OS. */
+    TCL_PLATFORM_WINDOWS = 2	/* Any Microsoft Windows OS. */
+} TclPlatformType;
+
+/*
+ * The following enum values are used to indicate the translation of a Tcl
+ * channel. Declared here so that each platform can define
+ * TCL_PLATFORM_TRANSLATION to the native translation on that platform.
+ */
+
+typedef enum TclEolTranslation {
+    TCL_TRANSLATE_AUTO,		/* Eol == \r, \n and \r\n. */
+    TCL_TRANSLATE_CR,		/* Eol == \r. */
+    TCL_TRANSLATE_LF,		/* Eol == \n. */
+    TCL_TRANSLATE_CRLF		/* Eol == \r\n. */
+} TclEolTranslation;
+
+/*
+ * Flags for TclInvoke:
+ *
+ * TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
+ *				an exposed command.
+ * TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
+ *				command to be invoked is not found. Only has
+ *				an effect if invoking an exposed command,
+ *				i.e. if TCL_INVOKE_HIDDEN is not also set.
+ * TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
+ *				invoked command returns an error. Used if the
+ *				caller plans on recording its own traceback
+ *				information.
+ */
+
+#define	TCL_INVOKE_HIDDEN	(1<<0)
+#define TCL_INVOKE_NO_UNKNOWN	(1<<1)
+#define TCL_INVOKE_NO_TRACEBACK	(1<<2)
+
+/*
+ * The structure used as the internal representation of Tcl list objects. This
+ * struct is grown (reallocated and copied) as necessary to hold all the
+ * list's element pointers. The struct might contain more slots than currently
+ * used to hold all element pointers. This is done to make append operations
+ * faster.
+ */
+
+typedef struct List {
+    int refCount;
+    int maxElemCount;		/* Total number of element array slots. */
+    int elemCount;		/* Current number of list elements. */
+    int canonicalFlag;		/* Set if the string representation was
+				 * derived from the list representation. May
+				 * be ignored if there is no string rep at
+				 * all.*/
+    Tcl_Obj *elements;		/* First list element; the struct is grown to
+				 * accomodate all elements. */
+} List;
+
+#define LIST_MAX \
+	(1 + (int)(((size_t)UINT_MAX - sizeof(List))/sizeof(Tcl_Obj *)))
+#define LIST_SIZE(numElems) \
+	(unsigned)(sizeof(List) + (((numElems) - 1) * sizeof(Tcl_Obj *)))
+
+/*
+ * Macro used to get the elements of a list object.
+ */
+
+#define ListRepPtr(listPtr) \
+    ((List *) (listPtr)->internalRep.twoPtrValue.ptr1)
+
+#define ListSetIntRep(objPtr, listRepPtr) \
+    (objPtr)->internalRep.twoPtrValue.ptr1 = (void *)(listRepPtr), \
+    (objPtr)->internalRep.twoPtrValue.ptr2 = NULL, \
+    (listRepPtr)->refCount++, \
+    (objPtr)->typePtr = &tclListType
+
+#define ListObjGetElements(listPtr, objc, objv) \
+    ((objv) = &(ListRepPtr(listPtr)->elements), \
+     (objc) = ListRepPtr(listPtr)->elemCount)
+
+#define ListObjLength(listPtr, len) \
+    ((len) = ListRepPtr(listPtr)->elemCount)
+
+#define ListObjIsCanonical(listPtr) \
+    (((listPtr)->bytes == NULL) || ListRepPtr(listPtr)->canonicalFlag)
+
+#define TclListObjGetElements(interp, listPtr, objcPtr, objvPtr) \
+    (((listPtr)->typePtr == &tclListType) \
+	    ? ((ListObjGetElements((listPtr), *(objcPtr), *(objvPtr))), TCL_OK)\
+	    : Tcl_ListObjGetElements((interp), (listPtr), (objcPtr), (objvPtr)))
+
+#define TclListObjLength(interp, listPtr, lenPtr) \
+    (((listPtr)->typePtr == &tclListType) \
+	    ? ((ListObjLength((listPtr), *(lenPtr))), TCL_OK)\
+	    : Tcl_ListObjLength((interp), (listPtr), (lenPtr)))
+
+#define TclListObjIsCanonical(listPtr) \
+    (((listPtr)->typePtr == &tclListType) ? ListObjIsCanonical((listPtr)) : 0)
+
+/*
+ * Modes for collecting (or not) in the implementations of TclNRForeachCmd,
+ * TclNRLmapCmd and their compilations.
+ */
+
+#define TCL_EACH_KEEP_NONE  0	/* Discard iteration result like [foreach] */
+#define TCL_EACH_COLLECT    1	/* Collect iteration result like [lmap] */
+
+/*
+ * Macros providing a faster path to integers: Tcl_GetLongFromObj everywhere,
+ * Tcl_GetIntFromObj and TclGetIntForIndex on platforms where longs are ints.
+ *
+ * WARNING: these macros eval their args more than once.
+ */
+
+#define TclGetLongFromObj(interp, objPtr, longPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(longPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : Tcl_GetLongFromObj((interp), (objPtr), (longPtr)))
+
+#if (LONG_MAX == INT_MAX)
+#define TclGetIntFromObj(interp, objPtr, intPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(intPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : Tcl_GetIntFromObj((interp), (objPtr), (intPtr)))
+#define TclGetIntForIndexM(interp, objPtr, endValue, idxPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(idxPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : TclGetIntForIndex((interp), (objPtr), (endValue), (idxPtr)))
+#else
+#define TclGetIntFromObj(interp, objPtr, intPtr) \
+    Tcl_GetIntFromObj((interp), (objPtr), (intPtr))
+#define TclGetIntForIndexM(interp, objPtr, ignore, idxPtr)	\
+    TclGetIntForIndex(interp, objPtr, ignore, idxPtr)
+#endif
+
+/*
+ * Flag values for TclTraceDictPath().
+ *
+ * DICT_PATH_READ indicates that all entries on the path must exist but no
+ * updates will be needed.
+ *
+ * DICT_PATH_UPDATE indicates that we are going to be doing an update at the
+ * tip of the path, so duplication of shared objects should be done along the
+ * way.
+ *
+ * DICT_PATH_EXISTS indicates that we are performing an existance test and a
+ * lookup failure should therefore not be an error. If (and only if) this flag
+ * is set, TclTraceDictPath() will return the special value
+ * DICT_PATH_NON_EXISTENT if the path is not traceable.
+ *
+ * DICT_PATH_CREATE (which also requires the DICT_PATH_UPDATE bit to be set)
+ * indicates that we are to create non-existant dictionaries on the path.
+ */
+
+#define DICT_PATH_READ		0
+#define DICT_PATH_UPDATE	1
+#define DICT_PATH_EXISTS	2
+#define DICT_PATH_CREATE	5
+
+#define DICT_PATH_NON_EXISTENT	((Tcl_Obj *) (void *) 1)
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to the filesystem internals
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The version_2 filesystem is private to Tcl. As and when these changes have
+ * been thoroughly tested and investigated a new public filesystem interface
+ * will be released. The aim is more versatile virtual filesystem interfaces,
+ * more efficiency in 'path' manipulation and usage, and cleaner filesystem
+ * code internally.
+ */
+
+#define TCL_FILESYSTEM_VERSION_2	((Tcl_FSVersion) 0x2)
+typedef ClientData (TclFSGetCwdProc2)(ClientData clientData);
+typedef int (Tcl_FSLoadFileProc2) (Tcl_Interp *interp, Tcl_Obj *pathPtr,
+	Tcl_LoadHandle *handlePtr, Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
+
+/*
+ * The following types are used for getting and storing platform-specific file
+ * attributes in tclFCmd.c and the various platform-versions of that file.
+ * This is done to have as much common code as possible in the file attributes
+ * code. For more information about the callbacks, see TclFileAttrsCmd in
+ * tclFCmd.c.
+ */
+
+typedef int (TclGetFileAttrProc)(Tcl_Interp *interp, int objIndex,
+	Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr);
+typedef int (TclSetFileAttrProc)(Tcl_Interp *interp, int objIndex,
+	Tcl_Obj *fileName, Tcl_Obj *attrObjPtr);
+
+typedef struct TclFileAttrProcs {
+    TclGetFileAttrProc *getProc;/* The procedure for getting attrs. */
+    TclSetFileAttrProc *setProc;/* The procedure for setting attrs. */
+} TclFileAttrProcs;
+
+/*
+ * Opaque handle used in pipeline routines to encapsulate platform-dependent
+ * state.
+ */
+
+typedef struct TclFile_ *TclFile;
+
+/*
+ * The "globParameters" argument of the function TclGlob is an or'ed
+ * combination of the following values:
+ */
+
+#define TCL_GLOBMODE_NO_COMPLAIN	1
+#define TCL_GLOBMODE_JOIN		2
+#define TCL_GLOBMODE_DIR		4
+#define TCL_GLOBMODE_TAILS		8
+
+typedef enum Tcl_PathPart {
+    TCL_PATH_DIRNAME,
+    TCL_PATH_TAIL,
+    TCL_PATH_EXTENSION,
+    TCL_PATH_ROOT
+} Tcl_PathPart;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to obsolete filesystem hooks
+ *----------------------------------------------------------------
+ */
+
+typedef int (TclStatProc_)(const char *path, struct stat *buf);
+typedef int (TclAccessProc_)(const char *path, int mode);
+typedef Tcl_Channel (TclOpenFileChannelProc_)(Tcl_Interp *interp,
+	const char *fileName, const char *modeString, int permissions);
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to procedures
+ *----------------------------------------------------------------
+ */
+
+typedef Tcl_CmdProc *TclCmdProcType;
+typedef Tcl_ObjCmdProc *TclObjCmdProcType;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures for process-global values.
+ *----------------------------------------------------------------
+ */
+
+typedef void (TclInitProcessGlobalValueProc)(char **valuePtr, int *lengthPtr,
+	Tcl_Encoding *encodingPtr);
+
+/*
+ * A ProcessGlobalValue struct exists for each internal value in Tcl that is
+ * to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
+ * the value, and the master is kept as a counted string, with epoch and mutex
+ * control. Each ProcessGlobalValue struct should be a static variable in some
+ * file.
+ */
+
+typedef struct ProcessGlobalValue {
+    int epoch;			/* Epoch counter to detect changes in the
+				 * master value. */
+    int numBytes;		/* Length of the master string. */
+    char *value;		/* The master string value. */
+    Tcl_Encoding encoding;	/* system encoding when master string was
+				 * initialized. */
+    TclInitProcessGlobalValueProc *proc;
+    				/* A procedure to initialize the master string
+				 * copy when a "get" request comes in before
+				 * any "set" request has been received. */
+    Tcl_Mutex mutex;		/* Enforce orderly access from multiple
+				 * threads. */
+    Tcl_ThreadDataKey key;	/* Key for per-thread data holding the
+				 * (Tcl_Obj) copy for each thread. */
+} ProcessGlobalValue;
+
+/*
+ *----------------------------------------------------------------------
+ * Flags for TclParseNumber
+ *----------------------------------------------------------------------
+ */
+
+#define TCL_PARSE_DECIMAL_ONLY		1
+				/* Leading zero doesn't denote octal or
+				 * hex. */
+#define TCL_PARSE_OCTAL_ONLY		2
+				/* Parse octal even without prefix. */
+#define TCL_PARSE_HEXADECIMAL_ONLY	4
+				/* Parse hexadecimal even without prefix. */
+#define TCL_PARSE_INTEGER_ONLY		8
+				/* Disable floating point parsing. */
+#define TCL_PARSE_SCAN_PREFIXES		16
+				/* Use [scan] rules dealing with 0?
+				 * prefixes. */
+#define TCL_PARSE_NO_WHITESPACE		32
+				/* Reject leading/trailing whitespace. */
+#define TCL_PARSE_BINARY_ONLY	64
+				/* Parse binary even without prefix. */
+
+/*
+ *----------------------------------------------------------------------
+ * Type values TclGetNumberFromObj
+ *----------------------------------------------------------------------
+ */
+
+#define TCL_NUMBER_LONG		1
+#define TCL_NUMBER_WIDE		2
+#define TCL_NUMBER_BIG		3
+#define TCL_NUMBER_DOUBLE	4
+#define TCL_NUMBER_NAN		5
+
+/*
+ *----------------------------------------------------------------
+ * Variables shared among Tcl modules but not used by the outside world.
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE char *tclNativeExecutableName;
+MODULE_SCOPE int tclFindExecutableSearchDone;
+MODULE_SCOPE char *tclMemDumpFileName;
+MODULE_SCOPE TclPlatformType tclPlatform;
+MODULE_SCOPE Tcl_NotifierProcs tclNotifierHooks;
+
+/*
+ * TIP #233 (Virtualized Time)
+ * Data for the time hooks, if any.
+ */
+
+MODULE_SCOPE Tcl_GetTimeProc *tclGetTimeProcPtr;
+MODULE_SCOPE Tcl_ScaleTimeProc *tclScaleTimeProcPtr;
+MODULE_SCOPE ClientData tclTimeClientData;
+
+/*
+ * Variables denoting the Tcl object types defined in the core.
+ */
+
+MODULE_SCOPE const Tcl_ObjType tclBignumType;
+MODULE_SCOPE const Tcl_ObjType tclBooleanType;
+MODULE_SCOPE const Tcl_ObjType tclByteArrayType;
+MODULE_SCOPE const Tcl_ObjType tclByteCodeType;
+MODULE_SCOPE const Tcl_ObjType tclDoubleType;
+MODULE_SCOPE const Tcl_ObjType tclEndOffsetType;
+MODULE_SCOPE const Tcl_ObjType tclIntType;
+MODULE_SCOPE const Tcl_ObjType tclListType;
+MODULE_SCOPE const Tcl_ObjType tclDictType;
+MODULE_SCOPE const Tcl_ObjType tclProcBodyType;
+MODULE_SCOPE const Tcl_ObjType tclStringType;
+MODULE_SCOPE const Tcl_ObjType tclArraySearchType;
+MODULE_SCOPE const Tcl_ObjType tclEnsembleCmdType;
+#ifndef NO_WIDE_TYPE
+MODULE_SCOPE const Tcl_ObjType tclWideIntType;
+#endif
+MODULE_SCOPE const Tcl_ObjType tclRegexpType;
+MODULE_SCOPE Tcl_ObjType tclCmdNameType;
+
+/*
+ * Variables denoting the hash key types defined in the core.
+ */
+
+MODULE_SCOPE const Tcl_HashKeyType tclArrayHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclOneWordHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclStringHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclObjHashKeyType;
+
+/*
+ * The head of the list of free Tcl objects, and the total number of Tcl
+ * objects ever allocated and freed.
+ */
+
+MODULE_SCOPE Tcl_Obj *	tclFreeObjList;
+
+#ifdef TCL_COMPILE_STATS
+MODULE_SCOPE long	tclObjsAlloced;
+MODULE_SCOPE long	tclObjsFreed;
+#define TCL_MAX_SHARED_OBJ_STATS 5
+MODULE_SCOPE long	tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
+#endif /* TCL_COMPILE_STATS */
+
+/*
+ * Pointer to a heap-allocated string of length zero that the Tcl core uses as
+ * the value of an empty string representation for an object. This value is
+ * shared by all new objects allocated by Tcl_NewObj.
+ */
+
+MODULE_SCOPE char *	tclEmptyStringRep;
+MODULE_SCOPE char	tclEmptyString;
+
+/*
+ *----------------------------------------------------------------
+ * Procedures shared among Tcl modules but not used by the outside world,
+ * introduced by/for NRE.
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_ObjCmdProc TclNRApplyObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNREvalObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRCatchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRExprObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRForObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRForeachCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRIfObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRLmapCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSourceObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSubstObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSwitchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRTryObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRUplevelObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRWhileObjCmd;
+
+MODULE_SCOPE Tcl_NRPostProc TclNRForIterCallback;
+MODULE_SCOPE Tcl_NRPostProc TclNRCoroutineActivateCallback;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRTailcallObjCmd;
+MODULE_SCOPE Tcl_NRPostProc TclNRTailcallEval;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRCoroutineObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldmObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldToObjCmd;
+
+MODULE_SCOPE void  TclSpliceTailcall(Tcl_Interp *interp,
+	               struct NRE_callback *tailcallPtr);
+
+/*
+ * This structure holds the data for the various iteration callbacks used to
+ * NRE the 'for' and 'while' commands. We need a separate structure because we
+ * have more than the 4 client data entries we can provide directly thorugh
+ * the callback API. It is the 'word' information which puts us over the
+ * limit. It is needed because the loop body is argument 4 of 'for' and
+ * argument 2 of 'while'. Not providing the correct index confuses the #280
+ * code. We TclSmallAlloc/Free this.
+ */
+
+typedef struct ForIterData {
+    Tcl_Obj *cond;		/* Loop condition expression. */
+    Tcl_Obj *body;		/* Loop body. */
+    Tcl_Obj *next;		/* Loop step script, NULL for 'while'. */
+    const char *msg;		/* Error message part. */
+    int word;			/* Index of the body script in the command */
+} ForIterData;
+
+/* TIP #357 - Structure doing the bookkeeping of handles for Tcl_LoadFile
+ *            and Tcl_FindSymbol. This structure corresponds to an opaque
+ *            typedef in tcl.h */
+
+typedef void* TclFindSymbolProc(Tcl_Interp* interp, Tcl_LoadHandle loadHandle,
+				const char* symbol);
+struct Tcl_LoadHandle_ {
+    ClientData clientData;	/* Client data is the load handle in the
+				 * native filesystem if a module was loaded
+				 * there, or an opaque pointer to a structure
+				 * for further bookkeeping on load-from-VFS
+				 * and load-from-memory */
+    TclFindSymbolProc* findSymbolProcPtr;
+				/* Procedure that resolves symbols in a
+				 * loaded module */
+    Tcl_FSUnloadFileProc* unloadFileProcPtr;
+				/* Procedure that unloads a loaded module */
+};
+
+/* Flags for conversion of doubles to digit strings */
+
+#define TCL_DD_SHORTEST 		0x4
+				/* Use the shortest possible string */
+#define TCL_DD_STEELE   		0x5
+				/* Use the original Steele&White algorithm */
+#define TCL_DD_E_FORMAT 		0x2
+				/* Use a fixed-length string of digits,
+				 * suitable for E format*/
+#define TCL_DD_F_FORMAT 		0x3
+				/* Use a fixed number of digits after the
+				 * decimal point, suitable for F format */
+
+#define TCL_DD_SHORTEN_FLAG 		0x4
+				/* Allow return of a shorter digit string
+				 * if it converts losslessly */
+#define TCL_DD_NO_QUICK 		0x8
+				/* Debug flag: forbid quick FP conversion */
+
+#define TCL_DD_CONVERSION_TYPE_MASK	0x3
+				/* Mask to isolate the conversion type */
+#define TCL_DD_STEELE0 			0x1
+				/* 'Steele&White' after masking */
+#define TCL_DD_SHORTEST0		0x0
+				/* 'Shortest possible' after masking */
+
+/*
+ *----------------------------------------------------------------
+ * Procedures shared among Tcl modules but not used by the outside world:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE void	TclAppendBytesToByteArray(Tcl_Obj *objPtr,
+			    const unsigned char *bytes, int len);
+MODULE_SCOPE int	TclNREvalCmd(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    int flags);
+MODULE_SCOPE void	TclPushTailcallPoint(Tcl_Interp *interp);
+MODULE_SCOPE void	TclAdvanceContinuations(int *line, int **next,
+			    int loc);
+MODULE_SCOPE void	TclAdvanceLines(int *line, const char *start,
+			    const char *end);
+MODULE_SCOPE void	TclArgumentEnter(Tcl_Interp *interp,
+			    Tcl_Obj *objv[], int objc, CmdFrame *cf);
+MODULE_SCOPE void	TclArgumentRelease(Tcl_Interp *interp,
+			    Tcl_Obj *objv[], int objc);
+MODULE_SCOPE void	TclArgumentBCEnter(Tcl_Interp *interp,
+			    Tcl_Obj *objv[], int objc,
+			    void *codePtr, CmdFrame *cfPtr, int pc);
+MODULE_SCOPE void	TclArgumentBCRelease(Tcl_Interp *interp,
+			    CmdFrame *cfPtr);
+MODULE_SCOPE void	TclArgumentGet(Tcl_Interp *interp, Tcl_Obj *obj,
+			    CmdFrame **cfPtrPtr, int *wordPtr);
+MODULE_SCOPE int	TclArraySet(Tcl_Interp *interp,
+			    Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj);
+MODULE_SCOPE double	TclBignumToDouble(const mp_int *bignum);
+MODULE_SCOPE int	TclByteArrayMatch(const unsigned char *string,
+			    int strLen, const unsigned char *pattern,
+			    int ptnLen, int flags);
+MODULE_SCOPE double	TclCeil(const mp_int *a);
+MODULE_SCOPE int	TclCheckBadOctal(Tcl_Interp *interp,
+			    const char *value);
+MODULE_SCOPE int	TclChanCaughtErrorBypass(Tcl_Interp *interp,
+			    Tcl_Channel chan);
+MODULE_SCOPE Tcl_ObjCmdProc TclChannelNamesCmd;
+MODULE_SCOPE int	TclClearRootEnsemble(ClientData data[],
+			    Tcl_Interp *interp, int result);
+MODULE_SCOPE ContLineLoc *TclContinuationsEnter(Tcl_Obj *objPtr, int num,
+			    int *loc);
+MODULE_SCOPE void	TclContinuationsEnterDerived(Tcl_Obj *objPtr,
+			    int start, int *clNext);
+MODULE_SCOPE ContLineLoc *TclContinuationsGet(Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclContinuationsCopy(Tcl_Obj *objPtr,
+			    Tcl_Obj *originObjPtr);
+MODULE_SCOPE int	TclConvertElement(const char *src, int length,
+			    char *dst, int flags);
+MODULE_SCOPE void	TclDeleteNamespaceVars(Namespace *nsPtr);
+/* TIP #280 - Modified token based evulation, with line information. */
+MODULE_SCOPE int	TclEvalEx(Tcl_Interp *interp, const char *script,
+			    int numBytes, int flags, int line,
+			    int *clNextOuter, const char *outerScript);
+MODULE_SCOPE Tcl_ObjCmdProc TclFileAttrsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileCopyCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileDeleteCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileLinkCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileMakeDirsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileReadLinkCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileRenameCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileTemporaryCmd;
+MODULE_SCOPE void	TclCreateLateExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE void	TclDeleteLateExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE char *	TclDStringAppendObj(Tcl_DString *dsPtr,
+			    Tcl_Obj *objPtr);
+MODULE_SCOPE char *	TclDStringAppendDString(Tcl_DString *dsPtr,
+			    Tcl_DString *toAppendPtr);
+MODULE_SCOPE Tcl_Obj *	TclDStringToObj(Tcl_DString *dsPtr);
+MODULE_SCOPE void	TclFinalizeAllocSubsystem(void);
+MODULE_SCOPE void	TclFinalizeAsync(void);
+MODULE_SCOPE void	TclFinalizeDoubleConversion(void);
+MODULE_SCOPE void	TclFinalizeEncodingSubsystem(void);
+MODULE_SCOPE void	TclFinalizeEnvironment(void);
+MODULE_SCOPE void	TclFinalizeEvaluation(void);
+MODULE_SCOPE void	TclFinalizeExecution(void);
+MODULE_SCOPE void	TclFinalizeIOSubsystem(void);
+MODULE_SCOPE void	TclFinalizeFilesystem(void);
+MODULE_SCOPE void	TclResetFilesystem(void);
+MODULE_SCOPE void	TclFinalizeLoad(void);
+MODULE_SCOPE void	TclFinalizeLock(void);
+MODULE_SCOPE void	TclFinalizeMemorySubsystem(void);
+MODULE_SCOPE void	TclFinalizeNotifier(void);
+MODULE_SCOPE void	TclFinalizeObjects(void);
+MODULE_SCOPE void	TclFinalizePreserve(void);
+MODULE_SCOPE void	TclFinalizeSynchronization(void);
+MODULE_SCOPE void	TclFinalizeThreadAlloc(void);
+MODULE_SCOPE void	TclFinalizeThreadData(void);
+MODULE_SCOPE void	TclFinalizeThreadObjects(void);
+MODULE_SCOPE double	TclFloor(const mp_int *a);
+MODULE_SCOPE void	TclFormatNaN(double value, char *buffer);
+MODULE_SCOPE int	TclFSFileAttrIndex(Tcl_Obj *pathPtr,
+			    const char *attributeName, int *indexPtr);
+MODULE_SCOPE int	TclNREvalFile(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    const char *encodingName);
+MODULE_SCOPE void	TclFSUnloadTempFile(Tcl_LoadHandle loadHandle);
+MODULE_SCOPE int *	TclGetAsyncReadyPtr(void);
+MODULE_SCOPE Tcl_Obj *	TclGetBgErrorHandler(Tcl_Interp *interp);
+MODULE_SCOPE int	TclGetChannelFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *objPtr, Tcl_Channel *chanPtr,
+			    int *modePtr, int flags);
+MODULE_SCOPE int TclGetCompletionCodeFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *value, int *code);
+MODULE_SCOPE int	TclGetNumberFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *objPtr, ClientData *clientDataPtr,
+			    int *typePtr);
+MODULE_SCOPE int	TclGetOpenModeEx(Tcl_Interp *interp,
+			    const char *modeString, int *seekFlagPtr,
+			    int *binaryPtr);
+MODULE_SCOPE Tcl_Obj *	TclGetProcessGlobalValue(ProcessGlobalValue *pgvPtr);
+MODULE_SCOPE const char *TclGetSrcInfoForCmd(Interp *iPtr, int *lenPtr);
+MODULE_SCOPE int	TclGlob(Tcl_Interp *interp, char *pattern,
+			    Tcl_Obj *unquotedPrefix, int globFlags,
+			    Tcl_GlobTypeData *types);
+MODULE_SCOPE int	TclIncrObj(Tcl_Interp *interp, Tcl_Obj *valuePtr,
+			    Tcl_Obj *incrPtr);
+MODULE_SCOPE Tcl_Obj *	TclIncrObjVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr, int flags);
+MODULE_SCOPE int	TclInfoExistsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclInfoCoroutineCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Obj *	TclInfoFrame(Tcl_Interp *interp, CmdFrame *framePtr);
+MODULE_SCOPE int	TclInfoGlobalsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclInfoLocalsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclInfoVarsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TclInitAlloc(void);
+MODULE_SCOPE void	TclInitDbCkalloc(void);
+MODULE_SCOPE void	TclInitDoubleConversion(void);
+MODULE_SCOPE void	TclInitEmbeddedConfigurationInformation(
+			    Tcl_Interp *interp);
+MODULE_SCOPE void	TclInitEncodingSubsystem(void);
+MODULE_SCOPE void	TclInitIOSubsystem(void);
+MODULE_SCOPE void	TclInitLimitSupport(Tcl_Interp *interp);
+MODULE_SCOPE void	TclInitNamespaceSubsystem(void);
+MODULE_SCOPE void	TclInitNotifier(void);
+MODULE_SCOPE void	TclInitObjSubsystem(void);
+MODULE_SCOPE void	TclInitSubsystems(void);
+MODULE_SCOPE int	TclInterpReady(Tcl_Interp *interp);
+MODULE_SCOPE int	TclIsLocalScalar(const char *src, int len);
+MODULE_SCOPE int	TclIsSpaceProc(char byte);
+MODULE_SCOPE Tcl_Obj *	TclJoinPath(int elements, Tcl_Obj * const objv[]);
+MODULE_SCOPE int	TclJoinThread(Tcl_ThreadId id, int *result);
+MODULE_SCOPE void	TclLimitRemoveAllHandlers(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_Obj *	TclLindexList(Tcl_Interp *interp,
+			    Tcl_Obj *listPtr, Tcl_Obj *argPtr);
+MODULE_SCOPE Tcl_Obj *	TclLindexFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    int indexCount, Tcl_Obj *const indexArray[]);
+/* TIP #280 */
+MODULE_SCOPE void	TclListLines(Tcl_Obj *listObj, int line, int n,
+			    int *lines, Tcl_Obj *const *elems);
+MODULE_SCOPE Tcl_Obj *	TclListObjCopy(Tcl_Interp *interp, Tcl_Obj *listPtr);
+MODULE_SCOPE Tcl_Obj *	TclLsetList(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    Tcl_Obj *indexPtr, Tcl_Obj *valuePtr);
+MODULE_SCOPE Tcl_Obj *	TclLsetFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    int indexCount, Tcl_Obj *const indexArray[],
+			    Tcl_Obj *valuePtr);
+MODULE_SCOPE Tcl_Command TclMakeEnsemble(Tcl_Interp *interp, const char *name,
+			    const EnsembleImplMap map[]);
+MODULE_SCOPE int	TclMaxListLength(const char *bytes, int numBytes,
+			    const char **endPtr);
+MODULE_SCOPE int	TclMergeReturnOptions(Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[], Tcl_Obj **optionsPtrPtr,
+			    int *codePtr, int *levelPtr);
+MODULE_SCOPE Tcl_Obj *  TclNoErrorStack(Tcl_Interp *interp, Tcl_Obj *options);
+MODULE_SCOPE int	TclNokia770Doubles(void);
+MODULE_SCOPE void	TclNsDecrRefCount(Namespace *nsPtr);
+MODULE_SCOPE void	TclObjVarErrMsg(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, const char *operation,
+			    const char *reason, int index);
+MODULE_SCOPE int	TclObjInvokeNamespace(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[],
+			    Tcl_Namespace *nsPtr, int flags);
+MODULE_SCOPE int	TclObjUnsetVar2(Tcl_Interp *interp,
+			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags);
+MODULE_SCOPE int	TclParseBackslash(const char *src,
+			    int numBytes, int *readPtr, char *dst);
+MODULE_SCOPE int	TclParseHex(const char *src, int numBytes,
+			    int *resultPtr);
+MODULE_SCOPE int	TclParseNumber(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    const char *expected, const char *bytes,
+			    int numBytes, const char **endPtrPtr, int flags);
+MODULE_SCOPE void	TclParseInit(Tcl_Interp *interp, const char *string,
+			    int numBytes, Tcl_Parse *parsePtr);
+MODULE_SCOPE int	TclParseAllWhiteSpace(const char *src, int numBytes);
+MODULE_SCOPE int	TclProcessReturn(Tcl_Interp *interp,
+			    int code, int level, Tcl_Obj *returnOpts);
+MODULE_SCOPE int	TclpObjLstat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);
+MODULE_SCOPE Tcl_Obj *	TclpTempFileName(void);
+MODULE_SCOPE Tcl_Obj *  TclpTempFileNameForLibrary(Tcl_Interp *interp, Tcl_Obj* pathPtr);
+MODULE_SCOPE Tcl_Obj *	TclNewFSPathObj(Tcl_Obj *dirPtr, const char *addStrRep,
+			    int len);
+MODULE_SCOPE int	TclpDeleteFile(const void *path);
+MODULE_SCOPE void	TclpFinalizeCondition(Tcl_Condition *condPtr);
+MODULE_SCOPE void	TclpFinalizeMutex(Tcl_Mutex *mutexPtr);
+MODULE_SCOPE void	TclpFinalizePipes(void);
+MODULE_SCOPE void	TclpFinalizeSockets(void);
+MODULE_SCOPE int	TclCreateSocketAddress(Tcl_Interp *interp,
+			    struct addrinfo **addrlist,
+			    const char *host, int port, int willBind,
+			    const char **errorMsgPtr);
+MODULE_SCOPE int	TclpThreadCreate(Tcl_ThreadId *idPtr,
+			    Tcl_ThreadCreateProc *proc, ClientData clientData,
+			    int stackSize, int flags);
+MODULE_SCOPE int	TclpFindVariable(const char *name, int *lengthPtr);
+MODULE_SCOPE void	TclpInitLibraryPath(char **valuePtr,
+			    int *lengthPtr, Tcl_Encoding *encodingPtr);
+MODULE_SCOPE void	TclpInitLock(void);
+MODULE_SCOPE void	TclpInitPlatform(void);
+MODULE_SCOPE void	TclpInitUnlock(void);
+MODULE_SCOPE Tcl_Obj *	TclpObjListVolumes(void);
+MODULE_SCOPE void	TclpMasterLock(void);
+MODULE_SCOPE void	TclpMasterUnlock(void);
+MODULE_SCOPE int	TclpMatchFiles(Tcl_Interp *interp, char *separators,
+			    Tcl_DString *dirPtr, char *pattern, char *tail);
+MODULE_SCOPE int	TclpObjNormalizePath(Tcl_Interp *interp,
+			    Tcl_Obj *pathPtr, int nextCheckpoint);
+MODULE_SCOPE void	TclpNativeJoinPath(Tcl_Obj *prefix, const char *joining);
+MODULE_SCOPE Tcl_Obj *	TclpNativeSplitPath(Tcl_Obj *pathPtr, int *lenPtr);
+MODULE_SCOPE Tcl_PathType TclpGetNativePathType(Tcl_Obj *pathPtr,
+			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef);
+MODULE_SCOPE int	TclCrossFilesystemCopy(Tcl_Interp *interp,
+			    Tcl_Obj *source, Tcl_Obj *target);
+MODULE_SCOPE int	TclpMatchInDirectory(Tcl_Interp *interp,
+			    Tcl_Obj *resultPtr, Tcl_Obj *pathPtr,
+			    const char *pattern, Tcl_GlobTypeData *types);
+MODULE_SCOPE ClientData	TclpGetNativeCwd(ClientData clientData);
+MODULE_SCOPE Tcl_FSDupInternalRepProc TclNativeDupInternalRep;
+MODULE_SCOPE Tcl_Obj *	TclpObjLink(Tcl_Obj *pathPtr, Tcl_Obj *toPtr,
+			    int linkType);
+MODULE_SCOPE int	TclpObjChdir(Tcl_Obj *pathPtr);
+MODULE_SCOPE Tcl_Channel TclpOpenTemporaryFile(Tcl_Obj *dirObj,
+			    Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+			    Tcl_Obj *resultingNameObj);
+MODULE_SCOPE Tcl_Obj *	TclPathPart(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    Tcl_PathPart portion);
+MODULE_SCOPE char *	TclpReadlink(const char *fileName,
+			    Tcl_DString *linkPtr);
+MODULE_SCOPE void	TclpSetInterfaces(void);
+MODULE_SCOPE void	TclpSetVariables(Tcl_Interp *interp);
+MODULE_SCOPE void *	TclThreadStorageKeyGet(Tcl_ThreadDataKey *keyPtr);
+MODULE_SCOPE void	TclThreadStorageKeySet(Tcl_ThreadDataKey *keyPtr,
+			    void *data);
+MODULE_SCOPE void	TclpThreadExit(int status);
+MODULE_SCOPE void	TclRememberCondition(Tcl_Condition *mutex);
+MODULE_SCOPE void	TclRememberJoinableThread(Tcl_ThreadId id);
+MODULE_SCOPE void	TclRememberMutex(Tcl_Mutex *mutex);
+MODULE_SCOPE void	TclRemoveScriptLimitCallbacks(Tcl_Interp *interp);
+MODULE_SCOPE int	TclReToGlob(Tcl_Interp *interp, const char *reStr,
+			    int reStrLen, Tcl_DString *dsPtr, int *flagsPtr);
+MODULE_SCOPE int	TclScanElement(const char *string, int length,
+			    int *flagPtr);
+MODULE_SCOPE void	TclSetBgErrorHandler(Tcl_Interp *interp,
+			    Tcl_Obj *cmdPrefix);
+MODULE_SCOPE void	TclSetBignumIntRep(Tcl_Obj *objPtr,
+			    mp_int *bignumValue);
+MODULE_SCOPE void	TclSetCmdNameObj(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    Command *cmdPtr);
+MODULE_SCOPE void	TclSetDuplicateObj(Tcl_Obj *dupPtr, Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclSetProcessGlobalValue(ProcessGlobalValue *pgvPtr,
+			    Tcl_Obj *newValue, Tcl_Encoding encoding);
+MODULE_SCOPE void	TclSignalExitThread(Tcl_ThreadId id, int result);
+MODULE_SCOPE void *	TclStackRealloc(Tcl_Interp *interp, void *ptr,
+			    int numBytes);
+MODULE_SCOPE int	TclStringMatch(const char *str, int strLen,
+			    const char *pattern, int ptnLen, int flags);
+MODULE_SCOPE int	TclStringMatchObj(Tcl_Obj *stringObj,
+			    Tcl_Obj *patternObj, int flags);
+MODULE_SCOPE Tcl_Obj *	TclStringObjReverse(Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclSubstCompile(Tcl_Interp *interp, const char *bytes,
+			    int numBytes, int flags, int line,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclSubstOptions(Tcl_Interp *interp, int numOpts,
+			    Tcl_Obj *const opts[], int *flagPtr);
+MODULE_SCOPE void	TclSubstParse(Tcl_Interp *interp, const char *bytes,
+			    int numBytes, int flags, Tcl_Parse *parsePtr,
+			    Tcl_InterpState *statePtr);
+MODULE_SCOPE int	TclSubstTokens(Tcl_Interp *interp, Tcl_Token *tokenPtr,
+			    int count, int *tokensLeftPtr, int line,
+			    int *clNextOuter, const char *outerScript);
+MODULE_SCOPE int	TclTrimLeft(const char *bytes, int numBytes,
+			    const char *trim, int numTrim);
+MODULE_SCOPE int	TclTrimRight(const char *bytes, int numBytes,
+			    const char *trim, int numTrim);
+MODULE_SCOPE Tcl_Obj *	TclpNativeToNormalized(ClientData clientData);
+MODULE_SCOPE Tcl_Obj *	TclpFilesystemPathType(Tcl_Obj *pathPtr);
+MODULE_SCOPE int	TclpDlopen(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    Tcl_LoadHandle *loadHandle,
+			    Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
+MODULE_SCOPE int	TclpUtime(Tcl_Obj *pathPtr, struct utimbuf *tval);
+#ifdef TCL_LOAD_FROM_MEMORY
+MODULE_SCOPE void *	TclpLoadMemoryGetBuffer(Tcl_Interp *interp, int size);
+MODULE_SCOPE int	TclpLoadMemory(Tcl_Interp *interp, void *buffer,
+			    int size, int codeSize, Tcl_LoadHandle *loadHandle,
+			    Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
+#endif
+MODULE_SCOPE void	TclInitThreadStorage(void);
+MODULE_SCOPE void	TclFinalizeThreadDataThread(void);
+MODULE_SCOPE void	TclFinalizeThreadStorage(void);
+#ifdef TCL_WIDE_CLICKS
+MODULE_SCOPE Tcl_WideInt TclpGetWideClicks(void);
+MODULE_SCOPE double	TclpWideClicksToNanoseconds(Tcl_WideInt clicks);
+#endif
+MODULE_SCOPE Tcl_Obj *	TclDisassembleByteCodeObj(Tcl_Obj *objPtr);
+MODULE_SCOPE int	TclZlibInit(Tcl_Interp *interp);
+MODULE_SCOPE void *	TclpThreadCreateKey(void);
+MODULE_SCOPE void	TclpThreadDeleteKey(void *keyPtr);
+MODULE_SCOPE void	TclpThreadSetMasterTSD(void *tsdKeyPtr, void *ptr);
+MODULE_SCOPE void *	TclpThreadGetMasterTSD(void *tsdKeyPtr);
+
+MODULE_SCOPE void	TclErrorStackResetIf(Tcl_Interp *interp, const char *msg, int length);
+
+/*
+ *----------------------------------------------------------------
+ * Command procedures in the generic core:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE int	Tcl_AfterObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_AppendObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ApplyObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitArrayCmd(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_Command TclInitBinaryCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_BreakObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CaseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CatchObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CdObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitChanCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclChanCreateObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclChanPostEventObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclChanPopObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclChanPushObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TclClockInit(Tcl_Interp *interp);
+MODULE_SCOPE int	TclClockOldscanObjCmd(
+			    ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CloseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ConcatObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ContinueObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_TimerToken TclCreateAbsoluteTimerHandler(
+			    Tcl_Time *timePtr, Tcl_TimerProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE int	TclDefaultBgErrorHandlerObjCmd(
+			    ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitDictCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclDictWithFinish(Tcl_Interp *interp, Var *varPtr,
+			    Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, int index, int pathc,
+			    Tcl_Obj *const pathv[], Tcl_Obj *keysPtr);
+MODULE_SCOPE Tcl_Obj *	TclDictWithInit(Tcl_Interp *interp, Tcl_Obj *dictPtr,
+			    int pathc, Tcl_Obj *const pathv[]);
+MODULE_SCOPE int	Tcl_DisassembleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+			    
+/* Assemble command function */			    
+MODULE_SCOPE int	Tcl_AssembleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);			    
+MODULE_SCOPE int	TclNRAssembleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);			    
+			    
+MODULE_SCOPE int	Tcl_EncodingObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_EofObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ErrorObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_EvalObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ExecObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ExitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ExprObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FblockedObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FconfigureObjCmd(
+			    ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FcopyObjCmd(ClientData dummy,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitFileCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclMakeFileCommandSafe(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_FileEventObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FlushObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ForObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ForeachObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FormatObjCmd(ClientData dummy,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_GetsObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_GlobalObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_GlobObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_IfObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_IncrObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitInfoCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_InterpObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_JoinObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LappendObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LassignObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LindexObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LinsertObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LlengthObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ListObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LmapObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LoadObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LrangeObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LrepeatObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LreplaceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LreverseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LsearchObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LsetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LsortObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitNamespaceCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclNamespaceEnsembleCmd(ClientData dummy,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_OpenObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PackageObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PidObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitPrefixCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_PutsObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PwdObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ReadObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RegexpObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RegsubObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RenameObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RepresentationCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ReturnObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ScanObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SeekObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SplitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SocketObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SourceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitStringCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_SubstObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SwitchObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TellObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ThrowObjCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TimeObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TraceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TryObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UnloadObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UnsetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UpdateObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UplevelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UpvarObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_VariableObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_VwaitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_WhileObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+
+/*
+ *----------------------------------------------------------------
+ * Compilation procedures for commands in the generic core:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE int	TclCompileAppendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileArrayExistsCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileArraySetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileArrayUnsetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileBreakCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileCatchCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileContinueCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictAppendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictCreateCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictExistsCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictForCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictGetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictIncrCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictLappendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictMapCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictMergeCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictSetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictUnsetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictUpdateCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictWithCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileEnsemble(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileErrorCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileExprCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileForCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileForeachCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileFormatCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileGlobalCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileIfCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoCommandsCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoCoroutineCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoExistsCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoLevelCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoObjectClassCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoObjectIsACmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoObjectNamespaceCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileIncrCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLappendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLassignCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLindexCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileListCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLlengthCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLmapCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLrangeCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLreplaceCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLsetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceCodeCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceCurrentCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceQualifiersCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceTailCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceUpvarCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceWhichCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNoOp(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileObjectSelfCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileRegexpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileRegsubCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileReturnCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileSetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringCmpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringEqualCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringFirstCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringIndexCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringLastCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringLenCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringMapCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringMatchCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringRangeCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileSubstCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileSwitchCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileTailcallCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileThrowCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileTryCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileUnsetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileUpvarCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileVariableCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileWhileCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileYieldCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+
+MODULE_SCOPE int	TclInvertOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileInvertOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclNotOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileNotOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclAddOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileAddOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclMulOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileMulOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclAndOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileAndOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclOrOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileOrOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclXorOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileXorOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclPowOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompilePowOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclLshiftOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileLshiftOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclRshiftOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileRshiftOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclModOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileModOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclNeqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileNeqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclStrneqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileStrneqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclInOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileInOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclNiOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileNiOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclMinusOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileMinusOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclDivOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileDivOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclLessOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileLessOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclLeqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileLeqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclGreaterOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileGreaterOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclGeqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileGeqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclEqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileEqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclStreqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileStreqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+			    
+MODULE_SCOPE int	TclCompileAssembleCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+
+/*
+ * Functions defined in generic/tclVar.c and currenttly exported only for use
+ * by the bytecode compiler and engine. Some of these could later be placed in
+ * the public interface.
+ */
+
+MODULE_SCOPE Var *	TclObjLookupVarEx(Tcl_Interp * interp,
+			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags,
+			    const char *msg, const int createPart1,
+			    const int createPart2, Var **arrayPtrPtr);
+MODULE_SCOPE Var *	TclLookupArrayElement(Tcl_Interp *interp,
+			    Tcl_Obj *arrayNamePtr, Tcl_Obj *elNamePtr,
+			    const int flags, const char *msg,
+			    const int createPart1, const int createPart2,
+			    Var *arrayPtr, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrGetVar(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, const int flags, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrSetVar(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr,
+			    const int flags, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrIncrObjVar(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr,
+			    const int flags, int index);
+MODULE_SCOPE int	TclPtrObjMakeUpvar(Tcl_Interp *interp, Var *otherPtr,
+			    Tcl_Obj *myNamePtr, int myFlags, int index);
+MODULE_SCOPE int	TclPtrUnsetVar(Tcl_Interp *interp, Var *varPtr,
+			    Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, const int flags,
+			    int index);
+MODULE_SCOPE void	TclInvalidateNsPath(Namespace *nsPtr);
+
+/*
+ * The new extended interface to the variable traces.
+ */
+
+MODULE_SCOPE int	TclObjCallVarTraces(Interp *iPtr, Var *arrayPtr,
+			    Var *varPtr, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr,
+			    int flags, int leaveErrMsg, int index);
+
+/*
+ * So tclObj.c and tclDictObj.c can share these implementations.
+ */
+
+MODULE_SCOPE int	TclCompareObjKeys(void *keyPtr, Tcl_HashEntry *hPtr);
+MODULE_SCOPE void	TclFreeObjEntry(Tcl_HashEntry *hPtr);
+MODULE_SCOPE unsigned	TclHashObjKey(Tcl_HashTable *tablePtr, void *keyPtr);
+
+MODULE_SCOPE int	TclFullFinalizationRequested(void);
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to create and release Tcl objects.
+ * TclNewObj(objPtr) creates a new object denoting an empty string.
+ * TclDecrRefCount(objPtr) decrements the object's reference count, and frees
+ * the object if its reference count is zero. These macros are inline versions
+ * of Tcl_NewObj() and Tcl_DecrRefCount(). Notice that the names differ in not
+ * having a "_" after the "Tcl". Notice also that these macros reference their
+ * argument more than once, so you should avoid calling them with an
+ * expression that is expensive to compute or has side effects. The ANSI C
+ * "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclNewObj(Tcl_Obj *objPtr);
+ * MODULE_SCOPE void	TclDecrRefCount(Tcl_Obj *objPtr);
+ *
+ * These macros are defined in terms of two macros that depend on memory
+ * allocator in use: TclAllocObjStorage, TclFreeObjStorage. They are defined
+ * below.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * DTrace object allocation probe macros.
+ */
+
+#ifdef USE_DTRACE
+#ifndef _TCLDTRACE_H
+typedef const char *TclDTraceStr;
+#include "tclDTrace.h"
+#endif
+#define	TCL_DTRACE_OBJ_CREATE(objPtr)	TCL_OBJ_CREATE(objPtr)
+#define	TCL_DTRACE_OBJ_FREE(objPtr)	TCL_OBJ_FREE(objPtr)
+#else /* USE_DTRACE */
+#define	TCL_DTRACE_OBJ_CREATE(objPtr)	{}
+#define	TCL_DTRACE_OBJ_FREE(objPtr)	{}
+#endif /* USE_DTRACE */
+
+#ifdef TCL_COMPILE_STATS
+#  define TclIncrObjsAllocated() \
+    tclObjsAlloced++
+#  define TclIncrObjsFreed() \
+    tclObjsFreed++
+#else
+#  define TclIncrObjsAllocated()
+#  define TclIncrObjsFreed()
+#endif /* TCL_COMPILE_STATS */
+
+#  define TclAllocObjStorage(objPtr)		\
+	TclAllocObjStorageEx(NULL, (objPtr))
+
+#  define TclFreeObjStorage(objPtr)		\
+	TclFreeObjStorageEx(NULL, (objPtr))
+
+#ifndef TCL_MEM_DEBUG
+# define TclNewObj(objPtr) \
+    TclIncrObjsAllocated(); \
+    TclAllocObjStorage(objPtr); \
+    (objPtr)->refCount = 0; \
+    (objPtr)->bytes    = tclEmptyStringRep; \
+    (objPtr)->length   = 0; \
+    (objPtr)->typePtr  = NULL; \
+    TCL_DTRACE_OBJ_CREATE(objPtr)
+
+/*
+ * Invalidate the string rep first so we can use the bytes value for our
+ * pointer chain, and signal an obj deletion (as opposed to shimmering) with
+ * 'length == -1'.
+ * Use empty 'if ; else' to handle use in unbraced outer if/else conditions.
+ */
+
+# define TclDecrRefCount(objPtr) \
+    if (--(objPtr)->refCount > 0) ; else { \
+	if (!(objPtr)->typePtr || !(objPtr)->typePtr->freeIntRepProc) { \
+	    TCL_DTRACE_OBJ_FREE(objPtr); \
+	    if ((objPtr)->bytes \
+		    && ((objPtr)->bytes != tclEmptyStringRep)) { \
+		ckfree((char *) (objPtr)->bytes); \
+	    } \
+	    (objPtr)->length = -1; \
+	    TclFreeObjStorage(objPtr); \
+	    TclIncrObjsFreed(); \
+	} else { \
+	    TclFreeObj(objPtr); \
+	} \
+    }
+
+#if defined(PURIFY)
+
+/*
+ * The PURIFY mode is like the regular mode, but instead of doing block
+ * Tcl_Obj allocation and keeping a freed list for efficiency, it always
+ * allocates and frees a single Tcl_Obj so that tools like Purify can better
+ * track memory leaks.
+ */
+
+#  define TclAllocObjStorageEx(interp, objPtr) \
+	(objPtr) = (Tcl_Obj *) Tcl_Alloc(sizeof(Tcl_Obj))
+
+#  define TclFreeObjStorageEx(interp, objPtr) \
+	ckfree((char *) (objPtr))
+
+#undef USE_THREAD_ALLOC
+#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)
+
+/*
+ * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's from
+ * per-thread caches.
+ */
+
+MODULE_SCOPE Tcl_Obj *	TclThreadAllocObj(void);
+MODULE_SCOPE void	TclThreadFreeObj(Tcl_Obj *);
+MODULE_SCOPE Tcl_Mutex *TclpNewAllocMutex(void);
+MODULE_SCOPE void	TclFreeAllocCache(void *);
+MODULE_SCOPE void *	TclpGetAllocCache(void);
+MODULE_SCOPE void	TclpSetAllocCache(void *);
+MODULE_SCOPE void	TclpFreeAllocMutex(Tcl_Mutex *mutex);
+MODULE_SCOPE void	TclpFreeAllocCache(void *);
+
+/*
+ * These macros need to be kept in sync with the code of TclThreadAllocObj()
+ * and TclThreadFreeObj().
+ *
+ * Note that the optimiser should resolve the case (interp==NULL) at compile
+ * time.
+ */
+
+#  define ALLOC_NOBJHIGH 1200
+
+#  define TclAllocObjStorageEx(interp, objPtr)				\
+    do {								\
+	AllocCache *cachePtr;						\
+	if (((interp) == NULL) ||					\
+		((cachePtr = ((Interp *)(interp))->allocCache),		\
+			(cachePtr->numObjects == 0))) {			\
+	    (objPtr) = TclThreadAllocObj();				\
+	} else {							\
+	    (objPtr) = cachePtr->firstObjPtr;				\
+	    cachePtr->firstObjPtr = (objPtr)->internalRep.otherValuePtr; \
+	    --cachePtr->numObjects;					\
+	}								\
+    } while (0)
+
+#  define TclFreeObjStorageEx(interp, objPtr)				\
+    do {								\
+	AllocCache *cachePtr;						\
+	if (((interp) == NULL) ||					\
+		((cachePtr = ((Interp *)(interp))->allocCache),		\
+			(cachePtr->numObjects >= ALLOC_NOBJHIGH))) {	\
+	    TclThreadFreeObj(objPtr);					\
+	} else {							\
+	    (objPtr)->internalRep.otherValuePtr = cachePtr->firstObjPtr; \
+	    cachePtr->firstObjPtr = objPtr;				\
+	    ++cachePtr->numObjects;					\
+	}								\
+    } while (0)
+
+#else /* not PURIFY or USE_THREAD_ALLOC */
+
+#if defined(USE_TCLALLOC) && USE_TCLALLOC
+    MODULE_SCOPE void TclFinalizeAllocSubsystem();
+    MODULE_SCOPE void TclInitAlloc();
+#else
+#   define USE_TCLALLOC 0
+#endif
+
+#ifdef TCL_THREADS
+/* declared in tclObj.c */
+MODULE_SCOPE Tcl_Mutex	tclObjMutex;
+#endif
+
+#  define TclAllocObjStorageEx(interp, objPtr) \
+    do {								\
+	Tcl_MutexLock(&tclObjMutex);					\
+	if (tclFreeObjList == NULL) {					\
+	    TclAllocateFreeObjects();					\
+	}								\
+	(objPtr) = tclFreeObjList;					\
+	tclFreeObjList = (Tcl_Obj *)					\
+		tclFreeObjList->internalRep.otherValuePtr;		\
+	Tcl_MutexUnlock(&tclObjMutex);					\
+    } while (0)
+
+#  define TclFreeObjStorageEx(interp, objPtr) \
+    do {							       \
+	Tcl_MutexLock(&tclObjMutex);				       \
+	(objPtr)->internalRep.otherValuePtr = (void *) tclFreeObjList; \
+	tclFreeObjList = (objPtr);				       \
+	Tcl_MutexUnlock(&tclObjMutex);				       \
+    } while (0)
+#endif
+
+#else /* TCL_MEM_DEBUG */
+MODULE_SCOPE void	TclDbInitNewObj(Tcl_Obj *objPtr, const char *file,
+			    int line);
+
+# define TclDbNewObj(objPtr, file, line) \
+    do { \
+	TclIncrObjsAllocated();						\
+	(objPtr) = (Tcl_Obj *)						\
+		Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line));		\
+	TclDbInitNewObj((objPtr), (file), (line));			\
+	TCL_DTRACE_OBJ_CREATE(objPtr);					\
+    } while (0)
+
+# define TclNewObj(objPtr) \
+    TclDbNewObj(objPtr, __FILE__, __LINE__);
+
+# define TclDecrRefCount(objPtr) \
+    Tcl_DbDecrRefCount(objPtr, __FILE__, __LINE__)
+
+# define TclNewListObjDirect(objc, objv) \
+    TclDbNewListObjDirect(objc, objv, __FILE__, __LINE__)
+
+#undef USE_THREAD_ALLOC
+#endif /* TCL_MEM_DEBUG */
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to set a Tcl_Obj's string representation to a
+ * copy of the "len" bytes starting at "bytePtr". This code works even if the
+ * byte array contains NULLs as long as the length is correct. Because "len"
+ * is referenced multiple times, it should be as simple an expression as
+ * possible. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void TclInitStringRep(Tcl_Obj *objPtr, char *bytePtr, int len);
+ *
+ * This macro should only be called on an unshared objPtr where
+ *  objPtr->typePtr->freeIntRepProc == NULL
+ *----------------------------------------------------------------
+ */
+
+#define TclInitStringRep(objPtr, bytePtr, len) \
+    if ((len) == 0) { \
+	(objPtr)->bytes	 = tclEmptyStringRep; \
+	(objPtr)->length = 0; \
+    } else { \
+	(objPtr)->bytes = (char *) ckalloc((unsigned) ((len) + 1)); \
+	memcpy((objPtr)->bytes, (bytePtr), (unsigned) (len)); \
+	(objPtr)->bytes[len] = '\0'; \
+	(objPtr)->length = (len); \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to get the string representation's byte array
+ * pointer from a Tcl_Obj. This is an inline version of Tcl_GetString(). The
+ * macro's expression result is the string rep's byte pointer which might be
+ * NULL. The bytes referenced by this pointer must not be modified by the
+ * caller. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE char *	TclGetString(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclGetString(objPtr) \
+    ((objPtr)->bytes? (objPtr)->bytes : Tcl_GetString((objPtr)))
+
+#define TclGetStringFromObj(objPtr, lenPtr) \
+    ((objPtr)->bytes \
+	    ? (*(lenPtr) = (objPtr)->length, (objPtr)->bytes)	\
+	    : Tcl_GetStringFromObj((objPtr), (lenPtr)))
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to clean out an object's internal
+ * representation. Does not actually reset the rep's bytes. The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclFreeIntRep(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclFreeIntRep(objPtr) \
+    if ((objPtr)->typePtr != NULL) { \
+	if ((objPtr)->typePtr->freeIntRepProc != NULL) { \
+	    (objPtr)->typePtr->freeIntRepProc(objPtr); \
+	} \
+	(objPtr)->typePtr = NULL; \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to clean out an object's string representation.
+ * The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclInvalidateStringRep(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclInvalidateStringRep(objPtr) \
+    if (objPtr->bytes != NULL) { \
+	if (objPtr->bytes != tclEmptyStringRep) { \
+	    ckfree((char *) objPtr->bytes); \
+	} \
+	objPtr->bytes = NULL; \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to grow Tcl_Token arrays. They use the same
+ * growth algorithm as used in tclStringObj.c for growing strings. The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclGrowTokenArray(Tcl_Token *tokenPtr, int used,
+ *				int available, int append,
+ *				Tcl_Token *staticPtr);
+ * MODULE_SCOPE void	TclGrowParseTokenArray(Tcl_Parse *parsePtr,
+ *				int append);
+ *----------------------------------------------------------------
+ */
+
+/* General tuning for minimum growth in Tcl growth algorithms */
+#ifndef TCL_MIN_GROWTH
+#  ifdef TCL_GROWTH_MIN_ALLOC
+     /* Support for any legacy tuners */
+#    define TCL_MIN_GROWTH TCL_GROWTH_MIN_ALLOC
+#  else
+#    define TCL_MIN_GROWTH 1024
+#  endif
+#endif
+
+/* Token growth tuning, default to the general value. */
+#ifndef TCL_MIN_TOKEN_GROWTH
+#define TCL_MIN_TOKEN_GROWTH TCL_MIN_GROWTH/sizeof(Tcl_Token)
+#endif
+
+#define TCL_MAX_TOKENS (int)(UINT_MAX / sizeof(Tcl_Token))
+#define TclGrowTokenArray(tokenPtr, used, available, append, staticPtr)	\
+    do {								\
+	int needed = (used) + (append);					\
+	if (needed > TCL_MAX_TOKENS) {					\
+	    Tcl_Panic("max # of tokens for a Tcl parse (%d) exceeded",	\
+		    TCL_MAX_TOKENS);					\
+	}								\
+	if (needed > (available)) {					\
+	    int allocated = 2 * needed;					\
+	    Tcl_Token *oldPtr = (tokenPtr);				\
+	    Tcl_Token *newPtr;						\
+	    if (oldPtr == (staticPtr)) {				\
+		oldPtr = NULL;						\
+	    }								\
+	    if (allocated > TCL_MAX_TOKENS) {				\
+		allocated = TCL_MAX_TOKENS;				\
+	    }								\
+	    newPtr = (Tcl_Token *) attemptckrealloc((char *) oldPtr,	\
+		    (unsigned int) (allocated * sizeof(Tcl_Token)));	\
+	    if (newPtr == NULL) {					\
+		allocated = needed + (append) + TCL_MIN_TOKEN_GROWTH;	\
+		if (allocated > TCL_MAX_TOKENS) {			\
+		    allocated = TCL_MAX_TOKENS;				\
+		}							\
+		newPtr = (Tcl_Token *) ckrealloc((char *) oldPtr,	\
+			(unsigned int) (allocated * sizeof(Tcl_Token))); \
+	    }								\
+	    (available) = allocated;					\
+	    if (oldPtr == NULL) {					\
+		memcpy(newPtr, staticPtr,				\
+			(size_t) ((used) * sizeof(Tcl_Token)));		\
+	    }								\
+	    (tokenPtr) = newPtr;					\
+	}								\
+    } while (0)
+
+#define TclGrowParseTokenArray(parsePtr, append)			\
+    TclGrowTokenArray((parsePtr)->tokenPtr, (parsePtr)->numTokens,	\
+	    (parsePtr)->tokensAvailable, (append),			\
+	    (parsePtr)->staticTokens)
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core get a unicode char from a utf string. It checks
+ * to see if we have a one-byte utf char before calling the real
+ * Tcl_UtfToUniChar, as this will save a lot of time for primarily ASCII
+ * string handling. The macro's expression result is 1 for the 1-byte case or
+ * the result of Tcl_UtfToUniChar. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclUtfToUniChar(const char *string, Tcl_UniChar *ch);
+ *----------------------------------------------------------------
+ */
+
+#define TclUtfToUniChar(str, chPtr) \
+	((((unsigned char) *(str)) < 0xC0) ?		\
+	    ((*(chPtr) = (Tcl_UniChar) *(str)), 1)	\
+	    : Tcl_UtfToUniChar(str, chPtr))
+
+/*
+ *----------------------------------------------------------------
+ * Macro counterpart of the Tcl_NumUtfChars() function. To be used in speed-
+ * -sensitive points where it pays to avoid a function call in the common case
+ * of counting along a string of all one-byte characters.  The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclNumUtfChars(int numChars, const char *bytes,
+ *				int numBytes);
+ *----------------------------------------------------------------
+ */
+
+#define TclNumUtfChars(numChars, bytes, numBytes) \
+    do { \
+	int count, i = (numBytes); \
+	unsigned char *str = (unsigned char *) (bytes); \
+	while (i && (*str < 0xC0)) { i--; str++; } \
+	count = (numBytes) - i; \
+	if (i) { \
+	    count += Tcl_NumUtfChars((bytes) + count, i); \
+	} \
+	(numChars) = count; \
+    } while (0);
+
+/*
+ *----------------------------------------------------------------
+ * Macro that encapsulates the logic that determines when it is safe to
+ * interpret a string as a byte array directly. In summary, the object must be
+ * a byte array and must not have a string representation (as the operations
+ * that it is used in are defined on strings, not byte arrays). Theoretically
+ * it is possible to also be efficient in the case where the object's bytes
+ * field is filled by generation from the byte array (c.f. list canonicality)
+ * but we don't do that at the moment since this is purely about efficiency.
+ * The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclIsPureByteArray(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclIsPureByteArray(objPtr) \
+	(((objPtr)->typePtr==&tclByteArrayType) && ((objPtr)->bytes==NULL))
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to compare Unicode strings. On big-endian
+ * systems we can use the more efficient memcmp, but this would not be
+ * lexically correct on little-endian systems. The ANSI C "prototype" for
+ * this macro is:
+ *
+ * MODULE_SCOPE int	TclUniCharNcmp(const Tcl_UniChar *cs,
+ *			    const Tcl_UniChar *ct, unsigned long n);
+ *----------------------------------------------------------------
+ */
+
+#ifdef WORDS_BIGENDIAN
+#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
+#else /* !WORDS_BIGENDIAN */
+#   define TclUniCharNcmp Tcl_UniCharNcmp
+#endif /* WORDS_BIGENDIAN */
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to increment a namespace's export export epoch
+ * counter. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclInvalidateNsCmdLookup(Namespace *nsPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclInvalidateNsCmdLookup(nsPtr) \
+    if ((nsPtr)->numExportPatterns) {		\
+	(nsPtr)->exportLookupEpoch++;		\
+    }						\
+    if ((nsPtr)->commandPathLength) {		\
+	(nsPtr)->cmdRefEpoch++;			\
+    }
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Core procedures added to libtommath for bignum manipulation.
+ *
+ *----------------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_PackageInitProc TclTommath_Init;
+MODULE_SCOPE void	TclBNInitBignumFromLong(mp_int *bignum, long initVal);
+MODULE_SCOPE void	TclBNInitBignumFromWideInt(mp_int *bignum,
+			    Tcl_WideInt initVal);
+MODULE_SCOPE void	TclBNInitBignumFromWideUInt(mp_int *bignum,
+			    Tcl_WideUInt initVal);
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * External (platform specific) initialization routine, these declarations
+ * explicitly don't use EXTERN since this code does not get compiled into the
+ * library:
+ *
+ *----------------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_PackageInitProc TclplatformtestInit;
+MODULE_SCOPE Tcl_PackageInitProc TclObjTest_Init;
+MODULE_SCOPE Tcl_PackageInitProc TclThread_Init;
+MODULE_SCOPE Tcl_PackageInitProc Procbodytest_Init;
+MODULE_SCOPE Tcl_PackageInitProc Procbodytest_SafeInit;
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to check whether a pattern has any characters
+ * special to [string match]. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclMatchIsTrivial(const char *pattern);
+ *----------------------------------------------------------------
+ */
+
+#define TclMatchIsTrivial(pattern) \
+    (strpbrk((pattern), "*[?\\") == NULL)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to set a Tcl_Obj's numeric representation
+ * avoiding the corresponding function calls in time critical parts of the
+ * core. They should only be called on unshared objects. The ANSI C
+ * "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclSetIntObj(Tcl_Obj *objPtr, int intValue);
+ * MODULE_SCOPE void	TclSetLongObj(Tcl_Obj *objPtr, long longValue);
+ * MODULE_SCOPE void	TclSetBooleanObj(Tcl_Obj *objPtr, long boolValue);
+ * MODULE_SCOPE void	TclSetWideIntObj(Tcl_Obj *objPtr, Tcl_WideInt w);
+ * MODULE_SCOPE void	TclSetDoubleObj(Tcl_Obj *objPtr, double d);
+ *----------------------------------------------------------------
+ */
+
+#define TclSetIntObj(objPtr, i) \
+    do {						\
+	TclInvalidateStringRep(objPtr);			\
+	TclFreeIntRep(objPtr);				\
+	(objPtr)->internalRep.longValue = (long)(i);	\
+	(objPtr)->typePtr = &tclIntType;		\
+    } while (0)
+
+#define TclSetLongObj(objPtr, l) \
+    TclSetIntObj((objPtr), (l))
+
+/*
+ * NOTE: There is to be no such thing as a "pure" boolean. Boolean values set
+ * programmatically go straight to being "int" Tcl_Obj's, with value 0 or 1.
+ * The only "boolean" Tcl_Obj's shall be those holding the cached boolean
+ * value of strings like: "yes", "no", "true", "false", "on", "off".
+ */
+
+#define TclSetBooleanObj(objPtr, b) \
+    TclSetIntObj((objPtr), ((b)? 1 : 0));
+
+#ifndef NO_WIDE_TYPE
+#define TclSetWideIntObj(objPtr, w) \
+    do {							\
+	TclInvalidateStringRep(objPtr);				\
+	TclFreeIntRep(objPtr);					\
+	(objPtr)->internalRep.wideValue = (Tcl_WideInt)(w);	\
+	(objPtr)->typePtr = &tclWideIntType;			\
+    } while (0)
+#endif
+
+#define TclSetDoubleObj(objPtr, d) \
+    do {							\
+	TclInvalidateStringRep(objPtr);				\
+	TclFreeIntRep(objPtr);					\
+	(objPtr)->internalRep.doubleValue = (double)(d);	\
+	(objPtr)->typePtr = &tclDoubleType;			\
+    } while (0)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to create and initialise objects of standard
+ * types, avoiding the corresponding function calls in time critical parts of
+ * the core. The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclNewIntObj(Tcl_Obj *objPtr, int i);
+ * MODULE_SCOPE void	TclNewLongObj(Tcl_Obj *objPtr, long l);
+ * MODULE_SCOPE void	TclNewBooleanObj(Tcl_Obj *objPtr, int b);
+ * MODULE_SCOPE void	TclNewWideObj(Tcl_Obj *objPtr, Tcl_WideInt w);
+ * MODULE_SCOPE void	TclNewDoubleObj(Tcl_Obj *objPtr, double d);
+ * MODULE_SCOPE void	TclNewStringObj(Tcl_Obj *objPtr, char *s, int len);
+ * MODULE_SCOPE void	TclNewLiteralStringObj(Tcl_Obj*objPtr, char*sLiteral);
+ *
+ *----------------------------------------------------------------
+ */
+
+#ifndef TCL_MEM_DEBUG
+#define TclNewIntObj(objPtr, i) \
+    do {						\
+	TclIncrObjsAllocated();				\
+	TclAllocObjStorage(objPtr);			\
+	(objPtr)->refCount = 0;				\
+	(objPtr)->bytes = NULL;				\
+	(objPtr)->internalRep.longValue = (long)(i);	\
+	(objPtr)->typePtr = &tclIntType;		\
+	TCL_DTRACE_OBJ_CREATE(objPtr);			\
+    } while (0)
+
+#define TclNewLongObj(objPtr, l) \
+    TclNewIntObj((objPtr), (l))
+
+/*
+ * NOTE: There is to be no such thing as a "pure" boolean.
+ * See comment above TclSetBooleanObj macro above.
+ */
+#define TclNewBooleanObj(objPtr, b) \
+    TclNewIntObj((objPtr), ((b)? 1 : 0))
+
+#define TclNewDoubleObj(objPtr, d) \
+    do {							\
+	TclIncrObjsAllocated();					\
+	TclAllocObjStorage(objPtr);				\
+	(objPtr)->refCount = 0;					\
+	(objPtr)->bytes = NULL;					\
+	(objPtr)->internalRep.doubleValue = (double)(d);	\
+	(objPtr)->typePtr = &tclDoubleType;			\
+	TCL_DTRACE_OBJ_CREATE(objPtr);				\
+    } while (0)
+
+#define TclNewStringObj(objPtr, s, len) \
+    do {							\
+	TclIncrObjsAllocated();					\
+	TclAllocObjStorage(objPtr);				\
+	(objPtr)->refCount = 0;					\
+	TclInitStringRep((objPtr), (s), (len));			\
+	(objPtr)->typePtr = NULL;				\
+	TCL_DTRACE_OBJ_CREATE(objPtr);				\
+    } while (0)
+
+#else /* TCL_MEM_DEBUG */
+#define TclNewIntObj(objPtr, i) \
+    (objPtr) = Tcl_NewIntObj(i)
+
+#define TclNewLongObj(objPtr, l) \
+    (objPtr) = Tcl_NewLongObj(l)
+
+#define TclNewBooleanObj(objPtr, b) \
+    (objPtr) = Tcl_NewBooleanObj(b)
+
+#define TclNewDoubleObj(objPtr, d) \
+    (objPtr) = Tcl_NewDoubleObj(d)
+
+#define TclNewStringObj(objPtr, s, len) \
+    (objPtr) = Tcl_NewStringObj((s), (len))
+#endif /* TCL_MEM_DEBUG */
+
+/*
+ * The sLiteral argument *must* be a string literal; the incantation with
+ * sizeof(sLiteral "") will fail to compile otherwise.
+ */
+#define TclNewLiteralStringObj(objPtr, sLiteral) \
+    TclNewStringObj((objPtr), (sLiteral), (int) (sizeof(sLiteral "") - 1))
+
+/*
+ *----------------------------------------------------------------
+ * Convenience macros for DStrings.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE char * TclDStringAppendLiteral(Tcl_DString *dsPtr,
+ *			const char *sLiteral);
+ * MODULE_SCOPE void   TclDStringClear(Tcl_DString *dsPtr);
+ */
+
+#define TclDStringAppendLiteral(dsPtr, sLiteral) \
+    Tcl_DStringAppend((dsPtr), (sLiteral), (int) (sizeof(sLiteral "") - 1))
+#define TclDStringClear(dsPtr) \
+    Tcl_DStringSetLength((dsPtr), 0)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to test for some special double values.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE int	TclIsInfinite(double d);
+ * MODULE_SCOPE int	TclIsNaN(double d);
+ */
+
+#ifdef _MSC_VER
+#    define TclIsInfinite(d)	(!(_finite((d))))
+#    define TclIsNaN(d)		(_isnan((d)))
+#else
+#    define TclIsInfinite(d)	((d) > DBL_MAX || (d) < -DBL_MAX)
+#    ifdef NO_ISNAN
+#	 define TclIsNaN(d)	((d) != (d))
+#    else
+#	 define TclIsNaN(d)	(isnan(d))
+#    endif
+#endif
+
+/*
+ * ----------------------------------------------------------------------
+ * Macro to use to find the offset of a field in a structure. Computes number
+ * of bytes from beginning of structure to a given field.
+ */
+
+#ifdef offsetof
+#define TclOffset(type, field) ((int) offsetof(type, field))
+#else
+#define TclOffset(type, field) ((int) ((char *) &((type *) 0)->field))
+#endif
+
+/*
+ *----------------------------------------------------------------
+ * Inline version of Tcl_GetCurrentNamespace and Tcl_GetGlobalNamespace.
+ */
+
+#define TclGetCurrentNamespace(interp) \
+    (Tcl_Namespace *) ((Interp *)(interp))->varFramePtr->nsPtr
+
+#define TclGetGlobalNamespace(interp) \
+    (Tcl_Namespace *) ((Interp *)(interp))->globalNsPtr
+
+/*
+ *----------------------------------------------------------------
+ * Inline version of TclCleanupCommand; still need the function as it is in
+ * the internal stubs, but the core can use the macro instead.
+ */
+
+#define TclCleanupCommandMacro(cmdPtr) \
+    if (--(cmdPtr)->refCount <= 0) { \
+	ckfree((char *) (cmdPtr));\
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Inline versions of Tcl_LimitReady() and Tcl_LimitExceeded to limit number
+ * of calls out of the critical path. Note that this code isn't particularly
+ * readable; the non-inline version (in tclInterp.c) is much easier to
+ * understand. Note also that these macros takes different args (iPtr->limit)
+ * to the non-inline version.
+ */
+
+#define TclLimitExceeded(limit) ((limit).exceeded != 0)
+
+#define TclLimitReady(limit)						\
+    (((limit).active == 0) ? 0 :					\
+    (++(limit).granularityTicker,					\
+    ((((limit).active & TCL_LIMIT_COMMANDS) &&				\
+	    (((limit).cmdGranularity == 1) ||				\
+	    ((limit).granularityTicker % (limit).cmdGranularity == 0)))	\
+	    ? 1 :							\
+    (((limit).active & TCL_LIMIT_TIME) &&				\
+	    (((limit).timeGranularity == 1) ||				\
+	    ((limit).granularityTicker % (limit).timeGranularity == 0)))\
+	    ? 1 : 0)))
+
+/*
+ * Compile-time assertions: these produce a compile time error if the
+ * expression is not known to be true at compile time. If the assertion is
+ * known to be false, the compiler (or optimizer?) will error out with
+ * "division by zero". If the assertion cannot be evaluated at compile time,
+ * the compiler will error out with "non-static initializer".
+ *
+ * Adapted with permission from
+ * http://www.pixelbeat.org/programming/gcc/static_assert.html
+ */
+
+#define TCL_CT_ASSERT(e) \
+    {enum { ct_assert_value = 1/(!!(e)) };}
+
+/*
+ *----------------------------------------------------------------
+ * Allocator for small structs (<=sizeof(Tcl_Obj)) using the Tcl_Obj pool.
+ * Only checked at compile time.
+ *
+ * ONLY USE FOR CONSTANT nBytes.
+ *
+ * DO NOT LET THEM CROSS THREAD BOUNDARIES
+ *----------------------------------------------------------------
+ */
+
+#define TclSmallAlloc(nbytes, memPtr) \
+    TclSmallAllocEx(NULL, (nbytes), (memPtr))
+
+#define TclSmallFree(memPtr) \
+    TclSmallFreeEx(NULL, (memPtr))
+
+#ifndef TCL_MEM_DEBUG
+#define TclSmallAllocEx(interp, nbytes, memPtr) \
+    do {								\
+	Tcl_Obj *objPtr;						\
+	TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));			\
+	TclIncrObjsAllocated();						\
+	TclAllocObjStorageEx((interp), (objPtr));			\
+	memPtr = (ClientData) (objPtr);					\
+    } while (0)
+
+#define TclSmallFreeEx(interp, memPtr) \
+    do {								\
+	TclFreeObjStorageEx((interp), (Tcl_Obj *) (memPtr));		\
+	TclIncrObjsFreed();						\
+    } while (0)
+
+#else    /* TCL_MEM_DEBUG */
+#define TclSmallAllocEx(interp, nbytes, memPtr) \
+    do {								\
+	Tcl_Obj *objPtr;						\
+	TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));			\
+	TclNewObj(objPtr);						\
+	memPtr = (ClientData) objPtr;					\
+    } while (0)
+
+#define TclSmallFreeEx(interp, memPtr) \
+    do {								\
+	Tcl_Obj *objPtr = (Tcl_Obj *) memPtr;				\
+	objPtr->bytes = NULL;						\
+	objPtr->typePtr = NULL;						\
+	objPtr->refCount = 1;						\
+	TclDecrRefCount(objPtr);					\
+    } while (0)
+#endif   /* TCL_MEM_DEBUG */
+
+/*
+ * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
+ */
+
+#if defined(PURIFY) && defined(__clang__)
+#if __has_feature(attribute_analyzer_noreturn) && \
+	!defined(Tcl_Panic) && defined(Tcl_Panic_TCL_DECLARED)
+void Tcl_Panic(const char *, ...) __attribute__((analyzer_noreturn));
+#endif
+#if !defined(CLANG_ASSERT)
+#include <assert.h>
+#define CLANG_ASSERT(x) assert(x)
+#endif
+#elif !defined(CLANG_ASSERT)
+#define CLANG_ASSERT(x)
+#endif /* PURIFY && __clang__ */
+
+/*
+ *----------------------------------------------------------------
+ * Parameters, structs and macros for the non-recursive engine (NRE)
+ *----------------------------------------------------------------
+ */
+
+#define NRE_USE_SMALL_ALLOC	1  /* Only turn off for debugging purposes. */
+#define NRE_ENABLE_ASSERTS	1
+
+/*
+ * This is the main data struct for representing NR commands. It is designed
+ * to fit in sizeof(Tcl_Obj) in order to exploit the fastest memory allocator
+ * available.
+ */
+
+typedef struct NRE_callback {
+    Tcl_NRPostProc *procPtr;
+    ClientData data[4];
+    struct NRE_callback *nextPtr;
+} NRE_callback;
+
+#define TOP_CB(iPtr) (((Interp *)(iPtr))->execEnvPtr->callbackPtr)
+
+/*
+ * Inline version of Tcl_NRAddCallback.
+ */
+
+#define TclNRAddCallback(interp,postProcPtr,data0,data1,data2,data3) \
+    do {								\
+	NRE_callback *callbackPtr;					\
+	TCLNR_ALLOC((interp), (callbackPtr));				\
+	callbackPtr->procPtr = (postProcPtr);				\
+	callbackPtr->data[0] = (ClientData)(data0);			\
+	callbackPtr->data[1] = (ClientData)(data1);			\
+	callbackPtr->data[2] = (ClientData)(data2);			\
+	callbackPtr->data[3] = (ClientData)(data3);			\
+	callbackPtr->nextPtr = TOP_CB(interp);				\
+	TOP_CB(interp) = callbackPtr;					\
+    } while (0)
+
+#define TclNRDeferCallback(interp,postProcPtr,data0,data1,data2,data3) \
+    do {								\
+	NRE_callback *callbackPtr;					\
+	TCLNR_ALLOC((interp), (callbackPtr));				\
+	callbackPtr->procPtr = (postProcPtr);				\
+	callbackPtr->data[0] = (ClientData)(data0);			\
+	callbackPtr->data[1] = (ClientData)(data1);			\
+	callbackPtr->data[2] = (ClientData)(data2);			\
+	callbackPtr->data[3] = (ClientData)(data3);			\
+	callbackPtr->nextPtr = ((Interp *)interp)->deferredCallbacks;	\
+	((Interp *)interp)->deferredCallbacks = callbackPtr;		\
+    } while (0)
+
+#define TclNRSpliceCallbacks(interp, topPtr) \
+    do {					\
+	NRE_callback *bottomPtr = topPtr;	\
+	while (bottomPtr->nextPtr) {		\
+	    bottomPtr = bottomPtr->nextPtr;	\
+	}					\
+	bottomPtr->nextPtr = TOP_CB(interp);	\
+	TOP_CB(interp) = topPtr;		\
+    } while (0)
+
+#define TclNRSpliceDeferred(interp)					\
+    if (((Interp *)interp)->deferredCallbacks) {			\
+	TclNRSpliceCallbacks(interp, ((Interp *)interp)->deferredCallbacks); \
+	((Interp *)interp)->deferredCallbacks = NULL;			\
+    }
+
+#if NRE_USE_SMALL_ALLOC
+#define TCLNR_ALLOC(interp, ptr) \
+    TclSmallAllocEx(interp, sizeof(NRE_callback), (ptr))
+#define TCLNR_FREE(interp, ptr)  TclSmallFreeEx((interp), (ptr))
+#else
+#define TCLNR_ALLOC(interp, ptr) \
+    (ptr = ((ClientData) ckalloc(sizeof(NRE_callback))))
+#define TCLNR_FREE(interp, ptr)  ckfree((char *) (ptr))
+#endif
+
+#if NRE_ENABLE_ASSERTS
+#define NRE_ASSERT(expr) assert((expr))
+#else
+#define NRE_ASSERT(expr)
+#endif
+
+#include "tclIntDecls.h"
+#include "tclIntPlatDecls.h"
+#include "tclTomMathDecls.h"
+
+#if !defined(USE_TCL_STUBS) && !defined(TCL_MEM_DEBUG)
+#define Tcl_AttemptAlloc(size)        TclpAlloc(size)
+#define Tcl_AttemptRealloc(ptr, size) TclpRealloc((ptr), (size))
+#define Tcl_Free(ptr)                 TclpFree(ptr)
+#endif
+
+#endif /* _TCLINT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
Index: src/tktext/tcl8.6/tclIntDecls.h
===================================================================
--- src/tktext/tcl8.6/tclIntDecls.h	(revision 0)
+++ src/tktext/tcl8.6/tclIntDecls.h	(working copy)
@@ -0,0 +1,1292 @@
+/*
+ * tclIntDecls.h --
+ *
+ *	This file contains the declarations for all unsupported
+ *	functions that are exported by the Tcl library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLINTDECLS
+#define _TCLINTDECLS
+
+#include "tclPort.h"
+
+#undef TCL_STORAGE_CLASS
+#ifdef BUILD_tcl
+#   define TCL_STORAGE_CLASS DLLEXPORT
+#else
+#   ifdef USE_TCL_STUBS
+#      define TCL_STORAGE_CLASS
+#   else
+#      define TCL_STORAGE_CLASS DLLIMPORT
+#   endif
+#endif
+
+/* [Bug #803489] Tcl_FindNamespace problem in the Stubs table */
+#undef Tcl_AppendExportList
+#undef Tcl_CreateNamespace
+#undef Tcl_DeleteNamespace
+#undef Tcl_Export
+#undef Tcl_FindCommand
+#undef Tcl_FindNamespace
+#undef Tcl_FindNamespaceVar
+#undef Tcl_ForgetImport
+#undef Tcl_GetCommandFromObj
+#undef Tcl_GetCommandFullName
+#undef Tcl_GetCurrentNamespace
+#undef Tcl_GetGlobalNamespace
+#undef Tcl_Import
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tclInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+/* Slot 0 is reserved */
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+/* 3 */
+EXTERN void		TclAllocateFreeObjects(void);
+/* Slot 4 is reserved */
+/* 5 */
+EXTERN int		TclCleanupChildren(Tcl_Interp *interp, int numPids,
+				Tcl_Pid *pidPtr, Tcl_Channel errorChan);
+/* 6 */
+EXTERN void		TclCleanupCommand(Command *cmdPtr);
+/* 7 */
+EXTERN int		TclCopyAndCollapse(int count, const char *src,
+				char *dst);
+/* 8 */
+EXTERN int		TclCopyChannelOld(Tcl_Interp *interp,
+				Tcl_Channel inChan, Tcl_Channel outChan,
+				int toRead, Tcl_Obj *cmdPtr);
+/* 9 */
+EXTERN int		TclCreatePipeline(Tcl_Interp *interp, int argc,
+				const char **argv, Tcl_Pid **pidArrayPtr,
+				TclFile *inPipePtr, TclFile *outPipePtr,
+				TclFile *errFilePtr);
+/* 10 */
+EXTERN int		TclCreateProc(Tcl_Interp *interp, Namespace *nsPtr,
+				const char *procName, Tcl_Obj *argsPtr,
+				Tcl_Obj *bodyPtr, Proc **procPtrPtr);
+/* 11 */
+EXTERN void		TclDeleteCompiledLocalVars(Interp *iPtr,
+				CallFrame *framePtr);
+/* 12 */
+EXTERN void		TclDeleteVars(Interp *iPtr,
+				TclVarHashTable *tablePtr);
+/* Slot 13 is reserved */
+/* 14 */
+EXTERN int		TclDumpMemoryInfo(ClientData clientData, int flags);
+/* Slot 15 is reserved */
+/* 16 */
+EXTERN void		TclExprFloatError(Tcl_Interp *interp, double value);
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* 22 */
+EXTERN int		TclFindElement(Tcl_Interp *interp,
+				const char *listStr, int listLength,
+				const char **elementPtr,
+				const char **nextPtr, int *sizePtr,
+				int *bracePtr);
+/* 23 */
+EXTERN Proc *		TclFindProc(Interp *iPtr, const char *procName);
+/* 24 */
+EXTERN int		TclFormatInt(char *buffer, long n);
+/* 25 */
+EXTERN void		TclFreePackageInfo(Interp *iPtr);
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* 28 */
+EXTERN Tcl_Channel	TclpGetDefaultStdChannel(int type);
+/* Slot 29 is reserved */
+/* Slot 30 is reserved */
+/* 31 */
+EXTERN const char *	TclGetExtension(const char *name);
+/* 32 */
+EXTERN int		TclGetFrame(Tcl_Interp *interp, const char *str,
+				CallFrame **framePtrPtr);
+/* Slot 33 is reserved */
+/* 34 */
+EXTERN int		TclGetIntForIndex(Tcl_Interp *interp,
+				Tcl_Obj *objPtr, int endValue, int *indexPtr);
+/* Slot 35 is reserved */
+/* Slot 36 is reserved */
+/* 37 */
+EXTERN int		TclGetLoadedPackages(Tcl_Interp *interp,
+				const char *targetName);
+/* 38 */
+EXTERN int		TclGetNamespaceForQualName(Tcl_Interp *interp,
+				const char *qualName, Namespace *cxtNsPtr,
+				int flags, Namespace **nsPtrPtr,
+				Namespace **altNsPtrPtr,
+				Namespace **actualCxtPtrPtr,
+				const char **simpleNamePtr);
+/* 39 */
+EXTERN TclObjCmdProcType TclGetObjInterpProc(void);
+/* 40 */
+EXTERN int		TclGetOpenMode(Tcl_Interp *interp, const char *str,
+				int *seekFlagPtr);
+/* 41 */
+EXTERN Tcl_Command	TclGetOriginalCommand(Tcl_Command command);
+/* 42 */
+EXTERN CONST86 char *	TclpGetUserHome(const char *name,
+				Tcl_DString *bufferPtr);
+/* Slot 43 is reserved */
+/* 44 */
+EXTERN int		TclGuessPackageName(const char *fileName,
+				Tcl_DString *bufPtr);
+/* 45 */
+EXTERN int		TclHideUnsafeCommands(Tcl_Interp *interp);
+/* 46 */
+EXTERN int		TclInExit(void);
+/* Slot 47 is reserved */
+/* Slot 48 is reserved */
+/* Slot 49 is reserved */
+/* 50 */
+EXTERN void		TclInitCompiledLocals(Tcl_Interp *interp,
+				CallFrame *framePtr, Namespace *nsPtr);
+/* 51 */
+EXTERN int		TclInterpInit(Tcl_Interp *interp);
+/* Slot 52 is reserved */
+/* 53 */
+EXTERN int		TclInvokeObjectCommand(ClientData clientData,
+				Tcl_Interp *interp, int argc,
+				CONST84 char **argv);
+/* 54 */
+EXTERN int		TclInvokeStringCommand(ClientData clientData,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+/* 55 */
+EXTERN Proc *		TclIsProc(Command *cmdPtr);
+/* Slot 56 is reserved */
+/* Slot 57 is reserved */
+/* 58 */
+EXTERN Var *		TclLookupVar(Tcl_Interp *interp, const char *part1,
+				const char *part2, int flags,
+				const char *msg, int createPart1,
+				int createPart2, Var **arrayPtrPtr);
+/* Slot 59 is reserved */
+/* 60 */
+EXTERN int		TclNeedSpace(const char *start, const char *end);
+/* 61 */
+EXTERN Tcl_Obj *	TclNewProcBodyObj(Proc *procPtr);
+/* 62 */
+EXTERN int		TclObjCommandComplete(Tcl_Obj *cmdPtr);
+/* 63 */
+EXTERN int		TclObjInterpProc(ClientData clientData,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+/* 64 */
+EXTERN int		TclObjInvoke(Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[], int flags);
+/* Slot 65 is reserved */
+/* Slot 66 is reserved */
+/* Slot 67 is reserved */
+/* Slot 68 is reserved */
+/* 69 */
+EXTERN char *		TclpAlloc(unsigned int size);
+/* Slot 70 is reserved */
+/* Slot 71 is reserved */
+/* Slot 72 is reserved */
+/* Slot 73 is reserved */
+/* 74 */
+EXTERN void		TclpFree(char *ptr);
+/* 75 */
+EXTERN unsigned long	TclpGetClicks(void);
+/* 76 */
+EXTERN unsigned long	TclpGetSeconds(void);
+/* 77 */
+EXTERN void		TclpGetTime(Tcl_Time *time);
+/* Slot 78 is reserved */
+/* Slot 79 is reserved */
+/* Slot 80 is reserved */
+/* 81 */
+EXTERN char *		TclpRealloc(char *ptr, unsigned int size);
+/* Slot 82 is reserved */
+/* Slot 83 is reserved */
+/* Slot 84 is reserved */
+/* Slot 85 is reserved */
+/* Slot 86 is reserved */
+/* Slot 87 is reserved */
+/* 88 */
+EXTERN char *		TclPrecTraceProc(ClientData clientData,
+				Tcl_Interp *interp, const char *name1,
+				const char *name2, int flags);
+/* 89 */
+EXTERN int		TclPreventAliasLoop(Tcl_Interp *interp,
+				Tcl_Interp *cmdInterp, Tcl_Command cmd);
+/* Slot 90 is reserved */
+/* 91 */
+EXTERN void		TclProcCleanupProc(Proc *procPtr);
+/* 92 */
+EXTERN int		TclProcCompileProc(Tcl_Interp *interp, Proc *procPtr,
+				Tcl_Obj *bodyPtr, Namespace *nsPtr,
+				const char *description,
+				const char *procName);
+/* 93 */
+EXTERN void		TclProcDeleteProc(ClientData clientData);
+/* Slot 94 is reserved */
+/* Slot 95 is reserved */
+/* 96 */
+EXTERN int		TclRenameCommand(Tcl_Interp *interp,
+				const char *oldName, const char *newName);
+/* 97 */
+EXTERN void		TclResetShadowedCmdRefs(Tcl_Interp *interp,
+				Command *newCmdPtr);
+/* 98 */
+EXTERN int		TclServiceIdle(void);
+/* Slot 99 is reserved */
+/* Slot 100 is reserved */
+/* 101 */
+EXTERN CONST86 char *	TclSetPreInitScript(const char *string);
+/* 102 */
+EXTERN void		TclSetupEnv(Tcl_Interp *interp);
+/* 103 */
+EXTERN int		TclSockGetPort(Tcl_Interp *interp, const char *str,
+				const char *proto, int *portPtr);
+/* 104 */
+EXTERN int		TclSockMinimumBuffersOld(int sock, int size);
+/* Slot 105 is reserved */
+/* Slot 106 is reserved */
+/* Slot 107 is reserved */
+/* 108 */
+EXTERN void		TclTeardownNamespace(Namespace *nsPtr);
+/* 109 */
+EXTERN int		TclUpdateReturnInfo(Interp *iPtr);
+/* 110 */
+EXTERN int		TclSockMinimumBuffers(void *sock, int size);
+/* 111 */
+EXTERN void		Tcl_AddInterpResolvers(Tcl_Interp *interp,
+				const char *name,
+				Tcl_ResolveCmdProc *cmdProc,
+				Tcl_ResolveVarProc *varProc,
+				Tcl_ResolveCompiledVarProc *compiledVarProc);
+/* 112 */
+EXTERN int		Tcl_AppendExportList(Tcl_Interp *interp,
+				Tcl_Namespace *nsPtr, Tcl_Obj *objPtr);
+/* 113 */
+EXTERN Tcl_Namespace *	Tcl_CreateNamespace(Tcl_Interp *interp,
+				const char *name, ClientData clientData,
+				Tcl_NamespaceDeleteProc *deleteProc);
+/* 114 */
+EXTERN void		Tcl_DeleteNamespace(Tcl_Namespace *nsPtr);
+/* 115 */
+EXTERN int		Tcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
+				const char *pattern, int resetListFirst);
+/* 116 */
+EXTERN Tcl_Command	Tcl_FindCommand(Tcl_Interp *interp, const char *name,
+				Tcl_Namespace *contextNsPtr, int flags);
+/* 117 */
+EXTERN Tcl_Namespace *	Tcl_FindNamespace(Tcl_Interp *interp,
+				const char *name,
+				Tcl_Namespace *contextNsPtr, int flags);
+/* 118 */
+EXTERN int		Tcl_GetInterpResolvers(Tcl_Interp *interp,
+				const char *name, Tcl_ResolverInfo *resInfo);
+/* 119 */
+EXTERN int		Tcl_GetNamespaceResolvers(
+				Tcl_Namespace *namespacePtr,
+				Tcl_ResolverInfo *resInfo);
+/* 120 */
+EXTERN Tcl_Var		Tcl_FindNamespaceVar(Tcl_Interp *interp,
+				const char *name,
+				Tcl_Namespace *contextNsPtr, int flags);
+/* 121 */
+EXTERN int		Tcl_ForgetImport(Tcl_Interp *interp,
+				Tcl_Namespace *nsPtr, const char *pattern);
+/* 122 */
+EXTERN Tcl_Command	Tcl_GetCommandFromObj(Tcl_Interp *interp,
+				Tcl_Obj *objPtr);
+/* 123 */
+EXTERN void		Tcl_GetCommandFullName(Tcl_Interp *interp,
+				Tcl_Command command, Tcl_Obj *objPtr);
+/* 124 */
+EXTERN Tcl_Namespace *	Tcl_GetCurrentNamespace(Tcl_Interp *interp);
+/* 125 */
+EXTERN Tcl_Namespace *	Tcl_GetGlobalNamespace(Tcl_Interp *interp);
+/* 126 */
+EXTERN void		Tcl_GetVariableFullName(Tcl_Interp *interp,
+				Tcl_Var variable, Tcl_Obj *objPtr);
+/* 127 */
+EXTERN int		Tcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
+				const char *pattern, int allowOverwrite);
+/* 128 */
+EXTERN void		Tcl_PopCallFrame(Tcl_Interp *interp);
+/* 129 */
+EXTERN int		Tcl_PushCallFrame(Tcl_Interp *interp,
+				Tcl_CallFrame *framePtr,
+				Tcl_Namespace *nsPtr, int isProcCallFrame);
+/* 130 */
+EXTERN int		Tcl_RemoveInterpResolvers(Tcl_Interp *interp,
+				const char *name);
+/* 131 */
+EXTERN void		Tcl_SetNamespaceResolvers(
+				Tcl_Namespace *namespacePtr,
+				Tcl_ResolveCmdProc *cmdProc,
+				Tcl_ResolveVarProc *varProc,
+				Tcl_ResolveCompiledVarProc *compiledVarProc);
+/* 132 */
+EXTERN int		TclpHasSockets(Tcl_Interp *interp);
+/* 133 */
+EXTERN struct tm *	TclpGetDate(const time_t *time, int useGMT);
+/* Slot 134 is reserved */
+/* Slot 135 is reserved */
+/* Slot 136 is reserved */
+/* Slot 137 is reserved */
+/* 138 */
+EXTERN CONST84_RETURN char * TclGetEnv(const char *name,
+				Tcl_DString *valuePtr);
+/* Slot 139 is reserved */
+/* Slot 140 is reserved */
+/* 141 */
+EXTERN CONST84_RETURN char * TclpGetCwd(Tcl_Interp *interp,
+				Tcl_DString *cwdPtr);
+/* 142 */
+EXTERN int		TclSetByteCodeFromAny(Tcl_Interp *interp,
+				Tcl_Obj *objPtr, CompileHookProc *hookProc,
+				ClientData clientData);
+/* 143 */
+EXTERN int		TclAddLiteralObj(struct CompileEnv *envPtr,
+				Tcl_Obj *objPtr, LiteralEntry **litPtrPtr);
+/* 144 */
+EXTERN void		TclHideLiteral(Tcl_Interp *interp,
+				struct CompileEnv *envPtr, int index);
+/* 145 */
+EXTERN const struct AuxDataType * TclGetAuxDataType(const char *typeName);
+/* 146 */
+EXTERN TclHandle	TclHandleCreate(void *ptr);
+/* 147 */
+EXTERN void		TclHandleFree(TclHandle handle);
+/* 148 */
+EXTERN TclHandle	TclHandlePreserve(TclHandle handle);
+/* 149 */
+EXTERN void		TclHandleRelease(TclHandle handle);
+/* 150 */
+EXTERN int		TclRegAbout(Tcl_Interp *interp, Tcl_RegExp re);
+/* 151 */
+EXTERN void		TclRegExpRangeUniChar(Tcl_RegExp re, int index,
+				int *startPtr, int *endPtr);
+/* 152 */
+EXTERN void		TclSetLibraryPath(Tcl_Obj *pathPtr);
+/* 153 */
+EXTERN Tcl_Obj *	TclGetLibraryPath(void);
+/* Slot 154 is reserved */
+/* Slot 155 is reserved */
+/* 156 */
+EXTERN void		TclRegError(Tcl_Interp *interp, const char *msg,
+				int status);
+/* 157 */
+EXTERN Var *		TclVarTraceExists(Tcl_Interp *interp,
+				const char *varName);
+/* Slot 158 is reserved */
+/* Slot 159 is reserved */
+/* Slot 160 is reserved */
+/* 161 */
+EXTERN int		TclChannelTransform(Tcl_Interp *interp,
+				Tcl_Channel chan, Tcl_Obj *cmdObjPtr);
+/* 162 */
+EXTERN void		TclChannelEventScriptInvoker(ClientData clientData,
+				int flags);
+/* 163 */
+EXTERN const void *	TclGetInstructionTable(void);
+/* 164 */
+EXTERN void		TclExpandCodeArray(void *envPtr);
+/* 165 */
+EXTERN void		TclpSetInitialEncodings(void);
+/* 166 */
+EXTERN int		TclListObjSetElement(Tcl_Interp *interp,
+				Tcl_Obj *listPtr, int index,
+				Tcl_Obj *valuePtr);
+/* Slot 167 is reserved */
+/* Slot 168 is reserved */
+/* 169 */
+EXTERN int		TclpUtfNcmp2(const char *s1, const char *s2,
+				unsigned long n);
+/* 170 */
+EXTERN int		TclCheckInterpTraces(Tcl_Interp *interp,
+				const char *command, int numChars,
+				Command *cmdPtr, int result, int traceFlags,
+				int objc, Tcl_Obj *const objv[]);
+/* 171 */
+EXTERN int		TclCheckExecutionTraces(Tcl_Interp *interp,
+				const char *command, int numChars,
+				Command *cmdPtr, int result, int traceFlags,
+				int objc, Tcl_Obj *const objv[]);
+/* 172 */
+EXTERN int		TclInThreadExit(void);
+/* 173 */
+EXTERN int		TclUniCharMatch(const Tcl_UniChar *string,
+				int strLen, const Tcl_UniChar *pattern,
+				int ptnLen, int flags);
+/* Slot 174 is reserved */
+/* 175 */
+EXTERN int		TclCallVarTraces(Interp *iPtr, Var *arrayPtr,
+				Var *varPtr, const char *part1,
+				const char *part2, int flags,
+				int leaveErrMsg);
+/* 176 */
+EXTERN void		TclCleanupVar(Var *varPtr, Var *arrayPtr);
+/* 177 */
+EXTERN void		TclVarErrMsg(Tcl_Interp *interp, const char *part1,
+				const char *part2, const char *operation,
+				const char *reason);
+/* Slot 178 is reserved */
+/* Slot 179 is reserved */
+/* Slot 180 is reserved */
+/* Slot 181 is reserved */
+/* 182 */
+EXTERN struct tm *	TclpLocaltime(const time_t *clock);
+/* 183 */
+EXTERN struct tm *	TclpGmtime(const time_t *clock);
+/* Slot 184 is reserved */
+/* Slot 185 is reserved */
+/* Slot 186 is reserved */
+/* Slot 187 is reserved */
+/* Slot 188 is reserved */
+/* Slot 189 is reserved */
+/* Slot 190 is reserved */
+/* Slot 191 is reserved */
+/* Slot 192 is reserved */
+/* Slot 193 is reserved */
+/* Slot 194 is reserved */
+/* Slot 195 is reserved */
+/* Slot 196 is reserved */
+/* Slot 197 is reserved */
+/* 198 */
+EXTERN int		TclObjGetFrame(Tcl_Interp *interp, Tcl_Obj *objPtr,
+				CallFrame **framePtrPtr);
+/* Slot 199 is reserved */
+/* 200 */
+EXTERN int		TclpObjRemoveDirectory(Tcl_Obj *pathPtr,
+				int recursive, Tcl_Obj **errorPtr);
+/* 201 */
+EXTERN int		TclpObjCopyDirectory(Tcl_Obj *srcPathPtr,
+				Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr);
+/* 202 */
+EXTERN int		TclpObjCreateDirectory(Tcl_Obj *pathPtr);
+/* 203 */
+EXTERN int		TclpObjDeleteFile(Tcl_Obj *pathPtr);
+/* 204 */
+EXTERN int		TclpObjCopyFile(Tcl_Obj *srcPathPtr,
+				Tcl_Obj *destPathPtr);
+/* 205 */
+EXTERN int		TclpObjRenameFile(Tcl_Obj *srcPathPtr,
+				Tcl_Obj *destPathPtr);
+/* 206 */
+EXTERN int		TclpObjStat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);
+/* 207 */
+EXTERN int		TclpObjAccess(Tcl_Obj *pathPtr, int mode);
+/* 208 */
+EXTERN Tcl_Channel	TclpOpenFileChannel(Tcl_Interp *interp,
+				Tcl_Obj *pathPtr, int mode, int permissions);
+/* Slot 209 is reserved */
+/* Slot 210 is reserved */
+/* Slot 211 is reserved */
+/* 212 */
+EXTERN void		TclpFindExecutable(const char *argv0);
+/* 213 */
+EXTERN Tcl_Obj *	TclGetObjNameOfExecutable(void);
+/* 214 */
+EXTERN void		TclSetObjNameOfExecutable(Tcl_Obj *name,
+				Tcl_Encoding encoding);
+/* 215 */
+EXTERN void *		TclStackAlloc(Tcl_Interp *interp, int numBytes);
+/* 216 */
+EXTERN void		TclStackFree(Tcl_Interp *interp, void *freePtr);
+/* 217 */
+EXTERN int		TclPushStackFrame(Tcl_Interp *interp,
+				Tcl_CallFrame **framePtrPtr,
+				Tcl_Namespace *namespacePtr,
+				int isProcCallFrame);
+/* 218 */
+EXTERN void		TclPopStackFrame(Tcl_Interp *interp);
+/* Slot 219 is reserved */
+/* Slot 220 is reserved */
+/* Slot 221 is reserved */
+/* Slot 222 is reserved */
+/* Slot 223 is reserved */
+/* 224 */
+EXTERN TclPlatformType * TclGetPlatform(void);
+/* 225 */
+EXTERN Tcl_Obj *	TclTraceDictPath(Tcl_Interp *interp,
+				Tcl_Obj *rootPtr, int keyc,
+				Tcl_Obj *const keyv[], int flags);
+/* 226 */
+EXTERN int		TclObjBeingDeleted(Tcl_Obj *objPtr);
+/* 227 */
+EXTERN void		TclSetNsPath(Namespace *nsPtr, int pathLength,
+				Tcl_Namespace *pathAry[]);
+/* Slot 228 is reserved */
+/* 229 */
+EXTERN int		TclPtrMakeUpvar(Tcl_Interp *interp, Var *otherP1Ptr,
+				const char *myName, int myFlags, int index);
+/* 230 */
+EXTERN Var *		TclObjLookupVar(Tcl_Interp *interp,
+				Tcl_Obj *part1Ptr, const char *part2,
+				int flags, const char *msg,
+				const int createPart1, const int createPart2,
+				Var **arrayPtrPtr);
+/* 231 */
+EXTERN int		TclGetNamespaceFromObj(Tcl_Interp *interp,
+				Tcl_Obj *objPtr, Tcl_Namespace **nsPtrPtr);
+/* 232 */
+EXTERN int		TclEvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr,
+				int flags, const CmdFrame *invoker, int word);
+/* 233 */
+EXTERN void		TclGetSrcInfoForPc(CmdFrame *contextPtr);
+/* 234 */
+EXTERN Var *		TclVarHashCreateVar(TclVarHashTable *tablePtr,
+				const char *key, int *newPtr);
+/* 235 */
+EXTERN void		TclInitVarHashTable(TclVarHashTable *tablePtr,
+				Namespace *nsPtr);
+/* Slot 236 is reserved */
+/* 237 */
+EXTERN int		TclResetCancellation(Tcl_Interp *interp, int force);
+/* 238 */
+EXTERN int		TclNRInterpProc(ClientData clientData,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+/* 239 */
+EXTERN int		TclNRInterpProcCore(Tcl_Interp *interp,
+				Tcl_Obj *procNameObj, int skip,
+				ProcErrorProc *errorProc);
+/* 240 */
+EXTERN int		TclNRRunCallbacks(Tcl_Interp *interp, int result,
+				struct NRE_callback *rootPtr);
+/* 241 */
+EXTERN int		TclNREvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr,
+				int flags, const CmdFrame *invoker, int word);
+/* 242 */
+EXTERN int		TclNREvalObjv(Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[], int flags,
+				Command *cmdPtr);
+/* 243 */
+EXTERN void		TclDbDumpActiveObjects(FILE *outFile);
+/* 244 */
+EXTERN Tcl_HashTable *	TclGetNamespaceChildTable(Tcl_Namespace *nsPtr);
+/* 245 */
+EXTERN Tcl_HashTable *	TclGetNamespaceCommandTable(Tcl_Namespace *nsPtr);
+/* 246 */
+EXTERN int		TclInitRewriteEnsemble(Tcl_Interp *interp,
+				int numRemoved, int numInserted,
+				Tcl_Obj *const *objv);
+/* 247 */
+EXTERN void		TclResetRewriteEnsemble(Tcl_Interp *interp,
+				int isRootEnsemble);
+/* 248 */
+EXTERN int		TclCopyChannel(Tcl_Interp *interp,
+				Tcl_Channel inChan, Tcl_Channel outChan,
+				Tcl_WideInt toRead, Tcl_Obj *cmdPtr);
+/* 249 */
+EXTERN char *		TclDoubleDigits(double dv, int ndigits, int flags,
+				int *decpt, int *signum, char **endPtr);
+/* 250 */
+EXTERN void		TclSetSlaveCancelFlags(Tcl_Interp *interp, int flags,
+				int force);
+
+typedef struct TclIntStubs {
+    int magic;
+    void *hooks;
+
+    void (*reserved0)(void);
+    void (*reserved1)(void);
+    void (*reserved2)(void);
+    void (*tclAllocateFreeObjects) (void); /* 3 */
+    void (*reserved4)(void);
+    int (*tclCleanupChildren) (Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr, Tcl_Channel errorChan); /* 5 */
+    void (*tclCleanupCommand) (Command *cmdPtr); /* 6 */
+    int (*tclCopyAndCollapse) (int count, const char *src, char *dst); /* 7 */
+    int (*tclCopyChannelOld) (Tcl_Interp *interp, Tcl_Channel inChan, Tcl_Channel outChan, int toRead, Tcl_Obj *cmdPtr); /* 8 */
+    int (*tclCreatePipeline) (Tcl_Interp *interp, int argc, const char **argv, Tcl_Pid **pidArrayPtr, TclFile *inPipePtr, TclFile *outPipePtr, TclFile *errFilePtr); /* 9 */
+    int (*tclCreateProc) (Tcl_Interp *interp, Namespace *nsPtr, const char *procName, Tcl_Obj *argsPtr, Tcl_Obj *bodyPtr, Proc **procPtrPtr); /* 10 */
+    void (*tclDeleteCompiledLocalVars) (Interp *iPtr, CallFrame *framePtr); /* 11 */
+    void (*tclDeleteVars) (Interp *iPtr, TclVarHashTable *tablePtr); /* 12 */
+    void (*reserved13)(void);
+    int (*tclDumpMemoryInfo) (ClientData clientData, int flags); /* 14 */
+    void (*reserved15)(void);
+    void (*tclExprFloatError) (Tcl_Interp *interp, double value); /* 16 */
+    void (*reserved17)(void);
+    void (*reserved18)(void);
+    void (*reserved19)(void);
+    void (*reserved20)(void);
+    void (*reserved21)(void);
+    int (*tclFindElement) (Tcl_Interp *interp, const char *listStr, int listLength, const char **elementPtr, const char **nextPtr, int *sizePtr, int *bracePtr); /* 22 */
+    Proc * (*tclFindProc) (Interp *iPtr, const char *procName); /* 23 */
+    int (*tclFormatInt) (char *buffer, long n); /* 24 */
+    void (*tclFreePackageInfo) (Interp *iPtr); /* 25 */
+    void (*reserved26)(void);
+    void (*reserved27)(void);
+    Tcl_Channel (*tclpGetDefaultStdChannel) (int type); /* 28 */
+    void (*reserved29)(void);
+    void (*reserved30)(void);
+    const char * (*tclGetExtension) (const char *name); /* 31 */
+    int (*tclGetFrame) (Tcl_Interp *interp, const char *str, CallFrame **framePtrPtr); /* 32 */
+    void (*reserved33)(void);
+    int (*tclGetIntForIndex) (Tcl_Interp *interp, Tcl_Obj *objPtr, int endValue, int *indexPtr); /* 34 */
+    void (*reserved35)(void);
+    void (*reserved36)(void);
+    int (*tclGetLoadedPackages) (Tcl_Interp *interp, const char *targetName); /* 37 */
+    int (*tclGetNamespaceForQualName) (Tcl_Interp *interp, const char *qualName, Namespace *cxtNsPtr, int flags, Namespace **nsPtrPtr, Namespace **altNsPtrPtr, Namespace **actualCxtPtrPtr, const char **simpleNamePtr); /* 38 */
+    TclObjCmdProcType (*tclGetObjInterpProc) (void); /* 39 */
+    int (*tclGetOpenMode) (Tcl_Interp *interp, const char *str, int *seekFlagPtr); /* 40 */
+    Tcl_Command (*tclGetOriginalCommand) (Tcl_Command command); /* 41 */
+    CONST86 char * (*tclpGetUserHome) (const char *name, Tcl_DString *bufferPtr); /* 42 */
+    void (*reserved43)(void);
+    int (*tclGuessPackageName) (const char *fileName, Tcl_DString *bufPtr); /* 44 */
+    int (*tclHideUnsafeCommands) (Tcl_Interp *interp); /* 45 */
+    int (*tclInExit) (void); /* 46 */
+    void (*reserved47)(void);
+    void (*reserved48)(void);
+    void (*reserved49)(void);
+    void (*tclInitCompiledLocals) (Tcl_Interp *interp, CallFrame *framePtr, Namespace *nsPtr); /* 50 */
+    int (*tclInterpInit) (Tcl_Interp *interp); /* 51 */
+    void (*reserved52)(void);
+    int (*tclInvokeObjectCommand) (ClientData clientData, Tcl_Interp *interp, int argc, CONST84 char **argv); /* 53 */
+    int (*tclInvokeStringCommand) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 54 */
+    Proc * (*tclIsProc) (Command *cmdPtr); /* 55 */
+    void (*reserved56)(void);
+    void (*reserved57)(void);
+    Var * (*tclLookupVar) (Tcl_Interp *interp, const char *part1, const char *part2, int flags, const char *msg, int createPart1, int createPart2, Var **arrayPtrPtr); /* 58 */
+    void (*reserved59)(void);
+    int (*tclNeedSpace) (const char *start, const char *end); /* 60 */
+    Tcl_Obj * (*tclNewProcBodyObj) (Proc *procPtr); /* 61 */
+    int (*tclObjCommandComplete) (Tcl_Obj *cmdPtr); /* 62 */
+    int (*tclObjInterpProc) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 63 */
+    int (*tclObjInvoke) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], int flags); /* 64 */
+    void (*reserved65)(void);
+    void (*reserved66)(void);
+    void (*reserved67)(void);
+    void (*reserved68)(void);
+    char * (*tclpAlloc) (unsigned int size); /* 69 */
+    void (*reserved70)(void);
+    void (*reserved71)(void);
+    void (*reserved72)(void);
+    void (*reserved73)(void);
+    void (*tclpFree) (char *ptr); /* 74 */
+    unsigned long (*tclpGetClicks) (void); /* 75 */
+    unsigned long (*tclpGetSeconds) (void); /* 76 */
+    void (*tclpGetTime) (Tcl_Time *time); /* 77 */
+    void (*reserved78)(void);
+    void (*reserved79)(void);
+    void (*reserved80)(void);
+    char * (*tclpRealloc) (char *ptr, unsigned int size); /* 81 */
+    void (*reserved82)(void);
+    void (*reserved83)(void);
+    void (*reserved84)(void);
+    void (*reserved85)(void);
+    void (*reserved86)(void);
+    void (*reserved87)(void);
+    char * (*tclPrecTraceProc) (ClientData clientData, Tcl_Interp *interp, const char *name1, const char *name2, int flags); /* 88 */
+    int (*tclPreventAliasLoop) (Tcl_Interp *interp, Tcl_Interp *cmdInterp, Tcl_Command cmd); /* 89 */
+    void (*reserved90)(void);
+    void (*tclProcCleanupProc) (Proc *procPtr); /* 91 */
+    int (*tclProcCompileProc) (Tcl_Interp *interp, Proc *procPtr, Tcl_Obj *bodyPtr, Namespace *nsPtr, const char *description, const char *procName); /* 92 */
+    void (*tclProcDeleteProc) (ClientData clientData); /* 93 */
+    void (*reserved94)(void);
+    void (*reserved95)(void);
+    int (*tclRenameCommand) (Tcl_Interp *interp, const char *oldName, const char *newName); /* 96 */
+    void (*tclResetShadowedCmdRefs) (Tcl_Interp *interp, Command *newCmdPtr); /* 97 */
+    int (*tclServiceIdle) (void); /* 98 */
+    void (*reserved99)(void);
+    void (*reserved100)(void);
+    CONST86 char * (*tclSetPreInitScript) (const char *string); /* 101 */
+    void (*tclSetupEnv) (Tcl_Interp *interp); /* 102 */
+    int (*tclSockGetPort) (Tcl_Interp *interp, const char *str, const char *proto, int *portPtr); /* 103 */
+    int (*tclSockMinimumBuffersOld) (int sock, int size); /* 104 */
+    void (*reserved105)(void);
+    void (*reserved106)(void);
+    void (*reserved107)(void);
+    void (*tclTeardownNamespace) (Namespace *nsPtr); /* 108 */
+    int (*tclUpdateReturnInfo) (Interp *iPtr); /* 109 */
+    int (*tclSockMinimumBuffers) (void *sock, int size); /* 110 */
+    void (*tcl_AddInterpResolvers) (Tcl_Interp *interp, const char *name, Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc, Tcl_ResolveCompiledVarProc *compiledVarProc); /* 111 */
+    int (*tcl_AppendExportList) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, Tcl_Obj *objPtr); /* 112 */
+    Tcl_Namespace * (*tcl_CreateNamespace) (Tcl_Interp *interp, const char *name, ClientData clientData, Tcl_NamespaceDeleteProc *deleteProc); /* 113 */
+    void (*tcl_DeleteNamespace) (Tcl_Namespace *nsPtr); /* 114 */
+    int (*tcl_Export) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *pattern, int resetListFirst); /* 115 */
+    Tcl_Command (*tcl_FindCommand) (Tcl_Interp *interp, const char *name, Tcl_Namespace *contextNsPtr, int flags); /* 116 */
+    Tcl_Namespace * (*tcl_FindNamespace) (Tcl_Interp *interp, const char *name, Tcl_Namespace *contextNsPtr, int flags); /* 117 */
+    int (*tcl_GetInterpResolvers) (Tcl_Interp *interp, const char *name, Tcl_ResolverInfo *resInfo); /* 118 */
+    int (*tcl_GetNamespaceResolvers) (Tcl_Namespace *namespacePtr, Tcl_ResolverInfo *resInfo); /* 119 */
+    Tcl_Var (*tcl_FindNamespaceVar) (Tcl_Interp *interp, const char *name, Tcl_Namespace *contextNsPtr, int flags); /* 120 */
+    int (*tcl_ForgetImport) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *pattern); /* 121 */
+    Tcl_Command (*tcl_GetCommandFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 122 */
+    void (*tcl_GetCommandFullName) (Tcl_Interp *interp, Tcl_Command command, Tcl_Obj *objPtr); /* 123 */
+    Tcl_Namespace * (*tcl_GetCurrentNamespace) (Tcl_Interp *interp); /* 124 */
+    Tcl_Namespace * (*tcl_GetGlobalNamespace) (Tcl_Interp *interp); /* 125 */
+    void (*tcl_GetVariableFullName) (Tcl_Interp *interp, Tcl_Var variable, Tcl_Obj *objPtr); /* 126 */
+    int (*tcl_Import) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *pattern, int allowOverwrite); /* 127 */
+    void (*tcl_PopCallFrame) (Tcl_Interp *interp); /* 128 */
+    int (*tcl_PushCallFrame) (Tcl_Interp *interp, Tcl_CallFrame *framePtr, Tcl_Namespace *nsPtr, int isProcCallFrame); /* 129 */
+    int (*tcl_RemoveInterpResolvers) (Tcl_Interp *interp, const char *name); /* 130 */
+    void (*tcl_SetNamespaceResolvers) (Tcl_Namespace *namespacePtr, Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc, Tcl_ResolveCompiledVarProc *compiledVarProc); /* 131 */
+    int (*tclpHasSockets) (Tcl_Interp *interp); /* 132 */
+    struct tm * (*tclpGetDate) (const time_t *time, int useGMT); /* 133 */
+    void (*reserved134)(void);
+    void (*reserved135)(void);
+    void (*reserved136)(void);
+    void (*reserved137)(void);
+    CONST84_RETURN char * (*tclGetEnv) (const char *name, Tcl_DString *valuePtr); /* 138 */
+    void (*reserved139)(void);
+    void (*reserved140)(void);
+    CONST84_RETURN char * (*tclpGetCwd) (Tcl_Interp *interp, Tcl_DString *cwdPtr); /* 141 */
+    int (*tclSetByteCodeFromAny) (Tcl_Interp *interp, Tcl_Obj *objPtr, CompileHookProc *hookProc, ClientData clientData); /* 142 */
+    int (*tclAddLiteralObj) (struct CompileEnv *envPtr, Tcl_Obj *objPtr, LiteralEntry **litPtrPtr); /* 143 */
+    void (*tclHideLiteral) (Tcl_Interp *interp, struct CompileEnv *envPtr, int index); /* 144 */
+    const struct AuxDataType * (*tclGetAuxDataType) (const char *typeName); /* 145 */
+    TclHandle (*tclHandleCreate) (void *ptr); /* 146 */
+    void (*tclHandleFree) (TclHandle handle); /* 147 */
+    TclHandle (*tclHandlePreserve) (TclHandle handle); /* 148 */
+    void (*tclHandleRelease) (TclHandle handle); /* 149 */
+    int (*tclRegAbout) (Tcl_Interp *interp, Tcl_RegExp re); /* 150 */
+    void (*tclRegExpRangeUniChar) (Tcl_RegExp re, int index, int *startPtr, int *endPtr); /* 151 */
+    void (*tclSetLibraryPath) (Tcl_Obj *pathPtr); /* 152 */
+    Tcl_Obj * (*tclGetLibraryPath) (void); /* 153 */
+    void (*reserved154)(void);
+    void (*reserved155)(void);
+    void (*tclRegError) (Tcl_Interp *interp, const char *msg, int status); /* 156 */
+    Var * (*tclVarTraceExists) (Tcl_Interp *interp, const char *varName); /* 157 */
+    void (*reserved158)(void);
+    void (*reserved159)(void);
+    void (*reserved160)(void);
+    int (*tclChannelTransform) (Tcl_Interp *interp, Tcl_Channel chan, Tcl_Obj *cmdObjPtr); /* 161 */
+    void (*tclChannelEventScriptInvoker) (ClientData clientData, int flags); /* 162 */
+    const void * (*tclGetInstructionTable) (void); /* 163 */
+    void (*tclExpandCodeArray) (void *envPtr); /* 164 */
+    void (*tclpSetInitialEncodings) (void); /* 165 */
+    int (*tclListObjSetElement) (Tcl_Interp *interp, Tcl_Obj *listPtr, int index, Tcl_Obj *valuePtr); /* 166 */
+    void (*reserved167)(void);
+    void (*reserved168)(void);
+    int (*tclpUtfNcmp2) (const char *s1, const char *s2, unsigned long n); /* 169 */
+    int (*tclCheckInterpTraces) (Tcl_Interp *interp, const char *command, int numChars, Command *cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *const objv[]); /* 170 */
+    int (*tclCheckExecutionTraces) (Tcl_Interp *interp, const char *command, int numChars, Command *cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *const objv[]); /* 171 */
+    int (*tclInThreadExit) (void); /* 172 */
+    int (*tclUniCharMatch) (const Tcl_UniChar *string, int strLen, const Tcl_UniChar *pattern, int ptnLen, int flags); /* 173 */
+    void (*reserved174)(void);
+    int (*tclCallVarTraces) (Interp *iPtr, Var *arrayPtr, Var *varPtr, const char *part1, const char *part2, int flags, int leaveErrMsg); /* 175 */
+    void (*tclCleanupVar) (Var *varPtr, Var *arrayPtr); /* 176 */
+    void (*tclVarErrMsg) (Tcl_Interp *interp, const char *part1, const char *part2, const char *operation, const char *reason); /* 177 */
+    void (*reserved178)(void);
+    void (*reserved179)(void);
+    void (*reserved180)(void);
+    void (*reserved181)(void);
+    struct tm * (*tclpLocaltime) (const time_t *clock); /* 182 */
+    struct tm * (*tclpGmtime) (const time_t *clock); /* 183 */
+    void (*reserved184)(void);
+    void (*reserved185)(void);
+    void (*reserved186)(void);
+    void (*reserved187)(void);
+    void (*reserved188)(void);
+    void (*reserved189)(void);
+    void (*reserved190)(void);
+    void (*reserved191)(void);
+    void (*reserved192)(void);
+    void (*reserved193)(void);
+    void (*reserved194)(void);
+    void (*reserved195)(void);
+    void (*reserved196)(void);
+    void (*reserved197)(void);
+    int (*tclObjGetFrame) (Tcl_Interp *interp, Tcl_Obj *objPtr, CallFrame **framePtrPtr); /* 198 */
+    void (*reserved199)(void);
+    int (*tclpObjRemoveDirectory) (Tcl_Obj *pathPtr, int recursive, Tcl_Obj **errorPtr); /* 200 */
+    int (*tclpObjCopyDirectory) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr); /* 201 */
+    int (*tclpObjCreateDirectory) (Tcl_Obj *pathPtr); /* 202 */
+    int (*tclpObjDeleteFile) (Tcl_Obj *pathPtr); /* 203 */
+    int (*tclpObjCopyFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr); /* 204 */
+    int (*tclpObjRenameFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr); /* 205 */
+    int (*tclpObjStat) (Tcl_Obj *pathPtr, Tcl_StatBuf *buf); /* 206 */
+    int (*tclpObjAccess) (Tcl_Obj *pathPtr, int mode); /* 207 */
+    Tcl_Channel (*tclpOpenFileChannel) (Tcl_Interp *interp, Tcl_Obj *pathPtr, int mode, int permissions); /* 208 */
+    void (*reserved209)(void);
+    void (*reserved210)(void);
+    void (*reserved211)(void);
+    void (*tclpFindExecutable) (const char *argv0); /* 212 */
+    Tcl_Obj * (*tclGetObjNameOfExecutable) (void); /* 213 */
+    void (*tclSetObjNameOfExecutable) (Tcl_Obj *name, Tcl_Encoding encoding); /* 214 */
+    void * (*tclStackAlloc) (Tcl_Interp *interp, int numBytes); /* 215 */
+    void (*tclStackFree) (Tcl_Interp *interp, void *freePtr); /* 216 */
+    int (*tclPushStackFrame) (Tcl_Interp *interp, Tcl_CallFrame **framePtrPtr, Tcl_Namespace *namespacePtr, int isProcCallFrame); /* 217 */
+    void (*tclPopStackFrame) (Tcl_Interp *interp); /* 218 */
+    void (*reserved219)(void);
+    void (*reserved220)(void);
+    void (*reserved221)(void);
+    void (*reserved222)(void);
+    void (*reserved223)(void);
+    TclPlatformType * (*tclGetPlatform) (void); /* 224 */
+    Tcl_Obj * (*tclTraceDictPath) (Tcl_Interp *interp, Tcl_Obj *rootPtr, int keyc, Tcl_Obj *const keyv[], int flags); /* 225 */
+    int (*tclObjBeingDeleted) (Tcl_Obj *objPtr); /* 226 */
+    void (*tclSetNsPath) (Namespace *nsPtr, int pathLength, Tcl_Namespace *pathAry[]); /* 227 */
+    void (*reserved228)(void);
+    int (*tclPtrMakeUpvar) (Tcl_Interp *interp, Var *otherP1Ptr, const char *myName, int myFlags, int index); /* 229 */
+    Var * (*tclObjLookupVar) (Tcl_Interp *interp, Tcl_Obj *part1Ptr, const char *part2, int flags, const char *msg, const int createPart1, const int createPart2, Var **arrayPtrPtr); /* 230 */
+    int (*tclGetNamespaceFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_Namespace **nsPtrPtr); /* 231 */
+    int (*tclEvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags, const CmdFrame *invoker, int word); /* 232 */
+    void (*tclGetSrcInfoForPc) (CmdFrame *contextPtr); /* 233 */
+    Var * (*tclVarHashCreateVar) (TclVarHashTable *tablePtr, const char *key, int *newPtr); /* 234 */
+    void (*tclInitVarHashTable) (TclVarHashTable *tablePtr, Namespace *nsPtr); /* 235 */
+    void (*reserved236)(void);
+    int (*tclResetCancellation) (Tcl_Interp *interp, int force); /* 237 */
+    int (*tclNRInterpProc) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 238 */
+    int (*tclNRInterpProcCore) (Tcl_Interp *interp, Tcl_Obj *procNameObj, int skip, ProcErrorProc *errorProc); /* 239 */
+    int (*tclNRRunCallbacks) (Tcl_Interp *interp, int result, struct NRE_callback *rootPtr); /* 240 */
+    int (*tclNREvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags, const CmdFrame *invoker, int word); /* 241 */
+    int (*tclNREvalObjv) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], int flags, Command *cmdPtr); /* 242 */
+    void (*tclDbDumpActiveObjects) (FILE *outFile); /* 243 */
+    Tcl_HashTable * (*tclGetNamespaceChildTable) (Tcl_Namespace *nsPtr); /* 244 */
+    Tcl_HashTable * (*tclGetNamespaceCommandTable) (Tcl_Namespace *nsPtr); /* 245 */
+    int (*tclInitRewriteEnsemble) (Tcl_Interp *interp, int numRemoved, int numInserted, Tcl_Obj *const *objv); /* 246 */
+    void (*tclResetRewriteEnsemble) (Tcl_Interp *interp, int isRootEnsemble); /* 247 */
+    int (*tclCopyChannel) (Tcl_Interp *interp, Tcl_Channel inChan, Tcl_Channel outChan, Tcl_WideInt toRead, Tcl_Obj *cmdPtr); /* 248 */
+    char * (*tclDoubleDigits) (double dv, int ndigits, int flags, int *decpt, int *signum, char **endPtr); /* 249 */
+    void (*tclSetSlaveCancelFlags) (Tcl_Interp *interp, int flags, int force); /* 250 */
+} TclIntStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TclIntStubs *tclIntStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TCL_STUBS)
+
+/*
+ * Inline function declarations:
+ */
+
+/* Slot 0 is reserved */
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+#define TclAllocateFreeObjects \
+	(tclIntStubsPtr->tclAllocateFreeObjects) /* 3 */
+/* Slot 4 is reserved */
+#define TclCleanupChildren \
+	(tclIntStubsPtr->tclCleanupChildren) /* 5 */
+#define TclCleanupCommand \
+	(tclIntStubsPtr->tclCleanupCommand) /* 6 */
+#define TclCopyAndCollapse \
+	(tclIntStubsPtr->tclCopyAndCollapse) /* 7 */
+#define TclCopyChannelOld \
+	(tclIntStubsPtr->tclCopyChannelOld) /* 8 */
+#define TclCreatePipeline \
+	(tclIntStubsPtr->tclCreatePipeline) /* 9 */
+#define TclCreateProc \
+	(tclIntStubsPtr->tclCreateProc) /* 10 */
+#define TclDeleteCompiledLocalVars \
+	(tclIntStubsPtr->tclDeleteCompiledLocalVars) /* 11 */
+#define TclDeleteVars \
+	(tclIntStubsPtr->tclDeleteVars) /* 12 */
+/* Slot 13 is reserved */
+#define TclDumpMemoryInfo \
+	(tclIntStubsPtr->tclDumpMemoryInfo) /* 14 */
+/* Slot 15 is reserved */
+#define TclExprFloatError \
+	(tclIntStubsPtr->tclExprFloatError) /* 16 */
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+#define TclFindElement \
+	(tclIntStubsPtr->tclFindElement) /* 22 */
+#define TclFindProc \
+	(tclIntStubsPtr->tclFindProc) /* 23 */
+#define TclFormatInt \
+	(tclIntStubsPtr->tclFormatInt) /* 24 */
+#define TclFreePackageInfo \
+	(tclIntStubsPtr->tclFreePackageInfo) /* 25 */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+#define TclpGetDefaultStdChannel \
+	(tclIntStubsPtr->tclpGetDefaultStdChannel) /* 28 */
+/* Slot 29 is reserved */
+/* Slot 30 is reserved */
+#define TclGetExtension \
+	(tclIntStubsPtr->tclGetExtension) /* 31 */
+#define TclGetFrame \
+	(tclIntStubsPtr->tclGetFrame) /* 32 */
+/* Slot 33 is reserved */
+#define TclGetIntForIndex \
+	(tclIntStubsPtr->tclGetIntForIndex) /* 34 */
+/* Slot 35 is reserved */
+/* Slot 36 is reserved */
+#define TclGetLoadedPackages \
+	(tclIntStubsPtr->tclGetLoadedPackages) /* 37 */
+#define TclGetNamespaceForQualName \
+	(tclIntStubsPtr->tclGetNamespaceForQualName) /* 38 */
+#define TclGetObjInterpProc \
+	(tclIntStubsPtr->tclGetObjInterpProc) /* 39 */
+#define TclGetOpenMode \
+	(tclIntStubsPtr->tclGetOpenMode) /* 40 */
+#define TclGetOriginalCommand \
+	(tclIntStubsPtr->tclGetOriginalCommand) /* 41 */
+#define TclpGetUserHome \
+	(tclIntStubsPtr->tclpGetUserHome) /* 42 */
+/* Slot 43 is reserved */
+#define TclGuessPackageName \
+	(tclIntStubsPtr->tclGuessPackageName) /* 44 */
+#define TclHideUnsafeCommands \
+	(tclIntStubsPtr->tclHideUnsafeCommands) /* 45 */
+#define TclInExit \
+	(tclIntStubsPtr->tclInExit) /* 46 */
+/* Slot 47 is reserved */
+/* Slot 48 is reserved */
+/* Slot 49 is reserved */
+#define TclInitCompiledLocals \
+	(tclIntStubsPtr->tclInitCompiledLocals) /* 50 */
+#define TclInterpInit \
+	(tclIntStubsPtr->tclInterpInit) /* 51 */
+/* Slot 52 is reserved */
+#define TclInvokeObjectCommand \
+	(tclIntStubsPtr->tclInvokeObjectCommand) /* 53 */
+#define TclInvokeStringCommand \
+	(tclIntStubsPtr->tclInvokeStringCommand) /* 54 */
+#define TclIsProc \
+	(tclIntStubsPtr->tclIsProc) /* 55 */
+/* Slot 56 is reserved */
+/* Slot 57 is reserved */
+#define TclLookupVar \
+	(tclIntStubsPtr->tclLookupVar) /* 58 */
+/* Slot 59 is reserved */
+#define TclNeedSpace \
+	(tclIntStubsPtr->tclNeedSpace) /* 60 */
+#define TclNewProcBodyObj \
+	(tclIntStubsPtr->tclNewProcBodyObj) /* 61 */
+#define TclObjCommandComplete \
+	(tclIntStubsPtr->tclObjCommandComplete) /* 62 */
+#define TclObjInterpProc \
+	(tclIntStubsPtr->tclObjInterpProc) /* 63 */
+#define TclObjInvoke \
+	(tclIntStubsPtr->tclObjInvoke) /* 64 */
+/* Slot 65 is reserved */
+/* Slot 66 is reserved */
+/* Slot 67 is reserved */
+/* Slot 68 is reserved */
+#define TclpAlloc \
+	(tclIntStubsPtr->tclpAlloc) /* 69 */
+/* Slot 70 is reserved */
+/* Slot 71 is reserved */
+/* Slot 72 is reserved */
+/* Slot 73 is reserved */
+#define TclpFree \
+	(tclIntStubsPtr->tclpFree) /* 74 */
+#define TclpGetClicks \
+	(tclIntStubsPtr->tclpGetClicks) /* 75 */
+#define TclpGetSeconds \
+	(tclIntStubsPtr->tclpGetSeconds) /* 76 */
+#define TclpGetTime \
+	(tclIntStubsPtr->tclpGetTime) /* 77 */
+/* Slot 78 is reserved */
+/* Slot 79 is reserved */
+/* Slot 80 is reserved */
+#define TclpRealloc \
+	(tclIntStubsPtr->tclpRealloc) /* 81 */
+/* Slot 82 is reserved */
+/* Slot 83 is reserved */
+/* Slot 84 is reserved */
+/* Slot 85 is reserved */
+/* Slot 86 is reserved */
+/* Slot 87 is reserved */
+#define TclPrecTraceProc \
+	(tclIntStubsPtr->tclPrecTraceProc) /* 88 */
+#define TclPreventAliasLoop \
+	(tclIntStubsPtr->tclPreventAliasLoop) /* 89 */
+/* Slot 90 is reserved */
+#define TclProcCleanupProc \
+	(tclIntStubsPtr->tclProcCleanupProc) /* 91 */
+#define TclProcCompileProc \
+	(tclIntStubsPtr->tclProcCompileProc) /* 92 */
+#define TclProcDeleteProc \
+	(tclIntStubsPtr->tclProcDeleteProc) /* 93 */
+/* Slot 94 is reserved */
+/* Slot 95 is reserved */
+#define TclRenameCommand \
+	(tclIntStubsPtr->tclRenameCommand) /* 96 */
+#define TclResetShadowedCmdRefs \
+	(tclIntStubsPtr->tclResetShadowedCmdRefs) /* 97 */
+#define TclServiceIdle \
+	(tclIntStubsPtr->tclServiceIdle) /* 98 */
+/* Slot 99 is reserved */
+/* Slot 100 is reserved */
+#define TclSetPreInitScript \
+	(tclIntStubsPtr->tclSetPreInitScript) /* 101 */
+#define TclSetupEnv \
+	(tclIntStubsPtr->tclSetupEnv) /* 102 */
+#define TclSockGetPort \
+	(tclIntStubsPtr->tclSockGetPort) /* 103 */
+#define TclSockMinimumBuffersOld \
+	(tclIntStubsPtr->tclSockMinimumBuffersOld) /* 104 */
+/* Slot 105 is reserved */
+/* Slot 106 is reserved */
+/* Slot 107 is reserved */
+#define TclTeardownNamespace \
+	(tclIntStubsPtr->tclTeardownNamespace) /* 108 */
+#define TclUpdateReturnInfo \
+	(tclIntStubsPtr->tclUpdateReturnInfo) /* 109 */
+#define TclSockMinimumBuffers \
+	(tclIntStubsPtr->tclSockMinimumBuffers) /* 110 */
+#define Tcl_AddInterpResolvers \
+	(tclIntStubsPtr->tcl_AddInterpResolvers) /* 111 */
+#define Tcl_AppendExportList \
+	(tclIntStubsPtr->tcl_AppendExportList) /* 112 */
+#define Tcl_CreateNamespace \
+	(tclIntStubsPtr->tcl_CreateNamespace) /* 113 */
+#define Tcl_DeleteNamespace \
+	(tclIntStubsPtr->tcl_DeleteNamespace) /* 114 */
+#define Tcl_Export \
+	(tclIntStubsPtr->tcl_Export) /* 115 */
+#define Tcl_FindCommand \
+	(tclIntStubsPtr->tcl_FindCommand) /* 116 */
+#define Tcl_FindNamespace \
+	(tclIntStubsPtr->tcl_FindNamespace) /* 117 */
+#define Tcl_GetInterpResolvers \
+	(tclIntStubsPtr->tcl_GetInterpResolvers) /* 118 */
+#define Tcl_GetNamespaceResolvers \
+	(tclIntStubsPtr->tcl_GetNamespaceResolvers) /* 119 */
+#define Tcl_FindNamespaceVar \
+	(tclIntStubsPtr->tcl_FindNamespaceVar) /* 120 */
+#define Tcl_ForgetImport \
+	(tclIntStubsPtr->tcl_ForgetImport) /* 121 */
+#define Tcl_GetCommandFromObj \
+	(tclIntStubsPtr->tcl_GetCommandFromObj) /* 122 */
+#define Tcl_GetCommandFullName \
+	(tclIntStubsPtr->tcl_GetCommandFullName) /* 123 */
+#define Tcl_GetCurrentNamespace \
+	(tclIntStubsPtr->tcl_GetCurrentNamespace) /* 124 */
+#define Tcl_GetGlobalNamespace \
+	(tclIntStubsPtr->tcl_GetGlobalNamespace) /* 125 */
+#define Tcl_GetVariableFullName \
+	(tclIntStubsPtr->tcl_GetVariableFullName) /* 126 */
+#define Tcl_Import \
+	(tclIntStubsPtr->tcl_Import) /* 127 */
+#define Tcl_PopCallFrame \
+	(tclIntStubsPtr->tcl_PopCallFrame) /* 128 */
+#define Tcl_PushCallFrame \
+	(tclIntStubsPtr->tcl_PushCallFrame) /* 129 */
+#define Tcl_RemoveInterpResolvers \
+	(tclIntStubsPtr->tcl_RemoveInterpResolvers) /* 130 */
+#define Tcl_SetNamespaceResolvers \
+	(tclIntStubsPtr->tcl_SetNamespaceResolvers) /* 131 */
+#define TclpHasSockets \
+	(tclIntStubsPtr->tclpHasSockets) /* 132 */
+#define TclpGetDate \
+	(tclIntStubsPtr->tclpGetDate) /* 133 */
+/* Slot 134 is reserved */
+/* Slot 135 is reserved */
+/* Slot 136 is reserved */
+/* Slot 137 is reserved */
+#define TclGetEnv \
+	(tclIntStubsPtr->tclGetEnv) /* 138 */
+/* Slot 139 is reserved */
+/* Slot 140 is reserved */
+#define TclpGetCwd \
+	(tclIntStubsPtr->tclpGetCwd) /* 141 */
+#define TclSetByteCodeFromAny \
+	(tclIntStubsPtr->tclSetByteCodeFromAny) /* 142 */
+#define TclAddLiteralObj \
+	(tclIntStubsPtr->tclAddLiteralObj) /* 143 */
+#define TclHideLiteral \
+	(tclIntStubsPtr->tclHideLiteral) /* 144 */
+#define TclGetAuxDataType \
+	(tclIntStubsPtr->tclGetAuxDataType) /* 145 */
+#define TclHandleCreate \
+	(tclIntStubsPtr->tclHandleCreate) /* 146 */
+#define TclHandleFree \
+	(tclIntStubsPtr->tclHandleFree) /* 147 */
+#define TclHandlePreserve \
+	(tclIntStubsPtr->tclHandlePreserve) /* 148 */
+#define TclHandleRelease \
+	(tclIntStubsPtr->tclHandleRelease) /* 149 */
+#define TclRegAbout \
+	(tclIntStubsPtr->tclRegAbout) /* 150 */
+#define TclRegExpRangeUniChar \
+	(tclIntStubsPtr->tclRegExpRangeUniChar) /* 151 */
+#define TclSetLibraryPath \
+	(tclIntStubsPtr->tclSetLibraryPath) /* 152 */
+#define TclGetLibraryPath \
+	(tclIntStubsPtr->tclGetLibraryPath) /* 153 */
+/* Slot 154 is reserved */
+/* Slot 155 is reserved */
+#define TclRegError \
+	(tclIntStubsPtr->tclRegError) /* 156 */
+#define TclVarTraceExists \
+	(tclIntStubsPtr->tclVarTraceExists) /* 157 */
+/* Slot 158 is reserved */
+/* Slot 159 is reserved */
+/* Slot 160 is reserved */
+#define TclChannelTransform \
+	(tclIntStubsPtr->tclChannelTransform) /* 161 */
+#define TclChannelEventScriptInvoker \
+	(tclIntStubsPtr->tclChannelEventScriptInvoker) /* 162 */
+#define TclGetInstructionTable \
+	(tclIntStubsPtr->tclGetInstructionTable) /* 163 */
+#define TclExpandCodeArray \
+	(tclIntStubsPtr->tclExpandCodeArray) /* 164 */
+#define TclpSetInitialEncodings \
+	(tclIntStubsPtr->tclpSetInitialEncodings) /* 165 */
+#define TclListObjSetElement \
+	(tclIntStubsPtr->tclListObjSetElement) /* 166 */
+/* Slot 167 is reserved */
+/* Slot 168 is reserved */
+#define TclpUtfNcmp2 \
+	(tclIntStubsPtr->tclpUtfNcmp2) /* 169 */
+#define TclCheckInterpTraces \
+	(tclIntStubsPtr->tclCheckInterpTraces) /* 170 */
+#define TclCheckExecutionTraces \
+	(tclIntStubsPtr->tclCheckExecutionTraces) /* 171 */
+#define TclInThreadExit \
+	(tclIntStubsPtr->tclInThreadExit) /* 172 */
+#define TclUniCharMatch \
+	(tclIntStubsPtr->tclUniCharMatch) /* 173 */
+/* Slot 174 is reserved */
+#define TclCallVarTraces \
+	(tclIntStubsPtr->tclCallVarTraces) /* 175 */
+#define TclCleanupVar \
+	(tclIntStubsPtr->tclCleanupVar) /* 176 */
+#define TclVarErrMsg \
+	(tclIntStubsPtr->tclVarErrMsg) /* 177 */
+/* Slot 178 is reserved */
+/* Slot 179 is reserved */
+/* Slot 180 is reserved */
+/* Slot 181 is reserved */
+#define TclpLocaltime \
+	(tclIntStubsPtr->tclpLocaltime) /* 182 */
+#define TclpGmtime \
+	(tclIntStubsPtr->tclpGmtime) /* 183 */
+/* Slot 184 is reserved */
+/* Slot 185 is reserved */
+/* Slot 186 is reserved */
+/* Slot 187 is reserved */
+/* Slot 188 is reserved */
+/* Slot 189 is reserved */
+/* Slot 190 is reserved */
+/* Slot 191 is reserved */
+/* Slot 192 is reserved */
+/* Slot 193 is reserved */
+/* Slot 194 is reserved */
+/* Slot 195 is reserved */
+/* Slot 196 is reserved */
+/* Slot 197 is reserved */
+#define TclObjGetFrame \
+	(tclIntStubsPtr->tclObjGetFrame) /* 198 */
+/* Slot 199 is reserved */
+#define TclpObjRemoveDirectory \
+	(tclIntStubsPtr->tclpObjRemoveDirectory) /* 200 */
+#define TclpObjCopyDirectory \
+	(tclIntStubsPtr->tclpObjCopyDirectory) /* 201 */
+#define TclpObjCreateDirectory \
+	(tclIntStubsPtr->tclpObjCreateDirectory) /* 202 */
+#define TclpObjDeleteFile \
+	(tclIntStubsPtr->tclpObjDeleteFile) /* 203 */
+#define TclpObjCopyFile \
+	(tclIntStubsPtr->tclpObjCopyFile) /* 204 */
+#define TclpObjRenameFile \
+	(tclIntStubsPtr->tclpObjRenameFile) /* 205 */
+#define TclpObjStat \
+	(tclIntStubsPtr->tclpObjStat) /* 206 */
+#define TclpObjAccess \
+	(tclIntStubsPtr->tclpObjAccess) /* 207 */
+#define TclpOpenFileChannel \
+	(tclIntStubsPtr->tclpOpenFileChannel) /* 208 */
+/* Slot 209 is reserved */
+/* Slot 210 is reserved */
+/* Slot 211 is reserved */
+#define TclpFindExecutable \
+	(tclIntStubsPtr->tclpFindExecutable) /* 212 */
+#define TclGetObjNameOfExecutable \
+	(tclIntStubsPtr->tclGetObjNameOfExecutable) /* 213 */
+#define TclSetObjNameOfExecutable \
+	(tclIntStubsPtr->tclSetObjNameOfExecutable) /* 214 */
+#define TclStackAlloc \
+	(tclIntStubsPtr->tclStackAlloc) /* 215 */
+#define TclStackFree \
+	(tclIntStubsPtr->tclStackFree) /* 216 */
+#define TclPushStackFrame \
+	(tclIntStubsPtr->tclPushStackFrame) /* 217 */
+#define TclPopStackFrame \
+	(tclIntStubsPtr->tclPopStackFrame) /* 218 */
+/* Slot 219 is reserved */
+/* Slot 220 is reserved */
+/* Slot 221 is reserved */
+/* Slot 222 is reserved */
+/* Slot 223 is reserved */
+#define TclGetPlatform \
+	(tclIntStubsPtr->tclGetPlatform) /* 224 */
+#define TclTraceDictPath \
+	(tclIntStubsPtr->tclTraceDictPath) /* 225 */
+#define TclObjBeingDeleted \
+	(tclIntStubsPtr->tclObjBeingDeleted) /* 226 */
+#define TclSetNsPath \
+	(tclIntStubsPtr->tclSetNsPath) /* 227 */
+/* Slot 228 is reserved */
+#define TclPtrMakeUpvar \
+	(tclIntStubsPtr->tclPtrMakeUpvar) /* 229 */
+#define TclObjLookupVar \
+	(tclIntStubsPtr->tclObjLookupVar) /* 230 */
+#define TclGetNamespaceFromObj \
+	(tclIntStubsPtr->tclGetNamespaceFromObj) /* 231 */
+#define TclEvalObjEx \
+	(tclIntStubsPtr->tclEvalObjEx) /* 232 */
+#define TclGetSrcInfoForPc \
+	(tclIntStubsPtr->tclGetSrcInfoForPc) /* 233 */
+#define TclVarHashCreateVar \
+	(tclIntStubsPtr->tclVarHashCreateVar) /* 234 */
+#define TclInitVarHashTable \
+	(tclIntStubsPtr->tclInitVarHashTable) /* 235 */
+/* Slot 236 is reserved */
+#define TclResetCancellation \
+	(tclIntStubsPtr->tclResetCancellation) /* 237 */
+#define TclNRInterpProc \
+	(tclIntStubsPtr->tclNRInterpProc) /* 238 */
+#define TclNRInterpProcCore \
+	(tclIntStubsPtr->tclNRInterpProcCore) /* 239 */
+#define TclNRRunCallbacks \
+	(tclIntStubsPtr->tclNRRunCallbacks) /* 240 */
+#define TclNREvalObjEx \
+	(tclIntStubsPtr->tclNREvalObjEx) /* 241 */
+#define TclNREvalObjv \
+	(tclIntStubsPtr->tclNREvalObjv) /* 242 */
+#define TclDbDumpActiveObjects \
+	(tclIntStubsPtr->tclDbDumpActiveObjects) /* 243 */
+#define TclGetNamespaceChildTable \
+	(tclIntStubsPtr->tclGetNamespaceChildTable) /* 244 */
+#define TclGetNamespaceCommandTable \
+	(tclIntStubsPtr->tclGetNamespaceCommandTable) /* 245 */
+#define TclInitRewriteEnsemble \
+	(tclIntStubsPtr->tclInitRewriteEnsemble) /* 246 */
+#define TclResetRewriteEnsemble \
+	(tclIntStubsPtr->tclResetRewriteEnsemble) /* 247 */
+#define TclCopyChannel \
+	(tclIntStubsPtr->tclCopyChannel) /* 248 */
+#define TclDoubleDigits \
+	(tclIntStubsPtr->tclDoubleDigits) /* 249 */
+#define TclSetSlaveCancelFlags \
+	(tclIntStubsPtr->tclSetSlaveCancelFlags) /* 250 */
+
+#endif /* defined(USE_TCL_STUBS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TCLINTDECLS */
Index: src/tktext/tcl8.6/tclIntPlatDecls.h
===================================================================
--- src/tktext/tcl8.6/tclIntPlatDecls.h	(revision 0)
+++ src/tktext/tcl8.6/tclIntPlatDecls.h	(working copy)
@@ -0,0 +1,557 @@
+/*
+ * tclIntPlatDecls.h --
+ *
+ *	This file contains the declarations for all platform dependent
+ *	unsupported functions that are exported by the Tcl library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ * All rights reserved.
+ */
+
+#ifndef _TCLINTPLATDECLS
+#define _TCLINTPLATDECLS
+
+#ifdef __WIN32__
+#   define Tcl_DirEntry void
+#   define DIR void
+#endif
+
+#undef TCL_STORAGE_CLASS
+#ifdef BUILD_tcl
+#   define TCL_STORAGE_CLASS DLLEXPORT
+#else
+#   ifdef USE_TCL_STUBS
+#      define TCL_STORAGE_CLASS
+#   else
+#      define TCL_STORAGE_CLASS DLLIMPORT
+#   endif
+#endif
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tclInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+#if !defined(__WIN32__) && !defined(__CYGWIN__) && !defined(MAC_OSX_TCL) /* UNIX */
+/* 0 */
+EXTERN void		TclGetAndDetachPids(Tcl_Interp *interp,
+				Tcl_Channel chan);
+/* 1 */
+EXTERN int		TclpCloseFile(TclFile file);
+/* 2 */
+EXTERN Tcl_Channel	TclpCreateCommandChannel(TclFile readFile,
+				TclFile writeFile, TclFile errorFile,
+				int numPids, Tcl_Pid *pidPtr);
+/* 3 */
+EXTERN int		TclpCreatePipe(TclFile *readPipe, TclFile *writePipe);
+/* 4 */
+EXTERN int		TclpCreateProcess(Tcl_Interp *interp, int argc,
+				const char **argv, TclFile inputFile,
+				TclFile outputFile, TclFile errorFile,
+				Tcl_Pid *pidPtr);
+/* Slot 5 is reserved */
+/* 6 */
+EXTERN TclFile		TclpMakeFile(Tcl_Channel channel, int direction);
+/* 7 */
+EXTERN TclFile		TclpOpenFile(const char *fname, int mode);
+/* 8 */
+EXTERN int		TclUnixWaitForFile(int fd, int mask, int timeout);
+/* 9 */
+EXTERN TclFile		TclpCreateTempFile(const char *contents);
+/* 10 */
+EXTERN Tcl_DirEntry *	TclpReaddir(DIR *dir);
+/* 11 */
+EXTERN struct tm *	TclpLocaltime_unix(const time_t *clock);
+/* 12 */
+EXTERN struct tm *	TclpGmtime_unix(const time_t *clock);
+/* 13 */
+EXTERN char *		TclpInetNtoa(struct in_addr addr);
+/* 14 */
+EXTERN int		TclUnixCopyFile(const char *src, const char *dst,
+				const Tcl_StatBuf *statBufPtr,
+				int dontCopyAtts);
+/* Slot 15 is reserved */
+/* Slot 16 is reserved */
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* Slot 22 is reserved */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+/* 29 */
+EXTERN int		TclWinCPUID(unsigned int index, unsigned int *regs);
+/* 30 */
+EXTERN int		TclUnixOpenTemporaryFile(Tcl_Obj *dirObj,
+				Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+				Tcl_Obj *resultingNameObj);
+#endif /* UNIX */
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
+/* 0 */
+EXTERN void		TclWinConvertError(DWORD errCode);
+/* 1 */
+EXTERN void		TclWinConvertWSAError(DWORD errCode);
+/* 2 */
+EXTERN struct servent *	 TclWinGetServByName(const char *nm,
+				const char *proto);
+/* 3 */
+EXTERN int		TclWinGetSockOpt(SOCKET s, int level, int optname,
+				char *optval, int *optlen);
+/* 4 */
+EXTERN HINSTANCE	TclWinGetTclInstance(void);
+/* 5 */
+EXTERN int		TclUnixWaitForFile(int fd, int mask, int timeout);
+/* 6 */
+EXTERN unsigned short	TclWinNToHS(unsigned short ns);
+/* 7 */
+EXTERN int		TclWinSetSockOpt(SOCKET s, int level, int optname,
+				const char *optval, int optlen);
+/* 8 */
+EXTERN int		TclpGetPid(Tcl_Pid pid);
+/* 9 */
+EXTERN int		TclWinGetPlatformId(void);
+/* 10 */
+EXTERN Tcl_DirEntry *	TclpReaddir(DIR *dir);
+/* 11 */
+EXTERN void		TclGetAndDetachPids(Tcl_Interp *interp,
+				Tcl_Channel chan);
+/* 12 */
+EXTERN int		TclpCloseFile(TclFile file);
+/* 13 */
+EXTERN Tcl_Channel	TclpCreateCommandChannel(TclFile readFile,
+				TclFile writeFile, TclFile errorFile,
+				int numPids, Tcl_Pid *pidPtr);
+/* 14 */
+EXTERN int		TclpCreatePipe(TclFile *readPipe, TclFile *writePipe);
+/* 15 */
+EXTERN int		TclpCreateProcess(Tcl_Interp *interp, int argc,
+				const char **argv, TclFile inputFile,
+				TclFile outputFile, TclFile errorFile,
+				Tcl_Pid *pidPtr);
+/* 16 */
+EXTERN int		TclpIsAtty(int fd);
+/* 17 */
+EXTERN int		TclUnixCopyFile(const char *src, const char *dst,
+				const Tcl_StatBuf *statBufPtr,
+				int dontCopyAtts);
+/* 18 */
+EXTERN TclFile		TclpMakeFile(Tcl_Channel channel, int direction);
+/* 19 */
+EXTERN TclFile		TclpOpenFile(const char *fname, int mode);
+/* 20 */
+EXTERN void		TclWinAddProcess(HANDLE hProcess, DWORD id);
+/* 21 */
+EXTERN char *		TclpInetNtoa(struct in_addr addr);
+/* 22 */
+EXTERN TclFile		TclpCreateTempFile(const char *contents);
+/* Slot 23 is reserved */
+/* 24 */
+EXTERN char *		TclWinNoBackslash(char *path);
+/* Slot 25 is reserved */
+/* 26 */
+EXTERN void		TclWinSetInterfaces(int wide);
+/* 27 */
+EXTERN void		TclWinFlushDirtyChannels(void);
+/* 28 */
+EXTERN void		TclWinResetInterfaces(void);
+/* 29 */
+EXTERN int		TclWinCPUID(unsigned int index, unsigned int *regs);
+/* 30 */
+EXTERN int		TclUnixOpenTemporaryFile(Tcl_Obj *dirObj,
+				Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+				Tcl_Obj *resultingNameObj);
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+/* 0 */
+EXTERN void		TclGetAndDetachPids(Tcl_Interp *interp,
+				Tcl_Channel chan);
+/* 1 */
+EXTERN int		TclpCloseFile(TclFile file);
+/* 2 */
+EXTERN Tcl_Channel	TclpCreateCommandChannel(TclFile readFile,
+				TclFile writeFile, TclFile errorFile,
+				int numPids, Tcl_Pid *pidPtr);
+/* 3 */
+EXTERN int		TclpCreatePipe(TclFile *readPipe, TclFile *writePipe);
+/* 4 */
+EXTERN int		TclpCreateProcess(Tcl_Interp *interp, int argc,
+				const char **argv, TclFile inputFile,
+				TclFile outputFile, TclFile errorFile,
+				Tcl_Pid *pidPtr);
+/* Slot 5 is reserved */
+/* 6 */
+EXTERN TclFile		TclpMakeFile(Tcl_Channel channel, int direction);
+/* 7 */
+EXTERN TclFile		TclpOpenFile(const char *fname, int mode);
+/* 8 */
+EXTERN int		TclUnixWaitForFile(int fd, int mask, int timeout);
+/* 9 */
+EXTERN TclFile		TclpCreateTempFile(const char *contents);
+/* 10 */
+EXTERN Tcl_DirEntry *	TclpReaddir(DIR *dir);
+/* 11 */
+EXTERN struct tm *	TclpLocaltime_unix(const time_t *clock);
+/* 12 */
+EXTERN struct tm *	TclpGmtime_unix(const time_t *clock);
+/* 13 */
+EXTERN char *		TclpInetNtoa(struct in_addr addr);
+/* 14 */
+EXTERN int		TclUnixCopyFile(const char *src, const char *dst,
+				const Tcl_StatBuf *statBufPtr,
+				int dontCopyAtts);
+/* 15 */
+EXTERN int		TclMacOSXGetFileAttribute(Tcl_Interp *interp,
+				int objIndex, Tcl_Obj *fileName,
+				Tcl_Obj **attributePtrPtr);
+/* 16 */
+EXTERN int		TclMacOSXSetFileAttribute(Tcl_Interp *interp,
+				int objIndex, Tcl_Obj *fileName,
+				Tcl_Obj *attributePtr);
+/* 17 */
+EXTERN int		TclMacOSXCopyFileAttributes(const char *src,
+				const char *dst,
+				const Tcl_StatBuf *statBufPtr);
+/* 18 */
+EXTERN int		TclMacOSXMatchType(Tcl_Interp *interp,
+				const char *pathName, const char *fileName,
+				Tcl_StatBuf *statBufPtr,
+				Tcl_GlobTypeData *types);
+/* 19 */
+EXTERN void		TclMacOSXNotifierAddRunLoopMode(
+				const void *runLoopMode);
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* Slot 22 is reserved */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+/* 29 */
+EXTERN int		TclWinCPUID(unsigned int index, unsigned int *regs);
+/* 30 */
+EXTERN int		TclUnixOpenTemporaryFile(Tcl_Obj *dirObj,
+				Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+				Tcl_Obj *resultingNameObj);
+#endif /* MACOSX */
+
+typedef struct TclIntPlatStubs {
+    int magic;
+    void *hooks;
+
+#if !defined(__WIN32__) && !defined(__CYGWIN__) && !defined(MAC_OSX_TCL) /* UNIX */
+    void (*tclGetAndDetachPids) (Tcl_Interp *interp, Tcl_Channel chan); /* 0 */
+    int (*tclpCloseFile) (TclFile file); /* 1 */
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr); /* 2 */
+    int (*tclpCreatePipe) (TclFile *readPipe, TclFile *writePipe); /* 3 */
+    int (*tclpCreateProcess) (Tcl_Interp *interp, int argc, const char **argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid *pidPtr); /* 4 */
+    void (*reserved5)(void);
+    TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 6 */
+    TclFile (*tclpOpenFile) (const char *fname, int mode); /* 7 */
+    int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 8 */
+    TclFile (*tclpCreateTempFile) (const char *contents); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (DIR *dir); /* 10 */
+    struct tm * (*tclpLocaltime_unix) (const time_t *clock); /* 11 */
+    struct tm * (*tclpGmtime_unix) (const time_t *clock); /* 12 */
+    char * (*tclpInetNtoa) (struct in_addr addr); /* 13 */
+    int (*tclUnixCopyFile) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr, int dontCopyAtts); /* 14 */
+    void (*reserved15)(void);
+    void (*reserved16)(void);
+    void (*reserved17)(void);
+    void (*reserved18)(void);
+    void (*reserved19)(void);
+    void (*reserved20)(void);
+    void (*reserved21)(void);
+    void (*reserved22)(void);
+    void (*reserved23)(void);
+    void (*reserved24)(void);
+    void (*reserved25)(void);
+    void (*reserved26)(void);
+    void (*reserved27)(void);
+    void (*reserved28)(void);
+    int (*tclWinCPUID) (unsigned int index, unsigned int *regs); /* 29 */
+    int (*tclUnixOpenTemporaryFile) (Tcl_Obj *dirObj, Tcl_Obj *basenameObj, Tcl_Obj *extensionObj, Tcl_Obj *resultingNameObj); /* 30 */
+#endif /* UNIX */
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
+    void (*tclWinConvertError) (DWORD errCode); /* 0 */
+    void (*tclWinConvertWSAError) (DWORD errCode); /* 1 */
+    struct servent * (*tclWinGetServByName) (const char *nm, const char *proto); /* 2 */
+    int (*tclWinGetSockOpt) (SOCKET s, int level, int optname, char *optval, int *optlen); /* 3 */
+    HINSTANCE (*tclWinGetTclInstance) (void); /* 4 */
+    int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 5 */
+    unsigned short (*tclWinNToHS) (unsigned short ns); /* 6 */
+    int (*tclWinSetSockOpt) (SOCKET s, int level, int optname, const char *optval, int optlen); /* 7 */
+    int (*tclpGetPid) (Tcl_Pid pid); /* 8 */
+    int (*tclWinGetPlatformId) (void); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (DIR *dir); /* 10 */
+    void (*tclGetAndDetachPids) (Tcl_Interp *interp, Tcl_Channel chan); /* 11 */
+    int (*tclpCloseFile) (TclFile file); /* 12 */
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr); /* 13 */
+    int (*tclpCreatePipe) (TclFile *readPipe, TclFile *writePipe); /* 14 */
+    int (*tclpCreateProcess) (Tcl_Interp *interp, int argc, const char **argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid *pidPtr); /* 15 */
+    int (*tclpIsAtty) (int fd); /* 16 */
+    int (*tclUnixCopyFile) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr, int dontCopyAtts); /* 17 */
+    TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 18 */
+    TclFile (*tclpOpenFile) (const char *fname, int mode); /* 19 */
+    void (*tclWinAddProcess) (HANDLE hProcess, DWORD id); /* 20 */
+    char * (*tclpInetNtoa) (struct in_addr addr); /* 21 */
+    TclFile (*tclpCreateTempFile) (const char *contents); /* 22 */
+    void (*reserved23)(void);
+    char * (*tclWinNoBackslash) (char *path); /* 24 */
+    void (*reserved25)(void);
+    void (*tclWinSetInterfaces) (int wide); /* 26 */
+    void (*tclWinFlushDirtyChannels) (void); /* 27 */
+    void (*tclWinResetInterfaces) (void); /* 28 */
+    int (*tclWinCPUID) (unsigned int index, unsigned int *regs); /* 29 */
+    int (*tclUnixOpenTemporaryFile) (Tcl_Obj *dirObj, Tcl_Obj *basenameObj, Tcl_Obj *extensionObj, Tcl_Obj *resultingNameObj); /* 30 */
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+    void (*tclGetAndDetachPids) (Tcl_Interp *interp, Tcl_Channel chan); /* 0 */
+    int (*tclpCloseFile) (TclFile file); /* 1 */
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr); /* 2 */
+    int (*tclpCreatePipe) (TclFile *readPipe, TclFile *writePipe); /* 3 */
+    int (*tclpCreateProcess) (Tcl_Interp *interp, int argc, const char **argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid *pidPtr); /* 4 */
+    void (*reserved5)(void);
+    TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 6 */
+    TclFile (*tclpOpenFile) (const char *fname, int mode); /* 7 */
+    int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 8 */
+    TclFile (*tclpCreateTempFile) (const char *contents); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (DIR *dir); /* 10 */
+    struct tm * (*tclpLocaltime_unix) (const time_t *clock); /* 11 */
+    struct tm * (*tclpGmtime_unix) (const time_t *clock); /* 12 */
+    char * (*tclpInetNtoa) (struct in_addr addr); /* 13 */
+    int (*tclUnixCopyFile) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr, int dontCopyAtts); /* 14 */
+    int (*tclMacOSXGetFileAttribute) (Tcl_Interp *interp, int objIndex, Tcl_Obj *fileName, Tcl_Obj **attributePtrPtr); /* 15 */
+    int (*tclMacOSXSetFileAttribute) (Tcl_Interp *interp, int objIndex, Tcl_Obj *fileName, Tcl_Obj *attributePtr); /* 16 */
+    int (*tclMacOSXCopyFileAttributes) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr); /* 17 */
+    int (*tclMacOSXMatchType) (Tcl_Interp *interp, const char *pathName, const char *fileName, Tcl_StatBuf *statBufPtr, Tcl_GlobTypeData *types); /* 18 */
+    void (*tclMacOSXNotifierAddRunLoopMode) (const void *runLoopMode); /* 19 */
+    void (*reserved20)(void);
+    void (*reserved21)(void);
+    void (*reserved22)(void);
+    void (*reserved23)(void);
+    void (*reserved24)(void);
+    void (*reserved25)(void);
+    void (*reserved26)(void);
+    void (*reserved27)(void);
+    void (*reserved28)(void);
+    int (*tclWinCPUID) (unsigned int index, unsigned int *regs); /* 29 */
+    int (*tclUnixOpenTemporaryFile) (Tcl_Obj *dirObj, Tcl_Obj *basenameObj, Tcl_Obj *extensionObj, Tcl_Obj *resultingNameObj); /* 30 */
+#endif /* MACOSX */
+} TclIntPlatStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TclIntPlatStubs *tclIntPlatStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TCL_STUBS)
+
+/*
+ * Inline function declarations:
+ */
+
+#if !defined(__WIN32__) && !defined(__CYGWIN__) && !defined(MAC_OSX_TCL) /* UNIX */
+#define TclGetAndDetachPids \
+	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 0 */
+#define TclpCloseFile \
+	(tclIntPlatStubsPtr->tclpCloseFile) /* 1 */
+#define TclpCreateCommandChannel \
+	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 2 */
+#define TclpCreatePipe \
+	(tclIntPlatStubsPtr->tclpCreatePipe) /* 3 */
+#define TclpCreateProcess \
+	(tclIntPlatStubsPtr->tclpCreateProcess) /* 4 */
+/* Slot 5 is reserved */
+#define TclpMakeFile \
+	(tclIntPlatStubsPtr->tclpMakeFile) /* 6 */
+#define TclpOpenFile \
+	(tclIntPlatStubsPtr->tclpOpenFile) /* 7 */
+#define TclUnixWaitForFile \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile) /* 8 */
+#define TclpCreateTempFile \
+	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 9 */
+#define TclpReaddir \
+	(tclIntPlatStubsPtr->tclpReaddir) /* 10 */
+#define TclpLocaltime_unix \
+	(tclIntPlatStubsPtr->tclpLocaltime_unix) /* 11 */
+#define TclpGmtime_unix \
+	(tclIntPlatStubsPtr->tclpGmtime_unix) /* 12 */
+#define TclpInetNtoa \
+	(tclIntPlatStubsPtr->tclpInetNtoa) /* 13 */
+#define TclUnixCopyFile \
+	(tclIntPlatStubsPtr->tclUnixCopyFile) /* 14 */
+/* Slot 15 is reserved */
+/* Slot 16 is reserved */
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* Slot 22 is reserved */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+#define TclWinCPUID \
+	(tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
+#define TclUnixOpenTemporaryFile \
+	(tclIntPlatStubsPtr->tclUnixOpenTemporaryFile) /* 30 */
+#endif /* UNIX */
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
+#define TclWinConvertError \
+	(tclIntPlatStubsPtr->tclWinConvertError) /* 0 */
+#define TclWinConvertWSAError \
+	(tclIntPlatStubsPtr->tclWinConvertWSAError) /* 1 */
+#define TclWinGetServByName \
+	(tclIntPlatStubsPtr->tclWinGetServByName) /* 2 */
+#define TclWinGetSockOpt \
+	(tclIntPlatStubsPtr->tclWinGetSockOpt) /* 3 */
+#define TclWinGetTclInstance \
+	(tclIntPlatStubsPtr->tclWinGetTclInstance) /* 4 */
+#define TclUnixWaitForFile \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile) /* 5 */
+#define TclWinNToHS \
+	(tclIntPlatStubsPtr->tclWinNToHS) /* 6 */
+#define TclWinSetSockOpt \
+	(tclIntPlatStubsPtr->tclWinSetSockOpt) /* 7 */
+#define TclpGetPid \
+	(tclIntPlatStubsPtr->tclpGetPid) /* 8 */
+#define TclWinGetPlatformId \
+	(tclIntPlatStubsPtr->tclWinGetPlatformId) /* 9 */
+#define TclpReaddir \
+	(tclIntPlatStubsPtr->tclpReaddir) /* 10 */
+#define TclGetAndDetachPids \
+	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 11 */
+#define TclpCloseFile \
+	(tclIntPlatStubsPtr->tclpCloseFile) /* 12 */
+#define TclpCreateCommandChannel \
+	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 13 */
+#define TclpCreatePipe \
+	(tclIntPlatStubsPtr->tclpCreatePipe) /* 14 */
+#define TclpCreateProcess \
+	(tclIntPlatStubsPtr->tclpCreateProcess) /* 15 */
+#define TclpIsAtty \
+	(tclIntPlatStubsPtr->tclpIsAtty) /* 16 */
+#define TclUnixCopyFile \
+	(tclIntPlatStubsPtr->tclUnixCopyFile) /* 17 */
+#define TclpMakeFile \
+	(tclIntPlatStubsPtr->tclpMakeFile) /* 18 */
+#define TclpOpenFile \
+	(tclIntPlatStubsPtr->tclpOpenFile) /* 19 */
+#define TclWinAddProcess \
+	(tclIntPlatStubsPtr->tclWinAddProcess) /* 20 */
+#define TclpInetNtoa \
+	(tclIntPlatStubsPtr->tclpInetNtoa) /* 21 */
+#define TclpCreateTempFile \
+	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 22 */
+/* Slot 23 is reserved */
+#define TclWinNoBackslash \
+	(tclIntPlatStubsPtr->tclWinNoBackslash) /* 24 */
+/* Slot 25 is reserved */
+#define TclWinSetInterfaces \
+	(tclIntPlatStubsPtr->tclWinSetInterfaces) /* 26 */
+#define TclWinFlushDirtyChannels \
+	(tclIntPlatStubsPtr->tclWinFlushDirtyChannels) /* 27 */
+#define TclWinResetInterfaces \
+	(tclIntPlatStubsPtr->tclWinResetInterfaces) /* 28 */
+#define TclWinCPUID \
+	(tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
+#define TclUnixOpenTemporaryFile \
+	(tclIntPlatStubsPtr->tclUnixOpenTemporaryFile) /* 30 */
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#define TclGetAndDetachPids \
+	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 0 */
+#define TclpCloseFile \
+	(tclIntPlatStubsPtr->tclpCloseFile) /* 1 */
+#define TclpCreateCommandChannel \
+	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 2 */
+#define TclpCreatePipe \
+	(tclIntPlatStubsPtr->tclpCreatePipe) /* 3 */
+#define TclpCreateProcess \
+	(tclIntPlatStubsPtr->tclpCreateProcess) /* 4 */
+/* Slot 5 is reserved */
+#define TclpMakeFile \
+	(tclIntPlatStubsPtr->tclpMakeFile) /* 6 */
+#define TclpOpenFile \
+	(tclIntPlatStubsPtr->tclpOpenFile) /* 7 */
+#define TclUnixWaitForFile \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile) /* 8 */
+#define TclpCreateTempFile \
+	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 9 */
+#define TclpReaddir \
+	(tclIntPlatStubsPtr->tclpReaddir) /* 10 */
+#define TclpLocaltime_unix \
+	(tclIntPlatStubsPtr->tclpLocaltime_unix) /* 11 */
+#define TclpGmtime_unix \
+	(tclIntPlatStubsPtr->tclpGmtime_unix) /* 12 */
+#define TclpInetNtoa \
+	(tclIntPlatStubsPtr->tclpInetNtoa) /* 13 */
+#define TclUnixCopyFile \
+	(tclIntPlatStubsPtr->tclUnixCopyFile) /* 14 */
+#define TclMacOSXGetFileAttribute \
+	(tclIntPlatStubsPtr->tclMacOSXGetFileAttribute) /* 15 */
+#define TclMacOSXSetFileAttribute \
+	(tclIntPlatStubsPtr->tclMacOSXSetFileAttribute) /* 16 */
+#define TclMacOSXCopyFileAttributes \
+	(tclIntPlatStubsPtr->tclMacOSXCopyFileAttributes) /* 17 */
+#define TclMacOSXMatchType \
+	(tclIntPlatStubsPtr->tclMacOSXMatchType) /* 18 */
+#define TclMacOSXNotifierAddRunLoopMode \
+	(tclIntPlatStubsPtr->tclMacOSXNotifierAddRunLoopMode) /* 19 */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* Slot 22 is reserved */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+#define TclWinCPUID \
+	(tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
+#define TclUnixOpenTemporaryFile \
+	(tclIntPlatStubsPtr->tclUnixOpenTemporaryFile) /* 30 */
+#endif /* MACOSX */
+
+#endif /* defined(USE_TCL_STUBS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+#undef TclpLocaltime_unix
+#undef TclpGmtime_unix
+#undef TclWinConvertWSAError
+#define TclWinConvertWSAError TclWinConvertError
+
+#if defined(__WIN32__) || defined(__CYGWIN__)
+#   undef TclWinNToHS
+#   define TclWinNToHS ntohs
+#else
+#   undef TclpGetPid
+#   define TclpGetPid(pid) ((unsigned long) (pid))
+#endif
+
+#endif /* _TCLINTPLATDECLS */
Index: src/tktext/tcl8.6/tclPort.h
===================================================================
--- src/tktext/tcl8.6/tclPort.h	(revision 0)
+++ src/tktext/tcl8.6/tclPort.h	(working copy)
@@ -0,0 +1,44 @@
+/*
+ * tclPort.h --
+ *
+ *	This header file handles porting issues that occur because
+ *	of differences between systems.  It reads in platform specific
+ *	portability files.
+ *
+ * Copyright (c) 1994-1995 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLPORT
+#define _TCLPORT
+
+#ifdef HAVE_TCL_CONFIG_H
+#include "tclConfig.h"
+#endif
+#if defined(_WIN32)
+#   include "tclWinPort.h"
+#endif
+#include "tcl.h"
+#if !defined(_WIN32)
+#   include "tclUnixPort.h"
+#endif
+
+#if !defined(LLONG_MIN)
+#   ifdef TCL_WIDE_INT_IS_LONG
+#      define LLONG_MIN LONG_MIN
+#   else
+#      ifdef LLONG_BIT
+#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<(LLONG_BIT-1)))
+#      else
+/* Assume we're on a system with a 64-bit 'long long' type */
+#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<63))
+#      endif
+#   endif
+/* Assume that if LLONG_MIN is undefined, then so is LLONG_MAX */
+#   define LLONG_MAX (~LLONG_MIN)
+#endif
+
+
+#endif /* _TCLPORT */
Index: src/tktext/tcl8.6/tclUnixPort.h
===================================================================
--- src/tktext/tcl8.6/tclUnixPort.h	(revision 0)
+++ src/tktext/tcl8.6/tclUnixPort.h	(working copy)
@@ -0,0 +1,758 @@
+/*
+ * tclUnixPort.h --
+ *
+ *	This header file handles porting issues that occur because of
+ *	differences between systems. It reads in UNIX-related header files and
+ *	sets up UNIX-related macros for Tcl's UNIX core. It should be the only
+ *	file that contains #ifdefs to handle different flavors of UNIX. This
+ *	file sets up the union of all UNIX-related things needed by any of the
+ *	Tcl core files. This file depends on configuration #defines such as
+ *	NO_DIRENT_H that are set up by the "configure" script.
+ *
+ *	Much of the material in this file was originally contributed by Karl
+ *	Lehenbauer, Mark Diekhans and Peter da Silva.
+ *
+ * Copyright (c) 1991-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLUNIXPORT
+#define _TCLUNIXPORT
+
+#ifndef MODULE_SCOPE
+#define MODULE_SCOPE	extern
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The following sets of #includes and #ifdefs are required to get Tcl to
+ * compile under the various flavors of unix.
+ *---------------------------------------------------------------------------
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_NET_ERRNO_H
+#   include <net/errno.h>
+#endif
+#include <pwd.h>
+#include <signal.h>
+#ifdef HAVE_SYS_PARAM_H
+#   include <sys/param.h>
+#endif
+#include <sys/types.h>
+#ifdef USE_DIRENT2_H
+#   include "../compat/dirent2.h"
+#else
+#ifdef NO_DIRENT_H
+#   include "../compat/dirent.h"
+#else
+#   include <dirent.h>
+#endif
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Parameterize for 64-bit filesystem support.
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef HAVE_STRUCT_DIRENT64
+typedef struct dirent64	Tcl_DirEntry;
+#   define TclOSreaddir		readdir64
+#else
+typedef struct dirent	Tcl_DirEntry;
+#   define TclOSreaddir		readdir
+#endif
+
+#ifdef HAVE_TYPE_OFF64_T
+typedef off64_t		Tcl_SeekOffset;
+#   define TclOSseek		lseek64
+#   define TclOSopen		open64
+#else
+typedef off_t		Tcl_SeekOffset;
+#   define TclOSseek		lseek
+#   define TclOSopen		open
+#endif
+
+#ifdef __CYGWIN__
+
+    /* Make some symbols available without including <windows.h> */
+#   define DWORD unsigned int
+#   define CP_UTF8 65001
+#   define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS 0x00000004
+#   define HANDLE void *
+#   define HINSTANCE void *
+#   define SOCKET unsigned int
+#   define WSAEWOULDBLOCK 10035
+    typedef unsigned short WCHAR;
+    DLLIMPORT extern __stdcall int GetModuleHandleExW(unsigned int, const char *, void *);
+    DLLIMPORT extern __stdcall int GetModuleFileNameW(void *, const char *, int);
+    DLLIMPORT extern __stdcall int WideCharToMultiByte(int, int, const char *, int,
+	    const char *, int, const char *, const char *);
+    DLLIMPORT extern __stdcall int MultiByteToWideChar(int, int, const char *, int,
+	    WCHAR *, int);
+    DLLIMPORT extern __stdcall void OutputDebugStringW(const WCHAR *);
+    DLLIMPORT extern __stdcall int IsDebuggerPresent();
+
+    DLLIMPORT extern int cygwin_conv_path(int, const void *, void *, int);
+    DLLIMPORT extern int cygwin_conv_path_list(int, const void *, void *, int);
+#   define USE_PUTENV 1
+#   define USE_PUTENV_FOR_UNSET 1
+/* On Cygwin, the environment is imported from the Cygwin DLL. */
+#   define environ __cygwin_environ
+#   define timezone _timezone
+    DLLIMPORT extern char **__cygwin_environ;
+    MODULE_SCOPE int TclOSstat(const char *name, Tcl_StatBuf *statBuf);
+    MODULE_SCOPE int TclOSlstat(const char *name, Tcl_StatBuf *statBuf);
+#elif defined(HAVE_STRUCT_STAT64)
+#   define TclOSstat		stat64
+#   define TclOSlstat		lstat64
+#else
+#   define TclOSstat		stat
+#   define TclOSlstat		lstat
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Miscellaneous includes that might be missing.
+ *---------------------------------------------------------------------------
+ */
+
+#include <sys/file.h>
+#ifdef HAVE_SYS_SELECT_H
+#   include <sys/select.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+#   include <sys/stat.h>
+#endif
+#if TIME_WITH_SYS_TIME
+#   include <sys/time.h>
+#   include <time.h>
+#else
+#if HAVE_SYS_TIME_H
+#   include <sys/time.h>
+#else
+#   include <time.h>
+#endif
+#endif
+#ifndef NO_SYS_WAIT_H
+#   include <sys/wait.h>
+#endif
+#if HAVE_INTTYPES_H
+#   include <inttypes.h>
+#endif
+#ifdef NO_LIMITS_H
+#   include "../compat/limits.h"
+#else
+#   include <limits.h>
+#endif
+#if HAVE_STDINT_H
+#   include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#   include <unistd.h>
+#else
+#   include "../compat/unistd.h"
+#endif
+
+MODULE_SCOPE int	TclUnixSetBlockingMode(int fd, int mode);
+
+#include <utime.h>
+
+/*
+ *---------------------------------------------------------------------------
+ * Socket support stuff: This likely needs more work to parameterize for each
+ * system.
+ *---------------------------------------------------------------------------
+ */
+
+#include <sys/socket.h>		/* struct sockaddr, SOCK_STREAM, ... */
+#ifndef NO_UNAME
+#   include <sys/utsname.h>	/* uname system call. */
+#endif
+#include <netinet/in.h>		/* struct in_addr, struct sockaddr_in */
+#include <arpa/inet.h>		/* inet_ntoa() */
+#include <netdb.h>		/* getaddrinfo() */
+#ifdef NEED_FAKE_RFC2553
+# include "../compat/fake-rfc2553.h"
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Some platforms (e.g. SunOS) don't define FLT_MAX and FLT_MIN, so we look
+ * for an alternative definition. If no other alternative is available we use
+ * a reasonable guess.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef NO_FLOAT_H
+#   include <float.h>
+#else
+#ifndef NO_VALUES_H
+#   include <values.h>
+#endif
+#endif
+
+#ifndef FLT_MAX
+#   ifdef MAXFLOAT
+#	define FLT_MAX	MAXFLOAT
+#   else
+#	define FLT_MAX	3.402823466E+38F
+#   endif
+#endif
+#ifndef FLT_MIN
+#   ifdef MINFLOAT
+#	define FLT_MIN	MINFLOAT
+#   else
+#	define FLT_MIN	1.175494351E-38F
+#   endif
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * NeXT doesn't define O_NONBLOCK, so #define it here if necessary.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef O_NONBLOCK
+#   define O_NONBLOCK 0x80
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The type of the status returned by wait varies from UNIX system to UNIX
+ * system. The macro below defines it:
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef _AIX
+#   define WAIT_STATUS_TYPE	pid_t
+#else
+#ifndef NO_UNION_WAIT
+#   define WAIT_STATUS_TYPE	union wait
+#else
+#   define WAIT_STATUS_TYPE	int
+#endif
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Supply definitions for macros to query wait status, if not already defined
+ * in header files above.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef WIFEXITED
+#   define WIFEXITED(stat)	(((*((int *) &(stat))) & 0xff) == 0)
+#endif
+
+#ifndef WEXITSTATUS
+#   define WEXITSTATUS(stat)	(((*((int *) &(stat))) >> 8) & 0xff)
+#endif
+
+#ifndef WIFSIGNALED
+#   define WIFSIGNALED(stat) \
+	(((*((int *) &(stat)))) && ((*((int *) &(stat))) \
+		== ((*((int *) &(stat))) & 0x00ff)))
+#endif
+
+#ifndef WTERMSIG
+#   define WTERMSIG(stat)	((*((int *) &(stat))) & 0x7f)
+#endif
+
+#ifndef WIFSTOPPED
+#   define WIFSTOPPED(stat)	(((*((int *) &(stat))) & 0xff) == 0177)
+#endif
+
+#ifndef WSTOPSIG
+#   define WSTOPSIG(stat)	(((*((int *) &(stat))) >> 8) & 0xff)
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Define constants for waitpid() system call if they aren't defined by a
+ * system header file.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef WNOHANG
+#   define WNOHANG 1
+#endif
+#ifndef WUNTRACED
+#   define WUNTRACED 2
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Supply macros for seek offsets, if they're not already provided by an
+ * include file.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef SEEK_SET
+#   define SEEK_SET 0
+#endif
+#ifndef SEEK_CUR
+#   define SEEK_CUR 1
+#endif
+#ifndef SEEK_END
+#   define SEEK_END 2
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The stuff below is needed by the "time" command. If this system has no
+ * gettimeofday call, then must use times() instead.
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef NO_GETTOD
+#   include <sys/times.h>
+#else
+#   ifdef HAVE_BSDGETTIMEOFDAY
+#	define gettimeofday BSDgettimeofday
+#   endif
+#endif
+
+#ifdef GETTOD_NOT_DECLARED
+MODULE_SCOPE int	gettimeofday(struct timeval *tp,
+			    struct timezone *tzp);
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Define access mode constants if they aren't already defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef F_OK
+#   define F_OK		00
+#endif
+#ifndef X_OK
+#   define X_OK		01
+#endif
+#ifndef W_OK
+#   define W_OK		02
+#endif
+#ifndef R_OK
+#   define R_OK		04
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Define FD_CLOEEXEC (the close-on-exec flag bit) if it isn't already
+ * defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef FD_CLOEXEC
+#   define FD_CLOEXEC	1
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * On systems without symbolic links (i.e. S_IFLNK isn't defined) define
+ * "lstat" to use "stat" instead.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef S_IFLNK
+#   undef TclOSlstat
+#   define lstat	stat
+#   define lstat64	stat64
+#   define TclOSlstat	TclOSstat
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Define macros to query file type bits, if they're not already defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef S_ISREG
+#   ifdef S_IFREG
+#	define S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
+#   else
+#	define S_ISREG(m)	0
+#   endif
+#endif /* !S_ISREG */
+#ifndef S_ISDIR
+#   ifdef S_IFDIR
+#	define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
+#   else
+#	define S_ISDIR(m)	0
+#   endif
+#endif /* !S_ISDIR */
+#ifndef S_ISCHR
+#   ifdef S_IFCHR
+#	define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
+#   else
+#	define S_ISCHR(m)	0
+#   endif
+#endif /* !S_ISCHR */
+
+#ifndef S_ISBLK
+#   ifdef S_IFBLK
+#	define S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
+#   else
+#	define S_ISBLK(m)	0
+#   endif
+#endif /* !S_ISBLK */
+
+#ifndef S_ISFIFO
+#   ifdef S_IFIFO
+#	define S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
+#   else
+#	define S_ISFIFO(m)	0
+#   endif
+#endif /* !S_ISFIFO */
+
+#ifndef S_ISLNK
+#   ifdef S_IFLNK
+#	define S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)
+#   else
+#	define S_ISLNK(m)	0
+#   endif
+#endif /* !S_ISLNK */
+
+#ifndef S_ISSOCK
+#   ifdef S_IFSOCK
+#	define S_ISSOCK(m)	(((m) & S_IFMT) == S_IFSOCK)
+#   else
+#	define S_ISSOCK(m)	0
+#   endif
+#endif /* !S_ISSOCK */
+
+/*
+ *---------------------------------------------------------------------------
+ * Make sure that MAXPATHLEN and MAXNAMLEN are defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef MAXPATHLEN
+#   ifdef PATH_MAX
+#	define MAXPATHLEN	PATH_MAX
+#   else
+#	define MAXPATHLEN	2048
+#   endif
+#endif
+
+#ifndef MAXNAMLEN
+#   ifdef NAME_MAX
+#	define MAXNAMLEN	NAME_MAX
+#   else
+#	define MAXNAMLEN	255
+#   endif
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Make sure that L_tmpnam is defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef L_tmpnam
+#   define L_tmpnam	100
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macro defines the type of the mask arguments to select:
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef NO_FD_SET
+#   define SELECT_MASK	fd_set
+#else /* NO_FD_SET */
+#   ifndef _AIX
+	typedef long	fd_mask;
+#   endif /* !AIX */
+#   if defined(_IBMR2)
+#	define SELECT_MASK	void
+#   else /* !defined(_IBMR2) */
+#	define SELECT_MASK	int
+#   endif /* defined(_IBMR2) */
+#endif /* !NO_FD_SET */
+
+/*
+ *---------------------------------------------------------------------------
+ * Define "NBBY" (number of bits per byte) if it's not already defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef NBBY
+#   define NBBY		8
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macro defines the number of fd_masks in an fd_set:
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef FD_SETSIZE
+#   ifdef OPEN_MAX
+#	define FD_SETSIZE	OPEN_MAX
+#   else
+#	define FD_SETSIZE	256
+#   endif
+#endif /* FD_SETSIZE */
+
+#ifndef howmany
+#   define howmany(x, y)	(((x)+((y)-1))/(y))
+#endif /* !defined(howmany) */
+
+#ifndef NFDBITS
+#   define NFDBITS	NBBY*sizeof(fd_mask)
+#endif /* NFDBITS */
+
+#define MASK_SIZE	howmany(FD_SETSIZE, NFDBITS)
+
+/*
+ *---------------------------------------------------------------------------
+ * Not all systems declare the errno variable in errno.h. so this file does it
+ * explicitly. The list of system error messages also isn't generally declared
+ * in a header file anywhere.
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef NO_ERRNO
+extern int errno;
+#endif /* NO_ERRNO */
+
+/*
+ *---------------------------------------------------------------------------
+ * Not all systems declare all the errors that Tcl uses! Provide some
+ * work-arounds...
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef EOVERFLOW
+#   ifdef EFBIG
+#	define EOVERFLOW	EFBIG
+#   else /* !EFBIG */
+#	define EOVERFLOW	EINVAL
+#   endif /* EFBIG */
+#endif /* EOVERFLOW */
+
+/*
+ *---------------------------------------------------------------------------
+ * Variables provided by the C library:
+ *---------------------------------------------------------------------------
+ */
+
+#if defined(__APPLE__) && defined(__DYNAMIC__)
+#   include <crt_externs.h>
+#   define environ	(*_NSGetEnviron())
+#   define USE_PUTENV	1
+#else
+#   if defined(_sgi) || defined(__sgi)
+#	define environ	_environ
+#   endif
+extern char **		environ;
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Darwin specifc configure overrides.
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef __APPLE__
+
+/*
+ *---------------------------------------------------------------------------
+ * Support for fat compiles: configure runs only once for multiple architectures
+ *---------------------------------------------------------------------------
+ */
+
+#   if defined(__LP64__) && defined (NO_COREFOUNDATION_64)
+#	undef HAVE_COREFOUNDATION
+#   endif /* __LP64__ && NO_COREFOUNDATION_64 */
+#   include <sys/cdefs.h>
+#   ifdef __DARWIN_UNIX03
+#	if __DARWIN_UNIX03
+#	    undef HAVE_PUTENV_THAT_COPIES
+#	else
+#	    define HAVE_PUTENV_THAT_COPIES	1
+#	endif
+#   endif /* __DARWIN_UNIX03 */
+
+/*
+ *---------------------------------------------------------------------------
+ * The termios configure test program relies on the configure script being run
+ * from a terminal, which is not the case e.g., when configuring from Xcode.
+ * Since termios is known to be present on all Mac OS X releases since 10.0,
+ * override the configure defines for serial API here. [Bug 497147]
+ *---------------------------------------------------------------------------
+ */
+
+#   define USE_TERMIOS 1
+#   undef USE_TERMIO
+#   undef USE_SGTTY
+
+/*
+ *---------------------------------------------------------------------------
+ * Include AvailabilityMacros.h here (when available) to ensure any symbolic
+ * MAC_OS_X_VERSION_* constants passed on the command line are translated.
+ *---------------------------------------------------------------------------
+ */
+
+#   ifdef HAVE_AVAILABILITYMACROS_H
+#	include <AvailabilityMacros.h>
+#   endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Support for weak import.
+ *---------------------------------------------------------------------------
+ */
+
+#   ifdef HAVE_WEAK_IMPORT
+#	if !defined(HAVE_AVAILABILITYMACROS_H) || !defined(MAC_OS_X_VERSION_MIN_REQUIRED)
+#	    undef HAVE_WEAK_IMPORT
+#	else
+#	    ifndef WEAK_IMPORT_ATTRIBUTE
+#		define WEAK_IMPORT_ATTRIBUTE	__attribute__((weak_import))
+#	    endif
+#	endif
+#   endif /* HAVE_WEAK_IMPORT */
+
+/*
+ *---------------------------------------------------------------------------
+ * Support for MAC_OS_X_VERSION_MAX_ALLOWED define from AvailabilityMacros.h:
+ * only use API available in the indicated OS version or earlier.
+ *---------------------------------------------------------------------------
+ */
+
+#   ifdef MAC_OS_X_VERSION_MAX_ALLOWED
+#	if MAC_OS_X_VERSION_MAX_ALLOWED < 1050 && defined(__LP64__)
+#	    undef HAVE_COREFOUNDATION
+#	endif
+#	if MAC_OS_X_VERSION_MAX_ALLOWED < 1040
+#	    undef HAVE_OSSPINLOCKLOCK
+#	    undef HAVE_PTHREAD_ATFORK
+#	    undef HAVE_COPYFILE
+#	endif
+#	if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
+#	    ifdef TCL_THREADS
+		/* prior to 10.3, realpath is not threadsafe, c.f. bug 711232 */
+#		define NO_REALPATH 1
+#	    endif
+#	    undef HAVE_LANGINFO
+#	endif
+#   endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#   if defined(HAVE_COREFOUNDATION) && defined(__LP64__) && \
+	    defined(HAVE_WEAK_IMPORT) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
+#	warning "Weak import of 64-bit CoreFoundation is not supported, will not run on Mac OS X < 10.5."
+#   endif
+
+/*
+ *---------------------------------------------------------------------------
+ * At present, using vfork() instead of fork() causes execve() to fail
+ * intermittently on Darwin x86_64. rdar://4685553
+ *---------------------------------------------------------------------------
+ */
+
+#   if defined(__x86_64__) && !defined(FIXED_RDAR_4685553)
+#	undef USE_VFORK
+#   endif /* __x86_64__ */
+/* Workaround problems with vfork() when building with llvm-gcc-4.2 */
+#   if defined (__llvm__) && \
+	    (__GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ > 2 || \
+	    (__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ > 0))))
+#	undef USE_VFORK
+#   endif /* __llvm__ */
+#endif /* __APPLE__ */
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macros and declarations represent the interface between
+ * generic and unix-specific parts of Tcl. Some of the macros may override
+ * functions declared in tclInt.h.
+ *---------------------------------------------------------------------------
+ */
+
+/*
+ * The default platform eol translation on Unix is TCL_TRANSLATE_LF.
+ */
+
+#ifdef DJGPP
+#define	TCL_PLATFORM_TRANSLATION	TCL_TRANSLATE_CRLF
+typedef int socklen_t;
+#else
+#define	TCL_PLATFORM_TRANSLATION	TCL_TRANSLATE_LF
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macros have trivial definitions, allowing generic code to
+ * address platform-specific issues.
+ *---------------------------------------------------------------------------
+ */
+
+#define TclpReleaseFile(file)	/* Nothing. */
+
+/*
+ *---------------------------------------------------------------------------
+ * The following defines wrap the system memory allocation routines.
+ *---------------------------------------------------------------------------
+ */
+
+#define TclpSysAlloc(size, isBin)	malloc((size_t)(size))
+#define TclpSysFree(ptr)		free((char *)(ptr))
+#define TclpSysRealloc(ptr, size)	realloc((char *)(ptr), (size_t)(size))
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macros and declaration wrap the C runtime library functions.
+ *---------------------------------------------------------------------------
+ */
+
+#define TclpExit	exit
+
+#ifdef TCL_THREADS
+#   include <pthread.h>
+#   undef inet_ntoa
+#   define inet_ntoa(x)	TclpInetNtoa(x)
+#endif /* TCL_THREADS */
+
+/* FIXME - Hyper-enormous platform assumption! */
+#ifndef AF_INET6
+#   define AF_INET6	10
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Set of MT-safe implementations of some known-to-be-MT-unsafe library calls.
+ * Instead of returning pointers to the static storage, those return pointers
+ * to the TSD data.
+ *---------------------------------------------------------------------------
+ */
+
+#include <pwd.h>
+#include <grp.h>
+
+MODULE_SCOPE struct passwd *	TclpGetPwNam(const char *name);
+MODULE_SCOPE struct group *	TclpGetGrNam(const char *name);
+MODULE_SCOPE struct passwd *	TclpGetPwUid(uid_t uid);
+MODULE_SCOPE struct group *	TclpGetGrGid(gid_t gid);
+MODULE_SCOPE struct hostent *	TclpGetHostByName(const char *name);
+MODULE_SCOPE struct hostent *	TclpGetHostByAddr(const char *addr,
+				    int length, int type);
+MODULE_SCOPE Tcl_Channel	TclpMakeTcpClientChannelMode(
+				    ClientData tcpSocket, int mode);
+
+#endif /* _TCLUNIXPORT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
Index: src/tktext/tk8.5/default.h
===================================================================
--- src/tktext/tk8.5/default.h	(revision 0)
+++ src/tktext/tk8.5/default.h	(working copy)
@@ -0,0 +1,30 @@
+/*
+ * default.h --
+ *
+ *	This file defines the defaults for all options for all of
+ *	the Tk widgets.
+ *
+ * Copyright (c) 1991-1994 The Regents of the University of California.
+ * Copyright (c) 1994 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: default.h,v 1.5 2004/03/17 18:15:42 das Exp $
+ */
+
+#ifndef _DEFAULT
+#define _DEFAULT
+
+#if defined(__WIN32__) || defined(_WIN32) || \
+    defined(__CYGWIN__) || defined(__MINGW32__)
+#   include "tkWinDefault.h"
+#else
+#   if defined(MAC_OSX_TK)
+#	include "tkMacOSXDefault.h"
+#   else
+#	include "tkUnixDefault.h"
+#   endif
+#endif
+
+#endif /* _DEFAULT */
Index: src/tktext/tk8.5/tk3d.h
===================================================================
--- src/tktext/tk8.5/tk3d.h	(revision 0)
+++ src/tktext/tk8.5/tk3d.h	(working copy)
@@ -0,0 +1,96 @@
+/*
+ * tk3d.h --
+ *
+ *	Declarations of types and functions shared by the 3d border module.
+ *
+ * Copyright (c) 1996-1997 by Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tk3d.h,v 1.7 2005/11/27 02:36:13 das Exp $
+ */
+
+#ifndef _TK3D
+#define _TK3D
+
+#include <tkInt.h>
+
+#ifdef BUILD_tk
+# undef TCL_STORAGE_CLASS
+# define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+/*
+ * One of the following data structures is allocated for each 3-D border
+ * currently in use. Structures of this type are indexed by borderTable, so
+ * that a single structure can be shared for several uses.
+ */
+
+typedef struct TkBorder {
+    Screen *screen;		/* Screen on which the border will be used. */
+    Visual *visual;		/* Visual for all windows and pixmaps using
+				 * the border. */
+    int depth;			/* Number of bits per pixel of drawables where
+				 * the border will be used. */
+    Colormap colormap;		/* Colormap out of which pixels are
+				 * allocated. */
+    int resourceRefCount;	/* Number of active uses of this color (each
+				 * active use corresponds to a call to
+				 * Tk_Alloc3DBorderFromObj or Tk_Get3DBorder).
+				 * If this count is 0, then this structure is
+				 * no longer valid and it isn't present in
+				 * borderTable: it is being kept around only
+				 * because there are objects referring to it.
+				 * The structure is freed when
+				 * resourceRefCount and objRefCount are both
+				 * 0. */
+    int objRefCount;		/* The number of Tcl objects that reference
+				 * this structure. */
+    XColor *bgColorPtr;		/* Background color (intensity between
+				 * lightColorPtr and darkColorPtr). */
+    XColor *darkColorPtr;	/* Color for darker areas (must free when
+				 * deleting structure). NULL means shadows
+				 * haven't been allocated yet.*/
+    XColor *lightColorPtr;	/* Color used for lighter areas of border
+				 * (must free this when deleting structure).
+				 * NULL means shadows haven't been allocated
+				 * yet. */
+    Pixmap shadow;		/* Stipple pattern to use for drawing shadows
+				 * areas. Used for displays with <= 64 colors
+				 * or where colormap has filled up. */
+    GC bgGC;			/* Used (if necessary) to draw areas in the
+				 * background color. */
+    GC darkGC;			/* Used to draw darker parts of the border.
+				 * None means the shadow colors haven't been
+				 * allocated yet.*/
+    GC lightGC;			/* Used to draw lighter parts of the border.
+				 * None means the shadow colors haven't been
+				 * allocated yet. */
+    Tcl_HashEntry *hashPtr;	/* Entry in borderTable (needed in order to
+				 * delete structure). */
+    struct TkBorder *nextPtr;	/* Points to the next TkBorder structure with
+				 * the same color name. Borders with the same
+				 * name but different screens or colormaps are
+				 * chained together off a single entry in
+				 * borderTable. */
+} TkBorder;
+
+/*
+ * Maximum intensity for a color:
+ */
+
+#define MAX_INTENSITY 65535
+
+/*
+ * Declarations for platform specific interfaces used by this module.
+ */
+
+MODULE_SCOPE TkBorder	*TkpGetBorder(void);
+MODULE_SCOPE void	TkpGetShadows(TkBorder *borderPtr, Tk_Window tkwin);
+MODULE_SCOPE void	TkpFreeBorder(TkBorder *borderPtr);
+
+# undef TCL_STORAGE_CLASS
+# define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TK3D */
Index: src/tktext/tk8.5/tkInt.h
===================================================================
--- src/tktext/tk8.5/tkInt.h	(revision 0)
+++ src/tktext/tk8.5/tkInt.h	(working copy)
@@ -0,0 +1,1228 @@
+/*
+ * tkInt.h --
+ *
+ *	Declarations for things used internally by the Tk functions but not
+ *	exported outside the module.
+ *
+ * Copyright (c) 1990-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright (c) 1998 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: $Id: tkInt.h,v 1.82.2.2 2008/12/21 23:52:45 ferrieux Exp $
+ */
+
+#ifndef _TKINT
+#define _TKINT
+
+#ifndef _TK
+#include "tk.h"
+#endif
+#ifndef _TCL
+#include "tcl.h"
+#endif
+#ifndef _TKPORT
+#include "tkPort.h"
+#endif
+
+/*
+ * Ensure WORDS_BIGENDIAN is defined correcly:
+ * Needs to happen here in addition to configure to work with fat compiles on
+ * Darwin (where configure runs only once for multiple architectures).
+ */
+
+#ifdef HAVE_SYS_TYPES_H
+#    include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#    include <sys/param.h>
+#endif
+#ifdef BYTE_ORDER
+#    ifdef BIG_ENDIAN
+#	 if BYTE_ORDER == BIG_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	     define WORDS_BIGENDIAN 1
+#	 endif
+#    endif
+#    ifdef LITTLE_ENDIAN
+#	 if BYTE_ORDER == LITTLE_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	 endif
+#    endif
+#endif
+
+/*
+ * Used to tag functions that are only to be visible within the module being
+ * built and not outside it (where this is supported by the linker).
+ */
+
+#ifndef MODULE_SCOPE
+#   ifdef __cplusplus
+#	define MODULE_SCOPE extern "C"
+#   else
+#	define MODULE_SCOPE extern
+#   endif
+#endif
+
+/*
+ * Macros used to cast between pointers and integers (e.g. when storing an int
+ * in ClientData), on 64-bit architectures they avoid gcc warning about "cast
+ * to/from pointer from/to integer of different size".
+ */
+
+#if !defined(INT2PTR) && !defined(PTR2INT)
+#   if defined(HAVE_INTPTR_T) || defined(intptr_t)
+#	define INT2PTR(p) ((void*)(intptr_t)(p))
+#	define PTR2INT(p) ((int)(intptr_t)(p))
+#   else
+#	define INT2PTR(p) ((void*)(p))
+#	define PTR2INT(p) ((int)(p))
+#   endif
+#endif
+#if !defined(UINT2PTR) && !defined(PTR2UINT)
+#   if defined(HAVE_UINTPTR_T) || defined(uintptr_t)
+#	define UINT2PTR(p) ((void*)(uintptr_t)(p))
+#	define PTR2UINT(p) ((unsigned int)(uintptr_t)(p))
+#   else
+#	define UINT2PTR(p) ((void*)(p))
+#	define PTR2UINT(p) ((unsigned int)(p))
+#   endif
+#endif
+
+/*
+ * Opaque type declarations:
+ */
+
+typedef struct TkColormap TkColormap;
+typedef struct TkFontAttributes TkFontAttributes;
+typedef struct TkGrabEvent TkGrabEvent;
+typedef struct TkpCursor_ *TkpCursor;
+typedef struct TkRegion_ *TkRegion;
+typedef struct TkStressedCmap TkStressedCmap;
+typedef struct TkBindInfo_ *TkBindInfo;
+
+/*
+ * Function types.
+ */
+
+typedef int (TkBindEvalProc)(ClientData clientData, Tcl_Interp *interp,
+	XEvent *eventPtr, Tk_Window tkwin, KeySym keySym);
+typedef void (TkBindFreeProc)(ClientData clientData);
+
+/*
+ * One of the following structures is maintained for each cursor in use in the
+ * system. This structure is used by tkCursor.c and the various system
+ * specific cursor files.
+ */
+
+typedef struct TkCursor {
+    Tk_Cursor cursor;		/* System specific identifier for cursor. */
+    Display *display;		/* Display containing cursor. Needed for
+				 * disposal and retrieval of cursors. */
+    int resourceRefCount;	/* Number of active uses of this cursor (each
+				 * active use corresponds to a call to
+				 * Tk_AllocPreserveFromObj or Tk_Preserve). If
+				 * this count is 0, then this structure is no
+				 * longer valid and it isn't present in a hash
+				 * table: it is being kept around only because
+				 * there are objects referring to it. The
+				 * structure is freed when resourceRefCount
+				 * and objRefCount are both 0. */
+    int objRefCount;		/* Number of Tcl objects that reference this
+				 * structure.. */
+    Tcl_HashTable *otherTable;	/* Second table (other than idTable) used to
+				 * index this entry. */
+    Tcl_HashEntry *hashPtr;	/* Entry in otherTable for this structure
+				 * (needed when deleting). */
+    Tcl_HashEntry *idHashPtr;	/* Entry in idTable for this structure (needed
+				 * when deleting). */
+    struct TkCursor *nextPtr;	/* Points to the next TkCursor structure with
+				 * the same name. Cursors with the same name
+				 * but different displays are chained together
+				 * off a single hash table entry. */
+} TkCursor;
+
+/*
+ * The following structure is kept one-per-TkDisplay to maintain information
+ * about the caret (cursor location) on this display. This is used to dictate
+ * global focus location (Windows Accessibility guidelines) and to position
+ * the IME or XIM over-the-spot window.
+ */
+
+typedef struct TkCaret {
+    struct TkWindow *winPtr;	/* The window on which we requested caret
+				 * placement. */
+    int x;			/* Relative x coord of the caret. */
+    int y;			/* Relative y coord of the caret. */
+    int height;			/* Specified height of the window. */
+} TkCaret;
+
+/*
+ * One of the following structures is maintained for each display containing a
+ * window managed by Tk. In part, the structure is used to store thread-
+ * specific data, since each thread will have its own TkDisplay structure.
+ */
+
+typedef struct TkDisplay {
+    Display *display;		/* Xlib's info about display. */
+    struct TkDisplay *nextPtr;	/* Next in list of all displays. */
+    char *name;			/* Name of display (with any screen identifier
+				 * removed). Malloc-ed. */
+    Time lastEventTime;		/* Time of last event received for this
+				 * display. */
+
+    /*
+     * Information used primarily by tk3d.c:
+     */
+
+    int borderInit;		/* 0 means borderTable needs initializing. */
+    Tcl_HashTable borderTable;	/* Maps from color name to TkBorder
+				 * structure. */
+
+    /*
+     * Information used by tkAtom.c only:
+     */
+
+    int atomInit;		/* 0 means stuff below hasn't been initialized
+				 * yet. */
+    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
+    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
+
+    /*
+     * Information used primarily by tkBind.c:
+     */
+
+    int bindInfoStale;		/* Non-zero means the variables in this part
+				 * of the structure are potentially incorrect
+				 * and should be recomputed. */
+    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to "mode shift". If no such
+				 * modifier, than this is zero. */
+    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
+    unsigned int altModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
+    enum {LU_IGNORE, LU_CAPS, LU_SHIFT} lockUsage;
+				/* Indicates how to interpret lock
+				 * modifier. */
+    int numModKeyCodes;		/* Number of entries in modKeyCodes array
+				 * below. */
+    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for all
+				 * of the keys that have modifiers associated
+				 * with them. Malloc'ed, but may be NULL. */
+
+    /*
+     * Information used by tkBitmap.c only:
+     */
+
+    int bitmapInit;		/* 0 means tables above need initializing. */
+    int bitmapAutoNumber;	/* Used to number bitmaps. */
+    Tcl_HashTable bitmapNameTable;
+				/* Maps from name of bitmap to the first
+				 * TkBitmap record for that name. */
+    Tcl_HashTable bitmapIdTable;/* Maps from bitmap id to the TkBitmap
+				 * structure for the bitmap. */
+    Tcl_HashTable bitmapDataTable;
+				/* Used by Tk_GetBitmapFromData to map from a
+				 * collection of in-core data about a bitmap
+				 * to a reference giving an automatically-
+				 * generated name for the bitmap. */
+
+    /*
+     * Information used by tkCanvas.c only:
+     */
+
+    int numIdSearches;
+    int numSlowSearches;
+
+    /*
+     * Used by tkColor.c only:
+     */
+
+    int colorInit;		/* 0 means color module needs initializing. */
+    TkStressedCmap *stressPtr;	/* First in list of colormaps that have filled
+				 * up, so we have to pick an approximate
+				 * color. */
+    Tcl_HashTable colorNameTable;
+				/* Maps from color name to TkColor structure
+				 * for that color. */
+    Tcl_HashTable colorValueTable;
+				/* Maps from integer RGB values to TkColor
+				 * structures. */
+
+    /*
+     * Used by tkCursor.c only:
+     */
+
+    int cursorInit;		/* 0 means cursor module need initializing. */
+    Tcl_HashTable cursorNameTable;
+				/* Maps from a string name to a cursor to the
+				 * TkCursor record for the cursor. */
+    Tcl_HashTable cursorDataTable;
+				/* Maps from a collection of in-core data
+				 * about a cursor to a TkCursor structure. */
+    Tcl_HashTable cursorIdTable;
+				/* Maps from a cursor id to the TkCursor
+				 * structure for the cursor. */
+    char cursorString[20];	/* Used to store a cursor id string. */
+    Font cursorFont;		/* Font to use for standard cursors. None
+				 * means font not loaded yet. */
+
+    /*
+     * Information used by tkError.c only:
+     */
+
+    struct TkErrorHandler *errorPtr;
+				/* First in list of error handlers for this
+				 * display. NULL means no handlers exist at
+				 * present. */
+    int deleteCount;		/* Counts # of handlers deleted since last
+				 * time inactive handlers were garbage-
+				 * collected. When this number gets big,
+				 * handlers get cleaned up. */
+
+    /*
+     * Used by tkEvent.c only:
+     */
+
+    struct TkWindowEvent *delayedMotionPtr;
+				/* Points to a malloc-ed motion event whose
+				 * processing has been delayed in the hopes
+				 * that another motion event will come along
+				 * right away and we can merge the two of them
+				 * together. NULL means that there is no
+				 * delayed motion event. */
+
+    /*
+     * Information used by tkFocus.c only:
+     */
+
+    int focusDebug;		/* 1 means collect focus debugging
+				 * statistics. */
+    struct TkWindow *implicitWinPtr;
+				/* If the focus arrived at a toplevel window
+				 * implicitly via an Enter event (rather than
+				 * via a FocusIn event), this points to the
+				 * toplevel window. Otherwise it is NULL. */
+    struct TkWindow *focusPtr;	/* Points to the window on this display that
+				 * should be receiving keyboard events. When
+				 * multiple applications on the display have
+				 * the focus, this will refer to the innermost
+				 * window in the innermost application. This
+				 * information isn't used under Unix or
+				 * Windows, but it's needed on the Mac. */
+
+    /*
+     * Information used by tkGC.c only:
+     */
+
+    Tcl_HashTable gcValueTable; /* Maps from a GC's values to a TkGC structure
+				 * describing a GC with those values. */
+    Tcl_HashTable gcIdTable;    /* Maps from a GC to a TkGC. */
+    int gcInit;			/* 0 means the tables below need
+				 * initializing. */
+
+    /*
+     * Information used by tkGeometry.c only:
+     */
+
+    Tcl_HashTable maintainHashTable;
+				/* Hash table that maps from a master's
+				 * Tk_Window token to a list of slaves managed
+				 * by that master. */
+    int geomInit;
+
+    /*
+     * Information used by tkGet.c only:
+     */
+
+    Tcl_HashTable uidTable;	/* Stores all Tk_Uid used in a thread. */
+    int uidInit;		/* 0 means uidTable needs initializing. */
+
+    /*
+     * Information used by tkGrab.c only:
+     */
+
+    struct TkWindow *grabWinPtr;/* Window in which the pointer is currently
+				 * grabbed, or NULL if none. */
+    struct TkWindow *eventualGrabWinPtr;
+				/* Value that grabWinPtr will have once the
+				 * grab event queue (below) has been
+				 * completely emptied. */
+    struct TkWindow *buttonWinPtr;
+				/* Window in which first mouse button was
+				 * pressed while grab was in effect, or NULL
+				 * if no such press in effect. */
+    struct TkWindow *serverWinPtr;
+				/* If no application contains the pointer then
+				 * this is NULL. Otherwise it contains the
+				 * last window for which we've gotten an Enter
+				 * or Leave event from the server (i.e. the
+				 * last window known to have contained the
+				 * pointer). Doesn't reflect events that were
+				 * synthesized in tkGrab.c. */
+    TkGrabEvent *firstGrabEventPtr;
+				/* First in list of enter/leave events
+				 * synthesized by grab code. These events must
+				 * be processed in order before any other
+				 * events are processed. NULL means no such
+				 * events. */
+    TkGrabEvent *lastGrabEventPtr;
+				/* Last in list of synthesized events, or NULL
+				 * if list is empty. */
+    int grabFlags;		/* Miscellaneous flag values. See definitions
+				 * in tkGrab.c. */
+
+    /*
+     * Information used by tkGrid.c only:
+     */
+
+    int gridInit;		/* 0 means table below needs initializing. */
+    Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to corresponding
+				 * Grid structures. */
+
+    /*
+     * Information used by tkImage.c only:
+     */
+
+    int imageId;		/* Value used to number image ids. */
+
+    /*
+     * Information used by tkMacWinMenu.c only:
+     */
+
+    int postCommandGeneration;
+
+    /*
+     * Information used by tkOption.c only.
+     */
+
+    /*
+     * Information used by tkPack.c only.
+     */
+
+    int packInit;		/* 0 means table below needs initializing. */
+    Tcl_HashTable packerHashTable;
+				/* Maps from Tk_Window tokens to corresponding
+				 * Packer structures. */
+
+    /*
+     * Information used by tkPlace.c only.
+     */
+
+    int placeInit;		/* 0 means tables below need initializing. */
+    Tcl_HashTable masterTable;	/* Maps from Tk_Window toke to the Master
+				 * structure for the window, if it exists. */
+    Tcl_HashTable slaveTable;	/* Maps from Tk_Window toke to the Slave
+				 * structure for the window, if it exists. */
+
+    /*
+     * Information used by tkSelect.c and tkClipboard.c only:
+     */
+
+    struct TkSelectionInfo *selectionInfoPtr;
+				/* First in list of selection information
+				 * records. Each entry contains information
+				 * about the current owner of a particular
+				 * selection on this display. */
+    Atom multipleAtom;		/* Atom for MULTIPLE. None means selection
+				 * stuff isn't initialized. */
+    Atom incrAtom;		/* Atom for INCR. */
+    Atom targetsAtom;		/* Atom for TARGETS. */
+    Atom timestampAtom;		/* Atom for TIMESTAMP. */
+    Atom textAtom;		/* Atom for TEXT. */
+    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
+    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
+    Atom windowAtom;		/* Atom for TK_WINDOW. */
+    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
+    Atom utf8Atom;		/* Atom for UTF8_STRING. */
+
+    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
+				 * retrieve selections between processes. NULL
+				 * means clipboard info hasn't been
+				 * initialized. */
+    int clipboardActive;	/* 1 means we currently own the clipboard
+				 * selection, 0 means we don't. */
+    struct TkMainInfo *clipboardAppPtr;
+				/* Last application that owned clipboard. */
+    struct TkClipboardTarget *clipTargetPtr;
+				/* First in list of clipboard type information
+				 * records. Each entry contains information
+				 * about the buffers for a given selection
+				 * target. */
+
+    /*
+     * Information used by tkSend.c only:
+     */
+
+    Tk_Window commTkwin;	/* Window used for communication between
+				 * interpreters during "send" commands. NULL
+				 * means send info hasn't been initialized
+				 * yet. */
+    Atom commProperty;		/* X's name for comm property. */
+    Atom registryProperty;	/* X's name for property containing registry
+				 * of interpreter names. */
+    Atom appNameProperty;	/* X's name for property used to hold the
+				 * application name on each comm window. */
+
+    /*
+     * Information used by tkXId.c only:
+     */
+
+    struct TkIdStack *idStackPtr;
+				/* First in list of chunks of free resource
+				 * identifiers, or NULL if there are no free
+				 * resources. */
+    XID (*defaultAllocProc) (Display *display);
+				/* Default resource allocator for display. */
+    struct TkIdStack *windowStackPtr;
+				/* First in list of chunks of window ids that
+				 * can't be reused right now. */
+    Tcl_TimerToken idCleanupScheduled;
+				/* If set, it means a call to WindowIdCleanup
+				 * has already been scheduled, 0 means it
+				 * hasn't. */
+
+    /*
+     * Information used by tkUnixWm.c and tkWinWm.c only:
+     */
+
+    struct TkWmInfo *firstWmPtr;/* Points to first top-level window. */
+    struct TkWmInfo *foregroundWmPtr;
+				/* Points to the foreground window. */
+
+    /*
+     * Information maintained by tkWindow.c for use later on by tkXId.c:
+     */
+
+    int destroyCount;		/* Number of Tk_DestroyWindow operations in
+				 * progress. */
+    unsigned long lastDestroyRequest;
+				/* Id of most recent XDestroyWindow request;
+				 * can re-use ids in windowStackPtr when
+				 * server has seen this request and event
+				 * queue is empty. */
+
+    /*
+     * Information used by tkVisual.c only:
+     */
+
+    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
+				 * allocated for this display. */
+
+    /*
+     * Miscellaneous information:
+     */
+
+#ifdef TK_USE_INPUT_METHODS
+    XIM inputMethod;		/* Input method for this display. */
+    XIMStyle inputStyle;	/* Input style selected for this display. */
+    XFontSet inputXfs;		/* XFontSet cached for over-the-spot XIM. */
+#endif /* TK_USE_INPUT_METHODS */
+    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
+
+    int refCount;		/* Reference count of how many Tk applications
+				 * are using this display. Used to clean up
+				 * the display when we no longer have any Tk
+				 * applications using it. */
+
+    /*
+     * The following field were all added for Tk8.3
+     */
+
+    int mouseButtonState;	/* Current mouse button state for this
+				 * display. */
+    Window mouseButtonWindow;	/* Window the button state was set in, added
+				 * in Tk 8.4. */
+    Window warpWindow;
+    int warpX;
+    int warpY;
+
+    /*
+     * The following field(s) were all added for Tk8.4
+     */
+
+    unsigned int flags;		/* Various flag values: these are all defined
+				 * in below. */
+    TkCaret caret;		/* Information about the caret for this
+				 * display. This is not a pointer. */
+
+    int iconDataSize;		/* Size of default iconphoto image data. */
+    unsigned char *iconDataPtr;	/* Default iconphoto image data, if set. */
+} TkDisplay;
+
+/*
+ * Flag values for TkDisplay flags.
+ *  TK_DISPLAY_COLLAPSE_MOTION_EVENTS:	(default on)
+ *	Indicates that we should collapse motion events on this display
+ *  TK_DISPLAY_USE_IM:			(default on, set via tk.tcl)
+ *	Whether to use input methods for this display
+ *  TK_DISPLAY_WM_TRACING:		(default off)
+ *	Whether we should do wm tracing on this display.
+ *  TK_DISPLAY_IN_WARP:			(default off)
+ *	Indicates that we are in a pointer warp
+ */
+
+#define TK_DISPLAY_COLLAPSE_MOTION_EVENTS	(1 << 0)
+#define TK_DISPLAY_USE_IM			(1 << 1)
+#define TK_DISPLAY_WM_TRACING			(1 << 3)
+#define TK_DISPLAY_IN_WARP			(1 << 4)
+
+/*
+ * One of the following structures exists for each error handler created by a
+ * call to Tk_CreateErrorHandler. The structure is managed by tkError.c.
+ */
+
+typedef struct TkErrorHandler {
+    TkDisplay *dispPtr;		/* Display to which handler applies. */
+    unsigned long firstRequest;	/* Only errors with serial numbers >= to this
+				 * are considered. */
+    unsigned long lastRequest;	/* Only errors with serial numbers <= to this
+				 * are considered. This field is filled in
+				 * when XUnhandle is called. -1 means
+				 * XUnhandle hasn't been called yet. */
+    int error;			/* Consider only errors with this error_code
+				 * (-1 means consider all errors). */
+    int request;		/* Consider only errors with this major
+				 * request code (-1 means consider all major
+				 * codes). */
+    int minorCode;		/* Consider only errors with this minor
+				 * request code (-1 means consider all minor
+				 * codes). */
+    Tk_ErrorProc *errorProc;	/* Function to invoke when a matching error
+				 * occurs. NULL means just ignore errors. */
+    ClientData clientData;	/* Arbitrary value to pass to errorProc. */
+    struct TkErrorHandler *nextPtr;
+				/* Pointer to next older handler for this
+				 * display, or NULL for end of list. */
+} TkErrorHandler;
+
+/*
+ * One of the following structures exists for each event handler created by
+ * calling Tk_CreateEventHandler. This information is used by tkEvent.c only.
+ */
+
+typedef struct TkEventHandler {
+    unsigned long mask;		/* Events for which to invoke proc. */
+    Tk_EventProc *proc;		/* Function to invoke when an event in mask
+				 * occurs. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    struct TkEventHandler *nextPtr;
+				/* Next in list of handlers associated with
+				 * window (NULL means end of list). */
+} TkEventHandler;
+
+/*
+ * Tk keeps one of the following data structures for each main window (created
+ * by a call to TkCreateMainWindow). It stores information that is shared by
+ * all of the windows associated with a particular main window.
+ */
+
+typedef struct TkMainInfo {
+    int refCount;		/* Number of windows whose "mainPtr" fields
+				 * point here. When this becomes zero, can
+				 * free up the structure (the reference count
+				 * is zero because windows can get deleted in
+				 * almost any order; the main window isn't
+				 * necessarily the last one deleted). */
+    struct TkWindow *winPtr;	/* Pointer to main window. */
+    Tcl_Interp *interp;		/* Interpreter associated with application. */
+    Tcl_HashTable nameTable;	/* Hash table mapping path names to TkWindow
+				 * structs for all windows related to this
+				 * main window. Managed by tkWindow.c. */
+    long deletionEpoch;		/* Incremented by window deletions. */
+    Tk_BindingTable bindingTable;
+				/* Used in conjunction with "bind" command to
+				 * bind events to Tcl commands. */
+    TkBindInfo bindInfo;	/* Information used by tkBind.c on a per
+				 * application basis. */
+    struct TkFontInfo *fontInfoPtr;
+				/* Information used by tkFont.c on a per
+				 * application basis. */
+
+    /*
+     * Information used only by tkFocus.c and tk*Embed.c:
+     */
+
+    struct TkToplevelFocusInfo *tlFocusPtr;
+				/* First in list of records containing focus
+				 * information for each top-level in the
+				 * application. Used only by tkFocus.c. */
+    struct TkDisplayFocusInfo *displayFocusPtr;
+				/* First in list of records containing focus
+				 * information for each display that this
+				 * application has ever used. Used only by
+				 * tkFocus.c. */
+
+    struct ElArray *optionRootPtr;
+				/* Top level of option hierarchy for this main
+				 * window. NULL means uninitialized. Managed
+				 * by tkOption.c. */
+    Tcl_HashTable imageTable;	/* Maps from image names to Tk_ImageMaster
+				 * structures. Managed by tkImage.c. */
+    int strictMotif;		/* This is linked to the tk_strictMotif global
+				 * variable. */
+    int alwaysShowSelection;	/* This is linked to the
+				 * ::tk::AlwaysShowSelection variable. */
+    struct TkMainInfo *nextPtr;	/* Next in list of all main windows managed by
+				 * this process. */
+} TkMainInfo;
+
+/*
+ * Tk keeps the following data structure for each of it's builtin bitmaps.
+ * This structure is only used by tkBitmap.c and other platform specific
+ * bitmap files.
+ */
+
+typedef struct {
+    const char *source;		/* Bits for bitmap. */
+    int width, height;		/* Dimensions of bitmap. */
+    int native;			/* 0 means generic (X style) bitmap, 1 means
+    				 * native style bitmap. */
+} TkPredefBitmap;
+
+/*
+ * Tk keeps one of the following structures for each window. Some of the
+ * information (like size and location) is a shadow of information managed by
+ * the X server, and some is special information used here, such as event and
+ * geometry management information. This information is (mostly) managed by
+ * tkWindow.c. WARNING: the declaration below must be kept consistent with the
+ * Tk_FakeWin structure in tk.h. If you change one, be sure to change the
+ * other!
+ */
+
+typedef struct TkWindow {
+    /*
+     * Structural information:
+     */
+
+    Display *display;		/* Display containing window. */
+    TkDisplay *dispPtr;		/* Tk's information about display for
+				 * window. */
+    int screenNum;		/* Index of screen for window, among all those
+				 * for dispPtr. */
+    Visual *visual;		/* Visual to use for window. If not default,
+				 * MUST be set before X window is created. */
+    int depth;			/* Number of bits/pixel. */
+    Window window;		/* X's id for window. NULL means window hasn't
+				 * actually been created yet, or it's been
+				 * deleted. */
+    struct TkWindow *childList;	/* First in list of child windows, or NULL if
+				 * no children. List is in stacking order,
+				 * lowest window first.*/
+    struct TkWindow *lastChildPtr;
+				/* Last in list of child windows (highest in
+				 * stacking order), or NULL if no children. */
+    struct TkWindow *parentPtr;	/* Pointer to parent window (logical parent,
+				 * not necessarily X parent). NULL means
+				 * either this is the main window, or the
+				 * window's parent has already been deleted. */
+    struct TkWindow *nextPtr;	/* Next higher sibling (in stacking order) in
+				 * list of children with same parent. NULL
+				 * means end of list. */
+    TkMainInfo *mainPtr;	/* Information shared by all windows
+				 * associated with a particular main window.
+				 * NULL means this window is a rogue that is
+				 * not associated with any application (at
+				 * present, this only happens for the dummy
+				 * windows used for "send" communication). */
+
+    /*
+     * Name and type information for the window:
+     */
+
+    char *pathName;		/* Path name of window (concatenation of all
+				 * names between this window and its top-level
+				 * ancestor). This is a pointer into an entry
+				 * in mainPtr->nameTable. NULL means that the
+				 * window hasn't been completely created
+				 * yet. */
+    Tk_Uid nameUid;		/* Name of the window within its parent
+				 * (unique within the parent). */
+    Tk_Uid classUid;		/* Class of the window. NULL means window
+				 * hasn't been given a class yet. */
+
+    /*
+     * Geometry and other attributes of window. This information may not be
+     * updated on the server immediately; stuff that hasn't been reflected in
+     * the server yet is called "dirty". At present, information can be dirty
+     * only if the window hasn't yet been created.
+     */
+
+    XWindowChanges changes;	/* Geometry and other info about window. */
+    unsigned int dirtyChanges;	/* Bits indicate fields of "changes" that are
+				 * dirty. */
+    XSetWindowAttributes atts;	/* Current attributes of window. */
+    unsigned long dirtyAtts;	/* Bits indicate fields of "atts" that are
+				 * dirty. */
+
+    unsigned int flags;		/* Various flag values: these are all defined
+				 * in tk.h (confusing, but they're needed
+				 * there for some query macros). */
+
+    /*
+     * Information kept by the event manager (tkEvent.c):
+     */
+
+    TkEventHandler *handlerList;/* First in list of event handlers declared
+				 * for this window, or NULL if none. */
+#ifdef TK_USE_INPUT_METHODS
+    XIC inputContext;		/* XIM input context. */
+#endif /* TK_USE_INPUT_METHODS */
+
+    /*
+     * Information used for event bindings (see "bind" and "bindtags" commands
+     * in tkCmds.c):
+     */
+
+    ClientData *tagPtr;		/* Points to array of tags used for bindings
+				 * on this window. Each tag is a Tk_Uid.
+				 * Malloc'ed. NULL means no tags. */
+    int numTags;		/* Number of tags at *tagPtr. */
+
+    /*
+     * Information used by tkOption.c to manage options for the window.
+     */
+
+    int optionLevel;		/* -1 means no option information is currently
+				 * cached for this window. Otherwise this
+				 * gives the level in the option stack at
+				 * which info is cached. */
+    /*
+     * Information used by tkSelect.c to manage the selection.
+     */
+
+    struct TkSelHandler *selHandlerList;
+				/* First in list of handlers for returning the
+				 * selection in various forms. */
+
+    /*
+     * Information used by tkGeometry.c for geometry management.
+     */
+
+    const Tk_GeomMgr *geomMgrPtr; /* Information about geometry manager for this
+				 * window. */
+    ClientData geomData;	/* Argument for geometry manager functions. */
+    int reqWidth, reqHeight;	/* Arguments from last call to
+				 * Tk_GeometryRequest, or 0's if
+				 * Tk_GeometryRequest hasn't been called. */
+    int internalBorderLeft;	/* Width of internal border of window (0 means
+				 * no internal border). Geometry managers
+				 * should not normally place children on top
+				 * of the border. Fields for the other three
+				 * sides are found below. */
+
+    /*
+     * Information maintained by tkWm.c for window manager communication.
+     */
+
+    struct TkWmInfo *wmInfoPtr;	/* For top-level windows (and also for special
+				 * Unix menubar and wrapper windows), points
+				 * to structure with wm-related info (see
+				 * tkWm.c). For other windows, this is NULL. */
+
+    /*
+     * Information used by widget classes.
+     */
+
+    Tk_ClassProcs *classProcsPtr;
+    ClientData instanceData;
+
+    /*
+     * Platform specific information private to each port.
+     */
+
+    struct TkWindowPrivate *privatePtr;
+
+    /*
+     * More information used by tkGeometry.c for geometry management.
+     */
+
+    /* The remaining fields of internal border. */
+    int internalBorderRight;
+    int internalBorderTop;
+    int internalBorderBottom;
+
+    int minReqWidth;		/* Minimum requested width. */
+    int minReqHeight;		/* Minimum requested height. */
+} TkWindow;
+
+/*
+ * The following structure is used as a two way map between integers and
+ * strings, usually to map between an internal C representation and the
+ * strings used in Tcl.
+ */
+
+typedef struct TkStateMap {
+    int numKey;			/* Integer representation of a value. */
+    const char *strKey;		/* String representation of a value. */
+} TkStateMap;
+
+/*
+ * This structure is used by the Mac and Window porting layers as the internal
+ * representation of a clip_mask in a GC.
+ */
+
+typedef struct TkpClipMask {
+    int type;			/* TKP_CLIP_PIXMAP or TKP_CLIP_REGION. */
+    union {
+	Pixmap pixmap;
+	TkRegion region;
+    } value;
+} TkpClipMask;
+
+#define TKP_CLIP_PIXMAP 0
+#define TKP_CLIP_REGION 1
+
+/*
+ * Pointer to first entry in list of all displays currently known.
+ */
+
+extern TkDisplay *tkDisplayList;
+
+/*
+ * Return values from TkGrabState:
+ */
+
+#define TK_GRAB_NONE		0
+#define TK_GRAB_IN_TREE		1
+#define TK_GRAB_ANCESTOR	2
+#define TK_GRAB_EXCLUDED	3
+
+/*
+ * Additional flag for TkpMeasureCharsInContext. Coordinate with other flags
+ * for this routine, but don't make public until TkpMeasureCharsInContext is
+ * made public, too.
+ */
+
+#define TK_ISOLATE_END		32
+
+/*
+ * The macro below is used to modify a "char" value (e.g. by casting it to an
+ * unsigned character) so that it can be used safely with macros such as
+ * isspace().
+ */
+
+#define UCHAR(c) ((unsigned char) (c))
+
+/*
+ * The following symbol is used in the mode field of FocusIn events generated
+ * by an embedded application to request the input focus from its container.
+ */
+
+#define EMBEDDED_APP_WANTS_FOCUS (NotifyNormal + 20)
+
+/*
+ * The following special modifier mask bits are defined, to indicate logical
+ * modifiers such as Meta and Alt that may float among the actual modifier
+ * bits.
+ */
+
+#define META_MASK	(AnyModifier<<1)
+#define ALT_MASK	(AnyModifier<<2)
+#define EXTENDED_MASK	(AnyModifier<<3)
+
+/*
+ * Object types not declared in tkObj.c need to be mentioned here so they can
+ * be properly registered with Tcl:
+ */
+
+MODULE_SCOPE Tcl_ObjType tkBorderObjType;
+MODULE_SCOPE Tcl_ObjType tkBitmapObjType;
+MODULE_SCOPE Tcl_ObjType tkColorObjType;
+MODULE_SCOPE Tcl_ObjType tkCursorObjType;
+MODULE_SCOPE Tcl_ObjType tkFontObjType;
+MODULE_SCOPE Tcl_ObjType tkOptionObjType;
+MODULE_SCOPE Tcl_ObjType tkStateKeyObjType;
+MODULE_SCOPE Tcl_ObjType tkTextIndexType;
+
+/*
+ * Miscellaneous variables shared among Tk modules but not exported to the
+ * outside world:
+ */
+
+MODULE_SCOPE Tk_SmoothMethod	tkBezierSmoothMethod;
+MODULE_SCOPE Tk_ImageType	tkBitmapImageType;
+MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtGIF;
+MODULE_SCOPE void		(*tkHandleEventProc) (XEvent* eventPtr);
+MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtPPM;
+MODULE_SCOPE TkMainInfo		*tkMainWindowList;
+MODULE_SCOPE Tk_ImageType	tkPhotoImageType;
+MODULE_SCOPE Tcl_HashTable	tkPredefBitmapTable;
+
+#include "tkIntDecls.h"
+
+#ifdef BUILD_tk
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+/*
+ * Themed widget set init function:
+ */
+
+MODULE_SCOPE int	Ttk_Init(Tcl_Interp *interp);
+
+/*
+ * Internal functions shared among Tk modules but not exported to the outside
+ * world:
+ */
+
+MODULE_SCOPE int	Tk_BellObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_BindObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_BindtagsObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ButtonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_CanvasObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_CheckbuttonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ClipboardObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ChooseColorObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ChooseDirectoryObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ChooseFontObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_DestroyObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_EntryObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_EventObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_FrameObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_FocusObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_FontObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GetOpenFileObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GetSaveFileObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GrabObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GridObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ImageObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_LabelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_LabelframeObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ListboxObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_LowerObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_MenubuttonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_MessageBoxObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_MessageObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_PanedWindowObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_OptionObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_PackObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_PlaceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_RadiobuttonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_RaiseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ScaleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ScrollbarCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc, const char **argv);
+MODULE_SCOPE int	Tk_SelectionObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_SendCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc, const char **argv);
+MODULE_SCOPE int	Tk_SendObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_SpinboxObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_TextObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_TkObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_TkwaitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ToplevelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_UpdateObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_WinfoObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_WmObjCmd(ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+
+MODULE_SCOPE int	Tk_GetDoublePixelsFromObj(Tcl_Interp *interp,
+						  Tk_Window tkwin,
+						  Tcl_Obj *objPtr,
+						  double *doublePtr);
+
+MODULE_SCOPE void	TkEventInit(void);
+MODULE_SCOPE void	TkRegisterObjTypes(void);
+MODULE_SCOPE int	TkCreateMenuCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TkDeadAppCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc, const char **argv);
+MODULE_SCOPE int	TkCanvasGetCoordObj(Tcl_Interp *interp,
+			    Tk_Canvas canvas, Tcl_Obj *obj,
+			    double *doublePtr);
+MODULE_SCOPE int	TkCanvasDashParseProc(ClientData clientData,
+			    Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *value, char *widgRec, int offset);
+MODULE_SCOPE char *	TkCanvasDashPrintProc(ClientData clientData,
+			    Tk_Window tkwin, char *widgRec, int offset,
+			    Tcl_FreeProc **freeProcPtr);
+MODULE_SCOPE int	TkGetDoublePixels(Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *string, double *doublePtr);
+MODULE_SCOPE int	TkOffsetParseProc(ClientData clientData,
+			    Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *value, char *widgRec, int offset);
+MODULE_SCOPE char *	TkOffsetPrintProc(ClientData clientData,
+			    Tk_Window tkwin, char *widgRec, int offset,
+			    Tcl_FreeProc **freeProcPtr);
+MODULE_SCOPE int	TkOrientParseProc(ClientData clientData,
+			    Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *value, char *widgRec, int offset);
+MODULE_SCOPE char *	TkOrientPrintProc(ClientData clientData,
+			    Tk_Window tkwin, char *widgRec, int offset,
+			    Tcl_FreeProc **freeProcPtr);
+MODULE_SCOPE int	TkPixelParseProc(ClientData clientData,
+			    Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *value, char *widgRec, int offset);
+MODULE_SCOPE char *	TkPixelPrintProc(ClientData clientData,
+			    Tk_Window tkwin, char *widgRec, int offset,
+			    Tcl_FreeProc **freeProcPtr);
+MODULE_SCOPE int	TkPostscriptImage(Tcl_Interp *interp, Tk_Window tkwin,
+			    Tk_PostscriptInfo psInfo, XImage *ximage,
+			    int x, int y, int width, int height);
+MODULE_SCOPE int	TkSmoothParseProc(ClientData clientData,
+			    Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *value, char *recordPtr, int offset);
+MODULE_SCOPE char *	TkSmoothPrintProc(ClientData clientData,
+			    Tk_Window tkwin, char *recordPtr, int offset,
+			    Tcl_FreeProc **freeProcPtr);
+MODULE_SCOPE int	TkStateParseProc(ClientData clientData,
+			    Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *value, char *widgRec, int offset);
+MODULE_SCOPE char *	TkStatePrintProc(ClientData clientData,
+			    Tk_Window tkwin, char *widgRec, int offset,
+			    Tcl_FreeProc **freeProcPtr);
+MODULE_SCOPE int	TkTileParseProc(ClientData clientData,
+			    Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *value, char *widgRec, int offset);
+MODULE_SCOPE char *	TkTilePrintProc(ClientData clientData, Tk_Window tkwin,
+			    char *widgRec, int offset,
+			    Tcl_FreeProc **freeProcPtr);
+MODULE_SCOPE void       TkMapTopFrame(Tk_Window tkwin);
+MODULE_SCOPE XEvent *	TkpGetBindingXEvent(Tcl_Interp *interp);
+MODULE_SCOPE void	TkCreateExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE void	TkDeleteExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE Tcl_ExitProc	TkFinalize;
+MODULE_SCOPE Tcl_ExitProc	TkFinalizeThread;
+MODULE_SCOPE void	TkpBuildRegionFromAlphaData(TkRegion region,
+			    unsigned x, unsigned y, unsigned width,
+			    unsigned height, unsigned char *dataPtr,
+			    unsigned pixelStride, unsigned lineStride);
+MODULE_SCOPE void	TkPrintPadAmount(Tcl_Interp *interp,
+			    char *buffer, int pad1, int pad2);
+MODULE_SCOPE int	TkParsePadAmount(Tcl_Interp *interp,
+			    Tk_Window tkwin, Tcl_Obj *objPtr,
+			    int *pad1Ptr, int *pad2Ptr);
+MODULE_SCOPE void       TkFocusSplit(TkWindow *winPtr);
+MODULE_SCOPE void       TkFocusJoin(TkWindow *winPtr);
+MODULE_SCOPE int	TkpAlwaysShowSelection(Tk_Window tkwin);
+MODULE_SCOPE void	TkpDrawCharsInContext(Display * display,
+			    Drawable drawable, GC gc, Tk_Font tkfont,
+			    const char *source, int numBytes, int rangeStart,
+			    int rangeLength, int x, int y);
+MODULE_SCOPE int	TkpMeasureCharsInContext(Tk_Font tkfont,
+			    const char *source, int numBytes, int rangeStart,
+			    int rangeLength, int maxLength, int flags,
+			    int *lengthPtr);
+MODULE_SCOPE void	TkUnderlineCharsInContext(Display *display,
+			    Drawable drawable, GC gc, Tk_Font tkfont,
+			    const char *string, int numBytes, int x, int y,
+			    int firstByte, int lastByte);
+MODULE_SCOPE void	TkpGetFontAttrsForChar(Tk_Window tkwin, Tk_Font tkfont,
+			    Tcl_UniChar c, struct TkFontAttributes *faPtr);
+
+/*
+ * Unsupported commands.
+ */
+
+MODULE_SCOPE int	TkUnsupported1ObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TKINT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
Index: src/tktext/tk8.5/tkIntDecls.h
===================================================================
--- src/tktext/tk8.5/tkIntDecls.h	(revision 0)
+++ src/tktext/tk8.5/tkIntDecls.h	(working copy)
@@ -0,0 +1,1908 @@
+/*
+ * tkIntDecls.h --
+ *
+ *	This file contains the declarations for all unsupported
+ *	functions that are exported by the Tk library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkIntDecls.h,v 1.31 2007/12/13 15:24:14 dgp Exp $
+ */
+
+#ifndef _TKINTDECLS
+#define _TKINTDECLS
+
+#ifdef BUILD_tk
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tkInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+#ifndef TkAllocWindow_TCL_DECLARED
+#define TkAllocWindow_TCL_DECLARED
+/* 0 */
+EXTERN TkWindow *	TkAllocWindow (TkDisplay * dispPtr, int screenNum, 
+				TkWindow * parentPtr);
+#endif
+#ifndef TkBezierPoints_TCL_DECLARED
+#define TkBezierPoints_TCL_DECLARED
+/* 1 */
+EXTERN void		TkBezierPoints (double control[], int numSteps, 
+				double * coordPtr);
+#endif
+#ifndef TkBezierScreenPoints_TCL_DECLARED
+#define TkBezierScreenPoints_TCL_DECLARED
+/* 2 */
+EXTERN void		TkBezierScreenPoints (Tk_Canvas canvas, 
+				double control[], int numSteps, 
+				XPoint * xPointPtr);
+#endif
+#ifndef TkBindDeadWindow_TCL_DECLARED
+#define TkBindDeadWindow_TCL_DECLARED
+/* 3 */
+EXTERN void		TkBindDeadWindow (TkWindow * winPtr);
+#endif
+#ifndef TkBindEventProc_TCL_DECLARED
+#define TkBindEventProc_TCL_DECLARED
+/* 4 */
+EXTERN void		TkBindEventProc (TkWindow * winPtr, 
+				XEvent * eventPtr);
+#endif
+#ifndef TkBindFree_TCL_DECLARED
+#define TkBindFree_TCL_DECLARED
+/* 5 */
+EXTERN void		TkBindFree (TkMainInfo * mainPtr);
+#endif
+#ifndef TkBindInit_TCL_DECLARED
+#define TkBindInit_TCL_DECLARED
+/* 6 */
+EXTERN void		TkBindInit (TkMainInfo * mainPtr);
+#endif
+#ifndef TkChangeEventWindow_TCL_DECLARED
+#define TkChangeEventWindow_TCL_DECLARED
+/* 7 */
+EXTERN void		TkChangeEventWindow (XEvent * eventPtr, 
+				TkWindow * winPtr);
+#endif
+#ifndef TkClipInit_TCL_DECLARED
+#define TkClipInit_TCL_DECLARED
+/* 8 */
+EXTERN int		TkClipInit (Tcl_Interp * interp, TkDisplay * dispPtr);
+#endif
+#ifndef TkComputeAnchor_TCL_DECLARED
+#define TkComputeAnchor_TCL_DECLARED
+/* 9 */
+EXTERN void		TkComputeAnchor (Tk_Anchor anchor, Tk_Window tkwin, 
+				int padX, int padY, int innerWidth, 
+				int innerHeight, int * xPtr, int * yPtr);
+#endif
+#ifndef TkCopyAndGlobalEval_TCL_DECLARED
+#define TkCopyAndGlobalEval_TCL_DECLARED
+/* 10 */
+EXTERN int		TkCopyAndGlobalEval (Tcl_Interp * interp, 
+				char * script);
+#endif
+#ifndef TkCreateBindingProcedure_TCL_DECLARED
+#define TkCreateBindingProcedure_TCL_DECLARED
+/* 11 */
+EXTERN unsigned long	TkCreateBindingProcedure (Tcl_Interp * interp, 
+				Tk_BindingTable bindingTable, 
+				ClientData object, CONST char * eventString, 
+				TkBindEvalProc * evalProc, 
+				TkBindFreeProc * freeProc, 
+				ClientData clientData);
+#endif
+#ifndef TkCreateCursorFromData_TCL_DECLARED
+#define TkCreateCursorFromData_TCL_DECLARED
+/* 12 */
+EXTERN TkCursor *	TkCreateCursorFromData (Tk_Window tkwin, 
+				CONST char * source, CONST char * mask, 
+				int width, int height, int xHot, int yHot, 
+				XColor fg, XColor bg);
+#endif
+#ifndef TkCreateFrame_TCL_DECLARED
+#define TkCreateFrame_TCL_DECLARED
+/* 13 */
+EXTERN int		TkCreateFrame (ClientData clientData, 
+				Tcl_Interp * interp, int argc, char ** argv, 
+				int toplevel, char * appName);
+#endif
+#ifndef TkCreateMainWindow_TCL_DECLARED
+#define TkCreateMainWindow_TCL_DECLARED
+/* 14 */
+EXTERN Tk_Window	TkCreateMainWindow (Tcl_Interp * interp, 
+				CONST char * screenName, char * baseName);
+#endif
+#ifndef TkCurrentTime_TCL_DECLARED
+#define TkCurrentTime_TCL_DECLARED
+/* 15 */
+EXTERN Time		TkCurrentTime (TkDisplay * dispPtr);
+#endif
+#ifndef TkDeleteAllImages_TCL_DECLARED
+#define TkDeleteAllImages_TCL_DECLARED
+/* 16 */
+EXTERN void		TkDeleteAllImages (TkMainInfo * mainPtr);
+#endif
+#ifndef TkDoConfigureNotify_TCL_DECLARED
+#define TkDoConfigureNotify_TCL_DECLARED
+/* 17 */
+EXTERN void		TkDoConfigureNotify (TkWindow * winPtr);
+#endif
+#ifndef TkDrawInsetFocusHighlight_TCL_DECLARED
+#define TkDrawInsetFocusHighlight_TCL_DECLARED
+/* 18 */
+EXTERN void		TkDrawInsetFocusHighlight (Tk_Window tkwin, GC gc, 
+				int width, Drawable drawable, int padding);
+#endif
+#ifndef TkEventDeadWindow_TCL_DECLARED
+#define TkEventDeadWindow_TCL_DECLARED
+/* 19 */
+EXTERN void		TkEventDeadWindow (TkWindow * winPtr);
+#endif
+#ifndef TkFillPolygon_TCL_DECLARED
+#define TkFillPolygon_TCL_DECLARED
+/* 20 */
+EXTERN void		TkFillPolygon (Tk_Canvas canvas, double * coordPtr, 
+				int numPoints, Display * display, 
+				Drawable drawable, GC gc, GC outlineGC);
+#endif
+#ifndef TkFindStateNum_TCL_DECLARED
+#define TkFindStateNum_TCL_DECLARED
+/* 21 */
+EXTERN int		TkFindStateNum (Tcl_Interp * interp, 
+				CONST char * option, 
+				CONST TkStateMap * mapPtr, 
+				CONST char * strKey);
+#endif
+#ifndef TkFindStateString_TCL_DECLARED
+#define TkFindStateString_TCL_DECLARED
+/* 22 */
+EXTERN char *		TkFindStateString (CONST TkStateMap * mapPtr, 
+				int numKey);
+#endif
+#ifndef TkFocusDeadWindow_TCL_DECLARED
+#define TkFocusDeadWindow_TCL_DECLARED
+/* 23 */
+EXTERN void		TkFocusDeadWindow (TkWindow * winPtr);
+#endif
+#ifndef TkFocusFilterEvent_TCL_DECLARED
+#define TkFocusFilterEvent_TCL_DECLARED
+/* 24 */
+EXTERN int		TkFocusFilterEvent (TkWindow * winPtr, 
+				XEvent * eventPtr);
+#endif
+#ifndef TkFocusKeyEvent_TCL_DECLARED
+#define TkFocusKeyEvent_TCL_DECLARED
+/* 25 */
+EXTERN TkWindow *	TkFocusKeyEvent (TkWindow * winPtr, 
+				XEvent * eventPtr);
+#endif
+#ifndef TkFontPkgInit_TCL_DECLARED
+#define TkFontPkgInit_TCL_DECLARED
+/* 26 */
+EXTERN void		TkFontPkgInit (TkMainInfo * mainPtr);
+#endif
+#ifndef TkFontPkgFree_TCL_DECLARED
+#define TkFontPkgFree_TCL_DECLARED
+/* 27 */
+EXTERN void		TkFontPkgFree (TkMainInfo * mainPtr);
+#endif
+#ifndef TkFreeBindingTags_TCL_DECLARED
+#define TkFreeBindingTags_TCL_DECLARED
+/* 28 */
+EXTERN void		TkFreeBindingTags (TkWindow * winPtr);
+#endif
+#ifndef TkpFreeCursor_TCL_DECLARED
+#define TkpFreeCursor_TCL_DECLARED
+/* 29 */
+EXTERN void		TkpFreeCursor (TkCursor * cursorPtr);
+#endif
+#ifndef TkGetBitmapData_TCL_DECLARED
+#define TkGetBitmapData_TCL_DECLARED
+/* 30 */
+EXTERN char *		TkGetBitmapData (Tcl_Interp * interp, char * string, 
+				char * fileName, int * widthPtr, 
+				int * heightPtr, int * hotXPtr, 
+				int * hotYPtr);
+#endif
+#ifndef TkGetButtPoints_TCL_DECLARED
+#define TkGetButtPoints_TCL_DECLARED
+/* 31 */
+EXTERN void		TkGetButtPoints (double p1[], double p2[], 
+				double width, int project, double m1[], 
+				double m2[]);
+#endif
+#ifndef TkGetCursorByName_TCL_DECLARED
+#define TkGetCursorByName_TCL_DECLARED
+/* 32 */
+EXTERN TkCursor *	TkGetCursorByName (Tcl_Interp * interp, 
+				Tk_Window tkwin, Tk_Uid string);
+#endif
+#ifndef TkGetDefaultScreenName_TCL_DECLARED
+#define TkGetDefaultScreenName_TCL_DECLARED
+/* 33 */
+EXTERN CONST84_RETURN char * TkGetDefaultScreenName (Tcl_Interp * interp, 
+				CONST char * screenName);
+#endif
+#ifndef TkGetDisplay_TCL_DECLARED
+#define TkGetDisplay_TCL_DECLARED
+/* 34 */
+EXTERN TkDisplay *	TkGetDisplay (Display * display);
+#endif
+#ifndef TkGetDisplayOf_TCL_DECLARED
+#define TkGetDisplayOf_TCL_DECLARED
+/* 35 */
+EXTERN int		TkGetDisplayOf (Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[], Tk_Window * tkwinPtr);
+#endif
+#ifndef TkGetFocusWin_TCL_DECLARED
+#define TkGetFocusWin_TCL_DECLARED
+/* 36 */
+EXTERN TkWindow *	TkGetFocusWin (TkWindow * winPtr);
+#endif
+#ifndef TkGetInterpNames_TCL_DECLARED
+#define TkGetInterpNames_TCL_DECLARED
+/* 37 */
+EXTERN int		TkGetInterpNames (Tcl_Interp * interp, 
+				Tk_Window tkwin);
+#endif
+#ifndef TkGetMiterPoints_TCL_DECLARED
+#define TkGetMiterPoints_TCL_DECLARED
+/* 38 */
+EXTERN int		TkGetMiterPoints (double p1[], double p2[], 
+				double p3[], double width, double m1[], 
+				double m2[]);
+#endif
+#ifndef TkGetPointerCoords_TCL_DECLARED
+#define TkGetPointerCoords_TCL_DECLARED
+/* 39 */
+EXTERN void		TkGetPointerCoords (Tk_Window tkwin, int * xPtr, 
+				int * yPtr);
+#endif
+#ifndef TkGetServerInfo_TCL_DECLARED
+#define TkGetServerInfo_TCL_DECLARED
+/* 40 */
+EXTERN void		TkGetServerInfo (Tcl_Interp * interp, 
+				Tk_Window tkwin);
+#endif
+#ifndef TkGrabDeadWindow_TCL_DECLARED
+#define TkGrabDeadWindow_TCL_DECLARED
+/* 41 */
+EXTERN void		TkGrabDeadWindow (TkWindow * winPtr);
+#endif
+#ifndef TkGrabState_TCL_DECLARED
+#define TkGrabState_TCL_DECLARED
+/* 42 */
+EXTERN int		TkGrabState (TkWindow * winPtr);
+#endif
+#ifndef TkIncludePoint_TCL_DECLARED
+#define TkIncludePoint_TCL_DECLARED
+/* 43 */
+EXTERN void		TkIncludePoint (Tk_Item * itemPtr, double * pointPtr);
+#endif
+#ifndef TkInOutEvents_TCL_DECLARED
+#define TkInOutEvents_TCL_DECLARED
+/* 44 */
+EXTERN void		TkInOutEvents (XEvent * eventPtr, 
+				TkWindow * sourcePtr, TkWindow * destPtr, 
+				int leaveType, int enterType, 
+				Tcl_QueuePosition position);
+#endif
+#ifndef TkInstallFrameMenu_TCL_DECLARED
+#define TkInstallFrameMenu_TCL_DECLARED
+/* 45 */
+EXTERN void		TkInstallFrameMenu (Tk_Window tkwin);
+#endif
+#ifndef TkKeysymToString_TCL_DECLARED
+#define TkKeysymToString_TCL_DECLARED
+/* 46 */
+EXTERN char *		TkKeysymToString (KeySym keysym);
+#endif
+#ifndef TkLineToArea_TCL_DECLARED
+#define TkLineToArea_TCL_DECLARED
+/* 47 */
+EXTERN int		TkLineToArea (double end1Ptr[], double end2Ptr[], 
+				double rectPtr[]);
+#endif
+#ifndef TkLineToPoint_TCL_DECLARED
+#define TkLineToPoint_TCL_DECLARED
+/* 48 */
+EXTERN double		TkLineToPoint (double end1Ptr[], double end2Ptr[], 
+				double pointPtr[]);
+#endif
+#ifndef TkMakeBezierCurve_TCL_DECLARED
+#define TkMakeBezierCurve_TCL_DECLARED
+/* 49 */
+EXTERN int		TkMakeBezierCurve (Tk_Canvas canvas, 
+				double * pointPtr, int numPoints, 
+				int numSteps, XPoint xPoints[], 
+				double dblPoints[]);
+#endif
+#ifndef TkMakeBezierPostscript_TCL_DECLARED
+#define TkMakeBezierPostscript_TCL_DECLARED
+/* 50 */
+EXTERN void		TkMakeBezierPostscript (Tcl_Interp * interp, 
+				Tk_Canvas canvas, double * pointPtr, 
+				int numPoints);
+#endif
+#ifndef TkOptionClassChanged_TCL_DECLARED
+#define TkOptionClassChanged_TCL_DECLARED
+/* 51 */
+EXTERN void		TkOptionClassChanged (TkWindow * winPtr);
+#endif
+#ifndef TkOptionDeadWindow_TCL_DECLARED
+#define TkOptionDeadWindow_TCL_DECLARED
+/* 52 */
+EXTERN void		TkOptionDeadWindow (TkWindow * winPtr);
+#endif
+#ifndef TkOvalToArea_TCL_DECLARED
+#define TkOvalToArea_TCL_DECLARED
+/* 53 */
+EXTERN int		TkOvalToArea (double * ovalPtr, double * rectPtr);
+#endif
+#ifndef TkOvalToPoint_TCL_DECLARED
+#define TkOvalToPoint_TCL_DECLARED
+/* 54 */
+EXTERN double		TkOvalToPoint (double ovalPtr[], double width, 
+				int filled, double pointPtr[]);
+#endif
+#ifndef TkpChangeFocus_TCL_DECLARED
+#define TkpChangeFocus_TCL_DECLARED
+/* 55 */
+EXTERN int		TkpChangeFocus (TkWindow * winPtr, int force);
+#endif
+#ifndef TkpCloseDisplay_TCL_DECLARED
+#define TkpCloseDisplay_TCL_DECLARED
+/* 56 */
+EXTERN void		TkpCloseDisplay (TkDisplay * dispPtr);
+#endif
+#ifndef TkpClaimFocus_TCL_DECLARED
+#define TkpClaimFocus_TCL_DECLARED
+/* 57 */
+EXTERN void		TkpClaimFocus (TkWindow * topLevelPtr, int force);
+#endif
+#ifndef TkpDisplayWarning_TCL_DECLARED
+#define TkpDisplayWarning_TCL_DECLARED
+/* 58 */
+EXTERN void		TkpDisplayWarning (CONST char * msg, 
+				CONST char * title);
+#endif
+#ifndef TkpGetAppName_TCL_DECLARED
+#define TkpGetAppName_TCL_DECLARED
+/* 59 */
+EXTERN void		TkpGetAppName (Tcl_Interp * interp, 
+				Tcl_DString * name);
+#endif
+#ifndef TkpGetOtherWindow_TCL_DECLARED
+#define TkpGetOtherWindow_TCL_DECLARED
+/* 60 */
+EXTERN TkWindow *	TkpGetOtherWindow (TkWindow * winPtr);
+#endif
+#ifndef TkpGetWrapperWindow_TCL_DECLARED
+#define TkpGetWrapperWindow_TCL_DECLARED
+/* 61 */
+EXTERN TkWindow *	TkpGetWrapperWindow (TkWindow * winPtr);
+#endif
+#ifndef TkpInit_TCL_DECLARED
+#define TkpInit_TCL_DECLARED
+/* 62 */
+EXTERN int		TkpInit (Tcl_Interp * interp);
+#endif
+#ifndef TkpInitializeMenuBindings_TCL_DECLARED
+#define TkpInitializeMenuBindings_TCL_DECLARED
+/* 63 */
+EXTERN void		TkpInitializeMenuBindings (Tcl_Interp * interp, 
+				Tk_BindingTable bindingTable);
+#endif
+#ifndef TkpMakeContainer_TCL_DECLARED
+#define TkpMakeContainer_TCL_DECLARED
+/* 64 */
+EXTERN void		TkpMakeContainer (Tk_Window tkwin);
+#endif
+#ifndef TkpMakeMenuWindow_TCL_DECLARED
+#define TkpMakeMenuWindow_TCL_DECLARED
+/* 65 */
+EXTERN void		TkpMakeMenuWindow (Tk_Window tkwin, int transient);
+#endif
+#ifndef TkpMakeWindow_TCL_DECLARED
+#define TkpMakeWindow_TCL_DECLARED
+/* 66 */
+EXTERN Window		TkpMakeWindow (TkWindow * winPtr, Window parent);
+#endif
+#ifndef TkpMenuNotifyToplevelCreate_TCL_DECLARED
+#define TkpMenuNotifyToplevelCreate_TCL_DECLARED
+/* 67 */
+EXTERN void		TkpMenuNotifyToplevelCreate (Tcl_Interp * interp1, 
+				char * menuName);
+#endif
+#ifndef TkpOpenDisplay_TCL_DECLARED
+#define TkpOpenDisplay_TCL_DECLARED
+/* 68 */
+EXTERN TkDisplay *	TkpOpenDisplay (CONST char * display_name);
+#endif
+#ifndef TkPointerEvent_TCL_DECLARED
+#define TkPointerEvent_TCL_DECLARED
+/* 69 */
+EXTERN int		TkPointerEvent (XEvent * eventPtr, TkWindow * winPtr);
+#endif
+#ifndef TkPolygonToArea_TCL_DECLARED
+#define TkPolygonToArea_TCL_DECLARED
+/* 70 */
+EXTERN int		TkPolygonToArea (double * polyPtr, int numPoints, 
+				double * rectPtr);
+#endif
+#ifndef TkPolygonToPoint_TCL_DECLARED
+#define TkPolygonToPoint_TCL_DECLARED
+/* 71 */
+EXTERN double		TkPolygonToPoint (double * polyPtr, int numPoints, 
+				double * pointPtr);
+#endif
+#ifndef TkPositionInTree_TCL_DECLARED
+#define TkPositionInTree_TCL_DECLARED
+/* 72 */
+EXTERN int		TkPositionInTree (TkWindow * winPtr, 
+				TkWindow * treePtr);
+#endif
+#ifndef TkpRedirectKeyEvent_TCL_DECLARED
+#define TkpRedirectKeyEvent_TCL_DECLARED
+/* 73 */
+EXTERN void		TkpRedirectKeyEvent (TkWindow * winPtr, 
+				XEvent * eventPtr);
+#endif
+#ifndef TkpSetMainMenubar_TCL_DECLARED
+#define TkpSetMainMenubar_TCL_DECLARED
+/* 74 */
+EXTERN void		TkpSetMainMenubar (Tcl_Interp * interp, 
+				Tk_Window tkwin, char * menuName);
+#endif
+#ifndef TkpUseWindow_TCL_DECLARED
+#define TkpUseWindow_TCL_DECLARED
+/* 75 */
+EXTERN int		TkpUseWindow (Tcl_Interp * interp, Tk_Window tkwin, 
+				CONST char * string);
+#endif
+#ifndef TkpWindowWasRecentlyDeleted_TCL_DECLARED
+#define TkpWindowWasRecentlyDeleted_TCL_DECLARED
+/* 76 */
+EXTERN int		TkpWindowWasRecentlyDeleted (Window win, 
+				TkDisplay * dispPtr);
+#endif
+#ifndef TkQueueEventForAllChildren_TCL_DECLARED
+#define TkQueueEventForAllChildren_TCL_DECLARED
+/* 77 */
+EXTERN void		TkQueueEventForAllChildren (TkWindow * winPtr, 
+				XEvent * eventPtr);
+#endif
+#ifndef TkReadBitmapFile_TCL_DECLARED
+#define TkReadBitmapFile_TCL_DECLARED
+/* 78 */
+EXTERN int		TkReadBitmapFile (Display * display, Drawable d, 
+				CONST char * filename, 
+				unsigned int * width_return, 
+				unsigned int * height_return, 
+				Pixmap * bitmap_return, int * x_hot_return, 
+				int * y_hot_return);
+#endif
+#ifndef TkScrollWindow_TCL_DECLARED
+#define TkScrollWindow_TCL_DECLARED
+/* 79 */
+EXTERN int		TkScrollWindow (Tk_Window tkwin, GC gc, int x, int y, 
+				int width, int height, int dx, int dy, 
+				TkRegion damageRgn);
+#endif
+#ifndef TkSelDeadWindow_TCL_DECLARED
+#define TkSelDeadWindow_TCL_DECLARED
+/* 80 */
+EXTERN void		TkSelDeadWindow (TkWindow * winPtr);
+#endif
+#ifndef TkSelEventProc_TCL_DECLARED
+#define TkSelEventProc_TCL_DECLARED
+/* 81 */
+EXTERN void		TkSelEventProc (Tk_Window tkwin, XEvent * eventPtr);
+#endif
+#ifndef TkSelInit_TCL_DECLARED
+#define TkSelInit_TCL_DECLARED
+/* 82 */
+EXTERN void		TkSelInit (Tk_Window tkwin);
+#endif
+#ifndef TkSelPropProc_TCL_DECLARED
+#define TkSelPropProc_TCL_DECLARED
+/* 83 */
+EXTERN void		TkSelPropProc (XEvent * eventPtr);
+#endif
+/* Slot 84 is reserved */
+#ifndef TkSetWindowMenuBar_TCL_DECLARED
+#define TkSetWindowMenuBar_TCL_DECLARED
+/* 85 */
+EXTERN void		TkSetWindowMenuBar (Tcl_Interp * interp, 
+				Tk_Window tkwin, char * oldMenuName, 
+				char * menuName);
+#endif
+#ifndef TkStringToKeysym_TCL_DECLARED
+#define TkStringToKeysym_TCL_DECLARED
+/* 86 */
+EXTERN KeySym		TkStringToKeysym (char * name);
+#endif
+#ifndef TkThickPolyLineToArea_TCL_DECLARED
+#define TkThickPolyLineToArea_TCL_DECLARED
+/* 87 */
+EXTERN int		TkThickPolyLineToArea (double * coordPtr, 
+				int numPoints, double width, int capStyle, 
+				int joinStyle, double * rectPtr);
+#endif
+#ifndef TkWmAddToColormapWindows_TCL_DECLARED
+#define TkWmAddToColormapWindows_TCL_DECLARED
+/* 88 */
+EXTERN void		TkWmAddToColormapWindows (TkWindow * winPtr);
+#endif
+#ifndef TkWmDeadWindow_TCL_DECLARED
+#define TkWmDeadWindow_TCL_DECLARED
+/* 89 */
+EXTERN void		TkWmDeadWindow (TkWindow * winPtr);
+#endif
+#ifndef TkWmFocusToplevel_TCL_DECLARED
+#define TkWmFocusToplevel_TCL_DECLARED
+/* 90 */
+EXTERN TkWindow *	TkWmFocusToplevel (TkWindow * winPtr);
+#endif
+#ifndef TkWmMapWindow_TCL_DECLARED
+#define TkWmMapWindow_TCL_DECLARED
+/* 91 */
+EXTERN void		TkWmMapWindow (TkWindow * winPtr);
+#endif
+#ifndef TkWmNewWindow_TCL_DECLARED
+#define TkWmNewWindow_TCL_DECLARED
+/* 92 */
+EXTERN void		TkWmNewWindow (TkWindow * winPtr);
+#endif
+#ifndef TkWmProtocolEventProc_TCL_DECLARED
+#define TkWmProtocolEventProc_TCL_DECLARED
+/* 93 */
+EXTERN void		TkWmProtocolEventProc (TkWindow * winPtr, 
+				XEvent * evenvPtr);
+#endif
+#ifndef TkWmRemoveFromColormapWindows_TCL_DECLARED
+#define TkWmRemoveFromColormapWindows_TCL_DECLARED
+/* 94 */
+EXTERN void		TkWmRemoveFromColormapWindows (TkWindow * winPtr);
+#endif
+#ifndef TkWmRestackToplevel_TCL_DECLARED
+#define TkWmRestackToplevel_TCL_DECLARED
+/* 95 */
+EXTERN void		TkWmRestackToplevel (TkWindow * winPtr, 
+				int aboveBelow, TkWindow * otherPtr);
+#endif
+#ifndef TkWmSetClass_TCL_DECLARED
+#define TkWmSetClass_TCL_DECLARED
+/* 96 */
+EXTERN void		TkWmSetClass (TkWindow * winPtr);
+#endif
+#ifndef TkWmUnmapWindow_TCL_DECLARED
+#define TkWmUnmapWindow_TCL_DECLARED
+/* 97 */
+EXTERN void		TkWmUnmapWindow (TkWindow * winPtr);
+#endif
+#ifndef TkDebugBitmap_TCL_DECLARED
+#define TkDebugBitmap_TCL_DECLARED
+/* 98 */
+EXTERN Tcl_Obj *	TkDebugBitmap (Tk_Window tkwin, char * name);
+#endif
+#ifndef TkDebugBorder_TCL_DECLARED
+#define TkDebugBorder_TCL_DECLARED
+/* 99 */
+EXTERN Tcl_Obj *	TkDebugBorder (Tk_Window tkwin, char * name);
+#endif
+#ifndef TkDebugCursor_TCL_DECLARED
+#define TkDebugCursor_TCL_DECLARED
+/* 100 */
+EXTERN Tcl_Obj *	TkDebugCursor (Tk_Window tkwin, char * name);
+#endif
+#ifndef TkDebugColor_TCL_DECLARED
+#define TkDebugColor_TCL_DECLARED
+/* 101 */
+EXTERN Tcl_Obj *	TkDebugColor (Tk_Window tkwin, char * name);
+#endif
+#ifndef TkDebugConfig_TCL_DECLARED
+#define TkDebugConfig_TCL_DECLARED
+/* 102 */
+EXTERN Tcl_Obj *	TkDebugConfig (Tcl_Interp * interp, 
+				Tk_OptionTable table);
+#endif
+#ifndef TkDebugFont_TCL_DECLARED
+#define TkDebugFont_TCL_DECLARED
+/* 103 */
+EXTERN Tcl_Obj *	TkDebugFont (Tk_Window tkwin, char * name);
+#endif
+#ifndef TkFindStateNumObj_TCL_DECLARED
+#define TkFindStateNumObj_TCL_DECLARED
+/* 104 */
+EXTERN int		TkFindStateNumObj (Tcl_Interp * interp, 
+				Tcl_Obj * optionPtr, 
+				CONST TkStateMap * mapPtr, Tcl_Obj * keyPtr);
+#endif
+#ifndef TkGetBitmapPredefTable_TCL_DECLARED
+#define TkGetBitmapPredefTable_TCL_DECLARED
+/* 105 */
+EXTERN Tcl_HashTable *	TkGetBitmapPredefTable (void);
+#endif
+#ifndef TkGetDisplayList_TCL_DECLARED
+#define TkGetDisplayList_TCL_DECLARED
+/* 106 */
+EXTERN TkDisplay *	TkGetDisplayList (void);
+#endif
+#ifndef TkGetMainInfoList_TCL_DECLARED
+#define TkGetMainInfoList_TCL_DECLARED
+/* 107 */
+EXTERN TkMainInfo *	TkGetMainInfoList (void);
+#endif
+#ifndef TkGetWindowFromObj_TCL_DECLARED
+#define TkGetWindowFromObj_TCL_DECLARED
+/* 108 */
+EXTERN int		TkGetWindowFromObj (Tcl_Interp * interp, 
+				Tk_Window tkwin, Tcl_Obj * objPtr, 
+				Tk_Window * windowPtr);
+#endif
+#ifndef TkpGetString_TCL_DECLARED
+#define TkpGetString_TCL_DECLARED
+/* 109 */
+EXTERN char *		TkpGetString (TkWindow * winPtr, XEvent * eventPtr, 
+				Tcl_DString * dsPtr);
+#endif
+#ifndef TkpGetSubFonts_TCL_DECLARED
+#define TkpGetSubFonts_TCL_DECLARED
+/* 110 */
+EXTERN void		TkpGetSubFonts (Tcl_Interp * interp, Tk_Font tkfont);
+#endif
+#ifndef TkpGetSystemDefault_TCL_DECLARED
+#define TkpGetSystemDefault_TCL_DECLARED
+/* 111 */
+EXTERN Tcl_Obj *	TkpGetSystemDefault (Tk_Window tkwin, 
+				CONST char * dbName, CONST char * className);
+#endif
+#ifndef TkpMenuThreadInit_TCL_DECLARED
+#define TkpMenuThreadInit_TCL_DECLARED
+/* 112 */
+EXTERN void		TkpMenuThreadInit (void);
+#endif
+#ifdef __WIN32__ /* WIN */
+#ifndef TkClipBox_TCL_DECLARED
+#define TkClipBox_TCL_DECLARED
+/* 113 */
+EXTERN void		TkClipBox (TkRegion rgn, XRectangle * rect_return);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkClipBox_TCL_DECLARED
+#define TkClipBox_TCL_DECLARED
+/* 113 */
+EXTERN void		TkClipBox (TkRegion rgn, XRectangle * rect_return);
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkCreateRegion_TCL_DECLARED
+#define TkCreateRegion_TCL_DECLARED
+/* 114 */
+EXTERN TkRegion		TkCreateRegion (void);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkCreateRegion_TCL_DECLARED
+#define TkCreateRegion_TCL_DECLARED
+/* 114 */
+EXTERN TkRegion		TkCreateRegion (void);
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkDestroyRegion_TCL_DECLARED
+#define TkDestroyRegion_TCL_DECLARED
+/* 115 */
+EXTERN void		TkDestroyRegion (TkRegion rgn);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkDestroyRegion_TCL_DECLARED
+#define TkDestroyRegion_TCL_DECLARED
+/* 115 */
+EXTERN void		TkDestroyRegion (TkRegion rgn);
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkIntersectRegion_TCL_DECLARED
+#define TkIntersectRegion_TCL_DECLARED
+/* 116 */
+EXTERN void		TkIntersectRegion (TkRegion sra, TkRegion srcb, 
+				TkRegion dr_return);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkIntersectRegion_TCL_DECLARED
+#define TkIntersectRegion_TCL_DECLARED
+/* 116 */
+EXTERN void		TkIntersectRegion (TkRegion sra, TkRegion srcb, 
+				TkRegion dr_return);
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkRectInRegion_TCL_DECLARED
+#define TkRectInRegion_TCL_DECLARED
+/* 117 */
+EXTERN int		TkRectInRegion (TkRegion rgn, int x, int y, 
+				unsigned int width, unsigned int height);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkRectInRegion_TCL_DECLARED
+#define TkRectInRegion_TCL_DECLARED
+/* 117 */
+EXTERN int		TkRectInRegion (TkRegion rgn, int x, int y, 
+				unsigned int width, unsigned int height);
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkSetRegion_TCL_DECLARED
+#define TkSetRegion_TCL_DECLARED
+/* 118 */
+EXTERN void		TkSetRegion (Display * display, GC gc, TkRegion rgn);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkSetRegion_TCL_DECLARED
+#define TkSetRegion_TCL_DECLARED
+/* 118 */
+EXTERN void		TkSetRegion (Display * display, GC gc, TkRegion rgn);
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkUnionRectWithRegion_TCL_DECLARED
+#define TkUnionRectWithRegion_TCL_DECLARED
+/* 119 */
+EXTERN void		TkUnionRectWithRegion (XRectangle * rect, 
+				TkRegion src, TkRegion dr_return);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkUnionRectWithRegion_TCL_DECLARED
+#define TkUnionRectWithRegion_TCL_DECLARED
+/* 119 */
+EXTERN void		TkUnionRectWithRegion (XRectangle * rect, 
+				TkRegion src, TkRegion dr_return);
+#endif
+#endif /* AQUA */
+/* Slot 120 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkpCreateNativeBitmap_TCL_DECLARED
+#define TkpCreateNativeBitmap_TCL_DECLARED
+/* 121 */
+EXTERN Pixmap		TkpCreateNativeBitmap (Display * display, 
+				CONST char * source);
+#endif
+#endif /* AQUA */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkpDefineNativeBitmaps_TCL_DECLARED
+#define TkpDefineNativeBitmaps_TCL_DECLARED
+/* 122 */
+EXTERN void		TkpDefineNativeBitmaps (void);
+#endif
+#endif /* AQUA */
+/* Slot 123 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkpGetNativeAppBitmap_TCL_DECLARED
+#define TkpGetNativeAppBitmap_TCL_DECLARED
+/* 124 */
+EXTERN Pixmap		TkpGetNativeAppBitmap (Display * display, 
+				CONST char * name, int * width, int * height);
+#endif
+#endif /* AQUA */
+/* Slot 125 is reserved */
+/* Slot 126 is reserved */
+/* Slot 127 is reserved */
+/* Slot 128 is reserved */
+/* Slot 129 is reserved */
+/* Slot 130 is reserved */
+/* Slot 131 is reserved */
+/* Slot 132 is reserved */
+/* Slot 133 is reserved */
+/* Slot 134 is reserved */
+#ifndef TkpDrawHighlightBorder_TCL_DECLARED
+#define TkpDrawHighlightBorder_TCL_DECLARED
+/* 135 */
+EXTERN void		TkpDrawHighlightBorder (Tk_Window tkwin, GC fgGC, 
+				GC bgGC, int highlightWidth, 
+				Drawable drawable);
+#endif
+#ifndef TkSetFocusWin_TCL_DECLARED
+#define TkSetFocusWin_TCL_DECLARED
+/* 136 */
+EXTERN void		TkSetFocusWin (TkWindow * winPtr, int force);
+#endif
+#ifndef TkpSetKeycodeAndState_TCL_DECLARED
+#define TkpSetKeycodeAndState_TCL_DECLARED
+/* 137 */
+EXTERN void		TkpSetKeycodeAndState (Tk_Window tkwin, 
+				KeySym keySym, XEvent * eventPtr);
+#endif
+#ifndef TkpGetKeySym_TCL_DECLARED
+#define TkpGetKeySym_TCL_DECLARED
+/* 138 */
+EXTERN KeySym		TkpGetKeySym (TkDisplay * dispPtr, XEvent * eventPtr);
+#endif
+#ifndef TkpInitKeymapInfo_TCL_DECLARED
+#define TkpInitKeymapInfo_TCL_DECLARED
+/* 139 */
+EXTERN void		TkpInitKeymapInfo (TkDisplay * dispPtr);
+#endif
+#ifndef TkPhotoGetValidRegion_TCL_DECLARED
+#define TkPhotoGetValidRegion_TCL_DECLARED
+/* 140 */
+EXTERN TkRegion		TkPhotoGetValidRegion (Tk_PhotoHandle handle);
+#endif
+#ifndef TkWmStackorderToplevel_TCL_DECLARED
+#define TkWmStackorderToplevel_TCL_DECLARED
+/* 141 */
+EXTERN TkWindow **	TkWmStackorderToplevel (TkWindow * parentPtr);
+#endif
+#ifndef TkFocusFree_TCL_DECLARED
+#define TkFocusFree_TCL_DECLARED
+/* 142 */
+EXTERN void		TkFocusFree (TkMainInfo * mainPtr);
+#endif
+#ifndef TkClipCleanup_TCL_DECLARED
+#define TkClipCleanup_TCL_DECLARED
+/* 143 */
+EXTERN void		TkClipCleanup (TkDisplay * dispPtr);
+#endif
+#ifndef TkGCCleanup_TCL_DECLARED
+#define TkGCCleanup_TCL_DECLARED
+/* 144 */
+EXTERN void		TkGCCleanup (TkDisplay * dispPtr);
+#endif
+#ifdef __WIN32__ /* WIN */
+#ifndef TkSubtractRegion_TCL_DECLARED
+#define TkSubtractRegion_TCL_DECLARED
+/* 145 */
+EXTERN void		TkSubtractRegion (TkRegion sra, TkRegion srcb, 
+				TkRegion dr_return);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkSubtractRegion_TCL_DECLARED
+#define TkSubtractRegion_TCL_DECLARED
+/* 145 */
+EXTERN void		TkSubtractRegion (TkRegion sra, TkRegion srcb, 
+				TkRegion dr_return);
+#endif
+#endif /* AQUA */
+#ifndef TkStylePkgInit_TCL_DECLARED
+#define TkStylePkgInit_TCL_DECLARED
+/* 146 */
+EXTERN void		TkStylePkgInit (TkMainInfo * mainPtr);
+#endif
+#ifndef TkStylePkgFree_TCL_DECLARED
+#define TkStylePkgFree_TCL_DECLARED
+/* 147 */
+EXTERN void		TkStylePkgFree (TkMainInfo * mainPtr);
+#endif
+#ifndef TkToplevelWindowForCommand_TCL_DECLARED
+#define TkToplevelWindowForCommand_TCL_DECLARED
+/* 148 */
+EXTERN Tk_Window	TkToplevelWindowForCommand (Tcl_Interp * interp, 
+				CONST char * cmdName);
+#endif
+#ifndef TkGetOptionSpec_TCL_DECLARED
+#define TkGetOptionSpec_TCL_DECLARED
+/* 149 */
+EXTERN CONST Tk_OptionSpec * TkGetOptionSpec (CONST char * name, 
+				Tk_OptionTable optionTable);
+#endif
+#ifndef TkMakeRawCurve_TCL_DECLARED
+#define TkMakeRawCurve_TCL_DECLARED
+/* 150 */
+EXTERN int		TkMakeRawCurve (Tk_Canvas canvas, double * pointPtr, 
+				int numPoints, int numSteps, 
+				XPoint xPoints[], double dblPoints[]);
+#endif
+#ifndef TkMakeRawCurvePostscript_TCL_DECLARED
+#define TkMakeRawCurvePostscript_TCL_DECLARED
+/* 151 */
+EXTERN void		TkMakeRawCurvePostscript (Tcl_Interp * interp, 
+				Tk_Canvas canvas, double * pointPtr, 
+				int numPoints);
+#endif
+#ifndef TkpDrawFrame_TCL_DECLARED
+#define TkpDrawFrame_TCL_DECLARED
+/* 152 */
+EXTERN void		TkpDrawFrame (Tk_Window tkwin, Tk_3DBorder border, 
+				int highlightWidth, int borderWidth, 
+				int relief);
+#endif
+#ifndef TkCreateThreadExitHandler_TCL_DECLARED
+#define TkCreateThreadExitHandler_TCL_DECLARED
+/* 153 */
+EXTERN void		TkCreateThreadExitHandler (Tcl_ExitProc * proc, 
+				ClientData clientData);
+#endif
+#ifndef TkDeleteThreadExitHandler_TCL_DECLARED
+#define TkDeleteThreadExitHandler_TCL_DECLARED
+/* 154 */
+EXTERN void		TkDeleteThreadExitHandler (Tcl_ExitProc * proc, 
+				ClientData clientData);
+#endif
+/* Slot 155 is reserved */
+#ifndef TkpTestembedCmd_TCL_DECLARED
+#define TkpTestembedCmd_TCL_DECLARED
+/* 156 */
+EXTERN int		TkpTestembedCmd (ClientData clientData, 
+				Tcl_Interp * interp, int argc, 
+				CONST char ** argv);
+#endif
+#ifndef TkpTesttextCmd_TCL_DECLARED
+#define TkpTesttextCmd_TCL_DECLARED
+/* 157 */
+EXTERN int		TkpTesttextCmd (ClientData dummy, 
+				Tcl_Interp * interp, int argc, 
+				CONST char ** argv);
+#endif
+
+typedef struct TkIntStubs {
+    int magic;
+    struct TkIntStubHooks *hooks;
+
+    TkWindow * (*tkAllocWindow) (TkDisplay * dispPtr, int screenNum, TkWindow * parentPtr); /* 0 */
+    void (*tkBezierPoints) (double control[], int numSteps, double * coordPtr); /* 1 */
+    void (*tkBezierScreenPoints) (Tk_Canvas canvas, double control[], int numSteps, XPoint * xPointPtr); /* 2 */
+    void (*tkBindDeadWindow) (TkWindow * winPtr); /* 3 */
+    void (*tkBindEventProc) (TkWindow * winPtr, XEvent * eventPtr); /* 4 */
+    void (*tkBindFree) (TkMainInfo * mainPtr); /* 5 */
+    void (*tkBindInit) (TkMainInfo * mainPtr); /* 6 */
+    void (*tkChangeEventWindow) (XEvent * eventPtr, TkWindow * winPtr); /* 7 */
+    int (*tkClipInit) (Tcl_Interp * interp, TkDisplay * dispPtr); /* 8 */
+    void (*tkComputeAnchor) (Tk_Anchor anchor, Tk_Window tkwin, int padX, int padY, int innerWidth, int innerHeight, int * xPtr, int * yPtr); /* 9 */
+    int (*tkCopyAndGlobalEval) (Tcl_Interp * interp, char * script); /* 10 */
+    unsigned long (*tkCreateBindingProcedure) (Tcl_Interp * interp, Tk_BindingTable bindingTable, ClientData object, CONST char * eventString, TkBindEvalProc * evalProc, TkBindFreeProc * freeProc, ClientData clientData); /* 11 */
+    TkCursor * (*tkCreateCursorFromData) (Tk_Window tkwin, CONST char * source, CONST char * mask, int width, int height, int xHot, int yHot, XColor fg, XColor bg); /* 12 */
+    int (*tkCreateFrame) (ClientData clientData, Tcl_Interp * interp, int argc, char ** argv, int toplevel, char * appName); /* 13 */
+    Tk_Window (*tkCreateMainWindow) (Tcl_Interp * interp, CONST char * screenName, char * baseName); /* 14 */
+    Time (*tkCurrentTime) (TkDisplay * dispPtr); /* 15 */
+    void (*tkDeleteAllImages) (TkMainInfo * mainPtr); /* 16 */
+    void (*tkDoConfigureNotify) (TkWindow * winPtr); /* 17 */
+    void (*tkDrawInsetFocusHighlight) (Tk_Window tkwin, GC gc, int width, Drawable drawable, int padding); /* 18 */
+    void (*tkEventDeadWindow) (TkWindow * winPtr); /* 19 */
+    void (*tkFillPolygon) (Tk_Canvas canvas, double * coordPtr, int numPoints, Display * display, Drawable drawable, GC gc, GC outlineGC); /* 20 */
+    int (*tkFindStateNum) (Tcl_Interp * interp, CONST char * option, CONST TkStateMap * mapPtr, CONST char * strKey); /* 21 */
+    char * (*tkFindStateString) (CONST TkStateMap * mapPtr, int numKey); /* 22 */
+    void (*tkFocusDeadWindow) (TkWindow * winPtr); /* 23 */
+    int (*tkFocusFilterEvent) (TkWindow * winPtr, XEvent * eventPtr); /* 24 */
+    TkWindow * (*tkFocusKeyEvent) (TkWindow * winPtr, XEvent * eventPtr); /* 25 */
+    void (*tkFontPkgInit) (TkMainInfo * mainPtr); /* 26 */
+    void (*tkFontPkgFree) (TkMainInfo * mainPtr); /* 27 */
+    void (*tkFreeBindingTags) (TkWindow * winPtr); /* 28 */
+    void (*tkpFreeCursor) (TkCursor * cursorPtr); /* 29 */
+    char * (*tkGetBitmapData) (Tcl_Interp * interp, char * string, char * fileName, int * widthPtr, int * heightPtr, int * hotXPtr, int * hotYPtr); /* 30 */
+    void (*tkGetButtPoints) (double p1[], double p2[], double width, int project, double m1[], double m2[]); /* 31 */
+    TkCursor * (*tkGetCursorByName) (Tcl_Interp * interp, Tk_Window tkwin, Tk_Uid string); /* 32 */
+    CONST84_RETURN char * (*tkGetDefaultScreenName) (Tcl_Interp * interp, CONST char * screenName); /* 33 */
+    TkDisplay * (*tkGetDisplay) (Display * display); /* 34 */
+    int (*tkGetDisplayOf) (Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], Tk_Window * tkwinPtr); /* 35 */
+    TkWindow * (*tkGetFocusWin) (TkWindow * winPtr); /* 36 */
+    int (*tkGetInterpNames) (Tcl_Interp * interp, Tk_Window tkwin); /* 37 */
+    int (*tkGetMiterPoints) (double p1[], double p2[], double p3[], double width, double m1[], double m2[]); /* 38 */
+    void (*tkGetPointerCoords) (Tk_Window tkwin, int * xPtr, int * yPtr); /* 39 */
+    void (*tkGetServerInfo) (Tcl_Interp * interp, Tk_Window tkwin); /* 40 */
+    void (*tkGrabDeadWindow) (TkWindow * winPtr); /* 41 */
+    int (*tkGrabState) (TkWindow * winPtr); /* 42 */
+    void (*tkIncludePoint) (Tk_Item * itemPtr, double * pointPtr); /* 43 */
+    void (*tkInOutEvents) (XEvent * eventPtr, TkWindow * sourcePtr, TkWindow * destPtr, int leaveType, int enterType, Tcl_QueuePosition position); /* 44 */
+    void (*tkInstallFrameMenu) (Tk_Window tkwin); /* 45 */
+    char * (*tkKeysymToString) (KeySym keysym); /* 46 */
+    int (*tkLineToArea) (double end1Ptr[], double end2Ptr[], double rectPtr[]); /* 47 */
+    double (*tkLineToPoint) (double end1Ptr[], double end2Ptr[], double pointPtr[]); /* 48 */
+    int (*tkMakeBezierCurve) (Tk_Canvas canvas, double * pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 49 */
+    void (*tkMakeBezierPostscript) (Tcl_Interp * interp, Tk_Canvas canvas, double * pointPtr, int numPoints); /* 50 */
+    void (*tkOptionClassChanged) (TkWindow * winPtr); /* 51 */
+    void (*tkOptionDeadWindow) (TkWindow * winPtr); /* 52 */
+    int (*tkOvalToArea) (double * ovalPtr, double * rectPtr); /* 53 */
+    double (*tkOvalToPoint) (double ovalPtr[], double width, int filled, double pointPtr[]); /* 54 */
+    int (*tkpChangeFocus) (TkWindow * winPtr, int force); /* 55 */
+    void (*tkpCloseDisplay) (TkDisplay * dispPtr); /* 56 */
+    void (*tkpClaimFocus) (TkWindow * topLevelPtr, int force); /* 57 */
+    void (*tkpDisplayWarning) (CONST char * msg, CONST char * title); /* 58 */
+    void (*tkpGetAppName) (Tcl_Interp * interp, Tcl_DString * name); /* 59 */
+    TkWindow * (*tkpGetOtherWindow) (TkWindow * winPtr); /* 60 */
+    TkWindow * (*tkpGetWrapperWindow) (TkWindow * winPtr); /* 61 */
+    int (*tkpInit) (Tcl_Interp * interp); /* 62 */
+    void (*tkpInitializeMenuBindings) (Tcl_Interp * interp, Tk_BindingTable bindingTable); /* 63 */
+    void (*tkpMakeContainer) (Tk_Window tkwin); /* 64 */
+    void (*tkpMakeMenuWindow) (Tk_Window tkwin, int transient); /* 65 */
+    Window (*tkpMakeWindow) (TkWindow * winPtr, Window parent); /* 66 */
+    void (*tkpMenuNotifyToplevelCreate) (Tcl_Interp * interp1, char * menuName); /* 67 */
+    TkDisplay * (*tkpOpenDisplay) (CONST char * display_name); /* 68 */
+    int (*tkPointerEvent) (XEvent * eventPtr, TkWindow * winPtr); /* 69 */
+    int (*tkPolygonToArea) (double * polyPtr, int numPoints, double * rectPtr); /* 70 */
+    double (*tkPolygonToPoint) (double * polyPtr, int numPoints, double * pointPtr); /* 71 */
+    int (*tkPositionInTree) (TkWindow * winPtr, TkWindow * treePtr); /* 72 */
+    void (*tkpRedirectKeyEvent) (TkWindow * winPtr, XEvent * eventPtr); /* 73 */
+    void (*tkpSetMainMenubar) (Tcl_Interp * interp, Tk_Window tkwin, char * menuName); /* 74 */
+    int (*tkpUseWindow) (Tcl_Interp * interp, Tk_Window tkwin, CONST char * string); /* 75 */
+    int (*tkpWindowWasRecentlyDeleted) (Window win, TkDisplay * dispPtr); /* 76 */
+    void (*tkQueueEventForAllChildren) (TkWindow * winPtr, XEvent * eventPtr); /* 77 */
+    int (*tkReadBitmapFile) (Display * display, Drawable d, CONST char * filename, unsigned int * width_return, unsigned int * height_return, Pixmap * bitmap_return, int * x_hot_return, int * y_hot_return); /* 78 */
+    int (*tkScrollWindow) (Tk_Window tkwin, GC gc, int x, int y, int width, int height, int dx, int dy, TkRegion damageRgn); /* 79 */
+    void (*tkSelDeadWindow) (TkWindow * winPtr); /* 80 */
+    void (*tkSelEventProc) (Tk_Window tkwin, XEvent * eventPtr); /* 81 */
+    void (*tkSelInit) (Tk_Window tkwin); /* 82 */
+    void (*tkSelPropProc) (XEvent * eventPtr); /* 83 */
+    void *reserved84;
+    void (*tkSetWindowMenuBar) (Tcl_Interp * interp, Tk_Window tkwin, char * oldMenuName, char * menuName); /* 85 */
+    KeySym (*tkStringToKeysym) (char * name); /* 86 */
+    int (*tkThickPolyLineToArea) (double * coordPtr, int numPoints, double width, int capStyle, int joinStyle, double * rectPtr); /* 87 */
+    void (*tkWmAddToColormapWindows) (TkWindow * winPtr); /* 88 */
+    void (*tkWmDeadWindow) (TkWindow * winPtr); /* 89 */
+    TkWindow * (*tkWmFocusToplevel) (TkWindow * winPtr); /* 90 */
+    void (*tkWmMapWindow) (TkWindow * winPtr); /* 91 */
+    void (*tkWmNewWindow) (TkWindow * winPtr); /* 92 */
+    void (*tkWmProtocolEventProc) (TkWindow * winPtr, XEvent * evenvPtr); /* 93 */
+    void (*tkWmRemoveFromColormapWindows) (TkWindow * winPtr); /* 94 */
+    void (*tkWmRestackToplevel) (TkWindow * winPtr, int aboveBelow, TkWindow * otherPtr); /* 95 */
+    void (*tkWmSetClass) (TkWindow * winPtr); /* 96 */
+    void (*tkWmUnmapWindow) (TkWindow * winPtr); /* 97 */
+    Tcl_Obj * (*tkDebugBitmap) (Tk_Window tkwin, char * name); /* 98 */
+    Tcl_Obj * (*tkDebugBorder) (Tk_Window tkwin, char * name); /* 99 */
+    Tcl_Obj * (*tkDebugCursor) (Tk_Window tkwin, char * name); /* 100 */
+    Tcl_Obj * (*tkDebugColor) (Tk_Window tkwin, char * name); /* 101 */
+    Tcl_Obj * (*tkDebugConfig) (Tcl_Interp * interp, Tk_OptionTable table); /* 102 */
+    Tcl_Obj * (*tkDebugFont) (Tk_Window tkwin, char * name); /* 103 */
+    int (*tkFindStateNumObj) (Tcl_Interp * interp, Tcl_Obj * optionPtr, CONST TkStateMap * mapPtr, Tcl_Obj * keyPtr); /* 104 */
+    Tcl_HashTable * (*tkGetBitmapPredefTable) (void); /* 105 */
+    TkDisplay * (*tkGetDisplayList) (void); /* 106 */
+    TkMainInfo * (*tkGetMainInfoList) (void); /* 107 */
+    int (*tkGetWindowFromObj) (Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr, Tk_Window * windowPtr); /* 108 */
+    char * (*tkpGetString) (TkWindow * winPtr, XEvent * eventPtr, Tcl_DString * dsPtr); /* 109 */
+    void (*tkpGetSubFonts) (Tcl_Interp * interp, Tk_Font tkfont); /* 110 */
+    Tcl_Obj * (*tkpGetSystemDefault) (Tk_Window tkwin, CONST char * dbName, CONST char * className); /* 111 */
+    void (*tkpMenuThreadInit) (void); /* 112 */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved113;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    void (*tkClipBox) (TkRegion rgn, XRectangle * rect_return); /* 113 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved113; /* Dummy entry for stubs table backwards compatibility */
+    void (*tkClipBox) (TkRegion rgn, XRectangle * rect_return); /* 113 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved114;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    TkRegion (*tkCreateRegion) (void); /* 114 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved114; /* Dummy entry for stubs table backwards compatibility */
+    TkRegion (*tkCreateRegion) (void); /* 114 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved115;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    void (*tkDestroyRegion) (TkRegion rgn); /* 115 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved115; /* Dummy entry for stubs table backwards compatibility */
+    void (*tkDestroyRegion) (TkRegion rgn); /* 115 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved116;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    void (*tkIntersectRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 116 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved116; /* Dummy entry for stubs table backwards compatibility */
+    void (*tkIntersectRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 116 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved117;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    int (*tkRectInRegion) (TkRegion rgn, int x, int y, unsigned int width, unsigned int height); /* 117 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved117; /* Dummy entry for stubs table backwards compatibility */
+    int (*tkRectInRegion) (TkRegion rgn, int x, int y, unsigned int width, unsigned int height); /* 117 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved118;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    void (*tkSetRegion) (Display * display, GC gc, TkRegion rgn); /* 118 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved118; /* Dummy entry for stubs table backwards compatibility */
+    void (*tkSetRegion) (Display * display, GC gc, TkRegion rgn); /* 118 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved119;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    void (*tkUnionRectWithRegion) (XRectangle * rect, TkRegion src, TkRegion dr_return); /* 119 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved119; /* Dummy entry for stubs table backwards compatibility */
+    void (*tkUnionRectWithRegion) (XRectangle * rect, TkRegion src, TkRegion dr_return); /* 119 */
+#endif /* AQUA */
+    void *reserved120;
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved121;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    void *reserved121;
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved121; /* Dummy entry for stubs table backwards compatibility */
+    Pixmap (*tkpCreateNativeBitmap) (Display * display, CONST char * source); /* 121 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved122;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    void *reserved122;
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved122; /* Dummy entry for stubs table backwards compatibility */
+    void (*tkpDefineNativeBitmaps) (void); /* 122 */
+#endif /* AQUA */
+    void *reserved123;
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved124;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    void *reserved124;
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved124; /* Dummy entry for stubs table backwards compatibility */
+    Pixmap (*tkpGetNativeAppBitmap) (Display * display, CONST char * name, int * width, int * height); /* 124 */
+#endif /* AQUA */
+    void *reserved125;
+    void *reserved126;
+    void *reserved127;
+    void *reserved128;
+    void *reserved129;
+    void *reserved130;
+    void *reserved131;
+    void *reserved132;
+    void *reserved133;
+    void *reserved134;
+    void (*tkpDrawHighlightBorder) (Tk_Window tkwin, GC fgGC, GC bgGC, int highlightWidth, Drawable drawable); /* 135 */
+    void (*tkSetFocusWin) (TkWindow * winPtr, int force); /* 136 */
+    void (*tkpSetKeycodeAndState) (Tk_Window tkwin, KeySym keySym, XEvent * eventPtr); /* 137 */
+    KeySym (*tkpGetKeySym) (TkDisplay * dispPtr, XEvent * eventPtr); /* 138 */
+    void (*tkpInitKeymapInfo) (TkDisplay * dispPtr); /* 139 */
+    TkRegion (*tkPhotoGetValidRegion) (Tk_PhotoHandle handle); /* 140 */
+    TkWindow ** (*tkWmStackorderToplevel) (TkWindow * parentPtr); /* 141 */
+    void (*tkFocusFree) (TkMainInfo * mainPtr); /* 142 */
+    void (*tkClipCleanup) (TkDisplay * dispPtr); /* 143 */
+    void (*tkGCCleanup) (TkDisplay * dispPtr); /* 144 */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void *reserved145;
+#endif /* X11 */
+#ifdef __WIN32__ /* WIN */
+    void (*tkSubtractRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 145 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void *reserved145; /* Dummy entry for stubs table backwards compatibility */
+    void (*tkSubtractRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 145 */
+#endif /* AQUA */
+    void (*tkStylePkgInit) (TkMainInfo * mainPtr); /* 146 */
+    void (*tkStylePkgFree) (TkMainInfo * mainPtr); /* 147 */
+    Tk_Window (*tkToplevelWindowForCommand) (Tcl_Interp * interp, CONST char * cmdName); /* 148 */
+    CONST Tk_OptionSpec * (*tkGetOptionSpec) (CONST char * name, Tk_OptionTable optionTable); /* 149 */
+    int (*tkMakeRawCurve) (Tk_Canvas canvas, double * pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 150 */
+    void (*tkMakeRawCurvePostscript) (Tcl_Interp * interp, Tk_Canvas canvas, double * pointPtr, int numPoints); /* 151 */
+    void (*tkpDrawFrame) (Tk_Window tkwin, Tk_3DBorder border, int highlightWidth, int borderWidth, int relief); /* 152 */
+    void (*tkCreateThreadExitHandler) (Tcl_ExitProc * proc, ClientData clientData); /* 153 */
+    void (*tkDeleteThreadExitHandler) (Tcl_ExitProc * proc, ClientData clientData); /* 154 */
+    void *reserved155;
+    int (*tkpTestembedCmd) (ClientData clientData, Tcl_Interp * interp, int argc, CONST char ** argv); /* 156 */
+    int (*tkpTesttextCmd) (ClientData dummy, Tcl_Interp * interp, int argc, CONST char ** argv); /* 157 */
+} TkIntStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern TkIntStubs *tkIntStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)
+
+/*
+ * Inline function declarations:
+ */
+
+#ifndef TkAllocWindow
+#define TkAllocWindow \
+	(tkIntStubsPtr->tkAllocWindow) /* 0 */
+#endif
+#ifndef TkBezierPoints
+#define TkBezierPoints \
+	(tkIntStubsPtr->tkBezierPoints) /* 1 */
+#endif
+#ifndef TkBezierScreenPoints
+#define TkBezierScreenPoints \
+	(tkIntStubsPtr->tkBezierScreenPoints) /* 2 */
+#endif
+#ifndef TkBindDeadWindow
+#define TkBindDeadWindow \
+	(tkIntStubsPtr->tkBindDeadWindow) /* 3 */
+#endif
+#ifndef TkBindEventProc
+#define TkBindEventProc \
+	(tkIntStubsPtr->tkBindEventProc) /* 4 */
+#endif
+#ifndef TkBindFree
+#define TkBindFree \
+	(tkIntStubsPtr->tkBindFree) /* 5 */
+#endif
+#ifndef TkBindInit
+#define TkBindInit \
+	(tkIntStubsPtr->tkBindInit) /* 6 */
+#endif
+#ifndef TkChangeEventWindow
+#define TkChangeEventWindow \
+	(tkIntStubsPtr->tkChangeEventWindow) /* 7 */
+#endif
+#ifndef TkClipInit
+#define TkClipInit \
+	(tkIntStubsPtr->tkClipInit) /* 8 */
+#endif
+#ifndef TkComputeAnchor
+#define TkComputeAnchor \
+	(tkIntStubsPtr->tkComputeAnchor) /* 9 */
+#endif
+#ifndef TkCopyAndGlobalEval
+#define TkCopyAndGlobalEval \
+	(tkIntStubsPtr->tkCopyAndGlobalEval) /* 10 */
+#endif
+#ifndef TkCreateBindingProcedure
+#define TkCreateBindingProcedure \
+	(tkIntStubsPtr->tkCreateBindingProcedure) /* 11 */
+#endif
+#ifndef TkCreateCursorFromData
+#define TkCreateCursorFromData \
+	(tkIntStubsPtr->tkCreateCursorFromData) /* 12 */
+#endif
+#ifndef TkCreateFrame
+#define TkCreateFrame \
+	(tkIntStubsPtr->tkCreateFrame) /* 13 */
+#endif
+#ifndef TkCreateMainWindow
+#define TkCreateMainWindow \
+	(tkIntStubsPtr->tkCreateMainWindow) /* 14 */
+#endif
+#ifndef TkCurrentTime
+#define TkCurrentTime \
+	(tkIntStubsPtr->tkCurrentTime) /* 15 */
+#endif
+#ifndef TkDeleteAllImages
+#define TkDeleteAllImages \
+	(tkIntStubsPtr->tkDeleteAllImages) /* 16 */
+#endif
+#ifndef TkDoConfigureNotify
+#define TkDoConfigureNotify \
+	(tkIntStubsPtr->tkDoConfigureNotify) /* 17 */
+#endif
+#ifndef TkDrawInsetFocusHighlight
+#define TkDrawInsetFocusHighlight \
+	(tkIntStubsPtr->tkDrawInsetFocusHighlight) /* 18 */
+#endif
+#ifndef TkEventDeadWindow
+#define TkEventDeadWindow \
+	(tkIntStubsPtr->tkEventDeadWindow) /* 19 */
+#endif
+#ifndef TkFillPolygon
+#define TkFillPolygon \
+	(tkIntStubsPtr->tkFillPolygon) /* 20 */
+#endif
+#ifndef TkFindStateNum
+#define TkFindStateNum \
+	(tkIntStubsPtr->tkFindStateNum) /* 21 */
+#endif
+#ifndef TkFindStateString
+#define TkFindStateString \
+	(tkIntStubsPtr->tkFindStateString) /* 22 */
+#endif
+#ifndef TkFocusDeadWindow
+#define TkFocusDeadWindow \
+	(tkIntStubsPtr->tkFocusDeadWindow) /* 23 */
+#endif
+#ifndef TkFocusFilterEvent
+#define TkFocusFilterEvent \
+	(tkIntStubsPtr->tkFocusFilterEvent) /* 24 */
+#endif
+#ifndef TkFocusKeyEvent
+#define TkFocusKeyEvent \
+	(tkIntStubsPtr->tkFocusKeyEvent) /* 25 */
+#endif
+#ifndef TkFontPkgInit
+#define TkFontPkgInit \
+	(tkIntStubsPtr->tkFontPkgInit) /* 26 */
+#endif
+#ifndef TkFontPkgFree
+#define TkFontPkgFree \
+	(tkIntStubsPtr->tkFontPkgFree) /* 27 */
+#endif
+#ifndef TkFreeBindingTags
+#define TkFreeBindingTags \
+	(tkIntStubsPtr->tkFreeBindingTags) /* 28 */
+#endif
+#ifndef TkpFreeCursor
+#define TkpFreeCursor \
+	(tkIntStubsPtr->tkpFreeCursor) /* 29 */
+#endif
+#ifndef TkGetBitmapData
+#define TkGetBitmapData \
+	(tkIntStubsPtr->tkGetBitmapData) /* 30 */
+#endif
+#ifndef TkGetButtPoints
+#define TkGetButtPoints \
+	(tkIntStubsPtr->tkGetButtPoints) /* 31 */
+#endif
+#ifndef TkGetCursorByName
+#define TkGetCursorByName \
+	(tkIntStubsPtr->tkGetCursorByName) /* 32 */
+#endif
+#ifndef TkGetDefaultScreenName
+#define TkGetDefaultScreenName \
+	(tkIntStubsPtr->tkGetDefaultScreenName) /* 33 */
+#endif
+#ifndef TkGetDisplay
+#define TkGetDisplay \
+	(tkIntStubsPtr->tkGetDisplay) /* 34 */
+#endif
+#ifndef TkGetDisplayOf
+#define TkGetDisplayOf \
+	(tkIntStubsPtr->tkGetDisplayOf) /* 35 */
+#endif
+#ifndef TkGetFocusWin
+#define TkGetFocusWin \
+	(tkIntStubsPtr->tkGetFocusWin) /* 36 */
+#endif
+#ifndef TkGetInterpNames
+#define TkGetInterpNames \
+	(tkIntStubsPtr->tkGetInterpNames) /* 37 */
+#endif
+#ifndef TkGetMiterPoints
+#define TkGetMiterPoints \
+	(tkIntStubsPtr->tkGetMiterPoints) /* 38 */
+#endif
+#ifndef TkGetPointerCoords
+#define TkGetPointerCoords \
+	(tkIntStubsPtr->tkGetPointerCoords) /* 39 */
+#endif
+#ifndef TkGetServerInfo
+#define TkGetServerInfo \
+	(tkIntStubsPtr->tkGetServerInfo) /* 40 */
+#endif
+#ifndef TkGrabDeadWindow
+#define TkGrabDeadWindow \
+	(tkIntStubsPtr->tkGrabDeadWindow) /* 41 */
+#endif
+#ifndef TkGrabState
+#define TkGrabState \
+	(tkIntStubsPtr->tkGrabState) /* 42 */
+#endif
+#ifndef TkIncludePoint
+#define TkIncludePoint \
+	(tkIntStubsPtr->tkIncludePoint) /* 43 */
+#endif
+#ifndef TkInOutEvents
+#define TkInOutEvents \
+	(tkIntStubsPtr->tkInOutEvents) /* 44 */
+#endif
+#ifndef TkInstallFrameMenu
+#define TkInstallFrameMenu \
+	(tkIntStubsPtr->tkInstallFrameMenu) /* 45 */
+#endif
+#ifndef TkKeysymToString
+#define TkKeysymToString \
+	(tkIntStubsPtr->tkKeysymToString) /* 46 */
+#endif
+#ifndef TkLineToArea
+#define TkLineToArea \
+	(tkIntStubsPtr->tkLineToArea) /* 47 */
+#endif
+#ifndef TkLineToPoint
+#define TkLineToPoint \
+	(tkIntStubsPtr->tkLineToPoint) /* 48 */
+#endif
+#ifndef TkMakeBezierCurve
+#define TkMakeBezierCurve \
+	(tkIntStubsPtr->tkMakeBezierCurve) /* 49 */
+#endif
+#ifndef TkMakeBezierPostscript
+#define TkMakeBezierPostscript \
+	(tkIntStubsPtr->tkMakeBezierPostscript) /* 50 */
+#endif
+#ifndef TkOptionClassChanged
+#define TkOptionClassChanged \
+	(tkIntStubsPtr->tkOptionClassChanged) /* 51 */
+#endif
+#ifndef TkOptionDeadWindow
+#define TkOptionDeadWindow \
+	(tkIntStubsPtr->tkOptionDeadWindow) /* 52 */
+#endif
+#ifndef TkOvalToArea
+#define TkOvalToArea \
+	(tkIntStubsPtr->tkOvalToArea) /* 53 */
+#endif
+#ifndef TkOvalToPoint
+#define TkOvalToPoint \
+	(tkIntStubsPtr->tkOvalToPoint) /* 54 */
+#endif
+#ifndef TkpChangeFocus
+#define TkpChangeFocus \
+	(tkIntStubsPtr->tkpChangeFocus) /* 55 */
+#endif
+#ifndef TkpCloseDisplay
+#define TkpCloseDisplay \
+	(tkIntStubsPtr->tkpCloseDisplay) /* 56 */
+#endif
+#ifndef TkpClaimFocus
+#define TkpClaimFocus \
+	(tkIntStubsPtr->tkpClaimFocus) /* 57 */
+#endif
+#ifndef TkpDisplayWarning
+#define TkpDisplayWarning \
+	(tkIntStubsPtr->tkpDisplayWarning) /* 58 */
+#endif
+#ifndef TkpGetAppName
+#define TkpGetAppName \
+	(tkIntStubsPtr->tkpGetAppName) /* 59 */
+#endif
+#ifndef TkpGetOtherWindow
+#define TkpGetOtherWindow \
+	(tkIntStubsPtr->tkpGetOtherWindow) /* 60 */
+#endif
+#ifndef TkpGetWrapperWindow
+#define TkpGetWrapperWindow \
+	(tkIntStubsPtr->tkpGetWrapperWindow) /* 61 */
+#endif
+#ifndef TkpInit
+#define TkpInit \
+	(tkIntStubsPtr->tkpInit) /* 62 */
+#endif
+#ifndef TkpInitializeMenuBindings
+#define TkpInitializeMenuBindings \
+	(tkIntStubsPtr->tkpInitializeMenuBindings) /* 63 */
+#endif
+#ifndef TkpMakeContainer
+#define TkpMakeContainer \
+	(tkIntStubsPtr->tkpMakeContainer) /* 64 */
+#endif
+#ifndef TkpMakeMenuWindow
+#define TkpMakeMenuWindow \
+	(tkIntStubsPtr->tkpMakeMenuWindow) /* 65 */
+#endif
+#ifndef TkpMakeWindow
+#define TkpMakeWindow \
+	(tkIntStubsPtr->tkpMakeWindow) /* 66 */
+#endif
+#ifndef TkpMenuNotifyToplevelCreate
+#define TkpMenuNotifyToplevelCreate \
+	(tkIntStubsPtr->tkpMenuNotifyToplevelCreate) /* 67 */
+#endif
+#ifndef TkpOpenDisplay
+#define TkpOpenDisplay \
+	(tkIntStubsPtr->tkpOpenDisplay) /* 68 */
+#endif
+#ifndef TkPointerEvent
+#define TkPointerEvent \
+	(tkIntStubsPtr->tkPointerEvent) /* 69 */
+#endif
+#ifndef TkPolygonToArea
+#define TkPolygonToArea \
+	(tkIntStubsPtr->tkPolygonToArea) /* 70 */
+#endif
+#ifndef TkPolygonToPoint
+#define TkPolygonToPoint \
+	(tkIntStubsPtr->tkPolygonToPoint) /* 71 */
+#endif
+#ifndef TkPositionInTree
+#define TkPositionInTree \
+	(tkIntStubsPtr->tkPositionInTree) /* 72 */
+#endif
+#ifndef TkpRedirectKeyEvent
+#define TkpRedirectKeyEvent \
+	(tkIntStubsPtr->tkpRedirectKeyEvent) /* 73 */
+#endif
+#ifndef TkpSetMainMenubar
+#define TkpSetMainMenubar \
+	(tkIntStubsPtr->tkpSetMainMenubar) /* 74 */
+#endif
+#ifndef TkpUseWindow
+#define TkpUseWindow \
+	(tkIntStubsPtr->tkpUseWindow) /* 75 */
+#endif
+#ifndef TkpWindowWasRecentlyDeleted
+#define TkpWindowWasRecentlyDeleted \
+	(tkIntStubsPtr->tkpWindowWasRecentlyDeleted) /* 76 */
+#endif
+#ifndef TkQueueEventForAllChildren
+#define TkQueueEventForAllChildren \
+	(tkIntStubsPtr->tkQueueEventForAllChildren) /* 77 */
+#endif
+#ifndef TkReadBitmapFile
+#define TkReadBitmapFile \
+	(tkIntStubsPtr->tkReadBitmapFile) /* 78 */
+#endif
+#ifndef TkScrollWindow
+#define TkScrollWindow \
+	(tkIntStubsPtr->tkScrollWindow) /* 79 */
+#endif
+#ifndef TkSelDeadWindow
+#define TkSelDeadWindow \
+	(tkIntStubsPtr->tkSelDeadWindow) /* 80 */
+#endif
+#ifndef TkSelEventProc
+#define TkSelEventProc \
+	(tkIntStubsPtr->tkSelEventProc) /* 81 */
+#endif
+#ifndef TkSelInit
+#define TkSelInit \
+	(tkIntStubsPtr->tkSelInit) /* 82 */
+#endif
+#ifndef TkSelPropProc
+#define TkSelPropProc \
+	(tkIntStubsPtr->tkSelPropProc) /* 83 */
+#endif
+/* Slot 84 is reserved */
+#ifndef TkSetWindowMenuBar
+#define TkSetWindowMenuBar \
+	(tkIntStubsPtr->tkSetWindowMenuBar) /* 85 */
+#endif
+#ifndef TkStringToKeysym
+#define TkStringToKeysym \
+	(tkIntStubsPtr->tkStringToKeysym) /* 86 */
+#endif
+#ifndef TkThickPolyLineToArea
+#define TkThickPolyLineToArea \
+	(tkIntStubsPtr->tkThickPolyLineToArea) /* 87 */
+#endif
+#ifndef TkWmAddToColormapWindows
+#define TkWmAddToColormapWindows \
+	(tkIntStubsPtr->tkWmAddToColormapWindows) /* 88 */
+#endif
+#ifndef TkWmDeadWindow
+#define TkWmDeadWindow \
+	(tkIntStubsPtr->tkWmDeadWindow) /* 89 */
+#endif
+#ifndef TkWmFocusToplevel
+#define TkWmFocusToplevel \
+	(tkIntStubsPtr->tkWmFocusToplevel) /* 90 */
+#endif
+#ifndef TkWmMapWindow
+#define TkWmMapWindow \
+	(tkIntStubsPtr->tkWmMapWindow) /* 91 */
+#endif
+#ifndef TkWmNewWindow
+#define TkWmNewWindow \
+	(tkIntStubsPtr->tkWmNewWindow) /* 92 */
+#endif
+#ifndef TkWmProtocolEventProc
+#define TkWmProtocolEventProc \
+	(tkIntStubsPtr->tkWmProtocolEventProc) /* 93 */
+#endif
+#ifndef TkWmRemoveFromColormapWindows
+#define TkWmRemoveFromColormapWindows \
+	(tkIntStubsPtr->tkWmRemoveFromColormapWindows) /* 94 */
+#endif
+#ifndef TkWmRestackToplevel
+#define TkWmRestackToplevel \
+	(tkIntStubsPtr->tkWmRestackToplevel) /* 95 */
+#endif
+#ifndef TkWmSetClass
+#define TkWmSetClass \
+	(tkIntStubsPtr->tkWmSetClass) /* 96 */
+#endif
+#ifndef TkWmUnmapWindow
+#define TkWmUnmapWindow \
+	(tkIntStubsPtr->tkWmUnmapWindow) /* 97 */
+#endif
+#ifndef TkDebugBitmap
+#define TkDebugBitmap \
+	(tkIntStubsPtr->tkDebugBitmap) /* 98 */
+#endif
+#ifndef TkDebugBorder
+#define TkDebugBorder \
+	(tkIntStubsPtr->tkDebugBorder) /* 99 */
+#endif
+#ifndef TkDebugCursor
+#define TkDebugCursor \
+	(tkIntStubsPtr->tkDebugCursor) /* 100 */
+#endif
+#ifndef TkDebugColor
+#define TkDebugColor \
+	(tkIntStubsPtr->tkDebugColor) /* 101 */
+#endif
+#ifndef TkDebugConfig
+#define TkDebugConfig \
+	(tkIntStubsPtr->tkDebugConfig) /* 102 */
+#endif
+#ifndef TkDebugFont
+#define TkDebugFont \
+	(tkIntStubsPtr->tkDebugFont) /* 103 */
+#endif
+#ifndef TkFindStateNumObj
+#define TkFindStateNumObj \
+	(tkIntStubsPtr->tkFindStateNumObj) /* 104 */
+#endif
+#ifndef TkGetBitmapPredefTable
+#define TkGetBitmapPredefTable \
+	(tkIntStubsPtr->tkGetBitmapPredefTable) /* 105 */
+#endif
+#ifndef TkGetDisplayList
+#define TkGetDisplayList \
+	(tkIntStubsPtr->tkGetDisplayList) /* 106 */
+#endif
+#ifndef TkGetMainInfoList
+#define TkGetMainInfoList \
+	(tkIntStubsPtr->tkGetMainInfoList) /* 107 */
+#endif
+#ifndef TkGetWindowFromObj
+#define TkGetWindowFromObj \
+	(tkIntStubsPtr->tkGetWindowFromObj) /* 108 */
+#endif
+#ifndef TkpGetString
+#define TkpGetString \
+	(tkIntStubsPtr->tkpGetString) /* 109 */
+#endif
+#ifndef TkpGetSubFonts
+#define TkpGetSubFonts \
+	(tkIntStubsPtr->tkpGetSubFonts) /* 110 */
+#endif
+#ifndef TkpGetSystemDefault
+#define TkpGetSystemDefault \
+	(tkIntStubsPtr->tkpGetSystemDefault) /* 111 */
+#endif
+#ifndef TkpMenuThreadInit
+#define TkpMenuThreadInit \
+	(tkIntStubsPtr->tkpMenuThreadInit) /* 112 */
+#endif
+#ifdef __WIN32__ /* WIN */
+#ifndef TkClipBox
+#define TkClipBox \
+	(tkIntStubsPtr->tkClipBox) /* 113 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkClipBox
+#define TkClipBox \
+	(tkIntStubsPtr->tkClipBox) /* 113 */
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkCreateRegion
+#define TkCreateRegion \
+	(tkIntStubsPtr->tkCreateRegion) /* 114 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkCreateRegion
+#define TkCreateRegion \
+	(tkIntStubsPtr->tkCreateRegion) /* 114 */
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkDestroyRegion
+#define TkDestroyRegion \
+	(tkIntStubsPtr->tkDestroyRegion) /* 115 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkDestroyRegion
+#define TkDestroyRegion \
+	(tkIntStubsPtr->tkDestroyRegion) /* 115 */
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkIntersectRegion
+#define TkIntersectRegion \
+	(tkIntStubsPtr->tkIntersectRegion) /* 116 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkIntersectRegion
+#define TkIntersectRegion \
+	(tkIntStubsPtr->tkIntersectRegion) /* 116 */
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkRectInRegion
+#define TkRectInRegion \
+	(tkIntStubsPtr->tkRectInRegion) /* 117 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkRectInRegion
+#define TkRectInRegion \
+	(tkIntStubsPtr->tkRectInRegion) /* 117 */
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkSetRegion
+#define TkSetRegion \
+	(tkIntStubsPtr->tkSetRegion) /* 118 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkSetRegion
+#define TkSetRegion \
+	(tkIntStubsPtr->tkSetRegion) /* 118 */
+#endif
+#endif /* AQUA */
+#ifdef __WIN32__ /* WIN */
+#ifndef TkUnionRectWithRegion
+#define TkUnionRectWithRegion \
+	(tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkUnionRectWithRegion
+#define TkUnionRectWithRegion \
+	(tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
+#endif
+#endif /* AQUA */
+/* Slot 120 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkpCreateNativeBitmap
+#define TkpCreateNativeBitmap \
+	(tkIntStubsPtr->tkpCreateNativeBitmap) /* 121 */
+#endif
+#endif /* AQUA */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkpDefineNativeBitmaps
+#define TkpDefineNativeBitmaps \
+	(tkIntStubsPtr->tkpDefineNativeBitmaps) /* 122 */
+#endif
+#endif /* AQUA */
+/* Slot 123 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkpGetNativeAppBitmap
+#define TkpGetNativeAppBitmap \
+	(tkIntStubsPtr->tkpGetNativeAppBitmap) /* 124 */
+#endif
+#endif /* AQUA */
+/* Slot 125 is reserved */
+/* Slot 126 is reserved */
+/* Slot 127 is reserved */
+/* Slot 128 is reserved */
+/* Slot 129 is reserved */
+/* Slot 130 is reserved */
+/* Slot 131 is reserved */
+/* Slot 132 is reserved */
+/* Slot 133 is reserved */
+/* Slot 134 is reserved */
+#ifndef TkpDrawHighlightBorder
+#define TkpDrawHighlightBorder \
+	(tkIntStubsPtr->tkpDrawHighlightBorder) /* 135 */
+#endif
+#ifndef TkSetFocusWin
+#define TkSetFocusWin \
+	(tkIntStubsPtr->tkSetFocusWin) /* 136 */
+#endif
+#ifndef TkpSetKeycodeAndState
+#define TkpSetKeycodeAndState \
+	(tkIntStubsPtr->tkpSetKeycodeAndState) /* 137 */
+#endif
+#ifndef TkpGetKeySym
+#define TkpGetKeySym \
+	(tkIntStubsPtr->tkpGetKeySym) /* 138 */
+#endif
+#ifndef TkpInitKeymapInfo
+#define TkpInitKeymapInfo \
+	(tkIntStubsPtr->tkpInitKeymapInfo) /* 139 */
+#endif
+#ifndef TkPhotoGetValidRegion
+#define TkPhotoGetValidRegion \
+	(tkIntStubsPtr->tkPhotoGetValidRegion) /* 140 */
+#endif
+#ifndef TkWmStackorderToplevel
+#define TkWmStackorderToplevel \
+	(tkIntStubsPtr->tkWmStackorderToplevel) /* 141 */
+#endif
+#ifndef TkFocusFree
+#define TkFocusFree \
+	(tkIntStubsPtr->tkFocusFree) /* 142 */
+#endif
+#ifndef TkClipCleanup
+#define TkClipCleanup \
+	(tkIntStubsPtr->tkClipCleanup) /* 143 */
+#endif
+#ifndef TkGCCleanup
+#define TkGCCleanup \
+	(tkIntStubsPtr->tkGCCleanup) /* 144 */
+#endif
+#ifdef __WIN32__ /* WIN */
+#ifndef TkSubtractRegion
+#define TkSubtractRegion \
+	(tkIntStubsPtr->tkSubtractRegion) /* 145 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkSubtractRegion
+#define TkSubtractRegion \
+	(tkIntStubsPtr->tkSubtractRegion) /* 145 */
+#endif
+#endif /* AQUA */
+#ifndef TkStylePkgInit
+#define TkStylePkgInit \
+	(tkIntStubsPtr->tkStylePkgInit) /* 146 */
+#endif
+#ifndef TkStylePkgFree
+#define TkStylePkgFree \
+	(tkIntStubsPtr->tkStylePkgFree) /* 147 */
+#endif
+#ifndef TkToplevelWindowForCommand
+#define TkToplevelWindowForCommand \
+	(tkIntStubsPtr->tkToplevelWindowForCommand) /* 148 */
+#endif
+#ifndef TkGetOptionSpec
+#define TkGetOptionSpec \
+	(tkIntStubsPtr->tkGetOptionSpec) /* 149 */
+#endif
+#ifndef TkMakeRawCurve
+#define TkMakeRawCurve \
+	(tkIntStubsPtr->tkMakeRawCurve) /* 150 */
+#endif
+#ifndef TkMakeRawCurvePostscript
+#define TkMakeRawCurvePostscript \
+	(tkIntStubsPtr->tkMakeRawCurvePostscript) /* 151 */
+#endif
+#ifndef TkpDrawFrame
+#define TkpDrawFrame \
+	(tkIntStubsPtr->tkpDrawFrame) /* 152 */
+#endif
+#ifndef TkCreateThreadExitHandler
+#define TkCreateThreadExitHandler \
+	(tkIntStubsPtr->tkCreateThreadExitHandler) /* 153 */
+#endif
+#ifndef TkDeleteThreadExitHandler
+#define TkDeleteThreadExitHandler \
+	(tkIntStubsPtr->tkDeleteThreadExitHandler) /* 154 */
+#endif
+/* Slot 155 is reserved */
+#ifndef TkpTestembedCmd
+#define TkpTestembedCmd \
+	(tkIntStubsPtr->tkpTestembedCmd) /* 156 */
+#endif
+#ifndef TkpTesttextCmd
+#define TkpTesttextCmd \
+	(tkIntStubsPtr->tkpTesttextCmd) /* 157 */
+#endif
+
+#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TKINTDECLS */
+
Index: src/tktext/tk8.5/tkIntPlatDecls.h
===================================================================
--- src/tktext/tk8.5/tkIntPlatDecls.h	(revision 0)
+++ src/tktext/tk8.5/tkIntPlatDecls.h	(working copy)
@@ -0,0 +1,1097 @@
+/*
+ * tkIntPlatDecls.h --
+ *
+ *	This file contains the declarations for all platform dependent
+ *	unsupported functions that are exported by the Tk library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ * All rights reserved.
+ *
+ * RCS: @(#) $Id: tkIntPlatDecls.h,v 1.29.2.2 2010/02/07 23:24:13 nijtmans Exp $
+ */
+
+#ifndef _TKINTPLATDECLS
+#define _TKINTPLATDECLS
+
+#ifdef BUILD_tk
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tkInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+#ifdef __WIN32__ /* WIN */
+#ifndef TkAlignImageData_TCL_DECLARED
+#define TkAlignImageData_TCL_DECLARED
+/* 0 */
+EXTERN char *		TkAlignImageData(XImage *image, int alignment,
+				int bitOrder);
+#endif
+/* Slot 1 is reserved */
+#ifndef TkGenerateActivateEvents_TCL_DECLARED
+#define TkGenerateActivateEvents_TCL_DECLARED
+/* 2 */
+EXTERN void		TkGenerateActivateEvents(TkWindow *winPtr,
+				int active);
+#endif
+#ifndef TkpGetMS_TCL_DECLARED
+#define TkpGetMS_TCL_DECLARED
+/* 3 */
+EXTERN unsigned long	TkpGetMS(void);
+#endif
+#ifndef TkPointerDeadWindow_TCL_DECLARED
+#define TkPointerDeadWindow_TCL_DECLARED
+/* 4 */
+EXTERN void		TkPointerDeadWindow(TkWindow *winPtr);
+#endif
+#ifndef TkpPrintWindowId_TCL_DECLARED
+#define TkpPrintWindowId_TCL_DECLARED
+/* 5 */
+EXTERN void		TkpPrintWindowId(char *buf, Window window);
+#endif
+#ifndef TkpScanWindowId_TCL_DECLARED
+#define TkpScanWindowId_TCL_DECLARED
+/* 6 */
+EXTERN int		TkpScanWindowId(Tcl_Interp *interp,
+				CONST char *string, Window *idPtr);
+#endif
+#ifndef TkpSetCapture_TCL_DECLARED
+#define TkpSetCapture_TCL_DECLARED
+/* 7 */
+EXTERN void		TkpSetCapture(TkWindow *winPtr);
+#endif
+#ifndef TkpSetCursor_TCL_DECLARED
+#define TkpSetCursor_TCL_DECLARED
+/* 8 */
+EXTERN void		TkpSetCursor(TkpCursor cursor);
+#endif
+#ifndef TkpWmSetState_TCL_DECLARED
+#define TkpWmSetState_TCL_DECLARED
+/* 9 */
+EXTERN void		TkpWmSetState(TkWindow *winPtr, int state);
+#endif
+#ifndef TkSetPixmapColormap_TCL_DECLARED
+#define TkSetPixmapColormap_TCL_DECLARED
+/* 10 */
+EXTERN void		TkSetPixmapColormap(Pixmap pixmap, Colormap colormap);
+#endif
+#ifndef TkWinCancelMouseTimer_TCL_DECLARED
+#define TkWinCancelMouseTimer_TCL_DECLARED
+/* 11 */
+EXTERN void		TkWinCancelMouseTimer(void);
+#endif
+#ifndef TkWinClipboardRender_TCL_DECLARED
+#define TkWinClipboardRender_TCL_DECLARED
+/* 12 */
+EXTERN void		TkWinClipboardRender(TkDisplay *dispPtr, UINT format);
+#endif
+#ifndef TkWinEmbeddedEventProc_TCL_DECLARED
+#define TkWinEmbeddedEventProc_TCL_DECLARED
+/* 13 */
+EXTERN LRESULT		TkWinEmbeddedEventProc(HWND hwnd, UINT message,
+				WPARAM wParam, LPARAM lParam);
+#endif
+#ifndef TkWinFillRect_TCL_DECLARED
+#define TkWinFillRect_TCL_DECLARED
+/* 14 */
+EXTERN void		TkWinFillRect(HDC dc, int x, int y, int width,
+				int height, int pixel);
+#endif
+#ifndef TkWinGetBorderPixels_TCL_DECLARED
+#define TkWinGetBorderPixels_TCL_DECLARED
+/* 15 */
+EXTERN COLORREF		TkWinGetBorderPixels(Tk_Window tkwin,
+				Tk_3DBorder border, int which);
+#endif
+#ifndef TkWinGetDrawableDC_TCL_DECLARED
+#define TkWinGetDrawableDC_TCL_DECLARED
+/* 16 */
+EXTERN HDC		TkWinGetDrawableDC(Display *display, Drawable d,
+				TkWinDCState *state);
+#endif
+#ifndef TkWinGetModifierState_TCL_DECLARED
+#define TkWinGetModifierState_TCL_DECLARED
+/* 17 */
+EXTERN int		TkWinGetModifierState(void);
+#endif
+#ifndef TkWinGetSystemPalette_TCL_DECLARED
+#define TkWinGetSystemPalette_TCL_DECLARED
+/* 18 */
+EXTERN HPALETTE		TkWinGetSystemPalette(void);
+#endif
+#ifndef TkWinGetWrapperWindow_TCL_DECLARED
+#define TkWinGetWrapperWindow_TCL_DECLARED
+/* 19 */
+EXTERN HWND		TkWinGetWrapperWindow(Tk_Window tkwin);
+#endif
+#ifndef TkWinHandleMenuEvent_TCL_DECLARED
+#define TkWinHandleMenuEvent_TCL_DECLARED
+/* 20 */
+EXTERN int		TkWinHandleMenuEvent(HWND *phwnd, UINT *pMessage,
+				WPARAM *pwParam, LPARAM *plParam,
+				LRESULT *plResult);
+#endif
+#ifndef TkWinIndexOfColor_TCL_DECLARED
+#define TkWinIndexOfColor_TCL_DECLARED
+/* 21 */
+EXTERN int		TkWinIndexOfColor(XColor *colorPtr);
+#endif
+#ifndef TkWinReleaseDrawableDC_TCL_DECLARED
+#define TkWinReleaseDrawableDC_TCL_DECLARED
+/* 22 */
+EXTERN void		TkWinReleaseDrawableDC(Drawable d, HDC hdc,
+				TkWinDCState *state);
+#endif
+#ifndef TkWinResendEvent_TCL_DECLARED
+#define TkWinResendEvent_TCL_DECLARED
+/* 23 */
+EXTERN LRESULT		TkWinResendEvent(WNDPROC wndproc, HWND hwnd,
+				XEvent *eventPtr);
+#endif
+#ifndef TkWinSelectPalette_TCL_DECLARED
+#define TkWinSelectPalette_TCL_DECLARED
+/* 24 */
+EXTERN HPALETTE		TkWinSelectPalette(HDC dc, Colormap colormap);
+#endif
+#ifndef TkWinSetMenu_TCL_DECLARED
+#define TkWinSetMenu_TCL_DECLARED
+/* 25 */
+EXTERN void		TkWinSetMenu(Tk_Window tkwin, HMENU hMenu);
+#endif
+#ifndef TkWinSetWindowPos_TCL_DECLARED
+#define TkWinSetWindowPos_TCL_DECLARED
+/* 26 */
+EXTERN void		TkWinSetWindowPos(HWND hwnd, HWND siblingHwnd,
+				int pos);
+#endif
+#ifndef TkWinWmCleanup_TCL_DECLARED
+#define TkWinWmCleanup_TCL_DECLARED
+/* 27 */
+EXTERN void		TkWinWmCleanup(HINSTANCE hInstance);
+#endif
+#ifndef TkWinXCleanup_TCL_DECLARED
+#define TkWinXCleanup_TCL_DECLARED
+/* 28 */
+EXTERN void		TkWinXCleanup(ClientData clientData);
+#endif
+#ifndef TkWinXInit_TCL_DECLARED
+#define TkWinXInit_TCL_DECLARED
+/* 29 */
+EXTERN void		TkWinXInit(HINSTANCE hInstance);
+#endif
+#ifndef TkWinSetForegroundWindow_TCL_DECLARED
+#define TkWinSetForegroundWindow_TCL_DECLARED
+/* 30 */
+EXTERN void		TkWinSetForegroundWindow(TkWindow *winPtr);
+#endif
+#ifndef TkWinDialogDebug_TCL_DECLARED
+#define TkWinDialogDebug_TCL_DECLARED
+/* 31 */
+EXTERN void		TkWinDialogDebug(int debug);
+#endif
+#ifndef TkWinGetMenuSystemDefault_TCL_DECLARED
+#define TkWinGetMenuSystemDefault_TCL_DECLARED
+/* 32 */
+EXTERN Tcl_Obj *	TkWinGetMenuSystemDefault(Tk_Window tkwin,
+				CONST char *dbName, CONST char *className);
+#endif
+#ifndef TkWinGetPlatformId_TCL_DECLARED
+#define TkWinGetPlatformId_TCL_DECLARED
+/* 33 */
+EXTERN int		TkWinGetPlatformId(void);
+#endif
+#ifndef TkWinSetHINSTANCE_TCL_DECLARED
+#define TkWinSetHINSTANCE_TCL_DECLARED
+/* 34 */
+EXTERN void		TkWinSetHINSTANCE(HINSTANCE hInstance);
+#endif
+#ifndef TkWinGetPlatformTheme_TCL_DECLARED
+#define TkWinGetPlatformTheme_TCL_DECLARED
+/* 35 */
+EXTERN int		TkWinGetPlatformTheme(void);
+#endif
+#ifndef TkWinChildProc_TCL_DECLARED
+#define TkWinChildProc_TCL_DECLARED
+/* 36 */
+EXTERN LRESULT CALLBACK	 TkWinChildProc(HWND hwnd, UINT message,
+				WPARAM wParam, LPARAM lParam);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkGenerateActivateEvents_TCL_DECLARED
+#define TkGenerateActivateEvents_TCL_DECLARED
+/* 0 */
+EXTERN void		TkGenerateActivateEvents(TkWindow *winPtr,
+				int active);
+#endif
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+#ifndef TkPointerDeadWindow_TCL_DECLARED
+#define TkPointerDeadWindow_TCL_DECLARED
+/* 3 */
+EXTERN void		TkPointerDeadWindow(TkWindow *winPtr);
+#endif
+#ifndef TkpSetCapture_TCL_DECLARED
+#define TkpSetCapture_TCL_DECLARED
+/* 4 */
+EXTERN void		TkpSetCapture(TkWindow *winPtr);
+#endif
+#ifndef TkpSetCursor_TCL_DECLARED
+#define TkpSetCursor_TCL_DECLARED
+/* 5 */
+EXTERN void		TkpSetCursor(TkpCursor cursor);
+#endif
+#ifndef TkpWmSetState_TCL_DECLARED
+#define TkpWmSetState_TCL_DECLARED
+/* 6 */
+EXTERN void		TkpWmSetState(TkWindow *winPtr, int state);
+#endif
+#ifndef TkAboutDlg_TCL_DECLARED
+#define TkAboutDlg_TCL_DECLARED
+/* 7 */
+EXTERN void		TkAboutDlg(void);
+#endif
+#ifndef TkMacOSXButtonKeyState_TCL_DECLARED
+#define TkMacOSXButtonKeyState_TCL_DECLARED
+/* 8 */
+EXTERN unsigned int	TkMacOSXButtonKeyState(void);
+#endif
+#ifndef TkMacOSXClearMenubarActive_TCL_DECLARED
+#define TkMacOSXClearMenubarActive_TCL_DECLARED
+/* 9 */
+EXTERN void		TkMacOSXClearMenubarActive(void);
+#endif
+#ifndef TkMacOSXDispatchMenuEvent_TCL_DECLARED
+#define TkMacOSXDispatchMenuEvent_TCL_DECLARED
+/* 10 */
+EXTERN int		TkMacOSXDispatchMenuEvent(int menuID, int index);
+#endif
+#ifndef TkMacOSXInstallCursor_TCL_DECLARED
+#define TkMacOSXInstallCursor_TCL_DECLARED
+/* 11 */
+EXTERN void		TkMacOSXInstallCursor(int resizeOverride);
+#endif
+#ifndef TkMacOSXHandleTearoffMenu_TCL_DECLARED
+#define TkMacOSXHandleTearoffMenu_TCL_DECLARED
+/* 12 */
+EXTERN void		TkMacOSXHandleTearoffMenu(void);
+#endif
+/* Slot 13 is reserved */
+#ifndef TkMacOSXDoHLEvent_TCL_DECLARED
+#define TkMacOSXDoHLEvent_TCL_DECLARED
+/* 14 */
+EXTERN int		TkMacOSXDoHLEvent(EventRecord *theEvent);
+#endif
+/* Slot 15 is reserved */
+#ifndef TkMacOSXGetXWindow_TCL_DECLARED
+#define TkMacOSXGetXWindow_TCL_DECLARED
+/* 16 */
+EXTERN Window		TkMacOSXGetXWindow(WindowRef macWinPtr);
+#endif
+#ifndef TkMacOSXGrowToplevel_TCL_DECLARED
+#define TkMacOSXGrowToplevel_TCL_DECLARED
+/* 17 */
+EXTERN int		TkMacOSXGrowToplevel(WindowRef whichWindow,
+				Point start);
+#endif
+#ifndef TkMacOSXHandleMenuSelect_TCL_DECLARED
+#define TkMacOSXHandleMenuSelect_TCL_DECLARED
+/* 18 */
+EXTERN void		TkMacOSXHandleMenuSelect(MenuID theMenu,
+				MenuItemIndex theItem, int optionKeyPressed);
+#endif
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+#ifndef TkMacOSXInvalidateWindow_TCL_DECLARED
+#define TkMacOSXInvalidateWindow_TCL_DECLARED
+/* 21 */
+EXTERN void		TkMacOSXInvalidateWindow(MacDrawable *macWin,
+				int flag);
+#endif
+#ifndef TkMacOSXIsCharacterMissing_TCL_DECLARED
+#define TkMacOSXIsCharacterMissing_TCL_DECLARED
+/* 22 */
+EXTERN int		TkMacOSXIsCharacterMissing(Tk_Font tkfont,
+				unsigned int searchChar);
+#endif
+#ifndef TkMacOSXMakeRealWindowExist_TCL_DECLARED
+#define TkMacOSXMakeRealWindowExist_TCL_DECLARED
+/* 23 */
+EXTERN void		TkMacOSXMakeRealWindowExist(TkWindow *winPtr);
+#endif
+#ifndef TkMacOSXMakeStippleMap_TCL_DECLARED
+#define TkMacOSXMakeStippleMap_TCL_DECLARED
+/* 24 */
+EXTERN BitMapPtr	TkMacOSXMakeStippleMap(Drawable d1, Drawable d2);
+#endif
+#ifndef TkMacOSXMenuClick_TCL_DECLARED
+#define TkMacOSXMenuClick_TCL_DECLARED
+/* 25 */
+EXTERN void		TkMacOSXMenuClick(void);
+#endif
+#ifndef TkMacOSXRegisterOffScreenWindow_TCL_DECLARED
+#define TkMacOSXRegisterOffScreenWindow_TCL_DECLARED
+/* 26 */
+EXTERN void		TkMacOSXRegisterOffScreenWindow(Window window,
+				GWorldPtr portPtr);
+#endif
+#ifndef TkMacOSXResizable_TCL_DECLARED
+#define TkMacOSXResizable_TCL_DECLARED
+/* 27 */
+EXTERN int		TkMacOSXResizable(TkWindow *winPtr);
+#endif
+#ifndef TkMacOSXSetHelpMenuItemCount_TCL_DECLARED
+#define TkMacOSXSetHelpMenuItemCount_TCL_DECLARED
+/* 28 */
+EXTERN void		TkMacOSXSetHelpMenuItemCount(void);
+#endif
+#ifndef TkMacOSXSetScrollbarGrow_TCL_DECLARED
+#define TkMacOSXSetScrollbarGrow_TCL_DECLARED
+/* 29 */
+EXTERN void		TkMacOSXSetScrollbarGrow(TkWindow *winPtr, int flag);
+#endif
+#ifndef TkMacOSXSetUpClippingRgn_TCL_DECLARED
+#define TkMacOSXSetUpClippingRgn_TCL_DECLARED
+/* 30 */
+EXTERN void		TkMacOSXSetUpClippingRgn(Drawable drawable);
+#endif
+#ifndef TkMacOSXSetUpGraphicsPort_TCL_DECLARED
+#define TkMacOSXSetUpGraphicsPort_TCL_DECLARED
+/* 31 */
+EXTERN void		TkMacOSXSetUpGraphicsPort(GC gc, GWorldPtr destPort);
+#endif
+#ifndef TkMacOSXUpdateClipRgn_TCL_DECLARED
+#define TkMacOSXUpdateClipRgn_TCL_DECLARED
+/* 32 */
+EXTERN void		TkMacOSXUpdateClipRgn(TkWindow *winPtr);
+#endif
+#ifndef TkMacOSXUnregisterMacWindow_TCL_DECLARED
+#define TkMacOSXUnregisterMacWindow_TCL_DECLARED
+/* 33 */
+EXTERN void		TkMacOSXUnregisterMacWindow(WindowRef portPtr);
+#endif
+#ifndef TkMacOSXUseMenuID_TCL_DECLARED
+#define TkMacOSXUseMenuID_TCL_DECLARED
+/* 34 */
+EXTERN int		TkMacOSXUseMenuID(short macID);
+#endif
+#ifndef TkMacOSXVisableClipRgn_TCL_DECLARED
+#define TkMacOSXVisableClipRgn_TCL_DECLARED
+/* 35 */
+EXTERN RgnHandle	TkMacOSXVisableClipRgn(TkWindow *winPtr);
+#endif
+#ifndef TkMacOSXWinBounds_TCL_DECLARED
+#define TkMacOSXWinBounds_TCL_DECLARED
+/* 36 */
+EXTERN void		TkMacOSXWinBounds(TkWindow *winPtr, Rect *geometry);
+#endif
+#ifndef TkMacOSXWindowOffset_TCL_DECLARED
+#define TkMacOSXWindowOffset_TCL_DECLARED
+/* 37 */
+EXTERN void		TkMacOSXWindowOffset(WindowRef wRef, int *xOffset,
+				int *yOffset);
+#endif
+#ifndef TkSetMacColor_TCL_DECLARED
+#define TkSetMacColor_TCL_DECLARED
+/* 38 */
+EXTERN int		TkSetMacColor(unsigned long pixel,
+				RGBColor *macColor);
+#endif
+#ifndef TkSetWMName_TCL_DECLARED
+#define TkSetWMName_TCL_DECLARED
+/* 39 */
+EXTERN void		TkSetWMName(TkWindow *winPtr, Tk_Uid titleUid);
+#endif
+#ifndef TkSuspendClipboard_TCL_DECLARED
+#define TkSuspendClipboard_TCL_DECLARED
+/* 40 */
+EXTERN void		TkSuspendClipboard(void);
+#endif
+#ifndef TkMacOSXZoomToplevel_TCL_DECLARED
+#define TkMacOSXZoomToplevel_TCL_DECLARED
+/* 41 */
+EXTERN int		TkMacOSXZoomToplevel(WindowPtr whichWindow,
+				short zoomPart);
+#endif
+#ifndef Tk_TopCoordsToWindow_TCL_DECLARED
+#define Tk_TopCoordsToWindow_TCL_DECLARED
+/* 42 */
+EXTERN Tk_Window	Tk_TopCoordsToWindow(Tk_Window tkwin, int rootX,
+				int rootY, int *newX, int *newY);
+#endif
+#ifndef TkMacOSXContainerId_TCL_DECLARED
+#define TkMacOSXContainerId_TCL_DECLARED
+/* 43 */
+EXTERN MacDrawable *	TkMacOSXContainerId(TkWindow *winPtr);
+#endif
+#ifndef TkMacOSXGetHostToplevel_TCL_DECLARED
+#define TkMacOSXGetHostToplevel_TCL_DECLARED
+/* 44 */
+EXTERN MacDrawable *	TkMacOSXGetHostToplevel(TkWindow *winPtr);
+#endif
+#ifndef TkMacOSXPreprocessMenu_TCL_DECLARED
+#define TkMacOSXPreprocessMenu_TCL_DECLARED
+/* 45 */
+EXTERN void		TkMacOSXPreprocessMenu(void);
+#endif
+#ifndef TkpIsWindowFloating_TCL_DECLARED
+#define TkpIsWindowFloating_TCL_DECLARED
+/* 46 */
+EXTERN int		TkpIsWindowFloating(WindowRef window);
+#endif
+#ifndef TkMacOSXGetCapture_TCL_DECLARED
+#define TkMacOSXGetCapture_TCL_DECLARED
+/* 47 */
+EXTERN Tk_Window	TkMacOSXGetCapture(void);
+#endif
+/* Slot 48 is reserved */
+#ifndef TkGetTransientMaster_TCL_DECLARED
+#define TkGetTransientMaster_TCL_DECLARED
+/* 49 */
+EXTERN Window		TkGetTransientMaster(TkWindow *winPtr);
+#endif
+#ifndef TkGenerateButtonEvent_TCL_DECLARED
+#define TkGenerateButtonEvent_TCL_DECLARED
+/* 50 */
+EXTERN int		TkGenerateButtonEvent(int x, int y, Window window,
+				unsigned int state);
+#endif
+#ifndef TkGenWMDestroyEvent_TCL_DECLARED
+#define TkGenWMDestroyEvent_TCL_DECLARED
+/* 51 */
+EXTERN void		TkGenWMDestroyEvent(Tk_Window tkwin);
+#endif
+/* Slot 52 is reserved */
+#ifndef TkpGetMS_TCL_DECLARED
+#define TkpGetMS_TCL_DECLARED
+/* 53 */
+EXTERN unsigned long	TkpGetMS(void);
+#endif
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+#ifndef TkCreateXEventSource_TCL_DECLARED
+#define TkCreateXEventSource_TCL_DECLARED
+/* 0 */
+EXTERN void		TkCreateXEventSource(void);
+#endif
+#ifndef TkFreeWindowId_TCL_DECLARED
+#define TkFreeWindowId_TCL_DECLARED
+/* 1 */
+EXTERN void		TkFreeWindowId(TkDisplay *dispPtr, Window w);
+#endif
+#ifndef TkInitXId_TCL_DECLARED
+#define TkInitXId_TCL_DECLARED
+/* 2 */
+EXTERN void		TkInitXId(TkDisplay *dispPtr);
+#endif
+#ifndef TkpCmapStressed_TCL_DECLARED
+#define TkpCmapStressed_TCL_DECLARED
+/* 3 */
+EXTERN int		TkpCmapStressed(Tk_Window tkwin, Colormap colormap);
+#endif
+#ifndef TkpSync_TCL_DECLARED
+#define TkpSync_TCL_DECLARED
+/* 4 */
+EXTERN void		TkpSync(Display *display);
+#endif
+#ifndef TkUnixContainerId_TCL_DECLARED
+#define TkUnixContainerId_TCL_DECLARED
+/* 5 */
+EXTERN Window		TkUnixContainerId(TkWindow *winPtr);
+#endif
+#ifndef TkUnixDoOneXEvent_TCL_DECLARED
+#define TkUnixDoOneXEvent_TCL_DECLARED
+/* 6 */
+EXTERN int		TkUnixDoOneXEvent(Tcl_Time *timePtr);
+#endif
+#ifndef TkUnixSetMenubar_TCL_DECLARED
+#define TkUnixSetMenubar_TCL_DECLARED
+/* 7 */
+EXTERN void		TkUnixSetMenubar(Tk_Window tkwin, Tk_Window menubar);
+#endif
+#ifndef TkpScanWindowId_TCL_DECLARED
+#define TkpScanWindowId_TCL_DECLARED
+/* 8 */
+EXTERN int		TkpScanWindowId(Tcl_Interp *interp,
+				CONST char *string, Window *idPtr);
+#endif
+#ifndef TkWmCleanup_TCL_DECLARED
+#define TkWmCleanup_TCL_DECLARED
+/* 9 */
+EXTERN void		TkWmCleanup(TkDisplay *dispPtr);
+#endif
+#ifndef TkSendCleanup_TCL_DECLARED
+#define TkSendCleanup_TCL_DECLARED
+/* 10 */
+EXTERN void		TkSendCleanup(TkDisplay *dispPtr);
+#endif
+#ifndef TkFreeXId_TCL_DECLARED
+#define TkFreeXId_TCL_DECLARED
+/* 11 */
+EXTERN void		TkFreeXId(TkDisplay *dispPtr);
+#endif
+#ifndef TkpWmSetState_TCL_DECLARED
+#define TkpWmSetState_TCL_DECLARED
+/* 12 */
+EXTERN int		TkpWmSetState(TkWindow *winPtr, int state);
+#endif
+#ifndef TkpTestsendCmd_TCL_DECLARED
+#define TkpTestsendCmd_TCL_DECLARED
+/* 13 */
+EXTERN int		TkpTestsendCmd(ClientData clientData,
+				Tcl_Interp *interp, int argc,
+				CONST char **argv);
+#endif
+#endif /* X11 */
+
+typedef struct TkIntPlatStubs {
+    int magic;
+    struct TkIntPlatStubHooks *hooks;
+
+#ifdef __WIN32__ /* WIN */
+    char * (*tkAlignImageData) (XImage *image, int alignment, int bitOrder); /* 0 */
+    void *reserved1;
+    void (*tkGenerateActivateEvents) (TkWindow *winPtr, int active); /* 2 */
+    unsigned long (*tkpGetMS) (void); /* 3 */
+    void (*tkPointerDeadWindow) (TkWindow *winPtr); /* 4 */
+    void (*tkpPrintWindowId) (char *buf, Window window); /* 5 */
+    int (*tkpScanWindowId) (Tcl_Interp *interp, CONST char *string, Window *idPtr); /* 6 */
+    void (*tkpSetCapture) (TkWindow *winPtr); /* 7 */
+    void (*tkpSetCursor) (TkpCursor cursor); /* 8 */
+    void (*tkpWmSetState) (TkWindow *winPtr, int state); /* 9 */
+    void (*tkSetPixmapColormap) (Pixmap pixmap, Colormap colormap); /* 10 */
+    void (*tkWinCancelMouseTimer) (void); /* 11 */
+    void (*tkWinClipboardRender) (TkDisplay *dispPtr, UINT format); /* 12 */
+    LRESULT (*tkWinEmbeddedEventProc) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); /* 13 */
+    void (*tkWinFillRect) (HDC dc, int x, int y, int width, int height, int pixel); /* 14 */
+    COLORREF (*tkWinGetBorderPixels) (Tk_Window tkwin, Tk_3DBorder border, int which); /* 15 */
+    HDC (*tkWinGetDrawableDC) (Display *display, Drawable d, TkWinDCState *state); /* 16 */
+    int (*tkWinGetModifierState) (void); /* 17 */
+    HPALETTE (*tkWinGetSystemPalette) (void); /* 18 */
+    HWND (*tkWinGetWrapperWindow) (Tk_Window tkwin); /* 19 */
+    int (*tkWinHandleMenuEvent) (HWND *phwnd, UINT *pMessage, WPARAM *pwParam, LPARAM *plParam, LRESULT *plResult); /* 20 */
+    int (*tkWinIndexOfColor) (XColor *colorPtr); /* 21 */
+    void (*tkWinReleaseDrawableDC) (Drawable d, HDC hdc, TkWinDCState *state); /* 22 */
+    LRESULT (*tkWinResendEvent) (WNDPROC wndproc, HWND hwnd, XEvent *eventPtr); /* 23 */
+    HPALETTE (*tkWinSelectPalette) (HDC dc, Colormap colormap); /* 24 */
+    void (*tkWinSetMenu) (Tk_Window tkwin, HMENU hMenu); /* 25 */
+    void (*tkWinSetWindowPos) (HWND hwnd, HWND siblingHwnd, int pos); /* 26 */
+    void (*tkWinWmCleanup) (HINSTANCE hInstance); /* 27 */
+    void (*tkWinXCleanup) (ClientData clientData); /* 28 */
+    void (*tkWinXInit) (HINSTANCE hInstance); /* 29 */
+    void (*tkWinSetForegroundWindow) (TkWindow *winPtr); /* 30 */
+    void (*tkWinDialogDebug) (int debug); /* 31 */
+    Tcl_Obj * (*tkWinGetMenuSystemDefault) (Tk_Window tkwin, CONST char *dbName, CONST char *className); /* 32 */
+    int (*tkWinGetPlatformId) (void); /* 33 */
+    void (*tkWinSetHINSTANCE) (HINSTANCE hInstance); /* 34 */
+    int (*tkWinGetPlatformTheme) (void); /* 35 */
+    LRESULT (CALLBACK *tkWinChildProc) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); /* 36 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*tkGenerateActivateEvents) (TkWindow *winPtr, int active); /* 0 */
+    void *reserved1;
+    void *reserved2;
+    void (*tkPointerDeadWindow) (TkWindow *winPtr); /* 3 */
+    void (*tkpSetCapture) (TkWindow *winPtr); /* 4 */
+    void (*tkpSetCursor) (TkpCursor cursor); /* 5 */
+    void (*tkpWmSetState) (TkWindow *winPtr, int state); /* 6 */
+    void (*tkAboutDlg) (void); /* 7 */
+    unsigned int (*tkMacOSXButtonKeyState) (void); /* 8 */
+    void (*tkMacOSXClearMenubarActive) (void); /* 9 */
+    int (*tkMacOSXDispatchMenuEvent) (int menuID, int index); /* 10 */
+    void (*tkMacOSXInstallCursor) (int resizeOverride); /* 11 */
+    void (*tkMacOSXHandleTearoffMenu) (void); /* 12 */
+    void *reserved13;
+    int (*tkMacOSXDoHLEvent) (EventRecord *theEvent); /* 14 */
+    void *reserved15;
+    Window (*tkMacOSXGetXWindow) (WindowRef macWinPtr); /* 16 */
+    int (*tkMacOSXGrowToplevel) (WindowRef whichWindow, Point start); /* 17 */
+    void (*tkMacOSXHandleMenuSelect) (MenuID theMenu, MenuItemIndex theItem, int optionKeyPressed); /* 18 */
+    void *reserved19;
+    void *reserved20;
+    void (*tkMacOSXInvalidateWindow) (MacDrawable *macWin, int flag); /* 21 */
+    int (*tkMacOSXIsCharacterMissing) (Tk_Font tkfont, unsigned int searchChar); /* 22 */
+    void (*tkMacOSXMakeRealWindowExist) (TkWindow *winPtr); /* 23 */
+    BitMapPtr (*tkMacOSXMakeStippleMap) (Drawable d1, Drawable d2); /* 24 */
+    void (*tkMacOSXMenuClick) (void); /* 25 */
+    void (*tkMacOSXRegisterOffScreenWindow) (Window window, GWorldPtr portPtr); /* 26 */
+    int (*tkMacOSXResizable) (TkWindow *winPtr); /* 27 */
+    void (*tkMacOSXSetHelpMenuItemCount) (void); /* 28 */
+    void (*tkMacOSXSetScrollbarGrow) (TkWindow *winPtr, int flag); /* 29 */
+    void (*tkMacOSXSetUpClippingRgn) (Drawable drawable); /* 30 */
+    void (*tkMacOSXSetUpGraphicsPort) (GC gc, GWorldPtr destPort); /* 31 */
+    void (*tkMacOSXUpdateClipRgn) (TkWindow *winPtr); /* 32 */
+    void (*tkMacOSXUnregisterMacWindow) (WindowRef portPtr); /* 33 */
+    int (*tkMacOSXUseMenuID) (short macID); /* 34 */
+    RgnHandle (*tkMacOSXVisableClipRgn) (TkWindow *winPtr); /* 35 */
+    void (*tkMacOSXWinBounds) (TkWindow *winPtr, Rect *geometry); /* 36 */
+    void (*tkMacOSXWindowOffset) (WindowRef wRef, int *xOffset, int *yOffset); /* 37 */
+    int (*tkSetMacColor) (unsigned long pixel, RGBColor *macColor); /* 38 */
+    void (*tkSetWMName) (TkWindow *winPtr, Tk_Uid titleUid); /* 39 */
+    void (*tkSuspendClipboard) (void); /* 40 */
+    int (*tkMacOSXZoomToplevel) (WindowPtr whichWindow, short zoomPart); /* 41 */
+    Tk_Window (*tk_TopCoordsToWindow) (Tk_Window tkwin, int rootX, int rootY, int *newX, int *newY); /* 42 */
+    MacDrawable * (*tkMacOSXContainerId) (TkWindow *winPtr); /* 43 */
+    MacDrawable * (*tkMacOSXGetHostToplevel) (TkWindow *winPtr); /* 44 */
+    void (*tkMacOSXPreprocessMenu) (void); /* 45 */
+    int (*tkpIsWindowFloating) (WindowRef window); /* 46 */
+    Tk_Window (*tkMacOSXGetCapture) (void); /* 47 */
+    void *reserved48;
+    Window (*tkGetTransientMaster) (TkWindow *winPtr); /* 49 */
+    int (*tkGenerateButtonEvent) (int x, int y, Window window, unsigned int state); /* 50 */
+    void (*tkGenWMDestroyEvent) (Tk_Window tkwin); /* 51 */
+    void *reserved52;
+    unsigned long (*tkpGetMS) (void); /* 53 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void (*tkCreateXEventSource) (void); /* 0 */
+    void (*tkFreeWindowId) (TkDisplay *dispPtr, Window w); /* 1 */
+    void (*tkInitXId) (TkDisplay *dispPtr); /* 2 */
+    int (*tkpCmapStressed) (Tk_Window tkwin, Colormap colormap); /* 3 */
+    void (*tkpSync) (Display *display); /* 4 */
+    Window (*tkUnixContainerId) (TkWindow *winPtr); /* 5 */
+    int (*tkUnixDoOneXEvent) (Tcl_Time *timePtr); /* 6 */
+    void (*tkUnixSetMenubar) (Tk_Window tkwin, Tk_Window menubar); /* 7 */
+    int (*tkpScanWindowId) (Tcl_Interp *interp, CONST char *string, Window *idPtr); /* 8 */
+    void (*tkWmCleanup) (TkDisplay *dispPtr); /* 9 */
+    void (*tkSendCleanup) (TkDisplay *dispPtr); /* 10 */
+    void (*tkFreeXId) (TkDisplay *dispPtr); /* 11 */
+    int (*tkpWmSetState) (TkWindow *winPtr, int state); /* 12 */
+    int (*tkpTestsendCmd) (ClientData clientData, Tcl_Interp *interp, int argc, CONST char **argv); /* 13 */
+#endif /* X11 */
+} TkIntPlatStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern TkIntPlatStubs *tkIntPlatStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)
+
+/*
+ * Inline function declarations:
+ */
+
+#ifdef __WIN32__ /* WIN */
+#ifndef TkAlignImageData
+#define TkAlignImageData \
+	(tkIntPlatStubsPtr->tkAlignImageData) /* 0 */
+#endif
+/* Slot 1 is reserved */
+#ifndef TkGenerateActivateEvents
+#define TkGenerateActivateEvents \
+	(tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 2 */
+#endif
+#ifndef TkpGetMS
+#define TkpGetMS \
+	(tkIntPlatStubsPtr->tkpGetMS) /* 3 */
+#endif
+#ifndef TkPointerDeadWindow
+#define TkPointerDeadWindow \
+	(tkIntPlatStubsPtr->tkPointerDeadWindow) /* 4 */
+#endif
+#ifndef TkpPrintWindowId
+#define TkpPrintWindowId \
+	(tkIntPlatStubsPtr->tkpPrintWindowId) /* 5 */
+#endif
+#ifndef TkpScanWindowId
+#define TkpScanWindowId \
+	(tkIntPlatStubsPtr->tkpScanWindowId) /* 6 */
+#endif
+#ifndef TkpSetCapture
+#define TkpSetCapture \
+	(tkIntPlatStubsPtr->tkpSetCapture) /* 7 */
+#endif
+#ifndef TkpSetCursor
+#define TkpSetCursor \
+	(tkIntPlatStubsPtr->tkpSetCursor) /* 8 */
+#endif
+#ifndef TkpWmSetState
+#define TkpWmSetState \
+	(tkIntPlatStubsPtr->tkpWmSetState) /* 9 */
+#endif
+#ifndef TkSetPixmapColormap
+#define TkSetPixmapColormap \
+	(tkIntPlatStubsPtr->tkSetPixmapColormap) /* 10 */
+#endif
+#ifndef TkWinCancelMouseTimer
+#define TkWinCancelMouseTimer \
+	(tkIntPlatStubsPtr->tkWinCancelMouseTimer) /* 11 */
+#endif
+#ifndef TkWinClipboardRender
+#define TkWinClipboardRender \
+	(tkIntPlatStubsPtr->tkWinClipboardRender) /* 12 */
+#endif
+#ifndef TkWinEmbeddedEventProc
+#define TkWinEmbeddedEventProc \
+	(tkIntPlatStubsPtr->tkWinEmbeddedEventProc) /* 13 */
+#endif
+#ifndef TkWinFillRect
+#define TkWinFillRect \
+	(tkIntPlatStubsPtr->tkWinFillRect) /* 14 */
+#endif
+#ifndef TkWinGetBorderPixels
+#define TkWinGetBorderPixels \
+	(tkIntPlatStubsPtr->tkWinGetBorderPixels) /* 15 */
+#endif
+#ifndef TkWinGetDrawableDC
+#define TkWinGetDrawableDC \
+	(tkIntPlatStubsPtr->tkWinGetDrawableDC) /* 16 */
+#endif
+#ifndef TkWinGetModifierState
+#define TkWinGetModifierState \
+	(tkIntPlatStubsPtr->tkWinGetModifierState) /* 17 */
+#endif
+#ifndef TkWinGetSystemPalette
+#define TkWinGetSystemPalette \
+	(tkIntPlatStubsPtr->tkWinGetSystemPalette) /* 18 */
+#endif
+#ifndef TkWinGetWrapperWindow
+#define TkWinGetWrapperWindow \
+	(tkIntPlatStubsPtr->tkWinGetWrapperWindow) /* 19 */
+#endif
+#ifndef TkWinHandleMenuEvent
+#define TkWinHandleMenuEvent \
+	(tkIntPlatStubsPtr->tkWinHandleMenuEvent) /* 20 */
+#endif
+#ifndef TkWinIndexOfColor
+#define TkWinIndexOfColor \
+	(tkIntPlatStubsPtr->tkWinIndexOfColor) /* 21 */
+#endif
+#ifndef TkWinReleaseDrawableDC
+#define TkWinReleaseDrawableDC \
+	(tkIntPlatStubsPtr->tkWinReleaseDrawableDC) /* 22 */
+#endif
+#ifndef TkWinResendEvent
+#define TkWinResendEvent \
+	(tkIntPlatStubsPtr->tkWinResendEvent) /* 23 */
+#endif
+#ifndef TkWinSelectPalette
+#define TkWinSelectPalette \
+	(tkIntPlatStubsPtr->tkWinSelectPalette) /* 24 */
+#endif
+#ifndef TkWinSetMenu
+#define TkWinSetMenu \
+	(tkIntPlatStubsPtr->tkWinSetMenu) /* 25 */
+#endif
+#ifndef TkWinSetWindowPos
+#define TkWinSetWindowPos \
+	(tkIntPlatStubsPtr->tkWinSetWindowPos) /* 26 */
+#endif
+#ifndef TkWinWmCleanup
+#define TkWinWmCleanup \
+	(tkIntPlatStubsPtr->tkWinWmCleanup) /* 27 */
+#endif
+#ifndef TkWinXCleanup
+#define TkWinXCleanup \
+	(tkIntPlatStubsPtr->tkWinXCleanup) /* 28 */
+#endif
+#ifndef TkWinXInit
+#define TkWinXInit \
+	(tkIntPlatStubsPtr->tkWinXInit) /* 29 */
+#endif
+#ifndef TkWinSetForegroundWindow
+#define TkWinSetForegroundWindow \
+	(tkIntPlatStubsPtr->tkWinSetForegroundWindow) /* 30 */
+#endif
+#ifndef TkWinDialogDebug
+#define TkWinDialogDebug \
+	(tkIntPlatStubsPtr->tkWinDialogDebug) /* 31 */
+#endif
+#ifndef TkWinGetMenuSystemDefault
+#define TkWinGetMenuSystemDefault \
+	(tkIntPlatStubsPtr->tkWinGetMenuSystemDefault) /* 32 */
+#endif
+#ifndef TkWinGetPlatformId
+#define TkWinGetPlatformId \
+	(tkIntPlatStubsPtr->tkWinGetPlatformId) /* 33 */
+#endif
+#ifndef TkWinSetHINSTANCE
+#define TkWinSetHINSTANCE \
+	(tkIntPlatStubsPtr->tkWinSetHINSTANCE) /* 34 */
+#endif
+#ifndef TkWinGetPlatformTheme
+#define TkWinGetPlatformTheme \
+	(tkIntPlatStubsPtr->tkWinGetPlatformTheme) /* 35 */
+#endif
+#ifndef TkWinChildProc
+#define TkWinChildProc \
+	(tkIntPlatStubsPtr->tkWinChildProc) /* 36 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef TkGenerateActivateEvents
+#define TkGenerateActivateEvents \
+	(tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 0 */
+#endif
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+#ifndef TkPointerDeadWindow
+#define TkPointerDeadWindow \
+	(tkIntPlatStubsPtr->tkPointerDeadWindow) /* 3 */
+#endif
+#ifndef TkpSetCapture
+#define TkpSetCapture \
+	(tkIntPlatStubsPtr->tkpSetCapture) /* 4 */
+#endif
+#ifndef TkpSetCursor
+#define TkpSetCursor \
+	(tkIntPlatStubsPtr->tkpSetCursor) /* 5 */
+#endif
+#ifndef TkpWmSetState
+#define TkpWmSetState \
+	(tkIntPlatStubsPtr->tkpWmSetState) /* 6 */
+#endif
+#ifndef TkAboutDlg
+#define TkAboutDlg \
+	(tkIntPlatStubsPtr->tkAboutDlg) /* 7 */
+#endif
+#ifndef TkMacOSXButtonKeyState
+#define TkMacOSXButtonKeyState \
+	(tkIntPlatStubsPtr->tkMacOSXButtonKeyState) /* 8 */
+#endif
+#ifndef TkMacOSXClearMenubarActive
+#define TkMacOSXClearMenubarActive \
+	(tkIntPlatStubsPtr->tkMacOSXClearMenubarActive) /* 9 */
+#endif
+#ifndef TkMacOSXDispatchMenuEvent
+#define TkMacOSXDispatchMenuEvent \
+	(tkIntPlatStubsPtr->tkMacOSXDispatchMenuEvent) /* 10 */
+#endif
+#ifndef TkMacOSXInstallCursor
+#define TkMacOSXInstallCursor \
+	(tkIntPlatStubsPtr->tkMacOSXInstallCursor) /* 11 */
+#endif
+#ifndef TkMacOSXHandleTearoffMenu
+#define TkMacOSXHandleTearoffMenu \
+	(tkIntPlatStubsPtr->tkMacOSXHandleTearoffMenu) /* 12 */
+#endif
+/* Slot 13 is reserved */
+#ifndef TkMacOSXDoHLEvent
+#define TkMacOSXDoHLEvent \
+	(tkIntPlatStubsPtr->tkMacOSXDoHLEvent) /* 14 */
+#endif
+/* Slot 15 is reserved */
+#ifndef TkMacOSXGetXWindow
+#define TkMacOSXGetXWindow \
+	(tkIntPlatStubsPtr->tkMacOSXGetXWindow) /* 16 */
+#endif
+#ifndef TkMacOSXGrowToplevel
+#define TkMacOSXGrowToplevel \
+	(tkIntPlatStubsPtr->tkMacOSXGrowToplevel) /* 17 */
+#endif
+#ifndef TkMacOSXHandleMenuSelect
+#define TkMacOSXHandleMenuSelect \
+	(tkIntPlatStubsPtr->tkMacOSXHandleMenuSelect) /* 18 */
+#endif
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+#ifndef TkMacOSXInvalidateWindow
+#define TkMacOSXInvalidateWindow \
+	(tkIntPlatStubsPtr->tkMacOSXInvalidateWindow) /* 21 */
+#endif
+#ifndef TkMacOSXIsCharacterMissing
+#define TkMacOSXIsCharacterMissing \
+	(tkIntPlatStubsPtr->tkMacOSXIsCharacterMissing) /* 22 */
+#endif
+#ifndef TkMacOSXMakeRealWindowExist
+#define TkMacOSXMakeRealWindowExist \
+	(tkIntPlatStubsPtr->tkMacOSXMakeRealWindowExist) /* 23 */
+#endif
+#ifndef TkMacOSXMakeStippleMap
+#define TkMacOSXMakeStippleMap \
+	(tkIntPlatStubsPtr->tkMacOSXMakeStippleMap) /* 24 */
+#endif
+#ifndef TkMacOSXMenuClick
+#define TkMacOSXMenuClick \
+	(tkIntPlatStubsPtr->tkMacOSXMenuClick) /* 25 */
+#endif
+#ifndef TkMacOSXRegisterOffScreenWindow
+#define TkMacOSXRegisterOffScreenWindow \
+	(tkIntPlatStubsPtr->tkMacOSXRegisterOffScreenWindow) /* 26 */
+#endif
+#ifndef TkMacOSXResizable
+#define TkMacOSXResizable \
+	(tkIntPlatStubsPtr->tkMacOSXResizable) /* 27 */
+#endif
+#ifndef TkMacOSXSetHelpMenuItemCount
+#define TkMacOSXSetHelpMenuItemCount \
+	(tkIntPlatStubsPtr->tkMacOSXSetHelpMenuItemCount) /* 28 */
+#endif
+#ifndef TkMacOSXSetScrollbarGrow
+#define TkMacOSXSetScrollbarGrow \
+	(tkIntPlatStubsPtr->tkMacOSXSetScrollbarGrow) /* 29 */
+#endif
+#ifndef TkMacOSXSetUpClippingRgn
+#define TkMacOSXSetUpClippingRgn \
+	(tkIntPlatStubsPtr->tkMacOSXSetUpClippingRgn) /* 30 */
+#endif
+#ifndef TkMacOSXSetUpGraphicsPort
+#define TkMacOSXSetUpGraphicsPort \
+	(tkIntPlatStubsPtr->tkMacOSXSetUpGraphicsPort) /* 31 */
+#endif
+#ifndef TkMacOSXUpdateClipRgn
+#define TkMacOSXUpdateClipRgn \
+	(tkIntPlatStubsPtr->tkMacOSXUpdateClipRgn) /* 32 */
+#endif
+#ifndef TkMacOSXUnregisterMacWindow
+#define TkMacOSXUnregisterMacWindow \
+	(tkIntPlatStubsPtr->tkMacOSXUnregisterMacWindow) /* 33 */
+#endif
+#ifndef TkMacOSXUseMenuID
+#define TkMacOSXUseMenuID \
+	(tkIntPlatStubsPtr->tkMacOSXUseMenuID) /* 34 */
+#endif
+#ifndef TkMacOSXVisableClipRgn
+#define TkMacOSXVisableClipRgn \
+	(tkIntPlatStubsPtr->tkMacOSXVisableClipRgn) /* 35 */
+#endif
+#ifndef TkMacOSXWinBounds
+#define TkMacOSXWinBounds \
+	(tkIntPlatStubsPtr->tkMacOSXWinBounds) /* 36 */
+#endif
+#ifndef TkMacOSXWindowOffset
+#define TkMacOSXWindowOffset \
+	(tkIntPlatStubsPtr->tkMacOSXWindowOffset) /* 37 */
+#endif
+#ifndef TkSetMacColor
+#define TkSetMacColor \
+	(tkIntPlatStubsPtr->tkSetMacColor) /* 38 */
+#endif
+#ifndef TkSetWMName
+#define TkSetWMName \
+	(tkIntPlatStubsPtr->tkSetWMName) /* 39 */
+#endif
+#ifndef TkSuspendClipboard
+#define TkSuspendClipboard \
+	(tkIntPlatStubsPtr->tkSuspendClipboard) /* 40 */
+#endif
+#ifndef TkMacOSXZoomToplevel
+#define TkMacOSXZoomToplevel \
+	(tkIntPlatStubsPtr->tkMacOSXZoomToplevel) /* 41 */
+#endif
+#ifndef Tk_TopCoordsToWindow
+#define Tk_TopCoordsToWindow \
+	(tkIntPlatStubsPtr->tk_TopCoordsToWindow) /* 42 */
+#endif
+#ifndef TkMacOSXContainerId
+#define TkMacOSXContainerId \
+	(tkIntPlatStubsPtr->tkMacOSXContainerId) /* 43 */
+#endif
+#ifndef TkMacOSXGetHostToplevel
+#define TkMacOSXGetHostToplevel \
+	(tkIntPlatStubsPtr->tkMacOSXGetHostToplevel) /* 44 */
+#endif
+#ifndef TkMacOSXPreprocessMenu
+#define TkMacOSXPreprocessMenu \
+	(tkIntPlatStubsPtr->tkMacOSXPreprocessMenu) /* 45 */
+#endif
+#ifndef TkpIsWindowFloating
+#define TkpIsWindowFloating \
+	(tkIntPlatStubsPtr->tkpIsWindowFloating) /* 46 */
+#endif
+#ifndef TkMacOSXGetCapture
+#define TkMacOSXGetCapture \
+	(tkIntPlatStubsPtr->tkMacOSXGetCapture) /* 47 */
+#endif
+/* Slot 48 is reserved */
+#ifndef TkGetTransientMaster
+#define TkGetTransientMaster \
+	(tkIntPlatStubsPtr->tkGetTransientMaster) /* 49 */
+#endif
+#ifndef TkGenerateButtonEvent
+#define TkGenerateButtonEvent \
+	(tkIntPlatStubsPtr->tkGenerateButtonEvent) /* 50 */
+#endif
+#ifndef TkGenWMDestroyEvent
+#define TkGenWMDestroyEvent \
+	(tkIntPlatStubsPtr->tkGenWMDestroyEvent) /* 51 */
+#endif
+/* Slot 52 is reserved */
+#ifndef TkpGetMS
+#define TkpGetMS \
+	(tkIntPlatStubsPtr->tkpGetMS) /* 53 */
+#endif
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+#ifndef TkCreateXEventSource
+#define TkCreateXEventSource \
+	(tkIntPlatStubsPtr->tkCreateXEventSource) /* 0 */
+#endif
+#ifndef TkFreeWindowId
+#define TkFreeWindowId \
+	(tkIntPlatStubsPtr->tkFreeWindowId) /* 1 */
+#endif
+#ifndef TkInitXId
+#define TkInitXId \
+	(tkIntPlatStubsPtr->tkInitXId) /* 2 */
+#endif
+#ifndef TkpCmapStressed
+#define TkpCmapStressed \
+	(tkIntPlatStubsPtr->tkpCmapStressed) /* 3 */
+#endif
+#ifndef TkpSync
+#define TkpSync \
+	(tkIntPlatStubsPtr->tkpSync) /* 4 */
+#endif
+#ifndef TkUnixContainerId
+#define TkUnixContainerId \
+	(tkIntPlatStubsPtr->tkUnixContainerId) /* 5 */
+#endif
+#ifndef TkUnixDoOneXEvent
+#define TkUnixDoOneXEvent \
+	(tkIntPlatStubsPtr->tkUnixDoOneXEvent) /* 6 */
+#endif
+#ifndef TkUnixSetMenubar
+#define TkUnixSetMenubar \
+	(tkIntPlatStubsPtr->tkUnixSetMenubar) /* 7 */
+#endif
+#ifndef TkpScanWindowId
+#define TkpScanWindowId \
+	(tkIntPlatStubsPtr->tkpScanWindowId) /* 8 */
+#endif
+#ifndef TkWmCleanup
+#define TkWmCleanup \
+	(tkIntPlatStubsPtr->tkWmCleanup) /* 9 */
+#endif
+#ifndef TkSendCleanup
+#define TkSendCleanup \
+	(tkIntPlatStubsPtr->tkSendCleanup) /* 10 */
+#endif
+#ifndef TkFreeXId
+#define TkFreeXId \
+	(tkIntPlatStubsPtr->tkFreeXId) /* 11 */
+#endif
+#ifndef TkpWmSetState
+#define TkpWmSetState \
+	(tkIntPlatStubsPtr->tkpWmSetState) /* 12 */
+#endif
+#ifndef TkpTestsendCmd
+#define TkpTestsendCmd \
+	(tkIntPlatStubsPtr->tkpTestsendCmd) /* 13 */
+#endif
+#endif /* X11 */
+
+#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TKINTPLATDECLS */
Index: src/tktext/tk8.5/tkMacOSX.h
===================================================================
--- src/tktext/tk8.5/tkMacOSX.h	(revision 0)
+++ src/tktext/tk8.5/tkMacOSX.h	(working copy)
@@ -0,0 +1,38 @@
+/*
+ * tkMacOSX.h --
+ *
+ *	Declarations of Macintosh specific exported variables and procedures.
+ *
+ * Copyright (c) 1995-1997 Sun Microsystems, Inc.
+ * Copyright 2001, Apple Computer, Inc.
+ * Copyright (c) 2005-2007 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkMacOSX.h,v 1.5 2007/04/23 21:24:32 das Exp $
+ */
+
+#ifndef _TKMAC
+#define _TKMAC
+
+#ifndef _TK
+#include "tk.h"
+#endif
+
+#include <Carbon/Carbon.h>
+
+/*
+ * Structures and function types for handling Netscape-type in process
+ * embedding where Tk does not control the top-level
+ */
+
+typedef int (Tk_MacOSXEmbedRegisterWinProc) (int winID, Tk_Window window);
+typedef GWorldPtr (Tk_MacOSXEmbedGetGrafPortProc) (Tk_Window window);
+typedef int (Tk_MacOSXEmbedMakeContainerExistProc) (Tk_Window window);
+typedef void (Tk_MacOSXEmbedGetClipProc) (Tk_Window window, RgnHandle rgn);
+typedef void (Tk_MacOSXEmbedGetOffsetInParentProc) (Tk_Window window, Point *ulCorner);
+
+#include "tkPlatDecls.h"
+
+#endif /* _TKMAC */
Index: src/tktext/tk8.5/tkMacOSXDefault.h
===================================================================
--- src/tktext/tk8.5/tkMacOSXDefault.h	(revision 0)
+++ src/tktext/tk8.5/tkMacOSXDefault.h	(working copy)
@@ -0,0 +1,550 @@
+/*
+ * tkMacOSXDefault.h --
+ *
+ *	This file defines the defaults for all options for all of
+ *	the Tk widgets.
+ *
+ * Copyright (c) 1991-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright 2001, Apple Computer, Inc.
+ * Copyright (c) 2006-2007 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkMacOSXDefault.h,v 1.15 2007/12/13 15:27:08 dgp Exp $
+ */
+
+#ifndef _TKMACDEFAULT
+#define _TKMACDEFAULT
+
+/*
+ * The definitions below provide symbolic names for the default colors.
+ * NORMAL_BG -		Normal background color.
+ * ACTIVE_BG -		Background color when widget is active.
+ * SELECT_BG -		Background color for selected text.
+ * SELECT_FG -		Foreground color for selected text.
+ * TROUGH -		Background color for troughs in scales and scrollbars.
+ * INDICATOR -		Color for indicator when button is selected.
+ * DISABLED -		Foreground color when widget is disabled.
+ */
+
+#define BLACK				"Black"
+#define WHITE				"White"
+#define NORMAL_BG			"systemWindowBody"
+#define ACTIVE_BG			"systemButtonFacePressed"
+#define ACTIVE_FG			"systemPushButtonPressedText"
+#define SELECT_BG			"systemHighlight"
+#define SELECT_FG			None
+#define INACTIVE_SELECT_BG		"systemHighlightSecondary"
+#define TROUGH				"#c3c3c3"
+#define INDICATOR			"#b03060"
+#define DISABLED			"#a3a3a3"
+
+/*
+ * Defaults for labels, buttons, checkbuttons, and radiobuttons:
+ */
+
+#define DEF_BUTTON_ANCHOR		"center"
+#define DEF_BUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_BUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_BUTTON_ACTIVE_FG_COLOR	ACTIVE_FG
+#define DEF_CHKRAD_ACTIVE_FG_COLOR	DEF_BUTTON_ACTIVE_FG_COLOR
+#define DEF_BUTTON_ACTIVE_FG_MONO	WHITE
+/* #define DEF_BUTTON_BG_COLOR	"systemButtonFace"*/
+#define DEF_BUTTON_BG_COLOR		WHITE
+#define DEF_BUTTON_BG_MONO		WHITE
+#define DEF_BUTTON_BITMAP		""
+#define DEF_BUTTON_BORDER_WIDTH		"2"
+#define DEF_BUTTON_CURSOR		""
+#define DEF_BUTTON_COMMAND		""
+#define DEF_BUTTON_COMPOUND		"none"
+#define DEF_BUTTON_DEFAULT		"disabled"
+#define DEF_BUTTON_DISABLED_FG_COLOR	DISABLED
+#define DEF_BUTTON_DISABLED_FG_MONO	""
+#define DEF_BUTTON_FG			"systemButtonText"
+#define DEF_CHKRAD_FG			DEF_BUTTON_FG
+#define DEF_BUTTON_FONT			"TkDefaultFont"
+#define DEF_BUTTON_HEIGHT		"0"
+#define DEF_BUTTON_HIGHLIGHT_BG_COLOR	DEF_BUTTON_BG_COLOR
+#define DEF_BUTTON_HIGHLIGHT_BG_MONO	DEF_BUTTON_BG_MONO
+#define DEF_BUTTON_HIGHLIGHT		"systemButtonFrame"
+#define DEF_LABEL_HIGHLIGHT_WIDTH	"0"
+#define DEF_BUTTON_HIGHLIGHT_WIDTH	"4"
+#define DEF_BUTTON_IMAGE		(char *) NULL
+#define DEF_BUTTON_INDICATOR		"1"
+#define DEF_BUTTON_JUSTIFY		"center"
+#define DEF_BUTTON_OFF_VALUE		"0"
+#define DEF_BUTTON_ON_VALUE		"1"
+#define DEF_BUTTON_TRISTATE_VALUE	""
+#define DEF_BUTTON_OVER_RELIEF		""
+#define DEF_BUTTON_PADX			"12"
+#define DEF_LABCHKRAD_PADX		"1"
+#define DEF_BUTTON_PADY			"3"
+#define DEF_LABCHKRAD_PADY		"1"
+#define DEF_BUTTON_RELIEF		"flat"
+#define DEF_LABCHKRAD_RELIEF		"flat"
+#define DEF_BUTTON_REPEAT_DELAY		"0"
+#define DEF_BUTTON_REPEAT_INTERVAL	"0"
+#define DEF_BUTTON_SELECT_COLOR		INDICATOR
+#define DEF_BUTTON_SELECT_MONO		BLACK
+#define DEF_BUTTON_SELECT_IMAGE		(char *) NULL
+#define DEF_BUTTON_STATE		"normal"
+#define DEF_LABEL_TAKE_FOCUS		"0"
+#define DEF_BUTTON_TAKE_FOCUS		(char *) NULL
+#define DEF_BUTTON_TEXT			""
+#define DEF_BUTTON_TEXT_VARIABLE	""
+#define DEF_BUTTON_UNDERLINE		"-1"
+#define DEF_BUTTON_VALUE		""
+#define DEF_BUTTON_WIDTH		"0"
+#define DEF_BUTTON_WRAP_LENGTH		"0"
+#define DEF_RADIOBUTTON_VARIABLE	"selectedButton"
+#define DEF_CHECKBUTTON_VARIABLE	""
+
+/*
+ * Defaults for canvases:
+ */
+
+#define DEF_CANVAS_BG_COLOR		NORMAL_BG
+#define DEF_CANVAS_BG_MONO		WHITE
+#define DEF_CANVAS_BORDER_WIDTH		"0"
+#define DEF_CANVAS_CLOSE_ENOUGH		"1"
+#define DEF_CANVAS_CONFINE		"1"
+#define DEF_CANVAS_CURSOR		""
+#define DEF_CANVAS_HEIGHT		"7c"
+#define DEF_CANVAS_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_CANVAS_HIGHLIGHT		BLACK
+#define DEF_CANVAS_HIGHLIGHT_WIDTH	"3"
+#define DEF_CANVAS_INSERT_BG		BLACK
+#define DEF_CANVAS_INSERT_BD_COLOR	"0"
+#define DEF_CANVAS_INSERT_BD_MONO	"0"
+#define DEF_CANVAS_INSERT_OFF_TIME	"300"
+#define DEF_CANVAS_INSERT_ON_TIME	"600"
+#define DEF_CANVAS_INSERT_WIDTH		"2"
+#define DEF_CANVAS_RELIEF		"flat"
+#define DEF_CANVAS_SCROLL_REGION	""
+#define DEF_CANVAS_SELECT_COLOR		SELECT_BG
+#define DEF_CANVAS_SELECT_MONO		BLACK
+#define DEF_CANVAS_SELECT_BD_COLOR	"1"
+#define DEF_CANVAS_SELECT_BD_MONO	"0"
+#define DEF_CANVAS_SELECT_FG_COLOR	SELECT_FG
+#define DEF_CANVAS_SELECT_FG_MONO	WHITE
+#define DEF_CANVAS_TAKE_FOCUS		(char *) NULL
+#define DEF_CANVAS_WIDTH		"10c"
+#define DEF_CANVAS_X_SCROLL_CMD		""
+#define DEF_CANVAS_X_SCROLL_INCREMENT	"0"
+#define DEF_CANVAS_Y_SCROLL_CMD		""
+#define DEF_CANVAS_Y_SCROLL_INCREMENT	"0"
+
+/*
+ * Defaults for entries:
+ */
+
+/*
+ * I test the following two values in TkpDrawEntryBorderAndFocus
+ * to determine whether to use the native entry widget. So if
+ * you change the defaults to be different from these, then you
+ * won't get the native widget by default.
+ */
+
+#define MAC_OSX_FOCUS_WIDTH		3
+#define MAC_OSX_ENTRY_BORDER		2
+#define MAC_OSX_ENTRY_RELIEF		TK_RELIEF_SUNKEN
+#define MAC_OSX_ENTRY_SELECT_RELIEF	TK_RELIEF_FLAT
+
+#define DEF_ENTRY_BG_COLOR		NORMAL_BG
+#define DEF_ENTRY_BG_MONO		WHITE
+#define DEF_ENTRY_BORDER_WIDTH		"2"
+#define DEF_ENTRY_CURSOR		"xterm"
+#define DEF_ENTRY_DISABLED_BG_COLOR	NORMAL_BG
+#define DEF_ENTRY_DISABLED_BG_MONO	WHITE
+#define DEF_ENTRY_DISABLED_FG		DISABLED
+#define DEF_ENTRY_EXPORT_SELECTION	"1"
+#define DEF_ENTRY_FONT			"TkTextFont"
+#define DEF_ENTRY_FG			BLACK
+#define DEF_ENTRY_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_ENTRY_HIGHLIGHT		BLACK
+/* #define DEF_ENTRY_HIGHLIGHT_WIDTH	"3" */
+#define DEF_ENTRY_HIGHLIGHT_WIDTH	"3"
+#define DEF_ENTRY_INSERT_BG		BLACK
+#define DEF_ENTRY_INSERT_BD_COLOR	"0"
+#define DEF_ENTRY_INSERT_BD_MONO	"0"
+#define DEF_ENTRY_INSERT_OFF_TIME	"300"
+#define DEF_ENTRY_INSERT_ON_TIME	"600"
+/* #define DEF_ENTRY_INSERT_WIDTH		"2" */
+#define DEF_ENTRY_INSERT_WIDTH		"1"
+#define DEF_ENTRY_JUSTIFY		"left"
+#define DEF_ENTRY_READONLY_BG_COLOR	NORMAL_BG
+#define DEF_ENTRY_READONLY_BG_MONO	WHITE
+#define DEF_ENTRY_RELIEF		"sunken"
+/* #define DEF_ENTRY_RELIEF		"solid" */
+#define DEF_ENTRY_SCROLL_COMMAND	""
+#define DEF_ENTRY_SELECT_COLOR		SELECT_BG
+#define DEF_ENTRY_SELECT_MONO		BLACK
+#define DEF_ENTRY_SELECT_BD_COLOR	"1"
+#define DEF_ENTRY_SELECT_BD_MONO	"0"
+#define DEF_ENTRY_SELECT_FG_COLOR	SELECT_FG
+#define DEF_ENTRY_SELECT_FG_MONO	WHITE
+#define DEF_ENTRY_SHOW			(char *) NULL
+#define DEF_ENTRY_STATE			"normal"
+#define DEF_ENTRY_TAKE_FOCUS		(char *) NULL
+#define DEF_ENTRY_TEXT_VARIABLE		""
+#define DEF_ENTRY_WIDTH			"20"
+
+/*
+ * Defaults for frames:
+ */
+
+#define DEF_FRAME_BG_COLOR		NORMAL_BG
+#define DEF_FRAME_BG_MONO		WHITE
+#define DEF_FRAME_BORDER_WIDTH		"0"
+#define DEF_FRAME_CLASS			"Frame"
+#define DEF_FRAME_COLORMAP		""
+#define DEF_FRAME_CONTAINER		"0"
+#define DEF_FRAME_CURSOR		""
+#define DEF_FRAME_HEIGHT		"0"
+#define DEF_FRAME_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_FRAME_HIGHLIGHT		BLACK
+#define DEF_FRAME_HIGHLIGHT_WIDTH	"0"
+#define DEF_FRAME_PADX			"0"
+#define DEF_FRAME_PADY			"0"
+#define DEF_FRAME_RELIEF		"flat"
+#define DEF_FRAME_TAKE_FOCUS		"0"
+#define DEF_FRAME_VISUAL		""
+#define DEF_FRAME_WIDTH			"0"
+
+/*
+ * Defaults for labelframes:
+ */
+
+#define DEF_LABELFRAME_BORDER_WIDTH	"2"
+#define DEF_LABELFRAME_CLASS		"Labelframe"
+#define DEF_LABELFRAME_RELIEF		"groove"
+#define DEF_LABELFRAME_FG		"systemButtonText"
+#define DEF_LABELFRAME_FONT		"TkDefaultFont"
+#define DEF_LABELFRAME_TEXT		""
+#define DEF_LABELFRAME_LABELANCHOR	"nw"
+
+/*
+ * Defaults for listboxes:
+ */
+
+#define DEF_LISTBOX_ACTIVE_STYLE	"dotbox"
+#define DEF_LISTBOX_BG_COLOR		WHITE
+#define DEF_LISTBOX_BG_MONO		WHITE
+#define DEF_LISTBOX_BORDER_WIDTH	"1"
+#define DEF_LISTBOX_CURSOR		""
+#define DEF_LISTBOX_DISABLED_FG		DISABLED
+#define DEF_LISTBOX_EXPORT_SELECTION	"1"
+#define DEF_LISTBOX_FONT		"TkTextFont"
+#define DEF_LISTBOX_FG			BLACK
+#define DEF_LISTBOX_HEIGHT		"10"
+#define DEF_LISTBOX_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_LISTBOX_HIGHLIGHT		BLACK
+#define DEF_LISTBOX_HIGHLIGHT_WIDTH	"0"
+#define DEF_LISTBOX_RELIEF		"solid"
+#define DEF_LISTBOX_SCROLL_COMMAND	""
+#define DEF_LISTBOX_LIST_VARIABLE	""
+#define DEF_LISTBOX_SELECT_COLOR	SELECT_BG
+#define DEF_LISTBOX_SELECT_MONO		BLACK
+#define DEF_LISTBOX_SELECT_BD		"0"
+#define DEF_LISTBOX_SELECT_FG_COLOR	SELECT_FG
+#define DEF_LISTBOX_SELECT_FG_MONO	WHITE
+#define DEF_LISTBOX_SELECT_MODE		"browse"
+#define DEF_LISTBOX_SET_GRID		"0"
+#define DEF_LISTBOX_STATE		"normal"
+#define DEF_LISTBOX_TAKE_FOCUS		(char *) NULL
+#define DEF_LISTBOX_WIDTH		"20"
+
+/*
+ * Defaults for individual entries of menus:
+ */
+
+#define DEF_MENU_ENTRY_ACTIVE_BG	(char *) NULL
+#define DEF_MENU_ENTRY_ACTIVE_FG	(char *) NULL
+#define DEF_MENU_ENTRY_ACCELERATOR	(char *) NULL
+#define DEF_MENU_ENTRY_BG		(char *) NULL
+#define DEF_MENU_ENTRY_BITMAP		None
+#define DEF_MENU_ENTRY_COLUMN_BREAK	"0"
+#define DEF_MENU_ENTRY_COMMAND		(char *) NULL
+#define DEF_MENU_ENTRY_COMPOUND		"none"
+#define DEF_MENU_ENTRY_FG		(char *) NULL
+#define DEF_MENU_ENTRY_FONT		(char *) NULL
+#define DEF_MENU_ENTRY_HIDE_MARGIN	"0"
+#define DEF_MENU_ENTRY_IMAGE		(char *) NULL
+#define DEF_MENU_ENTRY_INDICATOR	"1"
+#define DEF_MENU_ENTRY_LABEL		(char *) NULL
+#define DEF_MENU_ENTRY_MENU		(char *) NULL
+#define DEF_MENU_ENTRY_OFF_VALUE	"0"
+#define DEF_MENU_ENTRY_ON_VALUE		"1"
+#define DEF_MENU_ENTRY_SELECT_IMAGE	(char *) NULL
+#define DEF_MENU_ENTRY_STATE		"normal"
+#define DEF_MENU_ENTRY_VALUE		(char *) NULL
+#define DEF_MENU_ENTRY_CHECK_VARIABLE	(char *) NULL
+#define DEF_MENU_ENTRY_RADIO_VARIABLE	"selectedButton"
+#define DEF_MENU_ENTRY_SELECT	(char *) NULL
+#define DEF_MENU_ENTRY_UNDERLINE	"-1"
+
+/*
+ * Defaults for menus overall:
+ */
+
+#define DEF_MENU_ACTIVE_BG_COLOR	"systemMenuActive"
+#define DEF_MENU_ACTIVE_BG_MONO		BLACK
+#define DEF_MENU_ACTIVE_BORDER_WIDTH	"0"
+#define DEF_MENU_ACTIVE_FG_COLOR	"systemMenuActiveText"
+#define DEF_MENU_ACTIVE_FG_MONO		WHITE
+#define DEF_MENU_BG_COLOR		"systemMenu"
+#define DEF_MENU_BG_MONO		WHITE
+#define DEF_MENU_BORDER_WIDTH		"0"
+#define DEF_MENU_CURSOR			"arrow"
+#define DEF_MENU_DISABLED_FG_COLOR	"systemMenuDisabled"
+#define DEF_MENU_DISABLED_FG_MONO	""
+#define DEF_MENU_FONT			"menu" /* special: see tkMacOSXMenu.c */
+#define DEF_MENU_FG			"systemMenuText"
+#define DEF_MENU_POST_COMMAND		""
+#define DEF_MENU_RELIEF			"flat"
+#define DEF_MENU_SELECT_COLOR		"systemMenuActive"
+#define DEF_MENU_SELECT_MONO		BLACK
+#define DEF_MENU_TAKE_FOCUS		"0"
+
+/*
+ * FIXME: Turn the default back to 1 when we make tearoff menus work again.
+ */
+
+#define DEF_MENU_TEAROFF		"0"
+#define DEF_MENU_TEAROFF_CMD		(char *) NULL
+#define DEF_MENU_TITLE			""
+#define DEF_MENU_TYPE			"normal"
+
+/*
+ * Defaults for menubuttons:
+ */
+
+#define DEF_MENUBUTTON_ANCHOR		"center"
+#define DEF_MENUBUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_MENUBUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_MENUBUTTON_ACTIVE_FG_COLOR	ACTIVE_FG
+#define DEF_MENUBUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_MENUBUTTON_BG_COLOR		NORMAL_BG
+#define DEF_MENUBUTTON_BG_MONO		WHITE
+#define DEF_MENUBUTTON_BITMAP		""
+#define DEF_MENUBUTTON_BORDER_WIDTH	"2"
+#define DEF_MENUBUTTON_CURSOR		""
+#define DEF_MENUBUTTON_DIRECTION	"below"
+#define DEF_MENUBUTTON_DISABLED_FG_COLOR DISABLED
+#define DEF_MENUBUTTON_DISABLED_FG_MONO	""
+#define DEF_MENUBUTTON_FONT		"TkDefaultFont"
+#define DEF_MENUBUTTON_FG		BLACK
+#define DEF_MENUBUTTON_HEIGHT		"0"
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_COLOR DEF_MENUBUTTON_BG_COLOR
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
+#define DEF_MENUBUTTON_HIGHLIGHT	BLACK
+#define DEF_MENUBUTTON_HIGHLIGHT_WIDTH	"0"
+#define DEF_MENUBUTTON_IMAGE		(char *) NULL
+#define DEF_MENUBUTTON_INDICATOR	"0"
+/* #define DEF_MENUBUTTON_JUSTIFY		"center" */
+#define DEF_MENUBUTTON_JUSTIFY		"left"
+#define DEF_MENUBUTTON_MENU		""
+#define DEF_MENUBUTTON_PADX		"4p"
+#define DEF_MENUBUTTON_PADY		"3p"
+#define DEF_MENUBUTTON_RELIEF		"flat"
+#define DEF_MENUBUTTON_STATE		"normal"
+#define DEF_MENUBUTTON_TAKE_FOCUS	"0"
+#define DEF_MENUBUTTON_TEXT		""
+#define DEF_MENUBUTTON_TEXT_VARIABLE	""
+#define DEF_MENUBUTTON_UNDERLINE	"-1"
+#define DEF_MENUBUTTON_WIDTH		"0"
+#define DEF_MENUBUTTON_WRAP_LENGTH	"0"
+
+/*
+ * Defaults for messages:
+ */
+
+#define DEF_MESSAGE_ANCHOR		"center"
+#define DEF_MESSAGE_ASPECT		"150"
+#define DEF_MESSAGE_BG_COLOR		NORMAL_BG
+#define DEF_MESSAGE_BG_MONO		WHITE
+#define DEF_MESSAGE_BORDER_WIDTH	"1"
+#define DEF_MESSAGE_CURSOR		""
+#define DEF_MESSAGE_FG			BLACK
+#define DEF_MESSAGE_FONT		"TkDefaultFont"
+#define DEF_MESSAGE_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_MESSAGE_HIGHLIGHT		BLACK
+#define DEF_MESSAGE_HIGHLIGHT_WIDTH	"0"
+#define DEF_MESSAGE_JUSTIFY		"left"
+#define DEF_MESSAGE_PADX		"-1"
+#define DEF_MESSAGE_PADY		"-1"
+#define DEF_MESSAGE_RELIEF		"flat"
+#define DEF_MESSAGE_TAKE_FOCUS		"0"
+#define DEF_MESSAGE_TEXT		""
+#define DEF_MESSAGE_TEXT_VARIABLE	""
+#define DEF_MESSAGE_WIDTH		"0"
+/*
+ * Defaults for panedwindows
+ */
+
+#define DEF_PANEDWINDOW_BG_COLOR	NORMAL_BG
+#define DEF_PANEDWINDOW_BG_MONO		WHITE
+#define DEF_PANEDWINDOW_BORDERWIDTH	"1"
+#define DEF_PANEDWINDOW_CURSOR		""
+#define DEF_PANEDWINDOW_HANDLEPAD	"8"
+#define DEF_PANEDWINDOW_HANDLESIZE	"8"
+#define DEF_PANEDWINDOW_HEIGHT		""
+#define DEF_PANEDWINDOW_OPAQUERESIZE	"1"
+#define DEF_PANEDWINDOW_ORIENT		"horizontal"
+#define DEF_PANEDWINDOW_RELIEF		"flat"
+#define DEF_PANEDWINDOW_SASHCURSOR	""
+#define DEF_PANEDWINDOW_SASHPAD		"0"
+#define DEF_PANEDWINDOW_SASHRELIEF	"flat"
+#define DEF_PANEDWINDOW_SASHWIDTH	"3"
+#define DEF_PANEDWINDOW_SHOWHANDLE	"0"
+#define DEF_PANEDWINDOW_WIDTH		""
+
+/*
+ * Defaults for panedwindow panes
+ */
+
+#define DEF_PANEDWINDOW_PANE_AFTER	""
+#define DEF_PANEDWINDOW_PANE_BEFORE	""
+#define DEF_PANEDWINDOW_PANE_HEIGHT	""
+#define DEF_PANEDWINDOW_PANE_MINSIZE	"0"
+#define DEF_PANEDWINDOW_PANE_PADX	"0"
+#define DEF_PANEDWINDOW_PANE_PADY	"0"
+#define DEF_PANEDWINDOW_PANE_STICKY	"nsew"
+#define DEF_PANEDWINDOW_PANE_WIDTH	""
+#define DEF_PANEDWINDOW_PANE_HIDE	"0"
+#define DEF_PANEDWINDOW_PANE_STRETCH	"last"
+
+/*
+ * Defaults for scales:
+ */
+
+#define DEF_SCALE_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCALE_ACTIVE_BG_MONO	BLACK
+#define DEF_SCALE_BG_COLOR		NORMAL_BG
+#define DEF_SCALE_BG_MONO		WHITE
+#define DEF_SCALE_BIG_INCREMENT		"0"
+#define DEF_SCALE_BORDER_WIDTH		"1"
+#define DEF_SCALE_COMMAND		""
+#define DEF_SCALE_CURSOR		""
+#define DEF_SCALE_DIGITS		"0"
+#define DEF_SCALE_FONT			"TkDefaultFont"
+#define DEF_SCALE_FG_COLOR		BLACK
+#define DEF_SCALE_FG_MONO		BLACK
+#define DEF_SCALE_FROM			"0"
+#define DEF_SCALE_HIGHLIGHT_BG_COLOR	DEF_SCALE_BG_COLOR
+#define DEF_SCALE_HIGHLIGHT_BG_MONO	DEF_SCALE_BG_MONO
+#define DEF_SCALE_HIGHLIGHT		BLACK
+#define DEF_SCALE_HIGHLIGHT_WIDTH	"0"
+#define DEF_SCALE_LABEL			""
+#define DEF_SCALE_LENGTH		"100"
+#define DEF_SCALE_ORIENT		"vertical"
+#define DEF_SCALE_RELIEF		"flat"
+#define DEF_SCALE_REPEAT_DELAY	"300"
+#define DEF_SCALE_REPEAT_INTERVAL	"100"
+#define DEF_SCALE_RESOLUTION		"1"
+#define DEF_SCALE_TROUGH_COLOR		TROUGH
+#define DEF_SCALE_TROUGH_MONO		WHITE
+#define DEF_SCALE_SHOW_VALUE		"1"
+#define DEF_SCALE_SLIDER_LENGTH		"30"
+#define DEF_SCALE_SLIDER_RELIEF		"raised"
+#define DEF_SCALE_STATE			"normal"
+#define DEF_SCALE_TAKE_FOCUS		(char *) NULL
+#define DEF_SCALE_TICK_INTERVAL		"0"
+#define DEF_SCALE_TO			"100"
+#define DEF_SCALE_VARIABLE		""
+#define DEF_SCALE_WIDTH			"15"
+
+/*
+ * Defaults for scrollbars:
+ */
+
+#define DEF_SCROLLBAR_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCROLLBAR_ACTIVE_BG_MONO	BLACK
+#define DEF_SCROLLBAR_ACTIVE_RELIEF	"raised"
+#define DEF_SCROLLBAR_BG_COLOR		NORMAL_BG
+#define DEF_SCROLLBAR_BG_MONO		WHITE
+#define DEF_SCROLLBAR_BORDER_WIDTH	"0"
+#define DEF_SCROLLBAR_COMMAND		""
+#define DEF_SCROLLBAR_CURSOR		""
+#define DEF_SCROLLBAR_EL_BORDER_WIDTH	"-1"
+#define DEF_SCROLLBAR_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_SCROLLBAR_HIGHLIGHT		BLACK
+#define DEF_SCROLLBAR_HIGHLIGHT_WIDTH	"0"
+#define DEF_SCROLLBAR_JUMP		"0"
+#define DEF_SCROLLBAR_ORIENT		"vertical"
+#define DEF_SCROLLBAR_RELIEF		"flat"
+#define DEF_SCROLLBAR_REPEAT_DELAY	"300"
+#define DEF_SCROLLBAR_REPEAT_INTERVAL	"100"
+#define DEF_SCROLLBAR_TAKE_FOCUS	(char *) NULL
+#define DEF_SCROLLBAR_TROUGH_COLOR	TROUGH
+#define DEF_SCROLLBAR_TROUGH_MONO	WHITE
+#define DEF_SCROLLBAR_WIDTH		"15"
+
+/*
+ * Defaults for texts:
+ */
+
+#define DEF_TEXT_AUTO_SEPARATORS	"1"
+#define DEF_TEXT_BG_COLOR		NORMAL_BG
+#define DEF_TEXT_BG_MONO		WHITE
+#define DEF_TEXT_BLOCK_CURSOR		"0"
+#define DEF_TEXT_BORDER_WIDTH		"0"
+#define DEF_TEXT_CURSOR			"xterm"
+#define DEF_TEXT_FG			BLACK
+#define DEF_TEXT_EXPORT_SELECTION	"1"
+#define DEF_TEXT_FONT			"TkFixedFont"
+#define DEF_TEXT_HEIGHT			"24"
+#define DEF_TEXT_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_TEXT_HIGHLIGHT		BLACK
+#define DEF_TEXT_HIGHLIGHT_WIDTH	"3"
+#define DEF_TEXT_INSERT_BG		BLACK
+#define DEF_TEXT_INSERT_BD_COLOR	"0"
+#define DEF_TEXT_INSERT_BD_MONO		"0"
+#define DEF_TEXT_INSERT_OFF_TIME	"300"
+#define DEF_TEXT_INSERT_ON_TIME		"600"
+#define DEF_TEXT_INSERT_WIDTH		"1"
+#define DEF_TEXT_MAX_UNDO		"0"
+#define DEF_TEXT_PADX			"1"
+#define DEF_TEXT_PADY			"1"
+#define DEF_TEXT_RELIEF			"flat"
+#define DEF_TEXT_INACTIVE_SELECT_COLOR	INACTIVE_SELECT_BG
+#define DEF_TEXT_SELECT_COLOR		SELECT_BG
+#define DEF_TEXT_SELECT_MONO		BLACK
+#define DEF_TEXT_SELECT_BD_COLOR	"1"
+#define DEF_TEXT_SELECT_BD_MONO		"0"
+#define DEF_TEXT_SELECT_FG_COLOR	SELECT_FG
+#define DEF_TEXT_SELECT_FG_MONO		WHITE
+#define DEF_TEXT_SELECT_RELIEF		"flat"
+#define DEF_TEXT_SET_GRID		"0"
+#define DEF_TEXT_SPACING1		"0"
+#define DEF_TEXT_SPACING2		"0"
+#define DEF_TEXT_SPACING3		"0"
+#define DEF_TEXT_STATE			"normal"
+#define DEF_TEXT_TABS			""
+#define DEF_TEXT_TABSTYLE		"tabular"
+#define DEF_TEXT_TAKE_FOCUS		(char *) NULL
+#define DEF_TEXT_UNDO			"0"
+#define DEF_TEXT_WIDTH			"80"
+#define DEF_TEXT_WRAP			"char"
+#define DEF_TEXT_XSCROLL_COMMAND	""
+#define DEF_TEXT_YSCROLL_COMMAND	""
+
+/*
+ * Defaults for canvas text:
+ */
+
+#define DEF_CANVTEXT_FONT		"TkDefaultFont"
+
+/*
+ * Defaults for toplevels (most of the defaults for frames also apply
+ * to toplevels):
+ */
+
+#define DEF_TOPLEVEL_CLASS		"Toplevel"
+#define DEF_TOPLEVEL_MENU		""
+#define DEF_TOPLEVEL_SCREEN		""
+#define DEF_TOPLEVEL_USE		""
+
+#endif /* _TKMACDEFAULT */
Index: src/tktext/tk8.5/tkMacOSXFont.h
===================================================================
--- src/tktext/tk8.5/tkMacOSXFont.h	(revision 0)
+++ src/tktext/tk8.5/tkMacOSXFont.h	(working copy)
@@ -0,0 +1,34 @@
+/*
+ * tkMacOSXFont.h --
+ *
+ *	Contains the Macintosh implementation of the platform-independant
+ *	font package interface.
+ *
+ * Copyright (c) 1990-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright 2001, Apple Computer, Inc.
+ * Copyright (c) 2006-2007 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkMacOSXFont.h,v 1.5 2007/04/23 21:24:33 das Exp $
+ */
+
+#ifndef TKMACOSXFONT_H
+#define TKMACOSXFONT_H 1
+
+#include "tkFont.h"
+
+#ifndef _TKMACINT
+#include "tkMacOSXInt.h"
+#endif
+
+/*
+ * Function prototypes
+ */
+
+MODULE_SCOPE void TkMacOSXInitControlFontStyle(Tk_Font tkfont,
+	ControlFontStylePtr fsPtr);
+
+#endif /*TKMACOSXFONT_H*/
Index: src/tktext/tk8.5/tkMacOSXInt.h
===================================================================
--- src/tktext/tk8.5/tkMacOSXInt.h	(revision 0)
+++ src/tktext/tk8.5/tkMacOSXInt.h	(working copy)
@@ -0,0 +1,180 @@
+/*
+ * tkMacOSXInt.h --
+ *
+ *	Declarations of Macintosh specific shared variables and procedures.
+ *
+ * Copyright (c) 1995-1997 Sun Microsystems, Inc.
+ * Copyright 2001, Apple Computer, Inc.
+ * Copyright (c) 2005-2007 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkMacOSXInt.h,v 1.32 2007/12/13 15:27:09 dgp Exp $
+ */
+
+#ifndef _TKMACINT
+#define _TKMACINT
+
+#ifndef _TKINT
+#include "tkInt.h"
+#endif
+
+#define TextStyle MacTextStyle
+#include <Carbon/Carbon.h>
+#undef TextStyle
+
+/*
+ * Include platform specific public interfaces.
+ */
+
+#ifndef _TKMAC
+#include "tkMacOSX.h"
+#endif
+
+struct TkWindowPrivate {
+    TkWindow *winPtr;		/* Ptr to tk window or NULL if Pixmap */
+    CGrafPtr grafPtr;
+    CGContextRef context;
+    ControlRef rootControl;
+    int xOff;			/* X offset from toplevel window */
+    int yOff;			/* Y offset from toplevel window */
+    CGSize size;
+    HIShapeRef visRgn;		/* Visible region of window */
+    HIShapeRef aboveVisRgn;	/* Visible region of window & its children */
+    CGRect drawRect;		/* Clipped drawing rect */
+    int referenceCount;		/* Don't delete toplevel until children are
+				 * gone. */
+    struct TkWindowPrivate *toplevel;
+				/* Pointer to the toplevel datastruct. */
+    int flags;			/* Various state see defines below. */
+};
+typedef struct TkWindowPrivate MacDrawable;
+
+/*
+ * This list is used to keep track of toplevel windows that have a Mac
+ * window attached. This is useful for several things, not the least
+ * of which is maintaining floating windows.
+ */
+
+typedef struct TkMacOSXWindowList {
+    struct TkMacOSXWindowList *nextPtr;
+				/* The next window in the list. */
+    TkWindow *winPtr;		/* This window */
+} TkMacOSXWindowList;
+
+/*
+ * Defines use for the flags field of the MacDrawable data structure.
+ */
+
+#define TK_SCROLLBAR_GROW	0x01
+#define TK_CLIP_INVALID		0x02
+#define TK_HOST_EXISTS		0x04
+#define TK_DRAWN_UNDER_MENU	0x08
+#define TK_CLIPPED_DRAW		0x10
+#define TK_IS_PIXMAP		0x20
+#define TK_IS_BW_PIXMAP		0x40
+
+/*
+ * I am reserving TK_EMBEDDED = 0x100 in the MacDrawable flags
+ * This is defined in tk.h. We need to duplicate the TK_EMBEDDED flag in the
+ * TkWindow structure for the window, but in the MacWin. This way we can
+ * still tell what the correct port is after the TKWindow structure has been
+ * freed. This actually happens when you bind destroy of a toplevel to
+ * Destroy of a child.
+ */
+
+/*
+ * This structure is for handling Netscape-type in process
+ * embedding where Tk does not control the top-level. It contains
+ * various functions that are needed by Mac specific routines, like
+ * TkMacOSXGetDrawablePort. The definitions of the function types
+ * are in tkMacOSX.h.
+ */
+
+typedef struct {
+    Tk_MacOSXEmbedRegisterWinProc *registerWinProc;
+    Tk_MacOSXEmbedGetGrafPortProc *getPortProc;
+    Tk_MacOSXEmbedMakeContainerExistProc *containerExistProc;
+    Tk_MacOSXEmbedGetClipProc *getClipProc;
+    Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc;
+} TkMacOSXEmbedHandler;
+
+MODULE_SCOPE TkMacOSXEmbedHandler *tkMacOSXEmbedHandler;
+
+/*
+ * Defines used for TkMacOSXInvalidateWindow
+ */
+
+#define TK_WINDOW_ONLY 0
+#define TK_PARENT_WINDOW 1
+
+/*
+ * Accessor for the privatePtr flags field for the TK_HOST_EXISTS field
+ */
+
+#define TkMacOSXHostToplevelExists(tkwin) \
+    (((TkWindow *) (tkwin))->privatePtr->toplevel->flags & TK_HOST_EXISTS)
+
+/*
+ * Defines use for the flags argument to TkGenWMConfigureEvent.
+ */
+
+#define TK_LOCATION_CHANGED	1
+#define TK_SIZE_CHANGED		2
+#define TK_BOTH_CHANGED		3
+
+/*
+ * Defines for tkTextDisp.c
+ */
+
+#define TK_LAYOUT_WITH_BASE_CHUNKS	1
+#define TK_DRAW_IN_CONTEXT		1
+
+#if !TK_DRAW_IN_CONTEXT
+MODULE_SCOPE int TkMacOSXCompareColors(unsigned long c1, unsigned long c2);
+#endif
+
+/*
+ * Globals shared among TkAqua.
+ */
+
+MODULE_SCOPE MenuHandle tkCurrentAppleMenu; /* Handle to current Apple Menu */
+MODULE_SCOPE MenuHandle tkAppleMenu;	/* Handle to default Apple Menu */
+MODULE_SCOPE MenuHandle tkFileMenu;	/* Handles to menus */
+MODULE_SCOPE MenuHandle tkEditMenu;	/* Handles to menus */
+MODULE_SCOPE int tkPictureIsOpen;	/* If this is 1, we are drawing to a
+					 * picture The clipping should then be
+					 * done relative to the bounds of the
+					 * picture rather than the window. As
+					 * of OS X.0.4, something is seriously
+					 * wrong: The clipping bounds only
+					 * seem to work if the top,left values
+					 * are 0,0 The destination rectangle
+					 * for CopyBits should also have
+					 * top,left values of 0,0
+					 */
+MODULE_SCOPE TkMacOSXWindowList *tkMacOSXWindowListPtr; /* List of toplevels */
+MODULE_SCOPE Tcl_Encoding TkMacOSXCarbonEncoding;
+
+/*
+ * Prototypes of internal procs not in the stubs table.
+ */
+
+MODULE_SCOPE void TkMacOSXDefaultStartupScript(void);
+#if 0
+MODULE_SCOPE int XSetClipRectangles(Display *d, GC gc, int clip_x_origin,
+	int clip_y_origin, XRectangle* rectangles, int n, int ordering);
+#endif
+MODULE_SCOPE void TkpClipDrawableToRect(Display *display, Drawable d, int x,
+	int y, int width, int height);
+MODULE_SCOPE void TkpRetainRegion(TkRegion r);
+MODULE_SCOPE void TkpReleaseRegion(TkRegion r);
+
+/*
+ * Include the stubbed internal platform-specific API.
+ */
+
+#include "tkIntPlatDecls.h"
+
+#endif /* _TKMACINT */
Index: src/tktext/tk8.5/tkMacOSXPort.h
===================================================================
--- src/tktext/tk8.5/tkMacOSXPort.h	(revision 0)
+++ src/tktext/tk8.5/tkMacOSXPort.h	(working copy)
@@ -0,0 +1,206 @@
+/*
+ * tkMacOSXPort.h --
+ *
+ *	This file is included by all of the Tk C files. It contains
+ *	information that may be configuration-dependent, such as
+ *	#includes for system include files and a few other things.
+ *
+ * Copyright (c) 1994-1996 Sun Microsystems, Inc.
+ * Copyright 2001, Apple Computer, Inc.
+ * Copyright (c) 2005-2007 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkMacOSXPort.h,v 1.13 2007/12/13 15:27:10 dgp Exp $
+ */
+
+#ifndef _TKMACPORT
+#define _TKMACPORT
+
+/*
+ * Macro to use instead of "void" for arguments that must have
+ * type "void *" in ANSI C; maps them to type "char *" in
+ * non-ANSI systems. This macro may be used in some of the include
+ * files below, which is why it is defined here.
+ */
+
+#ifndef VOID
+#   ifdef __STDC__
+#	define VOID void
+#   else
+#	define VOID char
+#   endif
+#endif
+
+#include <stdio.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <math.h>
+#include <pwd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/file.h>
+#ifdef HAVE_SYS_SELECT_H
+#   include <sys/select.h>
+#endif
+#include <sys/stat.h>
+#ifndef _TCL
+#   include <tcl.h>
+#endif
+#if TIME_WITH_SYS_TIME
+#   include <sys/time.h>
+#   include <time.h>
+#else
+#   if HAVE_SYS_TIME_H
+#	include <sys/time.h>
+#   else
+#	include <time.h>
+#   endif
+#endif
+#if HAVE_INTTYPES_H
+#    include <inttypes.h>
+#endif
+#include <unistd.h>
+#include <X11/Xlib.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xfuncproto.h>
+#include <X11/Xutil.h>
+#include "tkIntXlibDecls.h"
+
+/*
+ * The following macro defines the type of the mask arguments to
+ * select:
+ */
+
+#ifndef NO_FD_SET
+#   define SELECT_MASK fd_set
+#else
+#   ifndef _AIX
+	typedef long fd_mask;
+#   endif
+#   if defined(_IBMR2)
+#	define SELECT_MASK void
+#   else
+#	define SELECT_MASK int
+#   endif
+#endif
+
+/*
+ * The following macro defines the number of fd_masks in an fd_set:
+ */
+
+#ifndef FD_SETSIZE
+#   ifdef OPEN_MAX
+#	define FD_SETSIZE OPEN_MAX
+#   else
+#	define FD_SETSIZE 256
+#   endif
+#endif
+#if !defined(howmany)
+#   define howmany(x, y) (((x)+((y)-1))/(y))
+#endif
+#ifndef NFDBITS
+#   define NFDBITS NBBY*sizeof(fd_mask)
+#endif
+#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)
+
+/*
+ * Define "NBBY" (number of bits per byte) if it's not already defined.
+ */
+
+#ifndef NBBY
+#   define NBBY 8
+#endif
+
+/*
+ * The following define causes Tk to use its internal keysym hash table
+ */
+
+#define REDO_KEYSYM_LOOKUP
+
+/*
+ * Defines for X functions that are used by Tk but are treated as
+ * no-op functions on the Macintosh.
+ */
+
+#define XFlush(display)
+#define XFree(data) {if ((data) != NULL) ckfree((char *) (data));}
+#define XGrabServer(display)
+#define XNoOp(display) {display->request++;}
+#define XUngrabServer(display)
+#define XSynchronize(display, bool) {display->request++;}
+#define XVisualIDFromVisual(visual) (visual->visualid)
+
+/*
+ * The following functions are not used on the Mac, so we stub them out.
+ */
+
+#define TkFreeWindowId(dispPtr,w)
+#define TkInitXId(dispPtr)
+#define TkpButtonSetDefaults(specPtr) {}
+#define TkpCmapStressed(tkwin,colormap) (0)
+#define TkpFreeColor(tkColPtr)
+#define TkSetPixmapColormap(p,c) {}
+#define TkpSync(display)
+
+/*
+ * The following macro returns the pixel value that corresponds to the
+ * RGB values in the given XColor structure.
+ */
+
+#define PIXEL_MAGIC ((unsigned char) 0x69)
+#define TkpGetPixel(p) ((((((PIXEL_MAGIC << 8) \
+	| (((p)->red >> 8) & 0xff)) << 8) \
+	| (((p)->green >> 8) & 0xff)) << 8) \
+	| (((p)->blue >> 8) & 0xff))
+
+/*
+ * This macro stores a representation of the window handle in a string.
+ * This should perhaps use the real size of an XID.
+ */
+
+#define TkpPrintWindowId(buf,w) \
+	sprintf((buf), "0x%x", (unsigned int) (w))
+
+/*
+ * TkpScanWindowId is just an alias for Tcl_GetInt on Unix.
+ */
+
+#define TkpScanWindowId(i,s,wp) \
+	Tcl_GetInt((i),(s),(int *) (wp))
+
+/*
+ * Turn off Tk double-buffering as Aqua windows are already double-buffered.
+ */
+
+#define TK_NO_DOUBLE_BUFFERING 1
+
+/*
+ * Magic pixel code values for system colors.
+ *
+ * NOTE: values must be kept in sync with indices into the
+ *	 systemColorMap array in tkMacOSXColor.c !
+ */
+
+#define TRANSPARENT_PIXEL		30
+#define HIGHLIGHT_PIXEL			31
+#define HIGHLIGHT_SECONDARY_PIXEL	32
+#define HIGHLIGHT_TEXT_PIXEL		33
+#define HIGHLIGHT_ALTERNATE_PIXEL	34
+#define CONTROL_TEXT_PIXEL		35
+#define CONTROL_BODY_PIXEL		37
+#define CONTROL_FRAME_PIXEL		39
+#define WINDOW_BODY_PIXEL		41
+#define MENU_ACTIVE_PIXEL		43
+#define MENU_ACTIVE_TEXT_PIXEL		45
+#define MENU_BACKGROUND_PIXEL		47
+#define MENU_DISABLED_PIXEL		49
+#define MENU_TEXT_PIXEL			51
+#define APPEARANCE_PIXEL		52
+
+#endif /* _TKMACPORT */
Index: src/tktext/tk8.5/tkMacOSXPrivate.h
===================================================================
--- src/tktext/tk8.5/tkMacOSXPrivate.h	(revision 0)
+++ src/tktext/tk8.5/tkMacOSXPrivate.h	(working copy)
@@ -0,0 +1,340 @@
+/*
+ * tkMacOSXPrivate.h --
+ *
+ *	Macros and declarations that are purely internal & private to TkAqua.
+ *
+ * Copyright (c) 2005-2007 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkMacOSXPrivate.h,v 1.6.2.2 2008/09/02 16:14:18 das Exp $
+ */
+
+#ifndef _TKMACPRIV
+#define _TKMACPRIV
+
+#ifndef _TKMACINT
+#include "tkMacOSXInt.h"
+#endif
+
+/* Define constants only available on Mac OS X 10.3 or later */
+#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
+    #define kEventAppAvailableWindowBoundsChanged 110
+    #define kEventParamTransactionID 'trns'
+    #define kEventParamWindowPartCode 'wpar'
+    #define typeWindowPartCode 'wpar'
+    #define kMenuAttrDoNotUseUserCommandKeys (1 << 7)
+    #define kSimpleWindowClass 18
+    #define kWindowDoesNotCycleAttribute (1L << 15)
+    #define kWindowAsyncDragAttribute (1L << 23)
+    #define kThemeBrushAlternatePrimaryHighlightColor -5
+    #define kThemeResizeUpCursor 19
+    #define kThemeResizeDownCursor 19
+    #define kThemeResizeUpDownCursor 19
+    #define kThemePoofCursor 19
+    #define kThemeBackgroundMetal 6
+    #define kThemeIncDecButtonSmall 21
+    #define kThemeIncDecButtonMini 22
+    #define kThemeComboBox 16
+    #define kThemeMiniSystemFont 109
+    #define kAppearancePartUpButton 20
+    #define kAppearancePartDownButton 21
+    #define kAppearancePartPageUpArea 22
+    #define kAppearancePartPageDownArea 23
+    #define kAppearancePartIndicator 129
+    #define kUIModeAllSuppressed 4
+    #define FixedToInt(a) ((short)(((Fixed)(a) + fixed1/2) >> 16))
+    #define IntToFixed(a) ((Fixed)(a) << 16)
+#endif
+/* Define constants only available on Mac OS X 10.4 or later */
+#if MAC_OS_X_VERSION_MAX_ALLOWED < 1040
+    #define kWindowNoTitleBarAttribute (1L << 9)
+    #define kWindowMetalNoContentSeparatorAttribute (1L << 11)
+    #define kThemeDisclosureTriangle 6
+    #define kThemeBrushListViewOddRowBackground 56
+    #define kThemeBrushListViewEvenRowBackground 57
+    #define kThemeBrushListViewColumnDivider 58
+    #define kThemeMetricScrollBarMinThumbHeight 132
+    #define kThemeMetricSmallScrollBarMinThumbHeight 134
+    #define kThemeScrollBarMedium kThemeMediumScrollBar
+    #define kThemeScrollBarSmall kThemeSmallScrollBar
+    #ifdef __BIG_ENDIAN__
+    #define kCGBitmapByteOrder32Host (4 << 12)
+    #else
+    #define kCGBitmapByteOrder32Host (2 << 12)
+    #endif
+#endif
+/* Define constants only available on Mac OS X 10.5 or later */
+#if MAC_OS_X_VERSION_MAX_ALLOWED < 1050
+    #define kWindowUnifiedTitleAndToolbarAttribute (1L << 7)
+    #define kWindowTexturedSquareCornersAttribute (1L << 10)
+#endif
+/* HIToolbox version constants */
+#ifndef kHIToolboxVersionNumber10_3
+    #define kHIToolboxVersionNumber10_3 (145)
+#endif
+#ifndef kHIToolboxVersionNumber10_4
+    #define kHIToolboxVersionNumber10_4 (219)
+#endif
+#ifndef kHIToolboxVersionNumber10_5
+    #define kHIToolboxVersionNumber10_5 (343)
+#endif
+/* Macros for HIToolbox runtime version checking */
+MODULE_SCOPE float tkMacOSXToolboxVersionNumber;
+#define TK_IF_HI_TOOLBOX(vers, ...) \
+	tk_if_mac_os_x_min_10_##vers(tkMacOSXToolboxVersionNumber >= \
+	kHIToolboxVersionNumber10_##vers, 1, __VA_ARGS__)
+#define TK_ELSE_HI_TOOLBOX(vers, ...) \
+	tk_else_mac_os_x_min_10_##vers(__VA_ARGS__)
+/* Macros for Mac OS X API availability checking */
+#define TK_IF_MAC_OS_X_API(vers, symbol, ...) \
+	tk_if_mac_os_x_10_##vers(symbol != NULL, 1, __VA_ARGS__)
+#define TK_ELSE_MAC_OS_X(vers, ...) \
+	tk_else_mac_os_x_10_##vers(__VA_ARGS__)
+#define TK_IF_MAC_OS_X_API_COND(vers, symbol, cond, ...) \
+	tk_if_mac_os_x_10_##vers(symbol != NULL, cond, __VA_ARGS__)
+#define TK_ELSE(...) \
+	} else { __VA_ARGS__
+#define TK_ENDIF \
+	}
+/* Private macros that implement the checking macros above */
+#define tk_if_mac_os_x_yes(chk, cond, ...) \
+	if (cond) { __VA_ARGS__
+#define tk_else_mac_os_x_yes(...) \
+	} else {
+#define tk_if_mac_os_x_chk(chk, cond, ...) \
+	if ((chk) && (cond)) { __VA_ARGS__
+#define tk_else_mac_os_x_chk(...) \
+	} else { __VA_ARGS__
+#define tk_if_mac_os_x_no(chk, cond, ...) \
+	if (0) {
+#define tk_else_mac_os_x_no(...) \
+	} else { __VA_ARGS__
+/* Private mapping macros defined according to Mac OS X version requirements */
+/* 10.3 Panther */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1030
+#define tk_if_mac_os_x_min_10_3		tk_if_mac_os_x_yes
+#define tk_else_mac_os_x_min_10_3	tk_else_mac_os_x_yes
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1030
+#define tk_if_mac_os_x_10_3		tk_if_mac_os_x_yes
+#define tk_else_mac_os_x_10_3		tk_else_mac_os_x_yes
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#else /* MAC_OS_X_VERSION_MIN_REQUIRED */
+#define tk_if_mac_os_x_min_10_3		tk_if_mac_os_x_chk
+#define tk_else_mac_os_x_min_10_3	tk_else_mac_os_x_chk
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1030
+#define tk_if_mac_os_x_10_3		tk_if_mac_os_x_chk
+#define tk_else_mac_os_x_10_3		tk_else_mac_os_x_chk
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#endif /* MAC_OS_X_VERSION_MIN_REQUIRED */
+#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
+#define tk_if_mac_os_x_10_3		tk_if_mac_os_x_no
+#define tk_else_mac_os_x_10_3		tk_else_mac_os_x_no
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+/* 10.4 Tiger */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1040
+#define tk_if_mac_os_x_min_10_4		tk_if_mac_os_x_yes
+#define tk_else_mac_os_x_min_10_4	tk_else_mac_os_x_yes
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1040
+#define tk_if_mac_os_x_10_4		tk_if_mac_os_x_yes
+#define tk_else_mac_os_x_10_4		tk_else_mac_os_x_yes
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#else /* MAC_OS_X_VERSION_MIN_REQUIRED */
+#define tk_if_mac_os_x_min_10_4		tk_if_mac_os_x_chk
+#define tk_else_mac_os_x_min_10_4	tk_else_mac_os_x_chk
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1040
+#define tk_if_mac_os_x_10_4		tk_if_mac_os_x_chk
+#define tk_else_mac_os_x_10_4		tk_else_mac_os_x_chk
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#endif /* MAC_OS_X_VERSION_MIN_REQUIRED */
+#if MAC_OS_X_VERSION_MAX_ALLOWED < 1040
+#define tk_if_mac_os_x_10_4		tk_if_mac_os_x_no
+#define tk_else_mac_os_x_10_4		tk_else_mac_os_x_no
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+/* 10.5 Leopard */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
+#define tk_if_mac_os_x_min_10_5		tk_if_mac_os_x_yes
+#define tk_else_mac_os_x_min_10_5	tk_else_mac_os_x_yes
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1050
+#define tk_if_mac_os_x_10_5		tk_if_mac_os_x_yes
+#define tk_else_mac_os_x_10_5		tk_else_mac_os_x_yes
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#else /* MAC_OS_X_VERSION_MIN_REQUIRED */
+#define tk_if_mac_os_x_min_10_5		tk_if_mac_os_x_chk
+#define tk_else_mac_os_x_min_10_5	tk_else_mac_os_x_chk
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1050
+#define tk_if_mac_os_x_10_5		tk_if_mac_os_x_chk
+#define tk_else_mac_os_x_10_5		tk_else_mac_os_x_chk
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#endif /* MAC_OS_X_VERSION_MIN_REQUIRED */
+#if MAC_OS_X_VERSION_MAX_ALLOWED < 1050
+#define tk_if_mac_os_x_10_5		tk_if_mac_os_x_no
+#define tk_else_mac_os_x_10_5		tk_else_mac_os_x_no
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+
+/*
+ * Macros for DEBUG_ASSERT_MESSAGE et al from Debugging.h.
+ */
+
+#undef kComponentSignatureString
+#undef COMPONENT_SIGNATURE
+#define kComponentSignatureString "TkMacOSX"
+#define COMPONENT_SIGNATURE 'Tk  '
+
+/*
+ * Macros abstracting checks only active in a debug build.
+ */
+
+#ifdef TK_MAC_DEBUG
+/*
+ * Macro to do debug message output.
+ */
+#define TkMacOSXDbgMsg(m, ...) do { \
+	    fprintf(stderr, "%s:%d: %s(): " m "\n", strrchr(__FILE__, '/')+1, \
+	    __LINE__, __func__, ##__VA_ARGS__); \
+	} while (0)
+/*
+ * Macro to do debug API failure message output.
+ */
+#if !defined(DEBUGLEVEL) || !DEBUGLEVEL
+#define TkMacOSXDbgOSErr(f, err) do { \
+	    TkMacOSXDbgMsg("%s failed: %ld", #f, err); \
+	} while (0)
+#else
+#define TkMacOSXDbgOSErr(f, err) do { \
+	    DEBUG_ASSERT_MESSAGE(kComponentSignatureString, #f " failed:", \
+	    __func__, 0, strrchr(__FILE__, '/')+1, __LINE__, err); \
+	} while (0)
+#endif
+/*
+ * Macro to do very common check for noErr return from given API and output
+ * debug message in case of failure.
+ */
+#define ChkErr(f, ...) ({ \
+	OSStatus err = f(__VA_ARGS__); \
+	if (err != noErr) { \
+	    TkMacOSXDbgOSErr(f, err); \
+	} \
+	err;})
+/*
+ * Macro to check emptyness of shared QD tmp region before use in debug builds.
+ */
+#define TkMacOSXCheckTmpQdRgnEmpty() do { \
+	    if (!EmptyRgn(tkMacOSXtmpQdRgn)) { \
+		Tcl_Panic("tkMacOSXtmpQdRgn nonempty"); \
+	    } \
+	} while(0)
+#else /* TK_MAC_DEBUG */
+#define TkMacOSXDbgMsg(m, ...)
+#define TkMacOSXDbgOSErr(f, err)
+#define ChkErr(f, ...) ({f(__VA_ARGS__);})
+#define TkMacOSXCheckTmpQdRgnEmpty()
+#endif /* TK_MAC_DEBUG */
+
+/*
+ * Macro abstracting use of TkMacOSXGetNamedSymbol to init named symbols.
+ */
+
+#define TkMacOSXInitNamedSymbol(module, ret, symbol, ...) \
+    static ret (* symbol)(__VA_ARGS__) = (void*)(-1L); \
+    if (symbol == (void*)(-1L)) { \
+	symbol = TkMacOSXGetNamedSymbol(STRINGIFY(module), \
+		STRINGIFY(_##symbol)); \
+    }
+MODULE_SCOPE void* TkMacOSXGetNamedSymbol(const char* module,
+	const char* symbol);
+
+/*
+ * Structure encapsulating current drawing environment.
+ */
+
+typedef struct TkMacOSXDrawingContext {
+    CGContextRef context;
+    CGrafPtr port, savePort;
+    ThemeDrawingState saveState;
+    RgnHandle saveClip;
+    HIShapeRef clipRgn;
+    PixPatHandle penPat;
+    Rect portBounds;
+    Boolean portChanged;
+} TkMacOSXDrawingContext;
+
+/*
+ * Variables internal to TkAqua.
+ */
+
+MODULE_SCOPE RgnHandle tkMacOSXtmpQdRgn;
+MODULE_SCOPE int tkMacOSXUseCGDrawing;
+
+/*
+ * Prototypes for TkMacOSXRegion.c.
+ */
+
+#if 0
+MODULE_SCOPE void TkMacOSXEmtpyRegion(TkRegion r);
+MODULE_SCOPE int TkMacOSXIsEmptyRegion(TkRegion r);
+#endif
+MODULE_SCOPE HIShapeRef TkMacOSXGetNativeRegion(TkRegion r);
+MODULE_SCOPE void TkMacOSXSetWithNativeRegion(TkRegion r, HIShapeRef rgn);
+MODULE_SCOPE void TkMacOSXOffsetRegion(TkRegion r, short dx, short dy);
+MODULE_SCOPE HIShapeRef TkMacOSXHIShapeCreateEmpty(void);
+MODULE_SCOPE HIMutableShapeRef TkMacOSXHIShapeCreateMutableWithRect(
+	const CGRect *inRect);
+MODULE_SCOPE OSStatus  TkMacOSXHIShapeSetWithShape(
+	HIMutableShapeRef inDestShape, HIShapeRef inSrcShape);
+#if 0
+MODULE_SCOPE OSStatus TkMacOSXHIShapeSetWithRect(HIMutableShapeRef inShape,
+	const CGRect *inRect);
+#endif
+MODULE_SCOPE OSStatus TkMacOSHIShapeDifferenceWithRect(
+	HIMutableShapeRef inShape, const CGRect *inRect);
+MODULE_SCOPE OSStatus TkMacOSHIShapeUnionWithRect(HIMutableShapeRef inShape,
+	const CGRect *inRect);
+MODULE_SCOPE OSStatus TkMacOSHIShapeUnion(HIShapeRef inShape1,
+	HIShapeRef inShape2, HIMutableShapeRef outResult);
+
+/*
+ * Prototypes of TkAqua internal procs.
+ */
+
+MODULE_SCOPE void TkMacOSXDisplayChanged(Display *display);
+MODULE_SCOPE void TkMacOSXInitScrollbarMetrics(void);
+MODULE_SCOPE int TkMacOSXUseAntialiasedText(Tcl_Interp *interp, int enable);
+MODULE_SCOPE void TkMacOSXInitCarbonEvents(Tcl_Interp *interp);
+MODULE_SCOPE int TkMacOSXInitCGDrawing(Tcl_Interp *interp, int enable,
+	int antiAlias);
+MODULE_SCOPE void TkMacOSXInitKeyboard(Tcl_Interp *interp);
+MODULE_SCOPE int TkMacOSXGenerateFocusEvent(Window window, int activeFlag);
+MODULE_SCOPE int TkMacOSXGenerateParentMenuSelectEvent(MenuRef menu);
+MODULE_SCOPE int TkMacOSXGenerateMenuSelectEvent(MenuRef menu,
+	MenuItemIndex index);
+MODULE_SCOPE void TkMacOSXClearActiveMenu(MenuRef menu);
+MODULE_SCOPE WindowClass TkMacOSXWindowClass(TkWindow *winPtr);
+MODULE_SCOPE int TkMacOSXIsWindowZoomed(TkWindow *winPtr);
+MODULE_SCOPE int TkGenerateButtonEventForXPointer(Window window);
+MODULE_SCOPE EventModifiers TkMacOSXModifierState(void);
+MODULE_SCOPE int TkMacOSXSetupDrawingContext(Drawable d, GC gc, int useCG,
+    TkMacOSXDrawingContext *dcPtr);
+MODULE_SCOPE void TkMacOSXRestoreDrawingContext(TkMacOSXDrawingContext *dcPtr);
+MODULE_SCOPE void TkMacOSXSetColorInPort(unsigned long pixel, int fg,
+	PixPatHandle penPat, CGrafPtr port);
+MODULE_SCOPE void TkMacOSXSetColorInContext(unsigned long pixel,
+	CGContextRef context);
+MODULE_SCOPE int TkMacOSXRunTclEventLoop(void);
+MODULE_SCOPE OSStatus TkMacOSXStartTclEventLoopCarbonTimer(void);
+MODULE_SCOPE OSStatus TkMacOSXStopTclEventLoopCarbonTimer(void);
+MODULE_SCOPE void TkMacOSXTrackingLoop(int tracking);
+MODULE_SCOPE OSStatus TkMacOSXReceiveAndDispatchEvent(void);
+MODULE_SCOPE void TkMacOSXInstallWindowCarbonEventHandler(Tcl_Interp *interp,
+	WindowRef window);
+MODULE_SCOPE int TkMacOSXMakeFullscreen(TkWindow *winPtr, WindowRef window,
+	int fullscreen, Tcl_Interp *interp);
+MODULE_SCOPE void TkMacOSXEnterExitFullscreen(TkWindow *winPtr, int active);
+MODULE_SCOPE void TkMacOSXBringWindowForward(WindowRef wRef);
+MODULE_SCOPE WindowRef TkMacOSXDrawableWindow(Drawable drawable);
+MODULE_SCOPE void TkMacOSXWinCGBounds(TkWindow *winPtr, CGRect *bounds);
+MODULE_SCOPE HIShapeRef TkMacOSXGetClipRgn(Drawable drawable);
+MODULE_SCOPE Tcl_Obj* TkMacOSXGetStringObjFromCFString(CFStringRef str);
+
+#endif /* _TKMACPRIV */
Index: src/tktext/tk8.5/tkPlatDecls.h
===================================================================
--- src/tktext/tk8.5/tkPlatDecls.h	(revision 0)
+++ src/tktext/tk8.5/tkPlatDecls.h	(working copy)
@@ -0,0 +1,253 @@
+/*
+ * tkPlatDecls.h --
+ *
+ *	Declarations of functions in the platform-specific public Tcl API.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkPlatDecls.h,v 1.15 2007/12/13 15:24:16 dgp Exp $
+ */
+
+#ifndef _TKPLATDECLS
+#define _TKPLATDECLS
+
+#ifdef BUILD_tk
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tk.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+#ifdef __WIN32__ /* WIN */
+#ifndef Tk_AttachHWND_TCL_DECLARED
+#define Tk_AttachHWND_TCL_DECLARED
+/* 0 */
+EXTERN Window		Tk_AttachHWND (Tk_Window tkwin, HWND hwnd);
+#endif
+#ifndef Tk_GetHINSTANCE_TCL_DECLARED
+#define Tk_GetHINSTANCE_TCL_DECLARED
+/* 1 */
+EXTERN HINSTANCE	Tk_GetHINSTANCE (void);
+#endif
+#ifndef Tk_GetHWND_TCL_DECLARED
+#define Tk_GetHWND_TCL_DECLARED
+/* 2 */
+EXTERN HWND		Tk_GetHWND (Window window);
+#endif
+#ifndef Tk_HWNDToWindow_TCL_DECLARED
+#define Tk_HWNDToWindow_TCL_DECLARED
+/* 3 */
+EXTERN Tk_Window	Tk_HWNDToWindow (HWND hwnd);
+#endif
+#ifndef Tk_PointerEvent_TCL_DECLARED
+#define Tk_PointerEvent_TCL_DECLARED
+/* 4 */
+EXTERN void		Tk_PointerEvent (HWND hwnd, int x, int y);
+#endif
+#ifndef Tk_TranslateWinEvent_TCL_DECLARED
+#define Tk_TranslateWinEvent_TCL_DECLARED
+/* 5 */
+EXTERN int		Tk_TranslateWinEvent (HWND hwnd, UINT message, 
+				WPARAM wParam, LPARAM lParam, 
+				LRESULT * result);
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef Tk_MacOSXSetEmbedHandler_TCL_DECLARED
+#define Tk_MacOSXSetEmbedHandler_TCL_DECLARED
+/* 0 */
+EXTERN void		Tk_MacOSXSetEmbedHandler (
+				Tk_MacOSXEmbedRegisterWinProc * registerWinProcPtr, 
+				Tk_MacOSXEmbedGetGrafPortProc * getPortProcPtr, 
+				Tk_MacOSXEmbedMakeContainerExistProc * containerExistProcPtr, 
+				Tk_MacOSXEmbedGetClipProc * getClipProc, 
+				Tk_MacOSXEmbedGetOffsetInParentProc * getOffsetProc);
+#endif
+#ifndef Tk_MacOSXTurnOffMenus_TCL_DECLARED
+#define Tk_MacOSXTurnOffMenus_TCL_DECLARED
+/* 1 */
+EXTERN void		Tk_MacOSXTurnOffMenus (void);
+#endif
+#ifndef Tk_MacOSXTkOwnsCursor_TCL_DECLARED
+#define Tk_MacOSXTkOwnsCursor_TCL_DECLARED
+/* 2 */
+EXTERN void		Tk_MacOSXTkOwnsCursor (int tkOwnsIt);
+#endif
+#ifndef TkMacOSXInitMenus_TCL_DECLARED
+#define TkMacOSXInitMenus_TCL_DECLARED
+/* 3 */
+EXTERN void		TkMacOSXInitMenus (Tcl_Interp * interp);
+#endif
+#ifndef TkMacOSXInitAppleEvents_TCL_DECLARED
+#define TkMacOSXInitAppleEvents_TCL_DECLARED
+/* 4 */
+EXTERN void		TkMacOSXInitAppleEvents (Tcl_Interp * interp);
+#endif
+#ifndef TkGenWMConfigureEvent_TCL_DECLARED
+#define TkGenWMConfigureEvent_TCL_DECLARED
+/* 5 */
+EXTERN void		TkGenWMConfigureEvent (Tk_Window tkwin, int x, int y, 
+				int width, int height, int flags);
+#endif
+#ifndef TkMacOSXInvalClipRgns_TCL_DECLARED
+#define TkMacOSXInvalClipRgns_TCL_DECLARED
+/* 6 */
+EXTERN void		TkMacOSXInvalClipRgns (Tk_Window tkwin);
+#endif
+#ifndef TkMacOSXGetDrawablePort_TCL_DECLARED
+#define TkMacOSXGetDrawablePort_TCL_DECLARED
+/* 7 */
+EXTERN GWorldPtr	TkMacOSXGetDrawablePort (Drawable drawable);
+#endif
+#ifndef TkMacOSXGetRootControl_TCL_DECLARED
+#define TkMacOSXGetRootControl_TCL_DECLARED
+/* 8 */
+EXTERN ControlRef	TkMacOSXGetRootControl (Drawable drawable);
+#endif
+#ifndef Tk_MacOSXSetupTkNotifier_TCL_DECLARED
+#define Tk_MacOSXSetupTkNotifier_TCL_DECLARED
+/* 9 */
+EXTERN void		Tk_MacOSXSetupTkNotifier (void);
+#endif
+#ifndef Tk_MacOSXIsAppInFront_TCL_DECLARED
+#define Tk_MacOSXIsAppInFront_TCL_DECLARED
+/* 10 */
+EXTERN int		Tk_MacOSXIsAppInFront (void);
+#endif
+#endif /* AQUA */
+
+typedef struct TkPlatStubs {
+    int magic;
+    struct TkPlatStubHooks *hooks;
+
+#ifdef __WIN32__ /* WIN */
+    Window (*tk_AttachHWND) (Tk_Window tkwin, HWND hwnd); /* 0 */
+    HINSTANCE (*tk_GetHINSTANCE) (void); /* 1 */
+    HWND (*tk_GetHWND) (Window window); /* 2 */
+    Tk_Window (*tk_HWNDToWindow) (HWND hwnd); /* 3 */
+    void (*tk_PointerEvent) (HWND hwnd, int x, int y); /* 4 */
+    int (*tk_TranslateWinEvent) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT * result); /* 5 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*tk_MacOSXSetEmbedHandler) (Tk_MacOSXEmbedRegisterWinProc * registerWinProcPtr, Tk_MacOSXEmbedGetGrafPortProc * getPortProcPtr, Tk_MacOSXEmbedMakeContainerExistProc * containerExistProcPtr, Tk_MacOSXEmbedGetClipProc * getClipProc, Tk_MacOSXEmbedGetOffsetInParentProc * getOffsetProc); /* 0 */
+    void (*tk_MacOSXTurnOffMenus) (void); /* 1 */
+    void (*tk_MacOSXTkOwnsCursor) (int tkOwnsIt); /* 2 */
+    void (*tkMacOSXInitMenus) (Tcl_Interp * interp); /* 3 */
+    void (*tkMacOSXInitAppleEvents) (Tcl_Interp * interp); /* 4 */
+    void (*tkGenWMConfigureEvent) (Tk_Window tkwin, int x, int y, int width, int height, int flags); /* 5 */
+    void (*tkMacOSXInvalClipRgns) (Tk_Window tkwin); /* 6 */
+    GWorldPtr (*tkMacOSXGetDrawablePort) (Drawable drawable); /* 7 */
+    ControlRef (*tkMacOSXGetRootControl) (Drawable drawable); /* 8 */
+    void (*tk_MacOSXSetupTkNotifier) (void); /* 9 */
+    int (*tk_MacOSXIsAppInFront) (void); /* 10 */
+#endif /* AQUA */
+} TkPlatStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern TkPlatStubs *tkPlatStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)
+
+/*
+ * Inline function declarations:
+ */
+
+#ifdef __WIN32__ /* WIN */
+#ifndef Tk_AttachHWND
+#define Tk_AttachHWND \
+	(tkPlatStubsPtr->tk_AttachHWND) /* 0 */
+#endif
+#ifndef Tk_GetHINSTANCE
+#define Tk_GetHINSTANCE \
+	(tkPlatStubsPtr->tk_GetHINSTANCE) /* 1 */
+#endif
+#ifndef Tk_GetHWND
+#define Tk_GetHWND \
+	(tkPlatStubsPtr->tk_GetHWND) /* 2 */
+#endif
+#ifndef Tk_HWNDToWindow
+#define Tk_HWNDToWindow \
+	(tkPlatStubsPtr->tk_HWNDToWindow) /* 3 */
+#endif
+#ifndef Tk_PointerEvent
+#define Tk_PointerEvent \
+	(tkPlatStubsPtr->tk_PointerEvent) /* 4 */
+#endif
+#ifndef Tk_TranslateWinEvent
+#define Tk_TranslateWinEvent \
+	(tkPlatStubsPtr->tk_TranslateWinEvent) /* 5 */
+#endif
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#ifndef Tk_MacOSXSetEmbedHandler
+#define Tk_MacOSXSetEmbedHandler \
+	(tkPlatStubsPtr->tk_MacOSXSetEmbedHandler) /* 0 */
+#endif
+#ifndef Tk_MacOSXTurnOffMenus
+#define Tk_MacOSXTurnOffMenus \
+	(tkPlatStubsPtr->tk_MacOSXTurnOffMenus) /* 1 */
+#endif
+#ifndef Tk_MacOSXTkOwnsCursor
+#define Tk_MacOSXTkOwnsCursor \
+	(tkPlatStubsPtr->tk_MacOSXTkOwnsCursor) /* 2 */
+#endif
+#ifndef TkMacOSXInitMenus
+#define TkMacOSXInitMenus \
+	(tkPlatStubsPtr->tkMacOSXInitMenus) /* 3 */
+#endif
+#ifndef TkMacOSXInitAppleEvents
+#define TkMacOSXInitAppleEvents \
+	(tkPlatStubsPtr->tkMacOSXInitAppleEvents) /* 4 */
+#endif
+#ifndef TkGenWMConfigureEvent
+#define TkGenWMConfigureEvent \
+	(tkPlatStubsPtr->tkGenWMConfigureEvent) /* 5 */
+#endif
+#ifndef TkMacOSXInvalClipRgns
+#define TkMacOSXInvalClipRgns \
+	(tkPlatStubsPtr->tkMacOSXInvalClipRgns) /* 6 */
+#endif
+#ifndef TkMacOSXGetDrawablePort
+#define TkMacOSXGetDrawablePort \
+	(tkPlatStubsPtr->tkMacOSXGetDrawablePort) /* 7 */
+#endif
+#ifndef TkMacOSXGetRootControl
+#define TkMacOSXGetRootControl \
+	(tkPlatStubsPtr->tkMacOSXGetRootControl) /* 8 */
+#endif
+#ifndef Tk_MacOSXSetupTkNotifier
+#define Tk_MacOSXSetupTkNotifier \
+	(tkPlatStubsPtr->tk_MacOSXSetupTkNotifier) /* 9 */
+#endif
+#ifndef Tk_MacOSXIsAppInFront
+#define Tk_MacOSXIsAppInFront \
+	(tkPlatStubsPtr->tk_MacOSXIsAppInFront) /* 10 */
+#endif
+#endif /* AQUA */
+
+#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TKPLATDECLS */
Index: src/tktext/tk8.5/tkPort.h
===================================================================
--- src/tktext/tk8.5/tkPort.h	(revision 0)
+++ src/tktext/tk8.5/tkPort.h	(working copy)
@@ -0,0 +1,36 @@
+/*
+ * tkPort.h --
+ *
+ *	This header file handles porting issues that occur because of
+ *	differences between systems.  It reads in platform specific
+ *	portability files.
+ *
+ * Copyright (c) 1995 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkPort.h,v 1.6 2004/04/24 06:00:18 das Exp $
+ */
+
+#ifndef _TKPORT
+#define _TKPORT
+
+#ifndef _TK
+#include "tk.h"
+#endif
+#ifndef _TCL
+#include "tcl.h"
+#endif
+
+#if defined(__WIN32__) || defined(_WIN32)
+#   include "tkWinPort.h"
+#else
+#   if defined(MAC_OSX_TK)
+#	include "tkMacOSXPort.h"
+#   else
+#	include "tkUnixPort.h"
+#   endif
+#endif
+
+#endif /* _TKPORT */
Index: src/tktext/tk8.5/tkUnixDefault.h
===================================================================
--- src/tktext/tk8.5/tkUnixDefault.h	(revision 0)
+++ src/tktext/tk8.5/tkUnixDefault.h	(working copy)
@@ -0,0 +1,526 @@
+/*
+ * tkUnixDefault.h --
+ *
+ *	This file defines the defaults for all options for all of
+ *	the Tk widgets.
+ *
+ * Copyright (c) 1991-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkUnixDefault.h,v 1.26 2007/12/13 15:28:50 dgp Exp $
+ */
+
+#ifndef _TKUNIXDEFAULT
+#define _TKUNIXDEFAULT
+
+/*
+ * The definitions below provide symbolic names for the default colors.
+ * NORMAL_BG -		Normal background color.
+ * ACTIVE_BG -		Background color when widget is active.
+ * SELECT_BG -		Background color for selected text.
+ * TROUGH -		Background color for troughs in scales and scrollbars.
+ * INDICATOR -		Color for indicator when button is selected.
+ * DISABLED -		Foreground color when widget is disabled.
+ */
+
+#define BLACK		"#000000"
+#define WHITE		"#ffffff"
+
+#define NORMAL_BG	"#d9d9d9"
+#define ACTIVE_BG	"#ececec"
+#define SELECT_BG	"#c3c3c3"
+#define TROUGH		"#b3b3b3"
+#define CHECK_INDICATOR	WHITE
+#define MENU_INDICATOR  BLACK
+#define DISABLED	"#a3a3a3"
+
+/*
+ * Defaults for labels, buttons, checkbuttons, and radiobuttons:
+ */
+
+#define DEF_BUTTON_ANCHOR		"center"
+#define DEF_BUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_BUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_BUTTON_ACTIVE_FG_COLOR	BLACK
+#define DEF_CHKRAD_ACTIVE_FG_COLOR	DEF_BUTTON_ACTIVE_FG_COLOR
+#define DEF_BUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_BUTTON_BG_COLOR		NORMAL_BG
+#define DEF_BUTTON_BG_MONO		WHITE
+#define DEF_BUTTON_BITMAP		""
+#define DEF_BUTTON_BORDER_WIDTH		"1"
+#define DEF_BUTTON_CURSOR		""
+#define DEF_BUTTON_COMPOUND		"none"
+#define DEF_BUTTON_COMMAND		""
+#define DEF_BUTTON_DEFAULT		"disabled"
+#define DEF_BUTTON_DISABLED_FG_COLOR	DISABLED
+#define DEF_BUTTON_DISABLED_FG_MONO	""
+#define DEF_BUTTON_FG			BLACK
+#define DEF_CHKRAD_FG			DEF_BUTTON_FG
+#define DEF_BUTTON_FONT			"TkDefaultFont"
+#define DEF_BUTTON_HEIGHT		"0"
+#define DEF_BUTTON_HIGHLIGHT_BG_COLOR	DEF_BUTTON_BG_COLOR
+#define DEF_BUTTON_HIGHLIGHT_BG_MONO	DEF_BUTTON_BG_MONO
+#define DEF_BUTTON_HIGHLIGHT		BLACK
+#define DEF_LABEL_HIGHLIGHT_WIDTH	"0"
+#define DEF_BUTTON_HIGHLIGHT_WIDTH	"1"
+#define DEF_BUTTON_IMAGE		(char *) NULL
+#define DEF_BUTTON_INDICATOR		"1"
+#define DEF_BUTTON_JUSTIFY		"center"
+#define DEF_BUTTON_OFF_VALUE		"0"
+#define DEF_BUTTON_ON_VALUE		"1"
+#define DEF_BUTTON_TRISTATE_VALUE	""
+#define DEF_BUTTON_OVER_RELIEF		""
+#define DEF_BUTTON_PADX			"3m"
+#define DEF_LABCHKRAD_PADX		"1"
+#define DEF_BUTTON_PADY			"1m"
+#define DEF_LABCHKRAD_PADY		"1"
+#define DEF_BUTTON_RELIEF		"raised"
+#define DEF_LABCHKRAD_RELIEF		"flat"
+#define DEF_BUTTON_REPEAT_DELAY		"0"
+#define DEF_BUTTON_REPEAT_INTERVAL	"0"
+#define DEF_BUTTON_SELECT_COLOR		CHECK_INDICATOR
+#define DEF_BUTTON_SELECT_MONO		BLACK
+#define DEF_BUTTON_SELECT_IMAGE		(char *) NULL
+#define DEF_BUTTON_STATE		"normal"
+#define DEF_LABEL_TAKE_FOCUS		"0"
+#define DEF_BUTTON_TAKE_FOCUS		(char *) NULL
+#define DEF_BUTTON_TEXT			""
+#define DEF_BUTTON_TEXT_VARIABLE	""
+#define DEF_BUTTON_UNDERLINE		"-1"
+#define DEF_BUTTON_VALUE		""
+#define DEF_BUTTON_WIDTH		"0"
+#define DEF_BUTTON_WRAP_LENGTH		"0"
+#define DEF_RADIOBUTTON_VARIABLE	"selectedButton"
+#define DEF_CHECKBUTTON_VARIABLE	""
+
+/*
+ * Defaults for canvases:
+ */
+
+#define DEF_CANVAS_BG_COLOR		NORMAL_BG
+#define DEF_CANVAS_BG_MONO		WHITE
+#define DEF_CANVAS_BORDER_WIDTH		"0"
+#define DEF_CANVAS_CLOSE_ENOUGH		"1"
+#define DEF_CANVAS_CONFINE		"1"
+#define DEF_CANVAS_CURSOR		""
+#define DEF_CANVAS_HEIGHT		"7c"
+#define DEF_CANVAS_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_CANVAS_HIGHLIGHT		BLACK
+#define DEF_CANVAS_HIGHLIGHT_WIDTH	"1"
+#define DEF_CANVAS_INSERT_BG		BLACK
+#define DEF_CANVAS_INSERT_BD_COLOR	"0"
+#define DEF_CANVAS_INSERT_BD_MONO	"0"
+#define DEF_CANVAS_INSERT_OFF_TIME	"300"
+#define DEF_CANVAS_INSERT_ON_TIME	"600"
+#define DEF_CANVAS_INSERT_WIDTH		"2"
+#define DEF_CANVAS_RELIEF		"flat"
+#define DEF_CANVAS_SCROLL_REGION	""
+#define DEF_CANVAS_SELECT_COLOR		SELECT_BG
+#define DEF_CANVAS_SELECT_MONO		BLACK
+#define DEF_CANVAS_SELECT_BD_COLOR	"1"
+#define DEF_CANVAS_SELECT_BD_MONO	"0"
+#define DEF_CANVAS_SELECT_FG_COLOR	BLACK
+#define DEF_CANVAS_SELECT_FG_MONO	WHITE
+#define DEF_CANVAS_TAKE_FOCUS		(char *) NULL
+#define DEF_CANVAS_WIDTH		"10c"
+#define DEF_CANVAS_X_SCROLL_CMD		""
+#define DEF_CANVAS_X_SCROLL_INCREMENT	"0"
+#define DEF_CANVAS_Y_SCROLL_CMD		""
+#define DEF_CANVAS_Y_SCROLL_INCREMENT	"0"
+
+/*
+ * Defaults for entries:
+ */
+
+#define DEF_ENTRY_BG_COLOR		WHITE
+#define DEF_ENTRY_BG_MONO		WHITE
+#define DEF_ENTRY_BORDER_WIDTH		"1"
+#define DEF_ENTRY_CURSOR		"xterm"
+#define DEF_ENTRY_DISABLED_BG_COLOR	NORMAL_BG
+#define DEF_ENTRY_DISABLED_BG_MONO	WHITE
+#define DEF_ENTRY_DISABLED_FG		DISABLED
+#define DEF_ENTRY_EXPORT_SELECTION	"1"
+#define DEF_ENTRY_FONT			"TkTextFont"
+#define DEF_ENTRY_FG			BLACK
+#define DEF_ENTRY_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_ENTRY_HIGHLIGHT		BLACK
+#define DEF_ENTRY_HIGHLIGHT_WIDTH	"1"
+#define DEF_ENTRY_INSERT_BG		BLACK
+#define DEF_ENTRY_INSERT_BD_COLOR	"0"
+#define DEF_ENTRY_INSERT_BD_MONO	"0"
+#define DEF_ENTRY_INSERT_OFF_TIME	"300"
+#define DEF_ENTRY_INSERT_ON_TIME	"600"
+#define DEF_ENTRY_INSERT_WIDTH		"2"
+#define DEF_ENTRY_JUSTIFY		"left"
+#define DEF_ENTRY_READONLY_BG_COLOR	NORMAL_BG
+#define DEF_ENTRY_READONLY_BG_MONO	WHITE
+#define DEF_ENTRY_RELIEF		"sunken"
+#define DEF_ENTRY_SCROLL_COMMAND	""
+#define DEF_ENTRY_SELECT_COLOR		SELECT_BG
+#define DEF_ENTRY_SELECT_MONO		BLACK
+#define DEF_ENTRY_SELECT_BD_COLOR	"0"
+#define DEF_ENTRY_SELECT_BD_MONO	"0"
+#define DEF_ENTRY_SELECT_FG_COLOR	BLACK
+#define DEF_ENTRY_SELECT_FG_MONO	WHITE
+#define DEF_ENTRY_SHOW			(char *) NULL
+#define DEF_ENTRY_STATE			"normal"
+#define DEF_ENTRY_TAKE_FOCUS		(char *) NULL
+#define DEF_ENTRY_TEXT_VARIABLE		""
+#define DEF_ENTRY_WIDTH			"20"
+
+/*
+ * Defaults for frames:
+ */
+
+#define DEF_FRAME_BG_COLOR		NORMAL_BG
+#define DEF_FRAME_BG_MONO		WHITE
+#define DEF_FRAME_BORDER_WIDTH		"0"
+#define DEF_FRAME_CLASS			"Frame"
+#define DEF_FRAME_COLORMAP		""
+#define DEF_FRAME_CONTAINER		"0"
+#define DEF_FRAME_CURSOR		""
+#define DEF_FRAME_HEIGHT		"0"
+#define DEF_FRAME_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_FRAME_HIGHLIGHT		BLACK
+#define DEF_FRAME_HIGHLIGHT_WIDTH	"0"
+#define DEF_FRAME_LABEL			""
+#define DEF_FRAME_PADX			"0"
+#define DEF_FRAME_PADY			"0"
+#define DEF_FRAME_RELIEF		"flat"
+#define DEF_FRAME_TAKE_FOCUS		"0"
+#define DEF_FRAME_VISUAL		""
+#define DEF_FRAME_WIDTH			"0"
+
+/*
+ * Defaults for labelframes:
+ */
+
+#define DEF_LABELFRAME_BORDER_WIDTH	"2"
+#define DEF_LABELFRAME_CLASS		"Labelframe"
+#define DEF_LABELFRAME_RELIEF		"groove"
+#define DEF_LABELFRAME_FG		BLACK
+#define DEF_LABELFRAME_FONT		"TkDefaultFont"
+#define DEF_LABELFRAME_TEXT		""
+#define DEF_LABELFRAME_LABELANCHOR	"nw"
+
+/*
+ * Defaults for listboxes:
+ */
+
+#define DEF_LISTBOX_ACTIVE_STYLE	"dotbox"
+#define DEF_LISTBOX_BG_COLOR		WHITE
+#define DEF_LISTBOX_BG_MONO		WHITE
+#define DEF_LISTBOX_BORDER_WIDTH	"1"
+#define DEF_LISTBOX_CURSOR		""
+#define DEF_LISTBOX_DISABLED_FG		DISABLED
+#define DEF_LISTBOX_EXPORT_SELECTION	"1"
+#define DEF_LISTBOX_FONT		"TkDefaultFont"
+#define DEF_LISTBOX_FG			BLACK
+#define DEF_LISTBOX_HEIGHT		"10"
+#define DEF_LISTBOX_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_LISTBOX_HIGHLIGHT		BLACK
+#define DEF_LISTBOX_HIGHLIGHT_WIDTH	"1"
+#define DEF_LISTBOX_RELIEF		"sunken"
+#define DEF_LISTBOX_SCROLL_COMMAND	""
+#define DEF_LISTBOX_LIST_VARIABLE	""
+#define DEF_LISTBOX_SELECT_COLOR	SELECT_BG
+#define DEF_LISTBOX_SELECT_MONO		BLACK
+#define DEF_LISTBOX_SELECT_BD		"0"
+#define DEF_LISTBOX_SELECT_FG_COLOR	BLACK
+#define DEF_LISTBOX_SELECT_FG_MONO	WHITE
+#define DEF_LISTBOX_SELECT_MODE		"browse"
+#define DEF_LISTBOX_SET_GRID		"0"
+#define DEF_LISTBOX_STATE		"normal"
+#define DEF_LISTBOX_TAKE_FOCUS		(char *) NULL
+#define DEF_LISTBOX_WIDTH		"20"
+
+/*
+ * Defaults for individual entries of menus:
+ */
+
+#define DEF_MENU_ENTRY_ACTIVE_BG	(char *) NULL
+#define DEF_MENU_ENTRY_ACTIVE_FG	(char *) NULL
+#define DEF_MENU_ENTRY_ACCELERATOR	(char *) NULL
+#define DEF_MENU_ENTRY_BG		(char *) NULL
+#define DEF_MENU_ENTRY_BITMAP		None
+#define DEF_MENU_ENTRY_COLUMN_BREAK	"0"
+#define DEF_MENU_ENTRY_COMMAND		(char *) NULL
+#define DEF_MENU_ENTRY_COMPOUND 	"none"
+#define DEF_MENU_ENTRY_FG		(char *) NULL
+#define DEF_MENU_ENTRY_FONT		(char *) NULL
+#define DEF_MENU_ENTRY_HIDE_MARGIN	"0"
+#define DEF_MENU_ENTRY_IMAGE		(char *) NULL
+#define DEF_MENU_ENTRY_INDICATOR	"1"
+#define DEF_MENU_ENTRY_LABEL		(char *) NULL
+#define DEF_MENU_ENTRY_MENU		(char *) NULL
+#define DEF_MENU_ENTRY_OFF_VALUE	"0"
+#define DEF_MENU_ENTRY_ON_VALUE		"1"
+#define DEF_MENU_ENTRY_SELECT_IMAGE	(char *) NULL
+#define DEF_MENU_ENTRY_STATE		"normal"
+#define DEF_MENU_ENTRY_VALUE		(char *) NULL
+#define DEF_MENU_ENTRY_CHECK_VARIABLE	(char *) NULL
+#define DEF_MENU_ENTRY_RADIO_VARIABLE	"selectedButton"
+#define DEF_MENU_ENTRY_SELECT	(char *) NULL
+#define DEF_MENU_ENTRY_UNDERLINE	"-1"
+
+/*
+ * Defaults for menus overall:
+ */
+
+#define DEF_MENU_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_MENU_ACTIVE_BG_MONO		BLACK
+#define DEF_MENU_ACTIVE_BORDER_WIDTH	"1"
+#define DEF_MENU_ACTIVE_FG_COLOR	BLACK
+#define DEF_MENU_ACTIVE_FG_MONO		WHITE
+#define DEF_MENU_BG_COLOR		NORMAL_BG
+#define DEF_MENU_BG_MONO		WHITE
+#define DEF_MENU_BORDER_WIDTH		"1"
+#define DEF_MENU_CURSOR			"arrow"
+#define DEF_MENU_DISABLED_FG_COLOR	DISABLED
+#define DEF_MENU_DISABLED_FG_MONO	""
+#define DEF_MENU_FONT			"TkMenuFont"
+#define DEF_MENU_FG			BLACK
+#define DEF_MENU_POST_COMMAND		""
+#define DEF_MENU_RELIEF			"raised"
+#define DEF_MENU_SELECT_COLOR		MENU_INDICATOR
+#define DEF_MENU_SELECT_MONO		BLACK
+#define DEF_MENU_TAKE_FOCUS		"0"
+#define DEF_MENU_TEAROFF		"1"
+#define DEF_MENU_TEAROFF_CMD		(char *) NULL
+#define DEF_MENU_TITLE			""
+#define DEF_MENU_TYPE			"normal"
+
+/*
+ * Defaults for menubuttons:
+ */
+
+#define DEF_MENUBUTTON_ANCHOR		"center"
+#define DEF_MENUBUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_MENUBUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_MENUBUTTON_ACTIVE_FG_COLOR	BLACK
+#define DEF_MENUBUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_MENUBUTTON_BG_COLOR		NORMAL_BG
+#define DEF_MENUBUTTON_BG_MONO		WHITE
+#define DEF_MENUBUTTON_BITMAP		""
+#define DEF_MENUBUTTON_BORDER_WIDTH	"1"
+#define DEF_MENUBUTTON_CURSOR		""
+#define DEF_MENUBUTTON_DIRECTION	"below"
+#define DEF_MENUBUTTON_DISABLED_FG_COLOR DISABLED
+#define DEF_MENUBUTTON_DISABLED_FG_MONO	""
+#define DEF_MENUBUTTON_FONT		"TkDefaultFont"
+#define DEF_MENUBUTTON_FG		BLACK
+#define DEF_MENUBUTTON_HEIGHT		"0"
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_COLOR DEF_MENUBUTTON_BG_COLOR
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
+#define DEF_MENUBUTTON_HIGHLIGHT	BLACK
+#define DEF_MENUBUTTON_HIGHLIGHT_WIDTH	"0"
+#define DEF_MENUBUTTON_IMAGE		(char *) NULL
+#define DEF_MENUBUTTON_INDICATOR	"0"
+#define DEF_MENUBUTTON_JUSTIFY		"center"
+#define DEF_MENUBUTTON_MENU		""
+#define DEF_MENUBUTTON_PADX		"4p"
+#define DEF_MENUBUTTON_PADY		"3p"
+#define DEF_MENUBUTTON_RELIEF		"flat"
+#define DEF_MENUBUTTON_STATE		"normal"
+#define DEF_MENUBUTTON_TAKE_FOCUS	"0"
+#define DEF_MENUBUTTON_TEXT		""
+#define DEF_MENUBUTTON_TEXT_VARIABLE	""
+#define DEF_MENUBUTTON_UNDERLINE	"-1"
+#define DEF_MENUBUTTON_WIDTH		"0"
+#define DEF_MENUBUTTON_WRAP_LENGTH	"0"
+
+/*
+ * Defaults for messages:
+ */
+
+#define DEF_MESSAGE_ANCHOR		"center"
+#define DEF_MESSAGE_ASPECT		"150"
+#define DEF_MESSAGE_BG_COLOR		NORMAL_BG
+#define DEF_MESSAGE_BG_MONO		WHITE
+#define DEF_MESSAGE_BORDER_WIDTH	"1"
+#define DEF_MESSAGE_CURSOR		""
+#define DEF_MESSAGE_FG			BLACK
+#define DEF_MESSAGE_FONT		"TkDefaultFont"
+#define DEF_MESSAGE_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_MESSAGE_HIGHLIGHT		BLACK
+#define DEF_MESSAGE_HIGHLIGHT_WIDTH	"0"
+#define DEF_MESSAGE_JUSTIFY		"left"
+#define DEF_MESSAGE_PADX		"-1"
+#define DEF_MESSAGE_PADY		"-1"
+#define DEF_MESSAGE_RELIEF		"flat"
+#define DEF_MESSAGE_TAKE_FOCUS		"0"
+#define DEF_MESSAGE_TEXT		""
+#define DEF_MESSAGE_TEXT_VARIABLE	""
+#define DEF_MESSAGE_WIDTH		"0"
+
+/*
+ * Defaults for panedwindows
+ */
+
+#define DEF_PANEDWINDOW_BG_COLOR	NORMAL_BG
+#define DEF_PANEDWINDOW_BG_MONO		WHITE
+#define DEF_PANEDWINDOW_BORDERWIDTH	"1"
+#define DEF_PANEDWINDOW_CURSOR		""
+#define DEF_PANEDWINDOW_HANDLEPAD	"8"
+#define DEF_PANEDWINDOW_HANDLESIZE	"8"
+#define DEF_PANEDWINDOW_HEIGHT		""
+#define DEF_PANEDWINDOW_OPAQUERESIZE	"1"
+#define DEF_PANEDWINDOW_ORIENT		"horizontal"
+#define DEF_PANEDWINDOW_RELIEF		"flat"
+#define DEF_PANEDWINDOW_SASHCURSOR	""
+#define DEF_PANEDWINDOW_SASHPAD		"0"
+#define DEF_PANEDWINDOW_SASHRELIEF	"flat"
+#define DEF_PANEDWINDOW_SASHWIDTH	"3"
+#define DEF_PANEDWINDOW_SHOWHANDLE	"0"
+#define DEF_PANEDWINDOW_WIDTH		""
+
+/*
+ * Defaults for panedwindow panes
+ */
+
+#define DEF_PANEDWINDOW_PANE_AFTER	""
+#define DEF_PANEDWINDOW_PANE_BEFORE	""
+#define DEF_PANEDWINDOW_PANE_HEIGHT	""
+#define DEF_PANEDWINDOW_PANE_MINSIZE	"0"
+#define DEF_PANEDWINDOW_PANE_PADX	"0"
+#define DEF_PANEDWINDOW_PANE_PADY	"0"
+#define DEF_PANEDWINDOW_PANE_STICKY	"nsew"
+#define DEF_PANEDWINDOW_PANE_WIDTH	""
+#define DEF_PANEDWINDOW_PANE_HIDE	"0"
+#define DEF_PANEDWINDOW_PANE_STRETCH	"last"
+
+/*
+ * Defaults for scales:
+ */
+
+#define DEF_SCALE_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCALE_ACTIVE_BG_MONO	BLACK
+#define DEF_SCALE_BG_COLOR		NORMAL_BG
+#define DEF_SCALE_BG_MONO		WHITE
+#define DEF_SCALE_BIG_INCREMENT		"0"
+#define DEF_SCALE_BORDER_WIDTH		"1"
+#define DEF_SCALE_COMMAND		""
+#define DEF_SCALE_CURSOR		""
+#define DEF_SCALE_DIGITS		"0"
+#define DEF_SCALE_FONT			"TkDefaultFont"
+#define DEF_SCALE_FG_COLOR		BLACK
+#define DEF_SCALE_FG_MONO		BLACK
+#define DEF_SCALE_FROM			"0"
+#define DEF_SCALE_HIGHLIGHT_BG_COLOR	DEF_SCALE_BG_COLOR
+#define DEF_SCALE_HIGHLIGHT_BG_MONO	DEF_SCALE_BG_MONO
+#define DEF_SCALE_HIGHLIGHT		BLACK
+#define DEF_SCALE_HIGHLIGHT_WIDTH	"1"
+#define DEF_SCALE_LABEL			""
+#define DEF_SCALE_LENGTH		"100"
+#define DEF_SCALE_ORIENT		"vertical"
+#define DEF_SCALE_RELIEF		"flat"
+#define DEF_SCALE_REPEAT_DELAY	        "300"
+#define DEF_SCALE_REPEAT_INTERVAL	"100"
+#define DEF_SCALE_RESOLUTION		"1"
+#define DEF_SCALE_TROUGH_COLOR		TROUGH
+#define DEF_SCALE_TROUGH_MONO		WHITE
+#define DEF_SCALE_SHOW_VALUE		"1"
+#define DEF_SCALE_SLIDER_LENGTH		"30"
+#define DEF_SCALE_SLIDER_RELIEF		"raised"
+#define DEF_SCALE_STATE			"normal"
+#define DEF_SCALE_TAKE_FOCUS		(char *) NULL
+#define DEF_SCALE_TICK_INTERVAL		"0"
+#define DEF_SCALE_TO			"100"
+#define DEF_SCALE_VARIABLE		""
+#define DEF_SCALE_WIDTH			"15"
+
+/*
+ * Defaults for scrollbars:
+ */
+
+#define DEF_SCROLLBAR_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCROLLBAR_ACTIVE_BG_MONO	BLACK
+#define DEF_SCROLLBAR_ACTIVE_RELIEF	"raised"
+#define DEF_SCROLLBAR_BG_COLOR		NORMAL_BG
+#define DEF_SCROLLBAR_BG_MONO		WHITE
+#define DEF_SCROLLBAR_BORDER_WIDTH	"1"
+#define DEF_SCROLLBAR_COMMAND		""
+#define DEF_SCROLLBAR_CURSOR		""
+#define DEF_SCROLLBAR_EL_BORDER_WIDTH	"-1"
+#define DEF_SCROLLBAR_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_SCROLLBAR_HIGHLIGHT		BLACK
+#define DEF_SCROLLBAR_HIGHLIGHT_WIDTH	"0"
+#define DEF_SCROLLBAR_JUMP		"0"
+#define DEF_SCROLLBAR_ORIENT		"vertical"
+#define DEF_SCROLLBAR_RELIEF		"sunken"
+#define DEF_SCROLLBAR_REPEAT_DELAY	"300"
+#define DEF_SCROLLBAR_REPEAT_INTERVAL	"100"
+#define DEF_SCROLLBAR_TAKE_FOCUS	(char *) NULL
+#define DEF_SCROLLBAR_TROUGH_COLOR	TROUGH
+#define DEF_SCROLLBAR_TROUGH_MONO	WHITE
+#define DEF_SCROLLBAR_WIDTH		"11"
+
+/*
+ * Defaults for texts:
+ */
+
+#define DEF_TEXT_AUTO_SEPARATORS	"1"
+#define DEF_TEXT_BG_COLOR		WHITE
+#define DEF_TEXT_BG_MONO		WHITE
+#define DEF_TEXT_BLOCK_CURSOR		"0"
+#define DEF_TEXT_BORDER_WIDTH		"1"
+#define DEF_TEXT_CURSOR			"xterm"
+#define DEF_TEXT_FG			BLACK
+#define DEF_TEXT_EXPORT_SELECTION	"1"
+#define DEF_TEXT_FONT			"TkFixedFont"
+#define DEF_TEXT_HEIGHT			"24"
+#define DEF_TEXT_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_TEXT_HIGHLIGHT		BLACK
+#define DEF_TEXT_HIGHLIGHT_WIDTH	"1"
+#define DEF_TEXT_INSERT_BG		BLACK
+#define DEF_TEXT_INSERT_BD_COLOR	"0"
+#define DEF_TEXT_INSERT_BD_MONO		"0"
+#define DEF_TEXT_INSERT_OFF_TIME	"300"
+#define DEF_TEXT_INSERT_ON_TIME		"600"
+#define DEF_TEXT_INSERT_WIDTH		"2"
+#define DEF_TEXT_MAX_UNDO    	"0"
+#define DEF_TEXT_PADX			"1"
+#define DEF_TEXT_PADY			"1"
+#define DEF_TEXT_RELIEF			"sunken"
+#define DEF_TEXT_INACTIVE_SELECT_COLOR	SELECT_BG
+#define DEF_TEXT_SELECT_COLOR		SELECT_BG
+#define DEF_TEXT_SELECT_MONO		BLACK
+#define DEF_TEXT_SELECT_BD_COLOR	"0"
+#define DEF_TEXT_SELECT_BD_MONO		"0"
+#define DEF_TEXT_SELECT_FG_COLOR	BLACK
+#define DEF_TEXT_SELECT_FG_MONO		WHITE
+#define DEF_TEXT_SELECT_RELIEF		"raised"
+#define DEF_TEXT_SET_GRID		"0"
+#define DEF_TEXT_SPACING1		"0"
+#define DEF_TEXT_SPACING2		"0"
+#define DEF_TEXT_SPACING3		"0"
+#define DEF_TEXT_STATE			"normal"
+#define DEF_TEXT_TABS			""
+#define DEF_TEXT_TABSTYLE		"tabular"
+#define DEF_TEXT_TAKE_FOCUS		(char *) NULL
+#define DEF_TEXT_UNDO    		"0"
+#define DEF_TEXT_WIDTH			"80"
+#define DEF_TEXT_WRAP			"char"
+#define DEF_TEXT_XSCROLL_COMMAND	""
+#define DEF_TEXT_YSCROLL_COMMAND	""
+
+/*
+ * Defaults for canvas text:
+ */
+
+#define DEF_CANVTEXT_FONT		"TkDefaultFont"
+
+/*
+ * Defaults for toplevels (most of the defaults for frames also apply
+ * to toplevels):
+ */
+
+#define DEF_TOPLEVEL_CLASS		"Toplevel"
+#define DEF_TOPLEVEL_MENU		""
+#define DEF_TOPLEVEL_SCREEN		""
+#define DEF_TOPLEVEL_USE		""
+
+#endif /* _TKUNIXDEFAULT */
Index: src/tktext/tk8.5/tkUnixPort.h
===================================================================
--- src/tktext/tk8.5/tkUnixPort.h	(revision 0)
+++ src/tktext/tk8.5/tkUnixPort.h	(working copy)
@@ -0,0 +1,218 @@
+/*
+ * tkUnixPort.h --
+ *
+ *	This file is included by all of the Tk C files.  It contains
+ *	information that may be configuration-dependent, such as
+ *	#includes for system include files and a few other things.
+ *
+ * Copyright (c) 1991-1993 The Regents of the University of California.
+ * Copyright (c) 1994-1996 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkUnixPort.h,v 1.14 2007/12/13 15:28:50 dgp Exp $
+ */
+
+#ifndef _UNIXPORT
+#define _UNIXPORT
+
+#define __UNIX__ 1
+
+/*
+ * Macro to use instead of "void" for arguments that must have
+ * type "void *" in ANSI C;  maps them to type "char *" in
+ * non-ANSI systems.  This macro may be used in some of the include
+ * files below, which is why it is defined here.
+ */
+
+#ifndef VOID
+#   ifdef __STDC__
+#       define VOID void
+#   else
+#       define VOID char
+#   endif
+#endif
+
+#include <stdio.h>
+#include <ctype.h>
+#include <fcntl.h>
+#ifndef NO_LIMITS_H
+#   include <limits.h>
+#else
+#   include "../compat/limits.h"
+#endif
+#include <math.h>
+#include <pwd.h>
+#ifdef NO_STDLIB_H
+#   include "../compat/stdlib.h"
+#else
+#   include <stdlib.h>
+#endif
+#include <string.h>
+#include <sys/types.h>
+#include <sys/file.h>
+#ifdef HAVE_SYS_SELECT_H
+#   include <sys/select.h>
+#endif
+#include <sys/stat.h>
+#ifndef _TCL
+#   include <tcl.h>
+#endif
+#if TIME_WITH_SYS_TIME
+#   include <sys/time.h>
+#   include <time.h>
+#else
+#   if HAVE_SYS_TIME_H
+#       include <sys/time.h>
+#   else
+#       include <time.h>
+#   endif
+#endif
+#if HAVE_INTTYPES_H
+#    include <inttypes.h>
+#endif
+#ifndef NO_UNISTD_H
+#   include <unistd.h>
+#else
+#   include "../compat/unistd.h"
+#endif
+#include <X11/Xlib.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xproto.h>
+#include <X11/Xresource.h>
+#include <X11/Xutil.h>
+
+/*
+ * The following macro defines the type of the mask arguments to
+ * select:
+ */
+
+#ifndef NO_FD_SET
+#   define SELECT_MASK fd_set
+#else
+#   ifndef _AIX
+	typedef long fd_mask;
+#   endif
+#   if defined(_IBMR2)
+#	define SELECT_MASK void
+#   else
+#	define SELECT_MASK int
+#   endif
+#endif
+
+/*
+ * The following macro defines the number of fd_masks in an fd_set:
+ */
+
+#ifndef FD_SETSIZE
+#   ifdef OPEN_MAX
+#	define FD_SETSIZE OPEN_MAX
+#   else
+#	define FD_SETSIZE 256
+#   endif
+#endif
+#if !defined(howmany)
+#   define howmany(x, y) (((x)+((y)-1))/(y))
+#endif
+#ifndef NFDBITS
+#   define NFDBITS NBBY*sizeof(fd_mask)
+#endif
+#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)
+
+/*
+ * Define "NBBY" (number of bits per byte) if it's not already defined.
+ */
+
+#ifndef NBBY
+#   define NBBY 8
+#endif
+
+/*
+ * These macros are just wrappers for the equivalent X Region calls.
+ */
+
+#define TkClipBox(rgn, rect) XClipBox((Region) rgn, rect)
+#define TkCreateRegion() (TkRegion) XCreateRegion()
+#define TkDestroyRegion(rgn) XDestroyRegion((Region) rgn)
+#define TkIntersectRegion(a, b, r) XIntersectRegion((Region) a, \
+	(Region) b, (Region) r)
+#define TkRectInRegion(r, x, y, w, h) XRectInRegion((Region) r, x, y, w, h)
+#define TkSetRegion(d, gc, rgn) XSetRegion(d, gc, (Region) rgn)
+#define TkSubtractRegion(a, b, r) XSubtractRegion((Region) a, \
+	(Region) b, (Region) r)
+#define TkUnionRectWithRegion(rect, src, ret) XUnionRectWithRegion(rect, \
+	(Region) src, (Region) ret)
+
+/*
+ * The TkPutImage macro strips off the color table information, which isn't
+ * needed for X.
+ */
+
+#define TkPutImage(colors, ncolors, display, pixels, gc, image, srcx, srcy, destx, desty, width, height) \
+	XPutImage(display, pixels, gc, image, srcx, srcy, destx, \
+	desty, width, height);
+
+/*
+ * Supply macros for seek offsets, if they're not already provided by
+ * an include file.
+ */
+
+#ifndef SEEK_SET
+#   define SEEK_SET 0
+#endif
+
+#ifndef SEEK_CUR
+#   define SEEK_CUR 1
+#endif
+
+#ifndef SEEK_END
+#   define SEEK_END 2
+#endif
+
+/*
+ * Declarations for various library procedures that may not be declared
+ * in any other header file.
+ */
+
+
+/*
+ * These functions do nothing under Unix, so we just eliminate calls to them.
+ */
+
+#define TkpButtonSetDefaults(specPtr) {}
+#define TkpDestroyButton(butPtr) {}
+#define TkSelUpdateClipboard(a,b) {}
+#define TkSetPixmapColormap(p,c) {}
+
+/*
+ * These calls implement native bitmaps which are not supported under
+ * UNIX.  The macros eliminate the calls.
+ */
+
+#define TkpDefineNativeBitmaps()
+#define TkpCreateNativeBitmap(display, source) None
+#define TkpGetNativeAppBitmap(display, name, w, h) None
+
+/*
+ * This macro stores a representation of the window handle in a string.
+ * This should perhaps use the real size of an XID.
+ */
+
+#define TkpPrintWindowId(buf,w) \
+	sprintf((buf), "%#08lx", (unsigned long) (w))
+
+/*
+ * The following declaration is used to get access to a private Tcl interface
+ * that is needed for portability reasons.
+ *
+ * Disabled for now to determined whether we really still need this.
+
+#ifndef _TCLINT
+#include <tclInt.h>
+#endif
+ */
+
+#endif /* _UNIXPORT */
Index: src/tktext/tk8.5/tkWin.h
===================================================================
--- src/tktext/tk8.5/tkWin.h	(revision 0)
+++ src/tktext/tk8.5/tkWin.h	(working copy)
@@ -0,0 +1,91 @@
+/*
+ * tkWin.h --
+ *
+ *	Declarations of public types and interfaces that are only
+ *	available under Windows.
+ *
+ * Copyright (c) 1996-1997 by Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkWin.h,v 1.15 2007/12/13 15:28:52 dgp Exp $
+ */
+
+#ifndef _TKWIN
+#define _TKWIN
+
+/*
+ * We must specify the lower version we intend to support. In particular
+ * the SystemParametersInfo API doesn't like to receive structures that
+ * are larger than it expects which affects the font assignements.
+ *
+ * WINVER = 0x0410 means Windows 98 and above
+ */
+
+#ifndef WINVER
+#define WINVER 0x0410
+#endif
+#ifndef _WIN32_WINDOWS
+#define _WIN32_WINDOWS 0x0410
+#endif
+
+#ifndef _TK
+#include <tk.h>
+#endif
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#undef WIN32_LEAN_AND_MEAN
+
+#ifdef BUILD_tk
+# undef TCL_STORAGE_CLASS
+# define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+/*
+ * The following messages are used to communicate between a Tk toplevel
+ * and its container window. A Tk container may not be able to provide 
+ * service to all of the following requests at the moment. But an embedded 
+ * Tk window will send out these requests to support external Tk container 
+ * application.
+ */
+
+#define TK_CLAIMFOCUS	    (WM_USER)	    /* an embedded window requests to focus */
+#define TK_GEOMETRYREQ	    (WM_USER+1)	    /* an embedded window requests to change size */
+#define TK_ATTACHWINDOW	    (WM_USER+2)	    /* an embedded window requests to attach */
+#define TK_DETACHWINDOW	    (WM_USER+3)	    /* an embedded window requests to detach */
+#define TK_MOVEWINDOW	    (WM_USER+4)	    /* an embedded window requests to move */
+#define TK_RAISEWINDOW	    (WM_USER+5)	    /* an embedded window requests to raise */
+#define TK_ICONIFY	    (WM_USER+6)	    /* an embedded window requests to iconify */
+#define TK_DEICONIFY	    (WM_USER+7)	    /* an embedded window requests to deiconify */
+#define TK_WITHDRAW	    (WM_USER+8)	    /* an embedded window requests to withdraw */
+#define TK_GETFRAMEWID	    (WM_USER+9)	    /* an embedded window requests a frame window id */
+#define TK_OVERRIDEREDIRECT (WM_USER+10)    /* an embedded window requests to overrideredirect */
+#define TK_SETMENU	    (WM_USER+11)    /* an embedded window requests to setup menu */
+#define TK_STATE	    (WM_USER+12)    /* an embedded window sets/gets state */
+#define TK_INFO		    (WM_USER+13)    /* an embedded window requests a container's info */
+
+/*
+ * The following are sub-messages (wParam) for TK_INFO.  An embedded window may
+ * send a TK_INFO message with one of the sub-messages to query a container 
+ * for verification and availability
+ */
+#define TK_CONTAINER_VERIFY	    0x01
+#define TK_CONTAINER_ISAVAILABLE    0x02
+
+
+/*
+ *--------------------------------------------------------------
+ *
+ * Exported procedures defined for the Windows platform only.
+ *
+ *--------------------------------------------------------------
+ */
+
+#include "tkPlatDecls.h"
+
+# undef TCL_STORAGE_CLASS
+# define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TKWIN */
Index: src/tktext/tk8.5/tkWinDefault.h
===================================================================
--- src/tktext/tk8.5/tkWinDefault.h	(revision 0)
+++ src/tktext/tk8.5/tkWinDefault.h	(working copy)
@@ -0,0 +1,529 @@
+/*
+ * tkWinDefault.h --
+ *
+ *	This file defines the defaults for all options for all of
+ *	the Tk widgets.
+ *
+ * Copyright (c) 1995-1997 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkWinDefault.h,v 1.24 2007/12/13 15:28:55 dgp Exp $
+ */
+
+#ifndef _TKWINDEFAULT
+#define _TKWINDEFAULT
+
+/*
+ * The definitions below provide symbolic names for the default colors.
+ * NORMAL_BG -		Normal background color.
+ * ACTIVE_BG -		Background color when widget is active.
+ * SELECT_BG -		Background color for selected text.
+ * TROUGH -		Background color for troughs in scales and scrollbars.
+ * INDICATOR -		Color for indicator when button is selected.
+ * DISABLED -		Foreground color when widget is disabled.
+ */
+
+#define BLACK		"Black"
+#define WHITE		"White"
+
+#define NORMAL_BG	"SystemButtonFace"
+#define NORMAL_FG	"SystemButtonText"
+#define ACTIVE_BG	NORMAL_BG
+#define TEXT_FG		"SystemWindowText"
+#define SELECT_BG	"SystemHighlight"
+#define SELECT_FG	"SystemHighlightText"
+#define TROUGH		"SystemScrollbar"
+#define INDICATOR	"SystemWindow"
+#define DISABLED	"SystemDisabledText"
+#define MENU_BG		"SystemMenu"
+#define MENU_FG		"SystemMenuText"
+#define HIGHLIGHT	"SystemWindowFrame"
+
+/*
+ * Defaults for labels, buttons, checkbuttons, and radiobuttons:
+ */
+
+#define DEF_BUTTON_ANCHOR		"center"
+#define DEF_BUTTON_ACTIVE_BG_COLOR	NORMAL_BG
+#define DEF_BUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_BUTTON_ACTIVE_FG_COLOR	NORMAL_FG
+#define DEF_CHKRAD_ACTIVE_FG_COLOR	TEXT_FG
+#define DEF_BUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_BUTTON_BG_COLOR		NORMAL_BG
+#define DEF_BUTTON_BG_MONO		WHITE
+#define DEF_BUTTON_BITMAP		""
+#define DEF_BUTTON_BORDER_WIDTH	"2"
+#define DEF_BUTTON_CURSOR		""
+#define DEF_BUTTON_COMMAND		""
+#define DEF_BUTTON_COMPOUND		"none"
+#define DEF_BUTTON_DEFAULT		"disabled"
+#define DEF_BUTTON_DISABLED_FG_COLOR	DISABLED
+#define DEF_BUTTON_DISABLED_FG_MONO	""
+#define DEF_BUTTON_FG			NORMAL_FG
+#define DEF_CHKRAD_FG			TEXT_FG
+#define DEF_BUTTON_FONT			"TkDefaultFont"
+#define DEF_BUTTON_HEIGHT		"0"
+#define DEF_BUTTON_HIGHLIGHT_BG_COLOR	DEF_BUTTON_BG_COLOR
+#define DEF_BUTTON_HIGHLIGHT_BG_MONO	DEF_BUTTON_BG_MONO
+#define DEF_BUTTON_HIGHLIGHT		HIGHLIGHT
+#define DEF_LABEL_HIGHLIGHT_WIDTH	"0"
+#define DEF_BUTTON_HIGHLIGHT_WIDTH	"1"
+#define DEF_BUTTON_IMAGE		(char *) NULL
+#define DEF_BUTTON_INDICATOR		"1"
+#define DEF_BUTTON_JUSTIFY		"center"
+#define DEF_BUTTON_OFF_VALUE		"0"
+#define DEF_BUTTON_ON_VALUE		"1"
+#define DEF_BUTTON_OVER_RELIEF		""
+#define DEF_BUTTON_PADX			"1"
+#define DEF_LABCHKRAD_PADX		"1"
+#define DEF_BUTTON_PADY			"1"
+#define DEF_LABCHKRAD_PADY		"1"
+#define DEF_BUTTON_RELIEF		"raised"
+#define DEF_LABCHKRAD_RELIEF		"flat"
+#define DEF_BUTTON_REPEAT_DELAY		"0"
+#define DEF_BUTTON_REPEAT_INTERVAL	"0"
+#define DEF_BUTTON_SELECT_COLOR		INDICATOR
+#define DEF_BUTTON_SELECT_MONO		BLACK
+#define DEF_BUTTON_SELECT_IMAGE		(char *) NULL
+#define DEF_BUTTON_STATE		"normal"
+#define DEF_LABEL_TAKE_FOCUS		"0"
+#define DEF_BUTTON_TAKE_FOCUS		(char *) NULL
+#define DEF_BUTTON_TEXT			""
+#define DEF_BUTTON_TEXT_VARIABLE	""
+#define DEF_BUTTON_TRISTATE_VALUE	""
+#define DEF_BUTTON_UNDERLINE		"-1"
+#define DEF_BUTTON_VALUE		""
+#define DEF_BUTTON_WIDTH		"0"
+#define DEF_BUTTON_WRAP_LENGTH		"0"
+#define DEF_RADIOBUTTON_VARIABLE	"selectedButton"
+#define DEF_CHECKBUTTON_VARIABLE	""
+
+/*
+ * Defaults for canvases:
+ */
+
+#define DEF_CANVAS_BG_COLOR		NORMAL_BG
+#define DEF_CANVAS_BG_MONO		WHITE
+#define DEF_CANVAS_BORDER_WIDTH		"0"
+#define DEF_CANVAS_CLOSE_ENOUGH		"1"
+#define DEF_CANVAS_CONFINE		"1"
+#define DEF_CANVAS_CURSOR		""
+#define DEF_CANVAS_HEIGHT		"7c"
+#define DEF_CANVAS_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_CANVAS_HIGHLIGHT		HIGHLIGHT
+#define DEF_CANVAS_HIGHLIGHT_WIDTH	"2"
+#define DEF_CANVAS_INSERT_BG		NORMAL_FG
+#define DEF_CANVAS_INSERT_BD_COLOR	"0"
+#define DEF_CANVAS_INSERT_BD_MONO	"0"
+#define DEF_CANVAS_INSERT_OFF_TIME	"300"
+#define DEF_CANVAS_INSERT_ON_TIME	"600"
+#define DEF_CANVAS_INSERT_WIDTH		"2"
+#define DEF_CANVAS_RELIEF		"flat"
+#define DEF_CANVAS_SCROLL_REGION	""
+#define DEF_CANVAS_SELECT_COLOR		SELECT_BG
+#define DEF_CANVAS_SELECT_MONO		BLACK
+#define DEF_CANVAS_SELECT_BD_COLOR	"1"
+#define DEF_CANVAS_SELECT_BD_MONO	"0"
+#define DEF_CANVAS_SELECT_FG_COLOR	SELECT_FG
+#define DEF_CANVAS_SELECT_FG_MONO	WHITE
+#define DEF_CANVAS_TAKE_FOCUS		(char *) NULL
+#define DEF_CANVAS_WIDTH		"10c"
+#define DEF_CANVAS_X_SCROLL_CMD		""
+#define DEF_CANVAS_X_SCROLL_INCREMENT	"0"
+#define DEF_CANVAS_Y_SCROLL_CMD		""
+#define DEF_CANVAS_Y_SCROLL_INCREMENT	"0"
+
+/*
+ * Defaults for entries:
+ */
+
+#define DEF_ENTRY_BG_COLOR		"SystemWindow"
+#define DEF_ENTRY_BG_MONO		WHITE
+#define DEF_ENTRY_BORDER_WIDTH		"1"
+#define DEF_ENTRY_CURSOR		"xterm"
+#define DEF_ENTRY_DISABLED_BG_COLOR	"SystemButtonFace"
+#define DEF_ENTRY_DISABLED_BG_MONO	WHITE
+#define DEF_ENTRY_DISABLED_FG		DISABLED
+#define DEF_ENTRY_EXPORT_SELECTION	"1"
+#define DEF_ENTRY_FONT			"TkTextFont"
+#define DEF_ENTRY_FG			TEXT_FG
+#define DEF_ENTRY_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_ENTRY_HIGHLIGHT		HIGHLIGHT
+#define DEF_ENTRY_HIGHLIGHT_WIDTH	"0"
+#define DEF_ENTRY_INSERT_BG		TEXT_FG
+#define DEF_ENTRY_INSERT_BD_COLOR	"0"
+#define DEF_ENTRY_INSERT_BD_MONO	"0"
+#define DEF_ENTRY_INSERT_OFF_TIME	"300"
+#define DEF_ENTRY_INSERT_ON_TIME	"600"
+#define DEF_ENTRY_INSERT_WIDTH		"2"
+#define DEF_ENTRY_JUSTIFY		"left"
+#define DEF_ENTRY_READONLY_BG_COLOR	"SystemButtonFace"
+#define DEF_ENTRY_READONLY_BG_MONO	WHITE
+#define DEF_ENTRY_RELIEF		"sunken"
+#define DEF_ENTRY_SCROLL_COMMAND	""
+#define DEF_ENTRY_SELECT_COLOR		SELECT_BG
+#define DEF_ENTRY_SELECT_MONO		BLACK
+#define DEF_ENTRY_SELECT_BD_COLOR	"0"
+#define DEF_ENTRY_SELECT_BD_MONO	"0"
+#define DEF_ENTRY_SELECT_FG_COLOR	SELECT_FG
+#define DEF_ENTRY_SELECT_FG_MONO	WHITE
+#define DEF_ENTRY_SHOW			(char *) NULL
+#define DEF_ENTRY_STATE			"normal"
+#define DEF_ENTRY_TAKE_FOCUS		(char *) NULL
+#define DEF_ENTRY_TEXT_VARIABLE		""
+#define DEF_ENTRY_WIDTH			"20"
+
+/*
+ * Defaults for frames:
+ */
+
+#define DEF_FRAME_BG_COLOR		NORMAL_BG
+#define DEF_FRAME_BG_MONO		WHITE
+#define DEF_FRAME_BORDER_WIDTH		"0"
+#define DEF_FRAME_CLASS			"Frame"
+#define DEF_FRAME_COLORMAP		""
+#define DEF_FRAME_CONTAINER		"0"
+#define DEF_FRAME_CURSOR		""
+#define DEF_FRAME_HEIGHT		"0"
+#define DEF_FRAME_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_FRAME_HIGHLIGHT		HIGHLIGHT
+#define DEF_FRAME_HIGHLIGHT_WIDTH	"0"
+#define DEF_FRAME_PADX			"0"
+#define DEF_FRAME_PADY			"0"
+#define DEF_FRAME_RELIEF		"flat"
+#define DEF_FRAME_TAKE_FOCUS		"0"
+#define DEF_FRAME_VISUAL		""
+#define DEF_FRAME_WIDTH			"0"
+
+/*
+ * Defaults for labelframes:
+ */
+
+#define DEF_LABELFRAME_BORDER_WIDTH	"2"
+#define DEF_LABELFRAME_CLASS		"Labelframe"
+#define DEF_LABELFRAME_RELIEF		"groove"
+#define DEF_LABELFRAME_FG		NORMAL_FG
+#define DEF_LABELFRAME_FONT		"TkDefaultFont"
+#define DEF_LABELFRAME_TEXT		""
+#define DEF_LABELFRAME_LABELANCHOR	"nw"
+
+/*
+ * Defaults for listboxes:
+ */
+
+#define DEF_LISTBOX_ACTIVE_STYLE	"underline"
+#define DEF_LISTBOX_BG_COLOR		"SystemWindow"
+#define DEF_LISTBOX_BG_MONO		WHITE
+#define DEF_LISTBOX_BORDER_WIDTH	"1"
+#define DEF_LISTBOX_CURSOR		""
+#define DEF_LISTBOX_DISABLED_FG		DISABLED
+#define DEF_LISTBOX_EXPORT_SELECTION	"1"
+#define DEF_LISTBOX_FONT		"TkDefaultFont"
+#define DEF_LISTBOX_FG			NORMAL_FG
+#define DEF_LISTBOX_HEIGHT		"10"
+#define DEF_LISTBOX_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_LISTBOX_HIGHLIGHT		HIGHLIGHT
+#define DEF_LISTBOX_HIGHLIGHT_WIDTH	"1"
+#define DEF_LISTBOX_RELIEF		"sunken"
+#define DEF_LISTBOX_SCROLL_COMMAND	""
+#define DEF_LISTBOX_LIST_VARIABLE	""
+#define DEF_LISTBOX_SELECT_COLOR	SELECT_BG
+#define DEF_LISTBOX_SELECT_MONO		BLACK
+#define DEF_LISTBOX_SELECT_BD		"0"
+#define DEF_LISTBOX_SELECT_FG_COLOR	SELECT_FG
+#define DEF_LISTBOX_SELECT_FG_MONO	WHITE
+#define DEF_LISTBOX_SELECT_MODE		"browse"
+#define DEF_LISTBOX_SET_GRID		"0"
+#define DEF_LISTBOX_STATE		"normal"
+#define DEF_LISTBOX_TAKE_FOCUS		(char *) NULL
+#define DEF_LISTBOX_WIDTH		"20"
+
+/*
+ * Defaults for individual entries of menus:
+ */
+
+#define DEF_MENU_ENTRY_ACTIVE_BG	(char *) NULL
+#define DEF_MENU_ENTRY_ACTIVE_FG	(char *) NULL
+#define DEF_MENU_ENTRY_ACCELERATOR	(char *) NULL
+#define DEF_MENU_ENTRY_BG		(char *) NULL
+#define DEF_MENU_ENTRY_BITMAP		None
+#define DEF_MENU_ENTRY_COLUMN_BREAK	"0"
+#define DEF_MENU_ENTRY_COMMAND		(char *) NULL
+#define DEF_MENU_ENTRY_COMPOUND 	"none"
+#define DEF_MENU_ENTRY_FG		(char *) NULL
+#define DEF_MENU_ENTRY_FONT		(char *) NULL
+#define DEF_MENU_ENTRY_HIDE_MARGIN	"0"
+#define DEF_MENU_ENTRY_IMAGE		(char *) NULL
+#define DEF_MENU_ENTRY_INDICATOR	"1"
+#define DEF_MENU_ENTRY_LABEL		(char *) NULL
+#define DEF_MENU_ENTRY_MENU		(char *) NULL
+#define DEF_MENU_ENTRY_OFF_VALUE	"0"
+#define DEF_MENU_ENTRY_ON_VALUE		"1"
+#define DEF_MENU_ENTRY_SELECT_IMAGE	(char *) NULL
+#define DEF_MENU_ENTRY_STATE		"normal"
+#define DEF_MENU_ENTRY_VALUE		(char *) NULL
+#define DEF_MENU_ENTRY_CHECK_VARIABLE	(char *) NULL
+#define DEF_MENU_ENTRY_RADIO_VARIABLE	"selectedButton"
+#define DEF_MENU_ENTRY_SELECT	(char *) NULL
+#define DEF_MENU_ENTRY_UNDERLINE	"-1"
+
+/*
+ * Defaults for menus overall:
+ */
+
+#define DEF_MENU_ACTIVE_BG_COLOR	SELECT_BG
+#define DEF_MENU_ACTIVE_BG_MONO		BLACK
+#define DEF_MENU_ACTIVE_BORDER_WIDTH	"0"
+#define DEF_MENU_ACTIVE_FG_COLOR	SELECT_FG
+#define DEF_MENU_ACTIVE_FG_MONO		WHITE
+#define DEF_MENU_BG_COLOR		MENU_BG
+#define DEF_MENU_BG_MONO		WHITE
+#define DEF_MENU_BORDER_WIDTH		"0"
+#define DEF_MENU_CURSOR			"arrow"
+#define DEF_MENU_DISABLED_FG_COLOR	DISABLED
+#define DEF_MENU_DISABLED_FG_MONO	""
+#define DEF_MENU_FONT			"TkMenuFont"
+#define DEF_MENU_FG			MENU_FG
+#define DEF_MENU_POST_COMMAND		""
+#define DEF_MENU_RELIEF			"flat"
+#define DEF_MENU_SELECT_COLOR		MENU_FG
+#define DEF_MENU_SELECT_MONO		BLACK
+#define DEF_MENU_TAKE_FOCUS		"0"
+#define DEF_MENU_TEAROFF		"1"
+#define DEF_MENU_TEAROFF_CMD		(char *) NULL
+#define DEF_MENU_TITLE			""
+#define DEF_MENU_TYPE			"normal"
+
+/*
+ * Defaults for menubuttons:
+ */
+
+#define DEF_MENUBUTTON_ANCHOR		"center"
+#define DEF_MENUBUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_MENUBUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_MENUBUTTON_ACTIVE_FG_COLOR	NORMAL_FG
+#define DEF_MENUBUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_MENUBUTTON_BG_COLOR		NORMAL_BG
+#define DEF_MENUBUTTON_BG_MONO		WHITE
+#define DEF_MENUBUTTON_BITMAP		""
+#define DEF_MENUBUTTON_BORDER_WIDTH	"1"
+#define DEF_MENUBUTTON_CURSOR		""
+#define DEF_MENUBUTTON_DIRECTION	"below"
+#define DEF_MENUBUTTON_DISABLED_FG_COLOR DISABLED
+#define DEF_MENUBUTTON_DISABLED_FG_MONO	""
+#define DEF_MENUBUTTON_FONT		"TkDefaultFont"
+#define DEF_MENUBUTTON_FG		NORMAL_FG
+#define DEF_MENUBUTTON_HEIGHT		"0"
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_COLOR DEF_MENUBUTTON_BG_COLOR
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
+#define DEF_MENUBUTTON_HIGHLIGHT	HIGHLIGHT
+#define DEF_MENUBUTTON_HIGHLIGHT_WIDTH	"0"
+#define DEF_MENUBUTTON_IMAGE		(char *) NULL
+#define DEF_MENUBUTTON_INDICATOR	"0"
+#define DEF_MENUBUTTON_JUSTIFY		"center"
+#define DEF_MENUBUTTON_MENU		""
+#define DEF_MENUBUTTON_PADX		"4p"
+#define DEF_MENUBUTTON_PADY		"3p"
+#define DEF_MENUBUTTON_RELIEF		"flat"
+#define DEF_MENUBUTTON_STATE		"normal"
+#define DEF_MENUBUTTON_TAKE_FOCUS	"0"
+#define DEF_MENUBUTTON_TEXT		""
+#define DEF_MENUBUTTON_TEXT_VARIABLE	""
+#define DEF_MENUBUTTON_UNDERLINE	"-1"
+#define DEF_MENUBUTTON_WIDTH		"0"
+#define DEF_MENUBUTTON_WRAP_LENGTH	"0"
+
+/*
+ * Defaults for messages:
+ */
+
+#define DEF_MESSAGE_ANCHOR		"center"
+#define DEF_MESSAGE_ASPECT		"150"
+#define DEF_MESSAGE_BG_COLOR		NORMAL_BG
+#define DEF_MESSAGE_BG_MONO		WHITE
+#define DEF_MESSAGE_BORDER_WIDTH	"1"
+#define DEF_MESSAGE_CURSOR		""
+#define DEF_MESSAGE_FG			NORMAL_FG
+#define DEF_MESSAGE_FONT		"TkDefaultFont"
+#define DEF_MESSAGE_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_MESSAGE_HIGHLIGHT		HIGHLIGHT
+#define DEF_MESSAGE_HIGHLIGHT_WIDTH	"0"
+#define DEF_MESSAGE_JUSTIFY		"left"
+#define DEF_MESSAGE_PADX		"-1"
+#define DEF_MESSAGE_PADY		"-1"
+#define DEF_MESSAGE_RELIEF		"flat"
+#define DEF_MESSAGE_TAKE_FOCUS		"0"
+#define DEF_MESSAGE_TEXT		""
+#define DEF_MESSAGE_TEXT_VARIABLE	""
+#define DEF_MESSAGE_WIDTH		"0"
+
+/*
+ * Defaults for panedwindows
+ */
+
+#define DEF_PANEDWINDOW_BG_COLOR	NORMAL_BG
+#define DEF_PANEDWINDOW_BG_MONO		WHITE
+#define DEF_PANEDWINDOW_BORDERWIDTH	"1"
+#define DEF_PANEDWINDOW_CURSOR		""
+#define DEF_PANEDWINDOW_HANDLEPAD	"8"
+#define DEF_PANEDWINDOW_HANDLESIZE	"8"
+#define DEF_PANEDWINDOW_HEIGHT		""
+#define DEF_PANEDWINDOW_OPAQUERESIZE	"1"
+#define DEF_PANEDWINDOW_ORIENT		"horizontal"
+#define DEF_PANEDWINDOW_RELIEF		"flat"
+#define DEF_PANEDWINDOW_SASHCURSOR	""
+#define DEF_PANEDWINDOW_SASHPAD		"0"
+#define DEF_PANEDWINDOW_SASHRELIEF	"flat"
+#define DEF_PANEDWINDOW_SASHWIDTH	"3"
+#define DEF_PANEDWINDOW_SHOWHANDLE	"0"
+#define DEF_PANEDWINDOW_WIDTH		""
+
+/*
+ * Defaults for panedwindow panes
+ */
+
+#define DEF_PANEDWINDOW_PANE_AFTER	""
+#define DEF_PANEDWINDOW_PANE_BEFORE	""
+#define DEF_PANEDWINDOW_PANE_HEIGHT	""
+#define DEF_PANEDWINDOW_PANE_MINSIZE	"0"
+#define DEF_PANEDWINDOW_PANE_PADX	"0"
+#define DEF_PANEDWINDOW_PANE_PADY	"0"
+#define DEF_PANEDWINDOW_PANE_STICKY	"nsew"
+#define DEF_PANEDWINDOW_PANE_WIDTH	""
+#define DEF_PANEDWINDOW_PANE_HIDE	"0"
+#define DEF_PANEDWINDOW_PANE_STRETCH	"last"
+
+/*
+ * Defaults for scales:
+ */
+
+#define DEF_SCALE_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCALE_ACTIVE_BG_MONO	BLACK
+#define DEF_SCALE_BG_COLOR		NORMAL_BG
+#define DEF_SCALE_BG_MONO		WHITE
+#define DEF_SCALE_BIG_INCREMENT		"0"
+#define DEF_SCALE_BORDER_WIDTH		"1"
+#define DEF_SCALE_COMMAND		""
+#define DEF_SCALE_CURSOR		""
+#define DEF_SCALE_DIGITS		"0"
+#define DEF_SCALE_FONT			"TkDefaultFont"
+#define DEF_SCALE_FG_COLOR		NORMAL_FG
+#define DEF_SCALE_FG_MONO		BLACK
+#define DEF_SCALE_FROM			"0"
+#define DEF_SCALE_HIGHLIGHT_BG_COLOR	DEF_SCALE_BG_COLOR
+#define DEF_SCALE_HIGHLIGHT_BG_MONO	DEF_SCALE_BG_MONO
+#define DEF_SCALE_HIGHLIGHT		HIGHLIGHT
+#define DEF_SCALE_HIGHLIGHT_WIDTH	"2"
+#define DEF_SCALE_LABEL			""
+#define DEF_SCALE_LENGTH		"100"
+#define DEF_SCALE_ORIENT		"vertical"
+#define DEF_SCALE_RELIEF		"flat"
+#define DEF_SCALE_REPEAT_DELAY	"300"
+#define DEF_SCALE_REPEAT_INTERVAL	"100"
+#define DEF_SCALE_RESOLUTION		"1"
+#define DEF_SCALE_TROUGH_COLOR		TROUGH
+#define DEF_SCALE_TROUGH_MONO		WHITE
+#define DEF_SCALE_SHOW_VALUE		"1"
+#define DEF_SCALE_SLIDER_LENGTH		"30"
+#define DEF_SCALE_SLIDER_RELIEF		"raised"
+#define DEF_SCALE_STATE			"normal"
+#define DEF_SCALE_TAKE_FOCUS		(char *) NULL
+#define DEF_SCALE_TICK_INTERVAL		"0"
+#define DEF_SCALE_TO			"100"
+#define DEF_SCALE_VARIABLE		""
+#define DEF_SCALE_WIDTH			"15"
+
+/*
+ * Defaults for scrollbars:
+ */
+
+#define DEF_SCROLLBAR_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCROLLBAR_ACTIVE_BG_MONO	BLACK
+#define DEF_SCROLLBAR_ACTIVE_RELIEF	"raised"
+#define DEF_SCROLLBAR_BG_COLOR		NORMAL_BG
+#define DEF_SCROLLBAR_BG_MONO		WHITE
+#define DEF_SCROLLBAR_BORDER_WIDTH	"0"
+#define DEF_SCROLLBAR_COMMAND		""
+#define DEF_SCROLLBAR_CURSOR		""
+#define DEF_SCROLLBAR_EL_BORDER_WIDTH	"-1"
+#define DEF_SCROLLBAR_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_SCROLLBAR_HIGHLIGHT	HIGHLIGHT
+#define DEF_SCROLLBAR_HIGHLIGHT_WIDTH	"0"
+#define DEF_SCROLLBAR_JUMP		"0"
+#define DEF_SCROLLBAR_ORIENT		"vertical"
+#define DEF_SCROLLBAR_RELIEF		"sunken"
+#define DEF_SCROLLBAR_REPEAT_DELAY	"300"
+#define DEF_SCROLLBAR_REPEAT_INTERVAL	"100"
+#define DEF_SCROLLBAR_TAKE_FOCUS	(char *) NULL
+#define DEF_SCROLLBAR_TROUGH_COLOR	TROUGH
+#define DEF_SCROLLBAR_TROUGH_MONO	WHITE
+#define DEF_SCROLLBAR_WIDTH		"10"
+
+/*
+ * Defaults for texts:
+ */
+
+#define DEF_TEXT_AUTO_SEPARATORS	"1"
+#define DEF_TEXT_BG_COLOR		"SystemWindow"
+#define DEF_TEXT_BG_MONO		WHITE
+#define DEF_TEXT_BLOCK_CURSOR		"0"
+#define DEF_TEXT_BORDER_WIDTH		"1"
+#define DEF_TEXT_CURSOR			"xterm"
+#define DEF_TEXT_FG			TEXT_FG
+#define DEF_TEXT_EXPORT_SELECTION	"1"
+#define DEF_TEXT_FONT			"TkFixedFont"
+#define DEF_TEXT_HEIGHT			"24"
+#define DEF_TEXT_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_TEXT_HIGHLIGHT		HIGHLIGHT
+#define DEF_TEXT_HIGHLIGHT_WIDTH	"0"
+#define DEF_TEXT_INSERT_BG		TEXT_FG
+#define DEF_TEXT_INSERT_BD_COLOR	"0"
+#define DEF_TEXT_INSERT_BD_MONO		"0"
+#define DEF_TEXT_INSERT_OFF_TIME	"300"
+#define DEF_TEXT_INSERT_ON_TIME		"600"
+#define DEF_TEXT_INSERT_WIDTH		"2"
+#define DEF_TEXT_MAX_UNDO    	"0"
+#define DEF_TEXT_PADX			"1"
+#define DEF_TEXT_PADY			"1"
+#define DEF_TEXT_RELIEF			"sunken"
+#define DEF_TEXT_INACTIVE_SELECT_COLOR	NULL
+#define DEF_TEXT_SELECT_COLOR		SELECT_BG
+#define DEF_TEXT_SELECT_MONO		BLACK
+#define DEF_TEXT_SELECT_BD_COLOR	"0"
+#define DEF_TEXT_SELECT_BD_MONO		"0"
+#define DEF_TEXT_SELECT_FG_COLOR	SELECT_FG
+#define DEF_TEXT_SELECT_FG_MONO		WHITE
+#define DEF_TEXT_SELECT_RELIEF		"flat"
+#define DEF_TEXT_SET_GRID		"0"
+#define DEF_TEXT_SPACING1		"0"
+#define DEF_TEXT_SPACING2		"0"
+#define DEF_TEXT_SPACING3		"0"
+#define DEF_TEXT_STATE			"normal"
+#define DEF_TEXT_TABS			""
+#define DEF_TEXT_TABSTYLE		"tabular"
+#define DEF_TEXT_TAKE_FOCUS		(char *) NULL
+#define DEF_TEXT_UNDO    		"0"
+#define DEF_TEXT_WIDTH			"80"
+#define DEF_TEXT_WRAP			"char"
+#define DEF_TEXT_XSCROLL_COMMAND	""
+#define DEF_TEXT_YSCROLL_COMMAND	""
+
+/*
+ * Defaults for canvas text:
+ */
+
+#define DEF_CANVTEXT_FONT		"TkDefaultFont"
+
+/*
+ * Defaults for toplevels (most of the defaults for frames also apply
+ * to toplevels):
+ */
+
+#define DEF_TOPLEVEL_CLASS		"Toplevel"
+#define DEF_TOPLEVEL_MENU		""
+#define DEF_TOPLEVEL_SCREEN		""
+#define DEF_TOPLEVEL_USE		""
+
+#endif /* _TKWINDEFAULT */
Index: src/tktext/tk8.5/tkWinInt.h
===================================================================
--- src/tktext/tk8.5/tkWinInt.h	(revision 0)
+++ src/tktext/tk8.5/tkWinInt.h	(working copy)
@@ -0,0 +1,298 @@
+/*
+ * tkWinInt.h --
+ *
+ *	This file contains declarations that are shared among the
+ *	Windows-specific parts of Tk, but aren't used by the rest of Tk.
+ *
+ * Copyright (c) 1995-1997 Sun Microsystems, Inc.
+ * Copyright (c) 1998-2000 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkWinInt.h,v 1.31 2007/12/14 15:56:09 patthoyts Exp $
+ */
+
+#ifndef _TKWININT
+#define _TKWININT
+
+#ifndef _TKINT
+#include "tkInt.h"
+#endif
+
+/*
+ * Include platform specific public interfaces.
+ */
+
+#ifndef _TKWIN
+#include "tkWin.h"
+#endif
+
+#ifndef _TKPORT
+#include "tkPort.h"
+#endif
+
+/*
+ * Define constants missing from older Win32 SDK header files.
+ */
+
+#ifndef WS_EX_TOOLWINDOW
+#define WS_EX_TOOLWINDOW	0x00000080L
+#endif
+
+/*
+ * The TkWinDCState is used to save the state of a device context so that it
+ * can be restored later.
+ */
+
+typedef struct TkWinDCState {
+    HPALETTE palette;
+    int bkmode;
+} TkWinDCState;
+
+/*
+ * The TkWinDrawable is the internal implementation of an X Drawable (either a
+ * Window or a Pixmap). The following constants define the valid Drawable
+ * types.
+ */
+
+#define TWD_BITMAP	1
+#define TWD_WINDOW	2
+#define TWD_WINDC	3
+
+typedef struct {
+    int type;
+    HWND handle;
+    TkWindow *winPtr;
+} TkWinWindow;
+
+typedef struct {
+    int type;
+    HBITMAP handle;
+    Colormap colormap;
+    int depth;
+} TkWinBitmap;
+
+typedef struct {
+    int type;
+    HDC hdc;
+}TkWinDC;
+
+typedef union {
+    int type;
+    TkWinWindow window;
+    TkWinBitmap bitmap;
+    TkWinDC winDC;
+} TkWinDrawable;
+
+/*
+ * The following macros are used to retrieve internal values from a Drawable.
+ */
+
+#define TkWinGetHWND(w)		(((TkWinDrawable *) w)->window.handle)
+#define TkWinGetWinPtr(w)	(((TkWinDrawable *) w)->window.winPtr)
+#define TkWinGetHBITMAP(w)	(((TkWinDrawable *) w)->bitmap.handle)
+#define TkWinGetColormap(w)	(((TkWinDrawable *) w)->bitmap.colormap)
+#define TkWinGetHDC(w)		(((TkWinDrawable *) w)->winDC.hdc)
+
+/*
+ * The following structure is used to encapsulate palette information.
+ */
+
+typedef struct {
+    HPALETTE palette;		/* Palette handle used when drawing. */
+    UINT size;			/* Number of entries in the palette. */
+    int stale;			/* 1 if palette needs to be realized,
+				 * otherwise 0. If the palette is stale, then
+				 * an idle handler is scheduled to realize the
+				 * palette. */
+    Tcl_HashTable refCounts;	/* Hash table of palette entry reference
+				 * counts indexed by pixel value. */
+} TkWinColormap;
+
+/*
+ * The following macro retrieves the Win32 palette from a colormap.
+ */
+
+#define TkWinGetPalette(colormap) (((TkWinColormap *) colormap)->palette)
+
+/*
+ * The following macros define the class names for Tk Window types.
+ */
+
+#define TK_WIN_TOPLEVEL_CLASS_NAME "TkTopLevel"
+#define TK_WIN_CHILD_CLASS_NAME "TkChild"
+
+/*
+ * The following variable is a translation table between X gc functions and
+ * Win32 raster and BitBlt op modes.
+ */
+
+extern int tkpWinRopModes[];
+extern int tkpWinBltModes[];
+
+/*
+ * The following defines are used with TkWinGetBorderPixels to get the extra 2
+ * border colors from a Tk_3DBorder.
+ */
+
+#define TK_3D_LIGHT2 TK_3D_DARK_GC+1
+#define TK_3D_DARK2 TK_3D_DARK_GC+2
+
+/*
+ * Internal functions used by more than one source file.
+ */
+
+#include "tkIntPlatDecls.h"
+
+/*
+ * We need to specially add the TkWinChildProc because of the special
+ * prototype it has (doesn't fit into stubs schema)
+ */
+
+#ifdef BUILD_tk
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+EXTERN LRESULT CALLBACK	TkWinChildProc(HWND hwnd, UINT message,
+			    WPARAM wParam, LPARAM lParam);
+
+/*
+ * Special proc needed as tsd accessor function between
+ * tkWinX.c:GenerateXEvent and tkWinClipboard.c:UpdateClipboard
+ */
+
+EXTERN void		TkWinUpdatingClipboard(int mode);
+
+/*
+ * Used by tkWinDialog.c to associate the right icon with tk_messageBox
+ */
+
+EXTERN HICON		TkWinGetIcon(Tk_Window tkw, DWORD iconsize);
+
+/*
+ * Used by tkWinX.c on for certain system display change messages and cleanup
+ * up containers
+ */
+
+EXTERN void		TkWinDisplayChanged(Display *display);
+void			TkWinCleanupContainerList(void);
+
+/*
+ * Used by tkWinWm.c for embedded menu handling. May become public.
+ */
+
+EXTERN HWND		Tk_GetMenuHWND(Tk_Window tkwin);
+EXTERN HWND		Tk_GetEmbeddedMenuHWND(Tk_Window tkwin);
+
+/*
+ * The following structure keeps track of whether we are using the multi-byte
+ * or the wide-character interfaces to the operating system. System calls
+ * should be made through the following function table.
+ *
+ * While some system calls need to use this A/W jump-table, it is not
+ * necessary for all calls to do it, which is why you won't see this used
+ * throughout the Tk code, but only in key areas. -- hobbs
+ */
+
+typedef struct TkWinProcs {
+    int useWide;
+    LRESULT (WINAPI *callWindowProc)(WNDPROC lpPrevWndFunc, HWND hWnd,
+	    UINT Msg, WPARAM wParam, LPARAM lParam);
+    LRESULT (WINAPI *defWindowProc)(HWND hWnd, UINT Msg, WPARAM wParam,
+	    LPARAM lParam);
+    ATOM (WINAPI *registerClass)(const WNDCLASS *lpWndClass);
+    BOOL (WINAPI *setWindowText)(HWND hWnd, LPCTSTR lpString);
+    HWND (WINAPI *createWindowEx)(DWORD dwExStyle, LPCTSTR lpClassName,
+	    LPCTSTR lpWindowName, DWORD dwStyle, int x, int y,
+	    int nWidth, int nHeight, HWND hWndParent, HMENU hMenu,
+	    HINSTANCE hInstance, LPVOID lpParam);
+    BOOL (WINAPI *insertMenu)(HMENU hMenu, UINT uPosition, UINT uFlags,
+	    UINT uIDNewItem, LPCTSTR lpNewItem);
+    int (WINAPI *getWindowText)(HWND hWnd, LPCTSTR lpString, int nMaxCount);
+} TkWinProcs;
+
+EXTERN TkWinProcs *tkWinProcs;
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+/*
+ * The following allows us to cache these encoding for multiple functions.
+ */
+
+
+extern Tcl_Encoding	TkWinGetKeyInputEncoding(void);
+extern Tcl_Encoding	TkWinGetUnicodeEncoding(void);
+extern void		TkWinSetupSystemFonts(TkMainInfo *mainPtr);
+
+/*
+ * Values returned by TkWinGetPlatformTheme.
+ */
+
+#define TK_THEME_WIN_CLASSIC    1
+#define TK_THEME_WIN_XP         2
+
+/*
+ * The following is implemented in tkWinWm and used by tkWinEmbed.c
+ */
+
+void			TkpWinToplevelWithDraw(TkWindow *winPtr);
+void			TkpWinToplevelIconify(TkWindow *winPtr);
+void			TkpWinToplevelDeiconify(TkWindow *winPtr);
+long			TkpWinToplevelIsControlledByWm(TkWindow *winPtr);
+long			TkpWinToplevelMove(TkWindow *winPtr, int x, int y);
+long			TkpWinToplevelOverrideRedirect(TkWindow *winPtr,
+			    int reqValue);
+void			TkpWinToplevelDetachWindow(TkWindow *winPtr);
+int			TkpWmGetState(TkWindow *winPtr);
+
+/*
+ * The following functions are not present in old versions of Windows
+ * API headers but are used in the Tk source to ensure 64bit 
+ * compatability.
+ */
+
+#ifndef GetClassLongPtr
+#   define GetClassLongPtrA	GetClassLongA
+#   define GetClassLongPtrW	GetClassLongW
+#   define SetClassLongPtrA	SetClassLongA
+#   define SetClassLongPtrW	SetClassLongW
+#   ifdef UNICODE
+#	define GetClassLongPtr	GetClassLongPtrW
+#	define SetClassLongPtr	SetClassLongPtrW
+#   else
+#	define GetClassLongPtr	GetClassLongPtrA
+#	define SetClassLongPtr	SetClassLongPtrA
+#   endif /* !UNICODE */
+#endif /* !GetClassLongPtr */
+#ifndef GCLP_HICON
+#   define GCLP_HICON		GCL_HICON
+#endif /* !GCLP_HICON */
+#ifndef GCLP_HICONSM
+#   define GCLP_HICONSM		(-34)
+#endif /* !GCLP_HICONSM */
+
+#ifndef GetWindowLongPtr
+#   define GetWindowLongPtrA	GetWindowLongA
+#   define GetWindowLongPtrW	GetWindowLongW
+#   define SetWindowLongPtrA	SetWindowLongA
+#   define SetWindowLongPtrW	SetWindowLongW
+#   ifdef UNICODE
+#	define GetWindowLongPtr	GetWindowLongPtrW
+#	define SetWindowLongPtr	SetWindowLongPtrW
+#   else
+#	define GetWindowLongPtr	GetWindowLongPtrW
+#	define SetWindowLongPtr	SetWindowLongPtrW
+#   endif /* !UNICODE */
+#endif /* !GetWindowLongPtr */
+#ifndef GWLP_WNDPROC
+#define GWLP_WNDPROC		GWL_WNDPROC
+#define GWLP_HINSTANCE		GWL_HINSTANCE
+#define GWLP_HWNDPARENT		GWL_HWNDPARENT
+#define GWLP_USERDATA		GWL_USERDATA
+#define GWLP_ID			GWL_ID
+#endif /* !GWLP_WNDPROC */
+
+#endif /* _TKWININT */
Index: src/tktext/tk8.5/tkWinPort.h
===================================================================
--- src/tktext/tk8.5/tkWinPort.h	(revision 0)
+++ src/tktext/tk8.5/tkWinPort.h	(working copy)
@@ -0,0 +1,142 @@
+/*
+ * tkWinPort.h --
+ *
+ *	This header file handles porting issues that occur because of
+ *	differences between Windows and Unix. It should be the only
+ *	file that contains #ifdefs to handle different flavors of OS.
+ *
+ * Copyright (c) 1995-1996 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id: tkWinPort.h,v 1.10.4.1 2010/04/19 08:23:31 nijtmans Exp $
+ */
+
+#ifndef _WINPORT
+#define _WINPORT
+
+#include <X11/Xlib.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xutil.h>
+
+#include <malloc.h>
+#include <errno.h>
+#include <ctype.h>
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <io.h>
+
+/*
+ * Need to block out this include for building extensions with MetroWerks
+ * compiler for Win32.
+ */
+
+#ifndef __MWERKS__
+#include <sys/stat.h>
+#endif
+
+#include <time.h>
+
+#ifdef _MSC_VER
+#   ifndef hypot
+#	define hypot _hypot
+#   endif
+#endif /* _MSC_VER */
+
+/*
+ *  Pull in the typedef of TCHAR for windows.
+ */
+#if !defined(_TCHAR_DEFINED)
+#   include <tchar.h>
+#   ifndef _TCHAR_DEFINED
+	/* Borland seems to forget to set this. */
+	typedef _TCHAR TCHAR;
+#	define _TCHAR_DEFINED
+#   endif
+#endif
+
+#ifdef __CYGWIN__
+#   ifndef _vsnprintf
+#	define _vsnprintf vsnprintf
+#   endif
+#   ifndef _wcsicmp
+#	define _wcsicmp wcscasecmp
+#   endif
+#else
+#   ifndef strncasecmp
+#	define strncasecmp strnicmp
+#   endif
+#   ifndef strcasecmp
+#	define strcasecmp stricmp
+#   endif
+#endif
+
+#define NBBY 8
+
+#ifndef OPEN_MAX
+#define OPEN_MAX 32
+#endif
+
+/*
+ * The following define causes Tk to use its internal keysym hash table
+ */
+
+#define REDO_KEYSYM_LOOKUP
+
+/*
+ * The following macro checks to see whether there is buffered
+ * input data available for a stdio FILE.
+ */
+
+#ifdef _MSC_VER
+#    define TK_READ_DATA_PENDING(f) ((f)->_cnt > 0)
+#else /* _MSC_VER */
+#    define TK_READ_DATA_PENDING(f) ((f)->level > 0)
+#endif /* _MSC_VER */
+
+/*
+ * The following stubs implement various calls that don't do anything
+ * under Windows.
+ */
+
+#define TkFreeWindowId(dispPtr,w)
+#define TkInitXId(dispPtr)
+#define TkpCmapStressed(tkwin,colormap) (0)
+#define XFlush(display)
+#define XGrabServer(display)
+#define XUngrabServer(display)
+#define TkpSync(display)
+
+/*
+ * The following functions are implemented as macros under Windows.
+ */
+
+#define XFree(data) {if ((data) != NULL) ckfree((char *) (data));}
+#define XNoOp(display) {display->request++;}
+#define XSynchronize(display, bool) {display->request++;}
+#define XSync(display, bool) {display->request++;}
+#define XVisualIDFromVisual(visual) (visual->visualid)
+
+/*
+ * The following Tk functions are implemented as macros under Windows.
+ */
+
+#define TkpGetPixel(p) (((((p)->red >> 8) & 0xff) \
+	| ((p)->green & 0xff00) | (((p)->blue << 8) & 0xff0000)) | 0x20000000)
+
+/*
+ * These calls implement native bitmaps which are not currently 
+ * supported under Windows.  The macros eliminate the calls.
+ */
+
+#define TkpDefineNativeBitmaps()
+#define TkpCreateNativeBitmap(display, source) None
+#define TkpGetNativeAppBitmap(display, name, w, h) None
+
+#endif /* _WINPORT */
Index: src/tktext/tk8.6/default.h
===================================================================
--- src/tktext/tk8.6/default.h	(revision 0)
+++ src/tktext/tk8.6/default.h	(working copy)
@@ -0,0 +1,28 @@
+/*
+ * default.h --
+ *
+ *	This file defines the defaults for all options for all of
+ *	the Tk widgets.
+ *
+ * Copyright (c) 1991-1994 The Regents of the University of California.
+ * Copyright (c) 1994 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _DEFAULT
+#define _DEFAULT
+
+#if defined(__WIN32__) || defined(_WIN32) || \
+    defined(__MINGW32__)
+#   include "tkWinDefault.h"
+#else
+#   if defined(MAC_OSX_TK)
+#	include "tkMacOSXDefault.h"
+#   else
+#	include "tkUnixDefault.h"
+#   endif
+#endif
+
+#endif /* _DEFAULT */
Index: src/tktext/tk8.6/tk3d.h
===================================================================
--- src/tktext/tk8.6/tk3d.h	(revision 0)
+++ src/tktext/tk8.6/tk3d.h	(working copy)
@@ -0,0 +1,85 @@
+/*
+ * tk3d.h --
+ *
+ *	Declarations of types and functions shared by the 3d border module.
+ *
+ * Copyright (c) 1996-1997 by Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TK3D
+#define _TK3D
+
+#include "tkInt.h"
+
+/*
+ * One of the following data structures is allocated for each 3-D border
+ * currently in use. Structures of this type are indexed by borderTable, so
+ * that a single structure can be shared for several uses.
+ */
+
+typedef struct TkBorder {
+    Screen *screen;		/* Screen on which the border will be used. */
+    Visual *visual;		/* Visual for all windows and pixmaps using
+				 * the border. */
+    int depth;			/* Number of bits per pixel of drawables where
+				 * the border will be used. */
+    Colormap colormap;		/* Colormap out of which pixels are
+				 * allocated. */
+    int resourceRefCount;	/* Number of active uses of this color (each
+				 * active use corresponds to a call to
+				 * Tk_Alloc3DBorderFromObj or Tk_Get3DBorder).
+				 * If this count is 0, then this structure is
+				 * no longer valid and it isn't present in
+				 * borderTable: it is being kept around only
+				 * because there are objects referring to it.
+				 * The structure is freed when objRefCount and
+				 * resourceRefCount are both 0. */
+    int objRefCount;		/* The number of Tcl objects that reference
+				 * this structure. */
+    XColor *bgColorPtr;		/* Background color (intensity between
+				 * lightColorPtr and darkColorPtr). */
+    XColor *darkColorPtr;	/* Color for darker areas (must free when
+				 * deleting structure). NULL means shadows
+				 * haven't been allocated yet.*/
+    XColor *lightColorPtr;	/* Color used for lighter areas of border
+				 * (must free this when deleting structure).
+				 * NULL means shadows haven't been allocated
+				 * yet. */
+    Pixmap shadow;		/* Stipple pattern to use for drawing shadows
+				 * areas. Used for displays with <= 64 colors
+				 * or where colormap has filled up. */
+    GC bgGC;			/* Used (if necessary) to draw areas in the
+				 * background color. */
+    GC darkGC;			/* Used to draw darker parts of the border.
+				 * None means the shadow colors haven't been
+				 * allocated yet.*/
+    GC lightGC;			/* Used to draw lighter parts of the border.
+				 * None means the shadow colors haven't been
+				 * allocated yet. */
+    Tcl_HashEntry *hashPtr;	/* Entry in borderTable (needed in order to
+				 * delete structure). */
+    struct TkBorder *nextPtr;	/* Points to the next TkBorder structure with
+				 * the same color name. Borders with the same
+				 * name but different screens or colormaps are
+				 * chained together off a single entry in
+				 * borderTable. */
+} TkBorder;
+
+/*
+ * Maximum intensity for a color:
+ */
+
+#define MAX_INTENSITY 65535
+
+/*
+ * Declarations for platform specific interfaces used by this module.
+ */
+
+MODULE_SCOPE TkBorder	*TkpGetBorder(void);
+MODULE_SCOPE void	TkpGetShadows(TkBorder *borderPtr, Tk_Window tkwin);
+MODULE_SCOPE void	TkpFreeBorder(TkBorder *borderPtr);
+
+#endif /* _TK3D */
Index: src/tktext/tk8.6/tkInt.h
===================================================================
--- src/tktext/tk8.6/tkInt.h	(revision 0)
+++ src/tktext/tk8.6/tkInt.h	(working copy)
@@ -0,0 +1,1263 @@
+/*
+ * tkInt.h --
+ *
+ *	Declarations for things used internally by the Tk functions but not
+ *	exported outside the module.
+ *
+ * Copyright (c) 1990-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright (c) 1998 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKINT
+#define _TKINT
+
+#ifndef _TKPORT
+#include "tkPort.h"
+#endif
+
+/*
+ * Ensure WORDS_BIGENDIAN is defined correctly:
+ * Needs to happen here in addition to configure to work with fat compiles on
+ * Darwin (where configure runs only once for multiple architectures).
+ */
+
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+#    include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#    include <sys/param.h>
+#endif
+#ifdef BYTE_ORDER
+#    ifdef BIG_ENDIAN
+#	 if BYTE_ORDER == BIG_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	     define WORDS_BIGENDIAN 1
+#	 endif
+#    endif
+#    ifdef LITTLE_ENDIAN
+#	 if BYTE_ORDER == LITTLE_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	 endif
+#    endif
+#endif
+
+/*
+ * Used to tag functions that are only to be visible within the module being
+ * built and not outside it (where this is supported by the linker).
+ */
+
+#ifndef MODULE_SCOPE
+#   ifdef __cplusplus
+#	define MODULE_SCOPE extern "C"
+#   else
+#	define MODULE_SCOPE extern
+#   endif
+#endif
+
+/*
+ * Macros used to cast between pointers and integers (e.g. when storing an int
+ * in ClientData), on 64-bit architectures they avoid gcc warning about "cast
+ * to/from pointer from/to integer of different size".
+ */
+
+#if !defined(INT2PTR) && !defined(PTR2INT)
+#   if defined(HAVE_INTPTR_T) || defined(intptr_t)
+#	define INT2PTR(p) ((void*)(intptr_t)(p))
+#	define PTR2INT(p) ((int)(intptr_t)(p))
+#   else
+#	define INT2PTR(p) ((void*)(p))
+#	define PTR2INT(p) ((int)(p))
+#   endif
+#endif
+#if !defined(UINT2PTR) && !defined(PTR2UINT)
+#   if defined(HAVE_UINTPTR_T) || defined(uintptr_t)
+#	define UINT2PTR(p) ((void*)(uintptr_t)(p))
+#	define PTR2UINT(p) ((unsigned int)(uintptr_t)(p))
+#   else
+#	define UINT2PTR(p) ((void*)(p))
+#	define PTR2UINT(p) ((unsigned int)(p))
+#   endif
+#endif
+
+/*
+ * Opaque type declarations:
+ */
+
+typedef struct TkColormap TkColormap;
+typedef struct TkFontAttributes TkFontAttributes;
+typedef struct TkGrabEvent TkGrabEvent;
+typedef struct TkpCursor_ *TkpCursor;
+typedef struct TkRegion_ *TkRegion;
+typedef struct TkStressedCmap TkStressedCmap;
+typedef struct TkBindInfo_ *TkBindInfo;
+typedef struct Busy *TkBusy;
+
+/*
+ * One of the following structures is maintained for each cursor in use in the
+ * system. This structure is used by tkCursor.c and the various system-
+ * specific cursor files.
+ */
+
+typedef struct TkCursor {
+    Tk_Cursor cursor;		/* System specific identifier for cursor. */
+    Display *display;		/* Display containing cursor. Needed for
+				 * disposal and retrieval of cursors. */
+    int resourceRefCount;	/* Number of active uses of this cursor (each
+				 * active use corresponds to a call to
+				 * Tk_AllocPreserveFromObj or Tk_Preserve). If
+				 * this count is 0, then this structure is no
+				 * longer valid and it isn't present in a hash
+				 * table: it is being kept around only because
+				 * there are objects referring to it. The
+				 * structure is freed when resourceRefCount
+				 * and objRefCount are both 0. */
+    int objRefCount;		/* Number of Tcl objects that reference this
+				 * structure.. */
+    Tcl_HashTable *otherTable;	/* Second table (other than idTable) used to
+				 * index this entry. */
+    Tcl_HashEntry *hashPtr;	/* Entry in otherTable for this structure
+				 * (needed when deleting). */
+    Tcl_HashEntry *idHashPtr;	/* Entry in idTable for this structure (needed
+				 * when deleting). */
+    struct TkCursor *nextPtr;	/* Points to the next TkCursor structure with
+				 * the same name. Cursors with the same name
+				 * but different displays are chained together
+				 * off a single hash table entry. */
+} TkCursor;
+
+/*
+ * The following structure is kept one-per-TkDisplay to maintain information
+ * about the caret (cursor location) on this display. This is used to dictate
+ * global focus location (Windows Accessibility guidelines) and to position
+ * the IME or XIM over-the-spot window.
+ */
+
+typedef struct TkCaret {
+    struct TkWindow *winPtr;	/* The window on which we requested caret
+				 * placement. */
+    int x;			/* Relative x coord of the caret. */
+    int y;			/* Relative y coord of the caret. */
+    int height;			/* Specified height of the window. */
+} TkCaret;
+
+/*
+ * One of the following structures is maintained for each display containing a
+ * window managed by Tk. In part, the structure is used to store thread-
+ * specific data, since each thread will have its own TkDisplay structure.
+ */
+
+typedef struct TkDisplay {
+    Display *display;		/* Xlib's info about display. */
+    struct TkDisplay *nextPtr;	/* Next in list of all displays. */
+    char *name;			/* Name of display (with any screen identifier
+				 * removed). Malloc-ed. */
+    Time lastEventTime;		/* Time of last event received for this
+				 * display. */
+
+    /*
+     * Information used primarily by tk3d.c:
+     */
+
+    int borderInit;		/* 0 means borderTable needs initializing. */
+    Tcl_HashTable borderTable;	/* Maps from color name to TkBorder
+				 * structure. */
+
+    /*
+     * Information used by tkAtom.c only:
+     */
+
+    int atomInit;		/* 0 means stuff below hasn't been initialized
+				 * yet. */
+    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
+    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
+
+    /*
+     * Information used primarily by tkBind.c:
+     */
+
+    int bindInfoStale;		/* Non-zero means the variables in this part
+				 * of the structure are potentially incorrect
+				 * and should be recomputed. */
+    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to "mode shift". If no such
+				 * modifier, than this is zero. */
+    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
+    unsigned int altModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
+    enum {LU_IGNORE, LU_CAPS, LU_SHIFT} lockUsage;
+				/* Indicates how to interpret lock
+				 * modifier. */
+    int numModKeyCodes;		/* Number of entries in modKeyCodes array
+				 * below. */
+    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for all
+				 * of the keys that have modifiers associated
+				 * with them. Malloc'ed, but may be NULL. */
+
+    /*
+     * Information used by tkBitmap.c only:
+     */
+
+    int bitmapInit;		/* 0 means tables above need initializing. */
+    int bitmapAutoNumber;	/* Used to number bitmaps. */
+    Tcl_HashTable bitmapNameTable;
+				/* Maps from name of bitmap to the first
+				 * TkBitmap record for that name. */
+    Tcl_HashTable bitmapIdTable;/* Maps from bitmap id to the TkBitmap
+				 * structure for the bitmap. */
+    Tcl_HashTable bitmapDataTable;
+				/* Used by Tk_GetBitmapFromData to map from a
+				 * collection of in-core data about a bitmap
+				 * to a reference giving an automatically-
+				 * generated name for the bitmap. */
+
+    /*
+     * Information used by tkCanvas.c only:
+     */
+
+    int numIdSearches;
+    int numSlowSearches;
+
+    /*
+     * Used by tkColor.c only:
+     */
+
+    int colorInit;		/* 0 means color module needs initializing. */
+    TkStressedCmap *stressPtr;	/* First in list of colormaps that have filled
+				 * up, so we have to pick an approximate
+				 * color. */
+    Tcl_HashTable colorNameTable;
+				/* Maps from color name to TkColor structure
+				 * for that color. */
+    Tcl_HashTable colorValueTable;
+				/* Maps from integer RGB values to TkColor
+				 * structures. */
+
+    /*
+     * Used by tkCursor.c only:
+     */
+
+    int cursorInit;		/* 0 means cursor module need initializing. */
+    Tcl_HashTable cursorNameTable;
+				/* Maps from a string name to a cursor to the
+				 * TkCursor record for the cursor. */
+    Tcl_HashTable cursorDataTable;
+				/* Maps from a collection of in-core data
+				 * about a cursor to a TkCursor structure. */
+    Tcl_HashTable cursorIdTable;
+				/* Maps from a cursor id to the TkCursor
+				 * structure for the cursor. */
+    char cursorString[20];	/* Used to store a cursor id string. */
+    Font cursorFont;		/* Font to use for standard cursors. None
+				 * means font not loaded yet. */
+
+    /*
+     * Information used by tkError.c only:
+     */
+
+    struct TkErrorHandler *errorPtr;
+				/* First in list of error handlers for this
+				 * display. NULL means no handlers exist at
+				 * present. */
+    int deleteCount;		/* Counts # of handlers deleted since last
+				 * time inactive handlers were garbage-
+				 * collected. When this number gets big,
+				 * handlers get cleaned up. */
+
+    /*
+     * Used by tkEvent.c only:
+     */
+
+    struct TkWindowEvent *delayedMotionPtr;
+				/* Points to a malloc-ed motion event whose
+				 * processing has been delayed in the hopes
+				 * that another motion event will come along
+				 * right away and we can merge the two of them
+				 * together. NULL means that there is no
+				 * delayed motion event. */
+
+    /*
+     * Information used by tkFocus.c only:
+     */
+
+    int focusDebug;		/* 1 means collect focus debugging
+				 * statistics. */
+    struct TkWindow *implicitWinPtr;
+				/* If the focus arrived at a toplevel window
+				 * implicitly via an Enter event (rather than
+				 * via a FocusIn event), this points to the
+				 * toplevel window. Otherwise it is NULL. */
+    struct TkWindow *focusPtr;	/* Points to the window on this display that
+				 * should be receiving keyboard events. When
+				 * multiple applications on the display have
+				 * the focus, this will refer to the innermost
+				 * window in the innermost application. This
+				 * information isn't used on Windows, but it's
+				 * needed on the Mac, and also on X11 when XIM
+				 * processing is being done. */
+
+    /*
+     * Information used by tkGC.c only:
+     */
+
+    Tcl_HashTable gcValueTable; /* Maps from a GC's values to a TkGC structure
+				 * describing a GC with those values. */
+    Tcl_HashTable gcIdTable;    /* Maps from a GC to a TkGC. */
+    int gcInit;			/* 0 means the tables below need
+				 * initializing. */
+
+    /*
+     * Information used by tkGeometry.c only:
+     */
+
+    Tcl_HashTable maintainHashTable;
+				/* Hash table that maps from a master's
+				 * Tk_Window token to a list of slaves managed
+				 * by that master. */
+    int geomInit;
+
+    /*
+     * Information used by tkGet.c only:
+     */
+
+    Tcl_HashTable uidTable;	/* Stores all Tk_Uid used in a thread. */
+    int uidInit;		/* 0 means uidTable needs initializing. */
+
+    /*
+     * Information used by tkGrab.c only:
+     */
+
+    struct TkWindow *grabWinPtr;/* Window in which the pointer is currently
+				 * grabbed, or NULL if none. */
+    struct TkWindow *eventualGrabWinPtr;
+				/* Value that grabWinPtr will have once the
+				 * grab event queue (below) has been
+				 * completely emptied. */
+    struct TkWindow *buttonWinPtr;
+				/* Window in which first mouse button was
+				 * pressed while grab was in effect, or NULL
+				 * if no such press in effect. */
+    struct TkWindow *serverWinPtr;
+				/* If no application contains the pointer then
+				 * this is NULL. Otherwise it contains the
+				 * last window for which we've gotten an Enter
+				 * or Leave event from the server (i.e. the
+				 * last window known to have contained the
+				 * pointer). Doesn't reflect events that were
+				 * synthesized in tkGrab.c. */
+    TkGrabEvent *firstGrabEventPtr;
+				/* First in list of enter/leave events
+				 * synthesized by grab code. These events must
+				 * be processed in order before any other
+				 * events are processed. NULL means no such
+				 * events. */
+    TkGrabEvent *lastGrabEventPtr;
+				/* Last in list of synthesized events, or NULL
+				 * if list is empty. */
+    int grabFlags;		/* Miscellaneous flag values. See definitions
+				 * in tkGrab.c. */
+
+    /*
+     * Information used by tkGrid.c only:
+     */
+
+    int gridInit;		/* 0 means table below needs initializing. */
+    Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to corresponding
+				 * Grid structures. */
+
+    /*
+     * Information used by tkImage.c only:
+     */
+
+    int imageId;		/* Value used to number image ids. */
+
+    /*
+     * Information used by tkMacWinMenu.c only:
+     */
+
+    int postCommandGeneration;
+
+    /*
+     * Information used by tkPack.c only.
+     */
+
+    int packInit;		/* 0 means table below needs initializing. */
+    Tcl_HashTable packerHashTable;
+				/* Maps from Tk_Window tokens to corresponding
+				 * Packer structures. */
+
+    /*
+     * Information used by tkPlace.c only.
+     */
+
+    int placeInit;		/* 0 means tables below need initializing. */
+    Tcl_HashTable masterTable;	/* Maps from Tk_Window toke to the Master
+				 * structure for the window, if it exists. */
+    Tcl_HashTable slaveTable;	/* Maps from Tk_Window toke to the Slave
+				 * structure for the window, if it exists. */
+
+    /*
+     * Information used by tkSelect.c and tkClipboard.c only:
+     */
+
+    struct TkSelectionInfo *selectionInfoPtr;
+				/* First in list of selection information
+				 * records. Each entry contains information
+				 * about the current owner of a particular
+				 * selection on this display. */
+    Atom multipleAtom;		/* Atom for MULTIPLE. None means selection
+				 * stuff isn't initialized. */
+    Atom incrAtom;		/* Atom for INCR. */
+    Atom targetsAtom;		/* Atom for TARGETS. */
+    Atom timestampAtom;		/* Atom for TIMESTAMP. */
+    Atom textAtom;		/* Atom for TEXT. */
+    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
+    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
+    Atom windowAtom;		/* Atom for TK_WINDOW. */
+    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
+    Atom utf8Atom;		/* Atom for UTF8_STRING. */
+
+    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
+				 * retrieve selections between processes. NULL
+				 * means clipboard info hasn't been
+				 * initialized. */
+    int clipboardActive;	/* 1 means we currently own the clipboard
+				 * selection, 0 means we don't. */
+    struct TkMainInfo *clipboardAppPtr;
+				/* Last application that owned clipboard. */
+    struct TkClipboardTarget *clipTargetPtr;
+				/* First in list of clipboard type information
+				 * records. Each entry contains information
+				 * about the buffers for a given selection
+				 * target. */
+
+    /*
+     * Information used by tkSend.c only:
+     */
+
+    Tk_Window commTkwin;	/* Window used for communication between
+				 * interpreters during "send" commands. NULL
+				 * means send info hasn't been initialized
+				 * yet. */
+    Atom commProperty;		/* X's name for comm property. */
+    Atom registryProperty;	/* X's name for property containing registry
+				 * of interpreter names. */
+    Atom appNameProperty;	/* X's name for property used to hold the
+				 * application name on each comm window. */
+
+    /*
+     * Information used by tkUnixWm.c and tkWinWm.c only:
+     */
+
+    struct TkWmInfo *firstWmPtr;/* Points to first top-level window. */
+    struct TkWmInfo *foregroundWmPtr;
+				/* Points to the foreground window. */
+
+    /*
+     * Information used by tkVisual.c only:
+     */
+
+    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
+				 * allocated for this display. */
+
+    /*
+     * Miscellaneous information:
+     */
+
+#ifdef TK_USE_INPUT_METHODS
+    XIM inputMethod;		/* Input method for this display. */
+    XIMStyle inputStyle;	/* Input style selected for this display. */
+    XFontSet inputXfs;		/* XFontSet cached for over-the-spot XIM. */
+#endif /* TK_USE_INPUT_METHODS */
+    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
+
+    int refCount;		/* Reference count of how many Tk applications
+				 * are using this display. Used to clean up
+				 * the display when we no longer have any Tk
+				 * applications using it. */
+
+    /*
+     * The following field were all added for Tk8.3
+     */
+
+    int mouseButtonState;	/* Current mouse button state for this
+				 * display. */
+    Window mouseButtonWindow;	/* Window the button state was set in, added
+				 * in Tk 8.4. */
+    Tk_Window warpWindow;
+    Tk_Window warpMainwin;	/* For finding the root window for warping
+				 * purposes. */
+    int warpX;
+    int warpY;
+
+    /*
+     * The following field(s) were all added for Tk8.4
+     */
+
+    unsigned int flags;		/* Various flag values: these are all defined
+				 * in below. */
+    TkCaret caret;		/* Information about the caret for this
+				 * display. This is not a pointer. */
+
+    int iconDataSize;		/* Size of default iconphoto image data. */
+    unsigned char *iconDataPtr;	/* Default iconphoto image data, if set. */
+} TkDisplay;
+
+/*
+ * Flag values for TkDisplay flags.
+ *  TK_DISPLAY_COLLAPSE_MOTION_EVENTS:	(default on)
+ *	Indicates that we should collapse motion events on this display
+ *  TK_DISPLAY_USE_IM:			(default on, set via tk.tcl)
+ *	Whether to use input methods for this display
+ *  TK_DISPLAY_WM_TRACING:		(default off)
+ *	Whether we should do wm tracing on this display.
+ *  TK_DISPLAY_IN_WARP:			(default off)
+ *	Indicates that we are in a pointer warp
+ */
+
+#define TK_DISPLAY_COLLAPSE_MOTION_EVENTS	(1 << 0)
+#define TK_DISPLAY_USE_IM			(1 << 1)
+#define TK_DISPLAY_WM_TRACING			(1 << 3)
+#define TK_DISPLAY_IN_WARP			(1 << 4)
+
+/*
+ * One of the following structures exists for each error handler created by a
+ * call to Tk_CreateErrorHandler. The structure is managed by tkError.c.
+ */
+
+typedef struct TkErrorHandler {
+    TkDisplay *dispPtr;		/* Display to which handler applies. */
+    unsigned long firstRequest;	/* Only errors with serial numbers >= to this
+				 * are considered. */
+    unsigned long lastRequest;	/* Only errors with serial numbers <= to this
+				 * are considered. This field is filled in
+				 * when XUnhandle is called. -1 means
+				 * XUnhandle hasn't been called yet. */
+    int error;			/* Consider only errors with this error_code
+				 * (-1 means consider all errors). */
+    int request;		/* Consider only errors with this major
+				 * request code (-1 means consider all major
+				 * codes). */
+    int minorCode;		/* Consider only errors with this minor
+				 * request code (-1 means consider all minor
+				 * codes). */
+    Tk_ErrorProc *errorProc;	/* Function to invoke when a matching error
+				 * occurs. NULL means just ignore errors. */
+    ClientData clientData;	/* Arbitrary value to pass to errorProc. */
+    struct TkErrorHandler *nextPtr;
+				/* Pointer to next older handler for this
+				 * display, or NULL for end of list. */
+} TkErrorHandler;
+
+/*
+ * One of the following structures exists for each event handler created by
+ * calling Tk_CreateEventHandler. This information is used by tkEvent.c only.
+ */
+
+typedef struct TkEventHandler {
+    unsigned long mask;		/* Events for which to invoke proc. */
+    Tk_EventProc *proc;		/* Function to invoke when an event in mask
+				 * occurs. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    struct TkEventHandler *nextPtr;
+				/* Next in list of handlers associated with
+				 * window (NULL means end of list). */
+} TkEventHandler;
+
+/*
+ * Tk keeps one of the following data structures for each main window (created
+ * by a call to TkCreateMainWindow). It stores information that is shared by
+ * all of the windows associated with a particular main window.
+ */
+
+typedef struct TkMainInfo {
+    int refCount;		/* Number of windows whose "mainPtr" fields
+				 * point here. When this becomes zero, can
+				 * free up the structure (the reference count
+				 * is zero because windows can get deleted in
+				 * almost any order; the main window isn't
+				 * necessarily the last one deleted). */
+    struct TkWindow *winPtr;	/* Pointer to main window. */
+    Tcl_Interp *interp;		/* Interpreter associated with application. */
+    Tcl_HashTable nameTable;	/* Hash table mapping path names to TkWindow
+				 * structs for all windows related to this
+				 * main window. Managed by tkWindow.c. */
+    long deletionEpoch;		/* Incremented by window deletions. */
+    Tk_BindingTable bindingTable;
+				/* Used in conjunction with "bind" command to
+				 * bind events to Tcl commands. */
+    TkBindInfo bindInfo;	/* Information used by tkBind.c on a per
+				 * application basis. */
+    struct TkFontInfo *fontInfoPtr;
+				/* Information used by tkFont.c on a per
+				 * application basis. */
+
+    /*
+     * Information used only by tkFocus.c and tk*Embed.c:
+     */
+
+    struct TkToplevelFocusInfo *tlFocusPtr;
+				/* First in list of records containing focus
+				 * information for each top-level in the
+				 * application. Used only by tkFocus.c. */
+    struct TkDisplayFocusInfo *displayFocusPtr;
+				/* First in list of records containing focus
+				 * information for each display that this
+				 * application has ever used. Used only by
+				 * tkFocus.c. */
+
+    struct ElArray *optionRootPtr;
+				/* Top level of option hierarchy for this main
+				 * window. NULL means uninitialized. Managed
+				 * by tkOption.c. */
+    Tcl_HashTable imageTable;	/* Maps from image names to Tk_ImageMaster
+				 * structures. Managed by tkImage.c. */
+    int strictMotif;		/* This is linked to the tk_strictMotif global
+				 * variable. */
+    int alwaysShowSelection;	/* This is linked to the
+				 * ::tk::AlwaysShowSelection variable. */
+    struct TkMainInfo *nextPtr;	/* Next in list of all main windows managed by
+				 * this process. */
+    Tcl_HashTable busyTable;	/* Information used by [tk busy] command. */
+} TkMainInfo;
+
+/*
+ * Tk keeps the following data structure for each of it's builtin bitmaps.
+ * This structure is only used by tkBitmap.c and other platform specific
+ * bitmap files.
+ */
+
+typedef struct {
+    const void *source;		/* Bits for bitmap. */
+    int width, height;		/* Dimensions of bitmap. */
+    int native;			/* 0 means generic (X style) bitmap, 1 means
+    				 * native style bitmap. */
+} TkPredefBitmap;
+
+/*
+ * Tk keeps one of the following structures for each window. Some of the
+ * information (like size and location) is a shadow of information managed by
+ * the X server, and some is special information used here, such as event and
+ * geometry management information. This information is (mostly) managed by
+ * tkWindow.c. WARNING: the declaration below must be kept consistent with the
+ * Tk_FakeWin structure in tk.h. If you change one, be sure to change the
+ * other!
+ */
+
+typedef struct TkWindow {
+    /*
+     * Structural information:
+     */
+
+    Display *display;		/* Display containing window. */
+    TkDisplay *dispPtr;		/* Tk's information about display for
+				 * window. */
+    int screenNum;		/* Index of screen for window, among all those
+				 * for dispPtr. */
+    Visual *visual;		/* Visual to use for window. If not default,
+				 * MUST be set before X window is created. */
+    int depth;			/* Number of bits/pixel. */
+    Window window;		/* X's id for window. NULL means window hasn't
+				 * actually been created yet, or it's been
+				 * deleted. */
+    struct TkWindow *childList;	/* First in list of child windows, or NULL if
+				 * no children. List is in stacking order,
+				 * lowest window first.*/
+    struct TkWindow *lastChildPtr;
+				/* Last in list of child windows (highest in
+				 * stacking order), or NULL if no children. */
+    struct TkWindow *parentPtr;	/* Pointer to parent window (logical parent,
+				 * not necessarily X parent). NULL means
+				 * either this is the main window, or the
+				 * window's parent has already been deleted. */
+    struct TkWindow *nextPtr;	/* Next higher sibling (in stacking order) in
+				 * list of children with same parent. NULL
+				 * means end of list. */
+    TkMainInfo *mainPtr;	/* Information shared by all windows
+				 * associated with a particular main window.
+				 * NULL means this window is a rogue that is
+				 * not associated with any application (at
+				 * present, this only happens for the dummy
+				 * windows used for "send" communication). */
+
+    /*
+     * Name and type information for the window:
+     */
+
+    char *pathName;		/* Path name of window (concatenation of all
+				 * names between this window and its top-level
+				 * ancestor). This is a pointer into an entry
+				 * in mainPtr->nameTable. NULL means that the
+				 * window hasn't been completely created
+				 * yet. */
+    Tk_Uid nameUid;		/* Name of the window within its parent
+				 * (unique within the parent). */
+    Tk_Uid classUid;		/* Class of the window. NULL means window
+				 * hasn't been given a class yet. */
+
+    /*
+     * Geometry and other attributes of window. This information may not be
+     * updated on the server immediately; stuff that hasn't been reflected in
+     * the server yet is called "dirty". At present, information can be dirty
+     * only if the window hasn't yet been created.
+     */
+
+    XWindowChanges changes;	/* Geometry and other info about window. */
+    unsigned int dirtyChanges;	/* Bits indicate fields of "changes" that are
+				 * dirty. */
+    XSetWindowAttributes atts;	/* Current attributes of window. */
+    unsigned long dirtyAtts;	/* Bits indicate fields of "atts" that are
+				 * dirty. */
+
+    unsigned int flags;		/* Various flag values: these are all defined
+				 * in tk.h (confusing, but they're needed
+				 * there for some query macros). */
+
+    /*
+     * Information kept by the event manager (tkEvent.c):
+     */
+
+    TkEventHandler *handlerList;/* First in list of event handlers declared
+				 * for this window, or NULL if none. */
+#ifdef TK_USE_INPUT_METHODS
+    XIC inputContext;		/* XIM input context. */
+#endif /* TK_USE_INPUT_METHODS */
+
+    /*
+     * Information used for event bindings (see "bind" and "bindtags" commands
+     * in tkCmds.c):
+     */
+
+    ClientData *tagPtr;		/* Points to array of tags used for bindings
+				 * on this window. Each tag is a Tk_Uid.
+				 * Malloc'ed. NULL means no tags. */
+    int numTags;		/* Number of tags at *tagPtr. */
+
+    /*
+     * Information used by tkOption.c to manage options for the window.
+     */
+
+    int optionLevel;		/* -1 means no option information is currently
+				 * cached for this window. Otherwise this
+				 * gives the level in the option stack at
+				 * which info is cached. */
+    /*
+     * Information used by tkSelect.c to manage the selection.
+     */
+
+    struct TkSelHandler *selHandlerList;
+				/* First in list of handlers for returning the
+				 * selection in various forms. */
+
+    /*
+     * Information used by tkGeometry.c for geometry management.
+     */
+
+    const Tk_GeomMgr *geomMgrPtr;
+				/* Information about geometry manager for this
+				 * window. */
+    ClientData geomData;	/* Argument for geometry manager functions. */
+    int reqWidth, reqHeight;	/* Arguments from last call to
+				 * Tk_GeometryRequest, or 0's if
+				 * Tk_GeometryRequest hasn't been called. */
+    int internalBorderLeft;	/* Width of internal border of window (0 means
+				 * no internal border). Geometry managers
+				 * should not normally place children on top
+				 * of the border. Fields for the other three
+				 * sides are found below. */
+
+    /*
+     * Information maintained by tkWm.c for window manager communication.
+     */
+
+    struct TkWmInfo *wmInfoPtr;	/* For top-level windows (and also for special
+				 * Unix menubar and wrapper windows), points
+				 * to structure with wm-related info (see
+				 * tkWm.c). For other windows, this is
+				 * NULL. */
+
+    /*
+     * Information used by widget classes.
+     */
+
+    const Tk_ClassProcs *classProcsPtr;
+    ClientData instanceData;
+
+    /*
+     * Platform specific information private to each port.
+     */
+
+    struct TkWindowPrivate *privatePtr;
+
+    /*
+     * More information used by tkGeometry.c for geometry management.
+     */
+
+    /* The remaining fields of internal border. */
+    int internalBorderRight;
+    int internalBorderTop;
+    int internalBorderBottom;
+
+    int minReqWidth;		/* Minimum requested width. */
+    int minReqHeight;		/* Minimum requested height. */
+    char *geometryMaster;
+} TkWindow;
+
+/*
+ * Real definition of some events. Note that these events come from outside
+ * but have internally generated pieces added to them.
+ */
+
+typedef struct {
+    XKeyEvent keyEvent;		/* The real event from X11. */
+    char *charValuePtr;		/* A pointer to a string that holds the key's
+				 * %A substitution text (before backslash
+				 * adding), or NULL if that has not been
+				 * computed yet. If non-NULL, this string was
+				 * allocated with ckalloc(). */
+    int charValueLen;		/* Length of string in charValuePtr when that
+				 * is non-NULL. */
+    KeySym keysym;		/* Key symbol computed after input methods
+				 * have been invoked */
+} TkKeyEvent;
+
+/*
+ * Flags passed to TkpMakeMenuWindow's 'transient' argument.
+ */
+
+#define TK_MAKE_MENU_TEAROFF	0	/* Only non-transient case. */
+#define TK_MAKE_MENU_POPUP	1
+#define TK_MAKE_MENU_DROPDOWN	2
+
+/*
+ * The following structure is used with TkMakeEnsemble to create ensemble
+ * commands and optionally to create sub-ensembles.
+ */
+
+typedef struct TkEnsemble {
+    const char *name;
+    Tcl_ObjCmdProc *proc;
+    const struct TkEnsemble *subensemble;
+} TkEnsemble;
+
+/*
+ * The following structure is used as a two way map between integers and
+ * strings, usually to map between an internal C representation and the
+ * strings used in Tcl.
+ */
+
+typedef struct TkStateMap {
+    int numKey;			/* Integer representation of a value. */
+    const char *strKey;		/* String representation of a value. */
+} TkStateMap;
+
+/*
+ * This structure is used by the Mac and Window porting layers as the internal
+ * representation of a clip_mask in a GC.
+ */
+
+typedef struct TkpClipMask {
+    int type;			/* TKP_CLIP_PIXMAP or TKP_CLIP_REGION. */
+    union {
+	Pixmap pixmap;
+	TkRegion region;
+    } value;
+} TkpClipMask;
+
+#define TKP_CLIP_PIXMAP 0
+#define TKP_CLIP_REGION 1
+
+/*
+ * Return values from TkGrabState:
+ */
+
+#define TK_GRAB_NONE		0
+#define TK_GRAB_IN_TREE		1
+#define TK_GRAB_ANCESTOR	2
+#define TK_GRAB_EXCLUDED	3
+
+/*
+ * Additional flag for TkpMeasureCharsInContext. Coordinate with other flags
+ * for this routine, but don't make public until TkpMeasureCharsInContext is
+ * made public, too.
+ */
+
+#define TK_ISOLATE_END		32
+
+/*
+ * The macro below is used to modify a "char" value (e.g. by casting it to an
+ * unsigned character) so that it can be used safely with macros such as
+ * isspace().
+ */
+
+#define UCHAR(c) ((unsigned char) (c))
+
+/*
+ * The following symbol is used in the mode field of FocusIn events generated
+ * by an embedded application to request the input focus from its container.
+ */
+
+#define EMBEDDED_APP_WANTS_FOCUS (NotifyNormal + 20)
+
+/*
+ * The following special modifier mask bits are defined, to indicate logical
+ * modifiers such as Meta and Alt that may float among the actual modifier
+ * bits.
+ */
+
+#define META_MASK	(AnyModifier<<1)
+#define ALT_MASK	(AnyModifier<<2)
+#define EXTENDED_MASK	(AnyModifier<<3)
+
+/*
+ * Object types not declared in tkObj.c need to be mentioned here so they can
+ * be properly registered with Tcl:
+ */
+
+MODULE_SCOPE const Tcl_ObjType tkBorderObjType;
+MODULE_SCOPE const Tcl_ObjType tkBitmapObjType;
+MODULE_SCOPE const Tcl_ObjType tkColorObjType;
+MODULE_SCOPE const Tcl_ObjType tkCursorObjType;
+MODULE_SCOPE const Tcl_ObjType tkFontObjType;
+MODULE_SCOPE const Tcl_ObjType tkStateKeyObjType;
+MODULE_SCOPE const Tcl_ObjType tkTextIndexType;
+
+/*
+ * Miscellaneous variables shared among Tk modules but not exported to the
+ * outside world:
+ */
+
+MODULE_SCOPE const Tk_SmoothMethod tkBezierSmoothMethod;
+MODULE_SCOPE Tk_ImageType	tkBitmapImageType;
+MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtGIF;
+MODULE_SCOPE void		(*tkHandleEventProc) (XEvent* eventPtr);
+MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtPNG;
+MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtPPM;
+MODULE_SCOPE TkMainInfo		*tkMainWindowList;
+MODULE_SCOPE Tk_ImageType	tkPhotoImageType;
+MODULE_SCOPE Tcl_HashTable	tkPredefBitmapTable;
+
+MODULE_SCOPE const char *const tkWebColors[20];
+
+/*
+ * The definition of pi, at least from the perspective of double-precision
+ * floats.
+ */
+
+#ifndef PI
+#ifdef M_PI
+#define PI	M_PI
+#else
+#define PI	3.14159265358979323846
+#endif
+#endif
+
+/*
+ * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
+ */
+
+#if defined(PURIFY) && defined(__clang__)
+#if __has_feature(attribute_analyzer_noreturn) && \
+	!defined(Tcl_Panic) && defined(Tcl_Panic_TCL_DECLARED)
+void Tcl_Panic(const char *, ...) __attribute__((analyzer_noreturn));
+#endif
+#if !defined(CLANG_ASSERT)
+#include <assert.h>
+#define CLANG_ASSERT(x) assert(x)
+#endif
+#elif !defined(CLANG_ASSERT)
+#define CLANG_ASSERT(x)
+#endif /* PURIFY && __clang__ */
+
+/*
+ * The following magic value is stored in the "send_event" field of FocusIn
+ * and FocusOut events. This allows us to separate "real" events coming from
+ * the server from those that we generated.
+ */
+
+#define GENERATED_FOCUS_EVENT_MAGIC	((Bool) 0x547321ac)
+
+/*
+ * Exported internals.
+ */
+
+#include "tkIntDecls.h"
+
+/*
+ * Themed widget set init function:
+ */
+
+MODULE_SCOPE int	Ttk_Init(Tcl_Interp *interp);
+
+/*
+ * Internal functions shared among Tk modules but not exported to the outside
+ * world:
+ */
+
+MODULE_SCOPE int	Tk_BellObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_BindObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_BindtagsObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_BusyObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ButtonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_CanvasObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_CheckbuttonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ClipboardObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ChooseColorObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ChooseDirectoryObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_DestroyObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_EntryObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_EventObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_FrameObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_FocusObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_FontObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GetOpenFileObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GetSaveFileObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GrabObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GridObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ImageObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_LabelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_LabelframeObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ListboxObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_LowerObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_MenubuttonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_MessageBoxObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_MessageObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_PanedWindowObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_OptionObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_PackObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_PlaceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_RadiobuttonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_RaiseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ScaleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ScrollbarCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc, const char **argv);
+MODULE_SCOPE int	Tk_SelectionObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_SendCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc, const char **argv);
+MODULE_SCOPE int	Tk_SendObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_SpinboxObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_TextObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_TkwaitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ToplevelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_UpdateObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_WinfoObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_WmObjCmd(ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+
+MODULE_SCOPE int	Tk_GetDoublePixelsFromObj(Tcl_Interp *interp,
+			    Tk_Window tkwin, Tcl_Obj *objPtr,
+			    double *doublePtr);
+MODULE_SCOPE int	TkSetGeometryMaster(Tcl_Interp *interp,
+			    Tk_Window tkwin, const char *master);
+MODULE_SCOPE void	TkFreeGeometryMaster(Tk_Window tkwin,
+			    const char *master);
+
+MODULE_SCOPE void	TkEventInit(void);
+MODULE_SCOPE void	TkRegisterObjTypes(void);
+MODULE_SCOPE int	TkCreateMenuCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TkDeadAppCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc, const char **argv);
+MODULE_SCOPE int	TkCanvasGetCoordObj(Tcl_Interp *interp,
+			    Tk_Canvas canvas, Tcl_Obj *obj,
+			    double *doublePtr);
+MODULE_SCOPE int	TkGetDoublePixels(Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *string, double *doublePtr);
+MODULE_SCOPE int	TkPostscriptImage(Tcl_Interp *interp, Tk_Window tkwin,
+			    Tk_PostscriptInfo psInfo, XImage *ximage,
+			    int x, int y, int width, int height);
+MODULE_SCOPE void       TkMapTopFrame(Tk_Window tkwin);
+MODULE_SCOPE XEvent *	TkpGetBindingXEvent(Tcl_Interp *interp);
+MODULE_SCOPE void	TkCreateExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE void	TkDeleteExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE Tcl_ExitProc	TkFinalize;
+MODULE_SCOPE Tcl_ExitProc	TkFinalizeThread;
+MODULE_SCOPE void	TkpBuildRegionFromAlphaData(TkRegion region,
+			    unsigned x, unsigned y, unsigned width,
+			    unsigned height, unsigned char *dataPtr,
+			    unsigned pixelStride, unsigned lineStride);
+MODULE_SCOPE void	TkAppendPadAmount(Tcl_Obj *bufferObj,
+			    const char *buffer, int pad1, int pad2);
+MODULE_SCOPE int	TkParsePadAmount(Tcl_Interp *interp,
+			    Tk_Window tkwin, Tcl_Obj *objPtr,
+			    int *pad1Ptr, int *pad2Ptr);
+MODULE_SCOPE void       TkFocusSplit(TkWindow *winPtr);
+MODULE_SCOPE void       TkFocusJoin(TkWindow *winPtr);
+MODULE_SCOPE int	TkpAlwaysShowSelection(Tk_Window tkwin);
+MODULE_SCOPE void	TkpDrawCharsInContext(Display * display,
+			    Drawable drawable, GC gc, Tk_Font tkfont,
+			    const char *source, int numBytes, int rangeStart,
+			    int rangeLength, int x, int y);
+MODULE_SCOPE int	TkpMeasureCharsInContext(Tk_Font tkfont,
+			    const char *source, int numBytes, int rangeStart,
+			    int rangeLength, int maxLength, int flags,
+			    int *lengthPtr);
+MODULE_SCOPE void	TkUnderlineCharsInContext(Display *display,
+			    Drawable drawable, GC gc, Tk_Font tkfont,
+			    const char *string, int numBytes, int x, int y,
+			    int firstByte, int lastByte);
+MODULE_SCOPE void	TkpGetFontAttrsForChar(Tk_Window tkwin, Tk_Font tkfont,
+			    Tcl_UniChar c, struct TkFontAttributes *faPtr);
+MODULE_SCOPE Tcl_Obj *	TkNewWindowObj(Tk_Window tkwin);
+MODULE_SCOPE void	TkpShowBusyWindow(TkBusy busy);
+MODULE_SCOPE void	TkpHideBusyWindow(TkBusy busy);
+MODULE_SCOPE void	TkpMakeTransparentWindowExist(Tk_Window tkwin,
+			    Window parent);
+MODULE_SCOPE void	TkpCreateBusy(Tk_FakeWin *winPtr, Tk_Window tkRef,
+			    Window *parentPtr, Tk_Window tkParent,
+			    TkBusy busy);
+MODULE_SCOPE int	TkBackgroundEvalObjv(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const *objv, int flags);
+#if TK_MAJOR_VERSION > 8 \
+	|| (TK_MAJOR_VERSION == 8 \
+	    && (TK_MINOR_VERSION > 6 || (TK_MINOR_VERSION == 6 && TK_RELEASE_SERIAL >= 6)))
+MODULE_SCOPE void	TkSendVirtualEvent(Tk_Window tgtWin,
+			    const char *eventName, Tcl_Obj *detail);
+#else
+MODULE_SCOPE void	TkSendVirtualEvent(Tk_Window tgtWin,
+			    const char *eventName);
+#endif
+MODULE_SCOPE Tcl_Command TkMakeEnsemble(Tcl_Interp *interp,
+			    const char *nsname, const char *name,
+			    ClientData clientData, const TkEnsemble *map);
+MODULE_SCOPE int	TkInitTkCmd(Tcl_Interp *interp,
+			    ClientData clientData);
+MODULE_SCOPE int	TkInitFontchooser(Tcl_Interp *interp,
+			    ClientData clientData);
+MODULE_SCOPE void	TkpWarpPointer(TkDisplay *dispPtr);
+
+#ifdef __WIN32__
+#define TkParseColor XParseColor
+#else
+MODULE_SCOPE Status TkParseColor (Display * display,
+				Colormap map, const char* spec,
+				XColor * colorPtr);
+#endif
+#ifdef HAVE_XFT
+MODULE_SCOPE void	TkUnixSetXftClipRegion(TkRegion clipRegion);
+#endif
+
+/*
+ * Unsupported commands.
+ */
+
+MODULE_SCOPE int	TkUnsupported1ObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+
+/*
+ * For Tktest.
+ */
+MODULE_SCOPE int SquareObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj * const objv[]);
+MODULE_SCOPE int	TkOldTestInit(Tcl_Interp *interp);
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK))
+#define TkplatformtestInit(x) TCL_OK
+#else
+MODULE_SCOPE int	TkplatformtestInit(Tcl_Interp *interp);
+#endif
+
+#endif /* _TKINT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
Index: src/tktext/tk8.6/tkIntDecls.h
===================================================================
--- src/tktext/tk8.6/tkIntDecls.h	(revision 0)
+++ src/tktext/tk8.6/tkIntDecls.h	(working copy)
@@ -0,0 +1,1182 @@
+/*
+ * tkIntDecls.h --
+ *
+ *	This file contains the declarations for all unsupported
+ *	functions that are exported by the Tk library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKINTDECLS
+#define _TKINTDECLS
+
+#ifdef BUILD_tk
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+struct TkText;
+typedef struct TkTextBTree_ *TkTextBTree;
+struct TkTextDispChunk;
+struct TkTextIndex;
+struct TkTextSegment;
+struct TkSharedText;
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tkInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+/* 0 */
+EXTERN TkWindow *	TkAllocWindow(TkDisplay *dispPtr, int screenNum,
+				TkWindow *parentPtr);
+/* 1 */
+EXTERN void		TkBezierPoints(double control[], int numSteps,
+				double *coordPtr);
+/* 2 */
+EXTERN void		TkBezierScreenPoints(Tk_Canvas canvas,
+				double control[], int numSteps,
+				XPoint *xPointPtr);
+/* Slot 3 is reserved */
+/* 4 */
+EXTERN void		TkBindEventProc(TkWindow *winPtr, XEvent *eventPtr);
+/* 5 */
+EXTERN void		TkBindFree(TkMainInfo *mainPtr);
+/* 6 */
+EXTERN void		TkBindInit(TkMainInfo *mainPtr);
+/* 7 */
+EXTERN void		TkChangeEventWindow(XEvent *eventPtr,
+				TkWindow *winPtr);
+/* 8 */
+EXTERN int		TkClipInit(Tcl_Interp *interp, TkDisplay *dispPtr);
+/* 9 */
+EXTERN void		TkComputeAnchor(Tk_Anchor anchor, Tk_Window tkwin,
+				int padX, int padY, int innerWidth,
+				int innerHeight, int *xPtr, int *yPtr);
+/* Slot 10 is reserved */
+/* Slot 11 is reserved */
+/* 12 */
+EXTERN TkCursor *	TkCreateCursorFromData(Tk_Window tkwin,
+				const char *source, const char *mask,
+				int width, int height, int xHot, int yHot,
+				XColor fg, XColor bg);
+/* 13 */
+EXTERN int		TkCreateFrame(ClientData clientData,
+				Tcl_Interp *interp, int argc,
+				const char *const *argv, int toplevel,
+				const char *appName);
+/* 14 */
+EXTERN Tk_Window	TkCreateMainWindow(Tcl_Interp *interp,
+				const char *screenName, const char *baseName);
+/* 15 */
+EXTERN Time		TkCurrentTime(TkDisplay *dispPtr);
+/* 16 */
+EXTERN void		TkDeleteAllImages(TkMainInfo *mainPtr);
+/* 17 */
+EXTERN void		TkDoConfigureNotify(TkWindow *winPtr);
+/* 18 */
+EXTERN void		TkDrawInsetFocusHighlight(Tk_Window tkwin, GC gc,
+				int width, Drawable drawable, int padding);
+/* 19 */
+EXTERN void		TkEventDeadWindow(TkWindow *winPtr);
+/* 20 */
+EXTERN void		TkFillPolygon(Tk_Canvas canvas, double *coordPtr,
+				int numPoints, Display *display,
+				Drawable drawable, GC gc, GC outlineGC);
+/* 21 */
+EXTERN int		TkFindStateNum(Tcl_Interp *interp,
+				const char *option, const TkStateMap *mapPtr,
+				const char *strKey);
+/* 22 */
+EXTERN CONST86 char *	TkFindStateString(const TkStateMap *mapPtr,
+				int numKey);
+/* 23 */
+EXTERN void		TkFocusDeadWindow(TkWindow *winPtr);
+/* 24 */
+EXTERN int		TkFocusFilterEvent(TkWindow *winPtr,
+				XEvent *eventPtr);
+/* 25 */
+EXTERN TkWindow *	TkFocusKeyEvent(TkWindow *winPtr, XEvent *eventPtr);
+/* 26 */
+EXTERN void		TkFontPkgInit(TkMainInfo *mainPtr);
+/* 27 */
+EXTERN void		TkFontPkgFree(TkMainInfo *mainPtr);
+/* 28 */
+EXTERN void		TkFreeBindingTags(TkWindow *winPtr);
+/* 29 */
+EXTERN void		TkpFreeCursor(TkCursor *cursorPtr);
+/* 30 */
+EXTERN char *		TkGetBitmapData(Tcl_Interp *interp,
+				const char *string, const char *fileName,
+				int *widthPtr, int *heightPtr, int *hotXPtr,
+				int *hotYPtr);
+/* 31 */
+EXTERN void		TkGetButtPoints(double p1[], double p2[],
+				double width, int project, double m1[],
+				double m2[]);
+/* 32 */
+EXTERN TkCursor *	TkGetCursorByName(Tcl_Interp *interp,
+				Tk_Window tkwin, Tk_Uid string);
+/* 33 */
+EXTERN const char *	TkGetDefaultScreenName(Tcl_Interp *interp,
+				const char *screenName);
+/* 34 */
+EXTERN TkDisplay *	TkGetDisplay(Display *display);
+/* 35 */
+EXTERN int		TkGetDisplayOf(Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[], Tk_Window *tkwinPtr);
+/* 36 */
+EXTERN TkWindow *	TkGetFocusWin(TkWindow *winPtr);
+/* 37 */
+EXTERN int		TkGetInterpNames(Tcl_Interp *interp, Tk_Window tkwin);
+/* 38 */
+EXTERN int		TkGetMiterPoints(double p1[], double p2[],
+				double p3[], double width, double m1[],
+				double m2[]);
+/* 39 */
+EXTERN void		TkGetPointerCoords(Tk_Window tkwin, int *xPtr,
+				int *yPtr);
+/* 40 */
+EXTERN void		TkGetServerInfo(Tcl_Interp *interp, Tk_Window tkwin);
+/* 41 */
+EXTERN void		TkGrabDeadWindow(TkWindow *winPtr);
+/* 42 */
+EXTERN int		TkGrabState(TkWindow *winPtr);
+/* 43 */
+EXTERN void		TkIncludePoint(Tk_Item *itemPtr, double *pointPtr);
+/* 44 */
+EXTERN void		TkInOutEvents(XEvent *eventPtr, TkWindow *sourcePtr,
+				TkWindow *destPtr, int leaveType,
+				int enterType, Tcl_QueuePosition position);
+/* 45 */
+EXTERN void		TkInstallFrameMenu(Tk_Window tkwin);
+/* 46 */
+EXTERN CONST86 char *	TkKeysymToString(KeySym keysym);
+/* 47 */
+EXTERN int		TkLineToArea(double end1Ptr[], double end2Ptr[],
+				double rectPtr[]);
+/* 48 */
+EXTERN double		TkLineToPoint(double end1Ptr[], double end2Ptr[],
+				double pointPtr[]);
+/* 49 */
+EXTERN int		TkMakeBezierCurve(Tk_Canvas canvas, double *pointPtr,
+				int numPoints, int numSteps,
+				XPoint xPoints[], double dblPoints[]);
+/* 50 */
+EXTERN void		TkMakeBezierPostscript(Tcl_Interp *interp,
+				Tk_Canvas canvas, double *pointPtr,
+				int numPoints);
+/* 51 */
+EXTERN void		TkOptionClassChanged(TkWindow *winPtr);
+/* 52 */
+EXTERN void		TkOptionDeadWindow(TkWindow *winPtr);
+/* 53 */
+EXTERN int		TkOvalToArea(double *ovalPtr, double *rectPtr);
+/* 54 */
+EXTERN double		TkOvalToPoint(double ovalPtr[], double width,
+				int filled, double pointPtr[]);
+/* 55 */
+EXTERN int		TkpChangeFocus(TkWindow *winPtr, int force);
+/* 56 */
+EXTERN void		TkpCloseDisplay(TkDisplay *dispPtr);
+/* 57 */
+EXTERN void		TkpClaimFocus(TkWindow *topLevelPtr, int force);
+/* 58 */
+EXTERN void		TkpDisplayWarning(const char *msg, const char *title);
+/* 59 */
+EXTERN void		TkpGetAppName(Tcl_Interp *interp, Tcl_DString *name);
+/* 60 */
+EXTERN TkWindow *	TkpGetOtherWindow(TkWindow *winPtr);
+/* 61 */
+EXTERN TkWindow *	TkpGetWrapperWindow(TkWindow *winPtr);
+/* 62 */
+EXTERN int		TkpInit(Tcl_Interp *interp);
+/* 63 */
+EXTERN void		TkpInitializeMenuBindings(Tcl_Interp *interp,
+				Tk_BindingTable bindingTable);
+/* 64 */
+EXTERN void		TkpMakeContainer(Tk_Window tkwin);
+/* 65 */
+EXTERN void		TkpMakeMenuWindow(Tk_Window tkwin, int transient);
+/* 66 */
+EXTERN Window		TkpMakeWindow(TkWindow *winPtr, Window parent);
+/* 67 */
+EXTERN void		TkpMenuNotifyToplevelCreate(Tcl_Interp *interp,
+				const char *menuName);
+/* 68 */
+EXTERN TkDisplay *	TkpOpenDisplay(const char *display_name);
+/* 69 */
+EXTERN int		TkPointerEvent(XEvent *eventPtr, TkWindow *winPtr);
+/* 70 */
+EXTERN int		TkPolygonToArea(double *polyPtr, int numPoints,
+				double *rectPtr);
+/* 71 */
+EXTERN double		TkPolygonToPoint(double *polyPtr, int numPoints,
+				double *pointPtr);
+/* 72 */
+EXTERN int		TkPositionInTree(TkWindow *winPtr, TkWindow *treePtr);
+/* 73 */
+EXTERN void		TkpRedirectKeyEvent(TkWindow *winPtr,
+				XEvent *eventPtr);
+/* 74 */
+EXTERN void		TkpSetMainMenubar(Tcl_Interp *interp,
+				Tk_Window tkwin, const char *menuName);
+/* 75 */
+EXTERN int		TkpUseWindow(Tcl_Interp *interp, Tk_Window tkwin,
+				const char *string);
+/* Slot 76 is reserved */
+/* 77 */
+EXTERN void		TkQueueEventForAllChildren(TkWindow *winPtr,
+				XEvent *eventPtr);
+/* 78 */
+EXTERN int		TkReadBitmapFile(Display *display, Drawable d,
+				const char *filename,
+				unsigned int *width_return,
+				unsigned int *height_return,
+				Pixmap *bitmap_return, int *x_hot_return,
+				int *y_hot_return);
+/* 79 */
+EXTERN int		TkScrollWindow(Tk_Window tkwin, GC gc, int x, int y,
+				int width, int height, int dx, int dy,
+				TkRegion damageRgn);
+/* 80 */
+EXTERN void		TkSelDeadWindow(TkWindow *winPtr);
+/* 81 */
+EXTERN void		TkSelEventProc(Tk_Window tkwin, XEvent *eventPtr);
+/* 82 */
+EXTERN void		TkSelInit(Tk_Window tkwin);
+/* 83 */
+EXTERN void		TkSelPropProc(XEvent *eventPtr);
+/* Slot 84 is reserved */
+/* 85 */
+EXTERN void		TkSetWindowMenuBar(Tcl_Interp *interp,
+				Tk_Window tkwin, const char *oldMenuName,
+				const char *menuName);
+/* 86 */
+EXTERN KeySym		TkStringToKeysym(const char *name);
+/* 87 */
+EXTERN int		TkThickPolyLineToArea(double *coordPtr,
+				int numPoints, double width, int capStyle,
+				int joinStyle, double *rectPtr);
+/* 88 */
+EXTERN void		TkWmAddToColormapWindows(TkWindow *winPtr);
+/* 89 */
+EXTERN void		TkWmDeadWindow(TkWindow *winPtr);
+/* 90 */
+EXTERN TkWindow *	TkWmFocusToplevel(TkWindow *winPtr);
+/* 91 */
+EXTERN void		TkWmMapWindow(TkWindow *winPtr);
+/* 92 */
+EXTERN void		TkWmNewWindow(TkWindow *winPtr);
+/* 93 */
+EXTERN void		TkWmProtocolEventProc(TkWindow *winPtr,
+				XEvent *evenvPtr);
+/* 94 */
+EXTERN void		TkWmRemoveFromColormapWindows(TkWindow *winPtr);
+/* 95 */
+EXTERN void		TkWmRestackToplevel(TkWindow *winPtr, int aboveBelow,
+				TkWindow *otherPtr);
+/* 96 */
+EXTERN void		TkWmSetClass(TkWindow *winPtr);
+/* 97 */
+EXTERN void		TkWmUnmapWindow(TkWindow *winPtr);
+/* 98 */
+EXTERN Tcl_Obj *	TkDebugBitmap(Tk_Window tkwin, const char *name);
+/* 99 */
+EXTERN Tcl_Obj *	TkDebugBorder(Tk_Window tkwin, const char *name);
+/* 100 */
+EXTERN Tcl_Obj *	TkDebugCursor(Tk_Window tkwin, const char *name);
+/* 101 */
+EXTERN Tcl_Obj *	TkDebugColor(Tk_Window tkwin, const char *name);
+/* 102 */
+EXTERN Tcl_Obj *	TkDebugConfig(Tcl_Interp *interp,
+				Tk_OptionTable table);
+/* 103 */
+EXTERN Tcl_Obj *	TkDebugFont(Tk_Window tkwin, const char *name);
+/* 104 */
+EXTERN int		TkFindStateNumObj(Tcl_Interp *interp,
+				Tcl_Obj *optionPtr, const TkStateMap *mapPtr,
+				Tcl_Obj *keyPtr);
+/* 105 */
+EXTERN Tcl_HashTable *	TkGetBitmapPredefTable(void);
+/* 106 */
+EXTERN TkDisplay *	TkGetDisplayList(void);
+/* 107 */
+EXTERN TkMainInfo *	TkGetMainInfoList(void);
+/* 108 */
+EXTERN int		TkGetWindowFromObj(Tcl_Interp *interp,
+				Tk_Window tkwin, Tcl_Obj *objPtr,
+				Tk_Window *windowPtr);
+/* 109 */
+EXTERN CONST86 char *	TkpGetString(TkWindow *winPtr, XEvent *eventPtr,
+				Tcl_DString *dsPtr);
+/* 110 */
+EXTERN void		TkpGetSubFonts(Tcl_Interp *interp, Tk_Font tkfont);
+/* 111 */
+EXTERN Tcl_Obj *	TkpGetSystemDefault(Tk_Window tkwin,
+				const char *dbName, const char *className);
+/* 112 */
+EXTERN void		TkpMenuThreadInit(void);
+/* 113 */
+EXTERN void		TkClipBox(TkRegion rgn, XRectangle *rect_return);
+/* 114 */
+EXTERN TkRegion		TkCreateRegion(void);
+/* 115 */
+EXTERN void		TkDestroyRegion(TkRegion rgn);
+/* 116 */
+EXTERN void		TkIntersectRegion(TkRegion sra, TkRegion srcb,
+				TkRegion dr_return);
+/* 117 */
+EXTERN int		TkRectInRegion(TkRegion rgn, int x, int y,
+				unsigned int width, unsigned int height);
+/* 118 */
+EXTERN void		TkSetRegion(Display *display, GC gc, TkRegion rgn);
+/* 119 */
+EXTERN void		TkUnionRectWithRegion(XRectangle *rect, TkRegion src,
+				TkRegion dr_return);
+/* Slot 120 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+/* 121 */
+EXTERN Pixmap		TkpCreateNativeBitmap(Display *display,
+				const void *source);
+#endif /* AQUA */
+#ifdef MAC_OSX_TK /* AQUA */
+/* 122 */
+EXTERN void		TkpDefineNativeBitmaps(void);
+#endif /* AQUA */
+/* Slot 123 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+/* 124 */
+EXTERN Pixmap		TkpGetNativeAppBitmap(Display *display,
+				const char *name, int *width, int *height);
+#endif /* AQUA */
+/* Slot 125 is reserved */
+/* Slot 126 is reserved */
+/* Slot 127 is reserved */
+/* Slot 128 is reserved */
+/* Slot 129 is reserved */
+/* Slot 130 is reserved */
+/* Slot 131 is reserved */
+/* Slot 132 is reserved */
+/* Slot 133 is reserved */
+/* Slot 134 is reserved */
+/* 135 */
+EXTERN void		TkpDrawHighlightBorder(Tk_Window tkwin, GC fgGC,
+				GC bgGC, int highlightWidth,
+				Drawable drawable);
+/* 136 */
+EXTERN void		TkSetFocusWin(TkWindow *winPtr, int force);
+/* 137 */
+EXTERN void		TkpSetKeycodeAndState(Tk_Window tkwin, KeySym keySym,
+				XEvent *eventPtr);
+/* 138 */
+EXTERN KeySym		TkpGetKeySym(TkDisplay *dispPtr, XEvent *eventPtr);
+/* 139 */
+EXTERN void		TkpInitKeymapInfo(TkDisplay *dispPtr);
+/* 140 */
+EXTERN TkRegion		TkPhotoGetValidRegion(Tk_PhotoHandle handle);
+/* 141 */
+EXTERN TkWindow **	TkWmStackorderToplevel(TkWindow *parentPtr);
+/* 142 */
+EXTERN void		TkFocusFree(TkMainInfo *mainPtr);
+/* 143 */
+EXTERN void		TkClipCleanup(TkDisplay *dispPtr);
+/* 144 */
+EXTERN void		TkGCCleanup(TkDisplay *dispPtr);
+/* 145 */
+EXTERN void		TkSubtractRegion(TkRegion sra, TkRegion srcb,
+				TkRegion dr_return);
+/* 146 */
+EXTERN void		TkStylePkgInit(TkMainInfo *mainPtr);
+/* 147 */
+EXTERN void		TkStylePkgFree(TkMainInfo *mainPtr);
+/* 148 */
+EXTERN Tk_Window	TkToplevelWindowForCommand(Tcl_Interp *interp,
+				const char *cmdName);
+/* 149 */
+EXTERN const Tk_OptionSpec * TkGetOptionSpec(const char *name,
+				Tk_OptionTable optionTable);
+/* 150 */
+EXTERN int		TkMakeRawCurve(Tk_Canvas canvas, double *pointPtr,
+				int numPoints, int numSteps,
+				XPoint xPoints[], double dblPoints[]);
+/* 151 */
+EXTERN void		TkMakeRawCurvePostscript(Tcl_Interp *interp,
+				Tk_Canvas canvas, double *pointPtr,
+				int numPoints);
+/* 152 */
+EXTERN void		TkpDrawFrame(Tk_Window tkwin, Tk_3DBorder border,
+				int highlightWidth, int borderWidth,
+				int relief);
+/* 153 */
+EXTERN void		TkCreateThreadExitHandler(Tcl_ExitProc *proc,
+				ClientData clientData);
+/* 154 */
+EXTERN void		TkDeleteThreadExitHandler(Tcl_ExitProc *proc,
+				ClientData clientData);
+/* Slot 155 is reserved */
+/* 156 */
+EXTERN int		TkpTestembedCmd(ClientData clientData,
+				Tcl_Interp *interp, int argc,
+				const char **argv);
+/* 157 */
+#if TK_MINOR_VERSION >= 6
+EXTERN int		TkpTesttextCmd(ClientData dummy, Tcl_Interp *interp,
+				int objc, Tcl_Obj *const objv[]);
+#else
+EXTERN int		TkpTesttextCmd(ClientData dummy, Tcl_Interp *interp,
+				int argc, const char **argv);
+#endif
+/* 158 */
+EXTERN int		TkSelGetSelection(Tcl_Interp *interp,
+				Tk_Window tkwin, Atom selection, Atom target,
+				Tk_GetSelProc *proc, ClientData clientData);
+/* 159 */
+EXTERN int		TkTextGetIndex(Tcl_Interp *interp,
+				struct TkText *textPtr, const char *string,
+				struct TkTextIndex *indexPtr);
+/* 160 */
+EXTERN int		TkTextIndexBackBytes(const struct TkText *textPtr,
+				const struct TkTextIndex *srcPtr, int count,
+				struct TkTextIndex *dstPtr);
+/* 161 */
+EXTERN int		TkTextIndexForwBytes(const struct TkText *textPtr,
+				const struct TkTextIndex *srcPtr, int count,
+				struct TkTextIndex *dstPtr);
+/* 162 */
+EXTERN struct TkTextIndex * TkTextMakeByteIndex(TkTextBTree tree,
+				const struct TkText *textPtr, int lineIndex,
+				int byteIndex, struct TkTextIndex *indexPtr);
+/* 163 */
+EXTERN int		TkTextPrintIndex(const struct TkText *textPtr,
+				const struct TkTextIndex *indexPtr,
+				char *string);
+/* 164 */
+EXTERN struct TkTextSegment * TkTextSetMark(struct TkText *textPtr,
+				const char *name,
+				struct TkTextIndex *indexPtr);
+/* 165 */
+EXTERN int		TkTextXviewCmd(struct TkText *textPtr,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+/* 166 */
+EXTERN void		TkTextChanged(struct TkSharedText *sharedTextPtr,
+				struct TkText *textPtr,
+				const struct TkTextIndex *index1Ptr,
+				const struct TkTextIndex *index2Ptr);
+/* 167 */
+EXTERN int		TkBTreeNumLines(TkTextBTree tree,
+				const struct TkText *textPtr);
+/* 168 */
+EXTERN void		TkTextInsertDisplayProc(struct TkText *textPtr,
+				struct TkTextDispChunk *chunkPtr, int x,
+				int y, int height, int baseline,
+				Display *display, Drawable dst, int screenY);
+/* 169 */
+EXTERN int		TkStateParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 170 */
+EXTERN CONST86 char *	TkStatePrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 171 */
+EXTERN int		TkCanvasDashParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 172 */
+EXTERN CONST86 char *	TkCanvasDashPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 173 */
+EXTERN int		TkOffsetParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 174 */
+EXTERN CONST86 char *	TkOffsetPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 175 */
+EXTERN int		TkPixelParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 176 */
+EXTERN CONST86 char *	TkPixelPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 177 */
+EXTERN int		TkOrientParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 178 */
+EXTERN CONST86 char *	TkOrientPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 179 */
+EXTERN int		TkSmoothParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 180 */
+EXTERN CONST86 char *	TkSmoothPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 181 */
+EXTERN void		TkDrawAngledTextLayout(Display *display,
+				Drawable drawable, GC gc,
+				Tk_TextLayout layout, int x, int y,
+				double angle, int firstChar, int lastChar);
+/* 182 */
+EXTERN void		TkUnderlineAngledTextLayout(Display *display,
+				Drawable drawable, GC gc,
+				Tk_TextLayout layout, int x, int y,
+				double angle, int underline);
+/* 183 */
+EXTERN int		TkIntersectAngledTextLayout(Tk_TextLayout layout,
+				int x, int y, int width, int height,
+				double angle);
+/* 184 */
+EXTERN void		TkDrawAngledChars(Display *display,
+				Drawable drawable, GC gc, Tk_Font tkfont,
+				const char *source, int numBytes, double x,
+				double y, double angle);
+
+typedef struct TkIntStubs {
+    int magic;
+    void *hooks;
+
+    TkWindow * (*tkAllocWindow) (TkDisplay *dispPtr, int screenNum, TkWindow *parentPtr); /* 0 */
+    void (*tkBezierPoints) (double control[], int numSteps, double *coordPtr); /* 1 */
+    void (*tkBezierScreenPoints) (Tk_Canvas canvas, double control[], int numSteps, XPoint *xPointPtr); /* 2 */
+    void (*reserved3)(void);
+    void (*tkBindEventProc) (TkWindow *winPtr, XEvent *eventPtr); /* 4 */
+    void (*tkBindFree) (TkMainInfo *mainPtr); /* 5 */
+    void (*tkBindInit) (TkMainInfo *mainPtr); /* 6 */
+    void (*tkChangeEventWindow) (XEvent *eventPtr, TkWindow *winPtr); /* 7 */
+    int (*tkClipInit) (Tcl_Interp *interp, TkDisplay *dispPtr); /* 8 */
+    void (*tkComputeAnchor) (Tk_Anchor anchor, Tk_Window tkwin, int padX, int padY, int innerWidth, int innerHeight, int *xPtr, int *yPtr); /* 9 */
+    void (*reserved10)(void);
+    void (*reserved11)(void);
+    TkCursor * (*tkCreateCursorFromData) (Tk_Window tkwin, const char *source, const char *mask, int width, int height, int xHot, int yHot, XColor fg, XColor bg); /* 12 */
+    int (*tkCreateFrame) (ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv, int toplevel, const char *appName); /* 13 */
+    Tk_Window (*tkCreateMainWindow) (Tcl_Interp *interp, const char *screenName, const char *baseName); /* 14 */
+    Time (*tkCurrentTime) (TkDisplay *dispPtr); /* 15 */
+    void (*tkDeleteAllImages) (TkMainInfo *mainPtr); /* 16 */
+    void (*tkDoConfigureNotify) (TkWindow *winPtr); /* 17 */
+    void (*tkDrawInsetFocusHighlight) (Tk_Window tkwin, GC gc, int width, Drawable drawable, int padding); /* 18 */
+    void (*tkEventDeadWindow) (TkWindow *winPtr); /* 19 */
+    void (*tkFillPolygon) (Tk_Canvas canvas, double *coordPtr, int numPoints, Display *display, Drawable drawable, GC gc, GC outlineGC); /* 20 */
+    int (*tkFindStateNum) (Tcl_Interp *interp, const char *option, const TkStateMap *mapPtr, const char *strKey); /* 21 */
+    CONST86 char * (*tkFindStateString) (const TkStateMap *mapPtr, int numKey); /* 22 */
+    void (*tkFocusDeadWindow) (TkWindow *winPtr); /* 23 */
+    int (*tkFocusFilterEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 24 */
+    TkWindow * (*tkFocusKeyEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 25 */
+    void (*tkFontPkgInit) (TkMainInfo *mainPtr); /* 26 */
+    void (*tkFontPkgFree) (TkMainInfo *mainPtr); /* 27 */
+    void (*tkFreeBindingTags) (TkWindow *winPtr); /* 28 */
+    void (*tkpFreeCursor) (TkCursor *cursorPtr); /* 29 */
+    char * (*tkGetBitmapData) (Tcl_Interp *interp, const char *string, const char *fileName, int *widthPtr, int *heightPtr, int *hotXPtr, int *hotYPtr); /* 30 */
+    void (*tkGetButtPoints) (double p1[], double p2[], double width, int project, double m1[], double m2[]); /* 31 */
+    TkCursor * (*tkGetCursorByName) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid string); /* 32 */
+    const char * (*tkGetDefaultScreenName) (Tcl_Interp *interp, const char *screenName); /* 33 */
+    TkDisplay * (*tkGetDisplay) (Display *display); /* 34 */
+    int (*tkGetDisplayOf) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], Tk_Window *tkwinPtr); /* 35 */
+    TkWindow * (*tkGetFocusWin) (TkWindow *winPtr); /* 36 */
+    int (*tkGetInterpNames) (Tcl_Interp *interp, Tk_Window tkwin); /* 37 */
+    int (*tkGetMiterPoints) (double p1[], double p2[], double p3[], double width, double m1[], double m2[]); /* 38 */
+    void (*tkGetPointerCoords) (Tk_Window tkwin, int *xPtr, int *yPtr); /* 39 */
+    void (*tkGetServerInfo) (Tcl_Interp *interp, Tk_Window tkwin); /* 40 */
+    void (*tkGrabDeadWindow) (TkWindow *winPtr); /* 41 */
+    int (*tkGrabState) (TkWindow *winPtr); /* 42 */
+    void (*tkIncludePoint) (Tk_Item *itemPtr, double *pointPtr); /* 43 */
+    void (*tkInOutEvents) (XEvent *eventPtr, TkWindow *sourcePtr, TkWindow *destPtr, int leaveType, int enterType, Tcl_QueuePosition position); /* 44 */
+    void (*tkInstallFrameMenu) (Tk_Window tkwin); /* 45 */
+    CONST86 char * (*tkKeysymToString) (KeySym keysym); /* 46 */
+    int (*tkLineToArea) (double end1Ptr[], double end2Ptr[], double rectPtr[]); /* 47 */
+    double (*tkLineToPoint) (double end1Ptr[], double end2Ptr[], double pointPtr[]); /* 48 */
+    int (*tkMakeBezierCurve) (Tk_Canvas canvas, double *pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 49 */
+    void (*tkMakeBezierPostscript) (Tcl_Interp *interp, Tk_Canvas canvas, double *pointPtr, int numPoints); /* 50 */
+    void (*tkOptionClassChanged) (TkWindow *winPtr); /* 51 */
+    void (*tkOptionDeadWindow) (TkWindow *winPtr); /* 52 */
+    int (*tkOvalToArea) (double *ovalPtr, double *rectPtr); /* 53 */
+    double (*tkOvalToPoint) (double ovalPtr[], double width, int filled, double pointPtr[]); /* 54 */
+    int (*tkpChangeFocus) (TkWindow *winPtr, int force); /* 55 */
+    void (*tkpCloseDisplay) (TkDisplay *dispPtr); /* 56 */
+    void (*tkpClaimFocus) (TkWindow *topLevelPtr, int force); /* 57 */
+    void (*tkpDisplayWarning) (const char *msg, const char *title); /* 58 */
+    void (*tkpGetAppName) (Tcl_Interp *interp, Tcl_DString *name); /* 59 */
+    TkWindow * (*tkpGetOtherWindow) (TkWindow *winPtr); /* 60 */
+    TkWindow * (*tkpGetWrapperWindow) (TkWindow *winPtr); /* 61 */
+    int (*tkpInit) (Tcl_Interp *interp); /* 62 */
+    void (*tkpInitializeMenuBindings) (Tcl_Interp *interp, Tk_BindingTable bindingTable); /* 63 */
+    void (*tkpMakeContainer) (Tk_Window tkwin); /* 64 */
+    void (*tkpMakeMenuWindow) (Tk_Window tkwin, int transient); /* 65 */
+    Window (*tkpMakeWindow) (TkWindow *winPtr, Window parent); /* 66 */
+    void (*tkpMenuNotifyToplevelCreate) (Tcl_Interp *interp, const char *menuName); /* 67 */
+    TkDisplay * (*tkpOpenDisplay) (const char *display_name); /* 68 */
+    int (*tkPointerEvent) (XEvent *eventPtr, TkWindow *winPtr); /* 69 */
+    int (*tkPolygonToArea) (double *polyPtr, int numPoints, double *rectPtr); /* 70 */
+    double (*tkPolygonToPoint) (double *polyPtr, int numPoints, double *pointPtr); /* 71 */
+    int (*tkPositionInTree) (TkWindow *winPtr, TkWindow *treePtr); /* 72 */
+    void (*tkpRedirectKeyEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 73 */
+    void (*tkpSetMainMenubar) (Tcl_Interp *interp, Tk_Window tkwin, const char *menuName); /* 74 */
+    int (*tkpUseWindow) (Tcl_Interp *interp, Tk_Window tkwin, const char *string); /* 75 */
+    void (*reserved76)(void);
+    void (*tkQueueEventForAllChildren) (TkWindow *winPtr, XEvent *eventPtr); /* 77 */
+    int (*tkReadBitmapFile) (Display *display, Drawable d, const char *filename, unsigned int *width_return, unsigned int *height_return, Pixmap *bitmap_return, int *x_hot_return, int *y_hot_return); /* 78 */
+    int (*tkScrollWindow) (Tk_Window tkwin, GC gc, int x, int y, int width, int height, int dx, int dy, TkRegion damageRgn); /* 79 */
+    void (*tkSelDeadWindow) (TkWindow *winPtr); /* 80 */
+    void (*tkSelEventProc) (Tk_Window tkwin, XEvent *eventPtr); /* 81 */
+    void (*tkSelInit) (Tk_Window tkwin); /* 82 */
+    void (*tkSelPropProc) (XEvent *eventPtr); /* 83 */
+    void (*reserved84)(void);
+    void (*tkSetWindowMenuBar) (Tcl_Interp *interp, Tk_Window tkwin, const char *oldMenuName, const char *menuName); /* 85 */
+    KeySym (*tkStringToKeysym) (const char *name); /* 86 */
+    int (*tkThickPolyLineToArea) (double *coordPtr, int numPoints, double width, int capStyle, int joinStyle, double *rectPtr); /* 87 */
+    void (*tkWmAddToColormapWindows) (TkWindow *winPtr); /* 88 */
+    void (*tkWmDeadWindow) (TkWindow *winPtr); /* 89 */
+    TkWindow * (*tkWmFocusToplevel) (TkWindow *winPtr); /* 90 */
+    void (*tkWmMapWindow) (TkWindow *winPtr); /* 91 */
+    void (*tkWmNewWindow) (TkWindow *winPtr); /* 92 */
+    void (*tkWmProtocolEventProc) (TkWindow *winPtr, XEvent *evenvPtr); /* 93 */
+    void (*tkWmRemoveFromColormapWindows) (TkWindow *winPtr); /* 94 */
+    void (*tkWmRestackToplevel) (TkWindow *winPtr, int aboveBelow, TkWindow *otherPtr); /* 95 */
+    void (*tkWmSetClass) (TkWindow *winPtr); /* 96 */
+    void (*tkWmUnmapWindow) (TkWindow *winPtr); /* 97 */
+    Tcl_Obj * (*tkDebugBitmap) (Tk_Window tkwin, const char *name); /* 98 */
+    Tcl_Obj * (*tkDebugBorder) (Tk_Window tkwin, const char *name); /* 99 */
+    Tcl_Obj * (*tkDebugCursor) (Tk_Window tkwin, const char *name); /* 100 */
+    Tcl_Obj * (*tkDebugColor) (Tk_Window tkwin, const char *name); /* 101 */
+    Tcl_Obj * (*tkDebugConfig) (Tcl_Interp *interp, Tk_OptionTable table); /* 102 */
+    Tcl_Obj * (*tkDebugFont) (Tk_Window tkwin, const char *name); /* 103 */
+    int (*tkFindStateNumObj) (Tcl_Interp *interp, Tcl_Obj *optionPtr, const TkStateMap *mapPtr, Tcl_Obj *keyPtr); /* 104 */
+    Tcl_HashTable * (*tkGetBitmapPredefTable) (void); /* 105 */
+    TkDisplay * (*tkGetDisplayList) (void); /* 106 */
+    TkMainInfo * (*tkGetMainInfoList) (void); /* 107 */
+    int (*tkGetWindowFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, Tk_Window *windowPtr); /* 108 */
+    CONST86 char * (*tkpGetString) (TkWindow *winPtr, XEvent *eventPtr, Tcl_DString *dsPtr); /* 109 */
+    void (*tkpGetSubFonts) (Tcl_Interp *interp, Tk_Font tkfont); /* 110 */
+    Tcl_Obj * (*tkpGetSystemDefault) (Tk_Window tkwin, const char *dbName, const char *className); /* 111 */
+    void (*tkpMenuThreadInit) (void); /* 112 */
+    void (*tkClipBox) (TkRegion rgn, XRectangle *rect_return); /* 113 */
+    TkRegion (*tkCreateRegion) (void); /* 114 */
+    void (*tkDestroyRegion) (TkRegion rgn); /* 115 */
+    void (*tkIntersectRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 116 */
+    int (*tkRectInRegion) (TkRegion rgn, int x, int y, unsigned int width, unsigned int height); /* 117 */
+    void (*tkSetRegion) (Display *display, GC gc, TkRegion rgn); /* 118 */
+    void (*tkUnionRectWithRegion) (XRectangle *rect, TkRegion src, TkRegion dr_return); /* 119 */
+    void (*reserved120)(void);
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void (*reserved121)(void);
+#endif /* X11 */
+#if defined(__WIN32__) /* WIN */
+    void (*reserved121)(void);
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*reserved121)(void); /* Dummy entry for stubs table backwards compatibility */
+    Pixmap (*tkpCreateNativeBitmap) (Display *display, const void *source); /* 121 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void (*reserved122)(void);
+#endif /* X11 */
+#if defined(__WIN32__) /* WIN */
+    void (*reserved122)(void);
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*reserved122)(void); /* Dummy entry for stubs table backwards compatibility */
+    void (*tkpDefineNativeBitmaps) (void); /* 122 */
+#endif /* AQUA */
+    void (*reserved123)(void);
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void (*reserved124)(void);
+#endif /* X11 */
+#if defined(__WIN32__) /* WIN */
+    void (*reserved124)(void);
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*reserved124)(void); /* Dummy entry for stubs table backwards compatibility */
+    Pixmap (*tkpGetNativeAppBitmap) (Display *display, const char *name, int *width, int *height); /* 124 */
+#endif /* AQUA */
+    void (*reserved125)(void);
+    void (*reserved126)(void);
+    void (*reserved127)(void);
+    void (*reserved128)(void);
+    void (*reserved129)(void);
+    void (*reserved130)(void);
+    void (*reserved131)(void);
+    void (*reserved132)(void);
+    void (*reserved133)(void);
+    void (*reserved134)(void);
+    void (*tkpDrawHighlightBorder) (Tk_Window tkwin, GC fgGC, GC bgGC, int highlightWidth, Drawable drawable); /* 135 */
+    void (*tkSetFocusWin) (TkWindow *winPtr, int force); /* 136 */
+    void (*tkpSetKeycodeAndState) (Tk_Window tkwin, KeySym keySym, XEvent *eventPtr); /* 137 */
+    KeySym (*tkpGetKeySym) (TkDisplay *dispPtr, XEvent *eventPtr); /* 138 */
+    void (*tkpInitKeymapInfo) (TkDisplay *dispPtr); /* 139 */
+    TkRegion (*tkPhotoGetValidRegion) (Tk_PhotoHandle handle); /* 140 */
+    TkWindow ** (*tkWmStackorderToplevel) (TkWindow *parentPtr); /* 141 */
+    void (*tkFocusFree) (TkMainInfo *mainPtr); /* 142 */
+    void (*tkClipCleanup) (TkDisplay *dispPtr); /* 143 */
+    void (*tkGCCleanup) (TkDisplay *dispPtr); /* 144 */
+    void (*tkSubtractRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 145 */
+    void (*tkStylePkgInit) (TkMainInfo *mainPtr); /* 146 */
+    void (*tkStylePkgFree) (TkMainInfo *mainPtr); /* 147 */
+    Tk_Window (*tkToplevelWindowForCommand) (Tcl_Interp *interp, const char *cmdName); /* 148 */
+    const Tk_OptionSpec * (*tkGetOptionSpec) (const char *name, Tk_OptionTable optionTable); /* 149 */
+    int (*tkMakeRawCurve) (Tk_Canvas canvas, double *pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 150 */
+    void (*tkMakeRawCurvePostscript) (Tcl_Interp *interp, Tk_Canvas canvas, double *pointPtr, int numPoints); /* 151 */
+    void (*tkpDrawFrame) (Tk_Window tkwin, Tk_3DBorder border, int highlightWidth, int borderWidth, int relief); /* 152 */
+    void (*tkCreateThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 153 */
+    void (*tkDeleteThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 154 */
+    void (*reserved155)(void);
+    int (*tkpTestembedCmd) (ClientData clientData, Tcl_Interp *interp, int argc, const char **argv); /* 156 */
+    int (*tkpTesttextCmd) (ClientData dummy, Tcl_Interp *interp, int argc, const char **argv); /* 157 */
+    int (*tkSelGetSelection) (Tcl_Interp *interp, Tk_Window tkwin, Atom selection, Atom target, Tk_GetSelProc *proc, ClientData clientData); /* 158 */
+    int (*tkTextGetIndex) (Tcl_Interp *interp, struct TkText *textPtr, const char *string, struct TkTextIndex *indexPtr); /* 159 */
+    int (*tkTextIndexBackBytes) (const struct TkText *textPtr, const struct TkTextIndex *srcPtr, int count, struct TkTextIndex *dstPtr); /* 160 */
+    int (*tkTextIndexForwBytes) (const struct TkText *textPtr, const struct TkTextIndex *srcPtr, int count, struct TkTextIndex *dstPtr); /* 161 */
+    struct TkTextIndex * (*tkTextMakeByteIndex) (TkTextBTree tree, const struct TkText *textPtr, int lineIndex, int byteIndex, struct TkTextIndex *indexPtr); /* 162 */
+    int (*tkTextPrintIndex) (const struct TkText *textPtr, const struct TkTextIndex *indexPtr, char *string); /* 163 */
+    struct TkTextSegment * (*tkTextSetMark) (struct TkText *textPtr, const char *name, struct TkTextIndex *indexPtr); /* 164 */
+    int (*tkTextXviewCmd) (struct TkText *textPtr, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 165 */
+    void (*tkTextChanged) (struct TkSharedText *sharedTextPtr, struct TkText *textPtr, const struct TkTextIndex *index1Ptr, const struct TkTextIndex *index2Ptr); /* 166 */
+    int (*tkBTreeNumLines) (TkTextBTree tree, const struct TkText *textPtr); /* 167 */
+    void (*tkTextInsertDisplayProc) (struct TkText *textPtr, struct TkTextDispChunk *chunkPtr, int x, int y, int height, int baseline, Display *display, Drawable dst, int screenY); /* 168 */
+    int (*tkStateParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 169 */
+    CONST86 char * (*tkStatePrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 170 */
+    int (*tkCanvasDashParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 171 */
+    CONST86 char * (*tkCanvasDashPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 172 */
+    int (*tkOffsetParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 173 */
+    CONST86 char * (*tkOffsetPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 174 */
+    int (*tkPixelParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 175 */
+    CONST86 char * (*tkPixelPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 176 */
+    int (*tkOrientParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 177 */
+    CONST86 char * (*tkOrientPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 178 */
+    int (*tkSmoothParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 179 */
+    CONST86 char * (*tkSmoothPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 180 */
+    void (*tkDrawAngledTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, double angle, int firstChar, int lastChar); /* 181 */
+    void (*tkUnderlineAngledTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, double angle, int underline); /* 182 */
+    int (*tkIntersectAngledTextLayout) (Tk_TextLayout layout, int x, int y, int width, int height, double angle); /* 183 */
+    void (*tkDrawAngledChars) (Display *display, Drawable drawable, GC gc, Tk_Font tkfont, const char *source, int numBytes, double x, double y, double angle); /* 184 */
+} TkIntStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TkIntStubs *tkIntStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TK_STUBS)
+
+/*
+ * Inline function declarations:
+ */
+
+#define TkAllocWindow \
+	(tkIntStubsPtr->tkAllocWindow) /* 0 */
+#define TkBezierPoints \
+	(tkIntStubsPtr->tkBezierPoints) /* 1 */
+#define TkBezierScreenPoints \
+	(tkIntStubsPtr->tkBezierScreenPoints) /* 2 */
+/* Slot 3 is reserved */
+#define TkBindEventProc \
+	(tkIntStubsPtr->tkBindEventProc) /* 4 */
+#define TkBindFree \
+	(tkIntStubsPtr->tkBindFree) /* 5 */
+#define TkBindInit \
+	(tkIntStubsPtr->tkBindInit) /* 6 */
+#define TkChangeEventWindow \
+	(tkIntStubsPtr->tkChangeEventWindow) /* 7 */
+#define TkClipInit \
+	(tkIntStubsPtr->tkClipInit) /* 8 */
+#define TkComputeAnchor \
+	(tkIntStubsPtr->tkComputeAnchor) /* 9 */
+/* Slot 10 is reserved */
+/* Slot 11 is reserved */
+#define TkCreateCursorFromData \
+	(tkIntStubsPtr->tkCreateCursorFromData) /* 12 */
+#define TkCreateFrame \
+	(tkIntStubsPtr->tkCreateFrame) /* 13 */
+#define TkCreateMainWindow \
+	(tkIntStubsPtr->tkCreateMainWindow) /* 14 */
+#define TkCurrentTime \
+	(tkIntStubsPtr->tkCurrentTime) /* 15 */
+#define TkDeleteAllImages \
+	(tkIntStubsPtr->tkDeleteAllImages) /* 16 */
+#define TkDoConfigureNotify \
+	(tkIntStubsPtr->tkDoConfigureNotify) /* 17 */
+#define TkDrawInsetFocusHighlight \
+	(tkIntStubsPtr->tkDrawInsetFocusHighlight) /* 18 */
+#define TkEventDeadWindow \
+	(tkIntStubsPtr->tkEventDeadWindow) /* 19 */
+#define TkFillPolygon \
+	(tkIntStubsPtr->tkFillPolygon) /* 20 */
+#define TkFindStateNum \
+	(tkIntStubsPtr->tkFindStateNum) /* 21 */
+#define TkFindStateString \
+	(tkIntStubsPtr->tkFindStateString) /* 22 */
+#define TkFocusDeadWindow \
+	(tkIntStubsPtr->tkFocusDeadWindow) /* 23 */
+#define TkFocusFilterEvent \
+	(tkIntStubsPtr->tkFocusFilterEvent) /* 24 */
+#define TkFocusKeyEvent \
+	(tkIntStubsPtr->tkFocusKeyEvent) /* 25 */
+#define TkFontPkgInit \
+	(tkIntStubsPtr->tkFontPkgInit) /* 26 */
+#define TkFontPkgFree \
+	(tkIntStubsPtr->tkFontPkgFree) /* 27 */
+#define TkFreeBindingTags \
+	(tkIntStubsPtr->tkFreeBindingTags) /* 28 */
+#define TkpFreeCursor \
+	(tkIntStubsPtr->tkpFreeCursor) /* 29 */
+#define TkGetBitmapData \
+	(tkIntStubsPtr->tkGetBitmapData) /* 30 */
+#define TkGetButtPoints \
+	(tkIntStubsPtr->tkGetButtPoints) /* 31 */
+#define TkGetCursorByName \
+	(tkIntStubsPtr->tkGetCursorByName) /* 32 */
+#define TkGetDefaultScreenName \
+	(tkIntStubsPtr->tkGetDefaultScreenName) /* 33 */
+#define TkGetDisplay \
+	(tkIntStubsPtr->tkGetDisplay) /* 34 */
+#define TkGetDisplayOf \
+	(tkIntStubsPtr->tkGetDisplayOf) /* 35 */
+#define TkGetFocusWin \
+	(tkIntStubsPtr->tkGetFocusWin) /* 36 */
+#define TkGetInterpNames \
+	(tkIntStubsPtr->tkGetInterpNames) /* 37 */
+#define TkGetMiterPoints \
+	(tkIntStubsPtr->tkGetMiterPoints) /* 38 */
+#define TkGetPointerCoords \
+	(tkIntStubsPtr->tkGetPointerCoords) /* 39 */
+#define TkGetServerInfo \
+	(tkIntStubsPtr->tkGetServerInfo) /* 40 */
+#define TkGrabDeadWindow \
+	(tkIntStubsPtr->tkGrabDeadWindow) /* 41 */
+#define TkGrabState \
+	(tkIntStubsPtr->tkGrabState) /* 42 */
+#define TkIncludePoint \
+	(tkIntStubsPtr->tkIncludePoint) /* 43 */
+#define TkInOutEvents \
+	(tkIntStubsPtr->tkInOutEvents) /* 44 */
+#define TkInstallFrameMenu \
+	(tkIntStubsPtr->tkInstallFrameMenu) /* 45 */
+#define TkKeysymToString \
+	(tkIntStubsPtr->tkKeysymToString) /* 46 */
+#define TkLineToArea \
+	(tkIntStubsPtr->tkLineToArea) /* 47 */
+#define TkLineToPoint \
+	(tkIntStubsPtr->tkLineToPoint) /* 48 */
+#define TkMakeBezierCurve \
+	(tkIntStubsPtr->tkMakeBezierCurve) /* 49 */
+#define TkMakeBezierPostscript \
+	(tkIntStubsPtr->tkMakeBezierPostscript) /* 50 */
+#define TkOptionClassChanged \
+	(tkIntStubsPtr->tkOptionClassChanged) /* 51 */
+#define TkOptionDeadWindow \
+	(tkIntStubsPtr->tkOptionDeadWindow) /* 52 */
+#define TkOvalToArea \
+	(tkIntStubsPtr->tkOvalToArea) /* 53 */
+#define TkOvalToPoint \
+	(tkIntStubsPtr->tkOvalToPoint) /* 54 */
+#define TkpChangeFocus \
+	(tkIntStubsPtr->tkpChangeFocus) /* 55 */
+#define TkpCloseDisplay \
+	(tkIntStubsPtr->tkpCloseDisplay) /* 56 */
+#define TkpClaimFocus \
+	(tkIntStubsPtr->tkpClaimFocus) /* 57 */
+#define TkpDisplayWarning \
+	(tkIntStubsPtr->tkpDisplayWarning) /* 58 */
+#define TkpGetAppName \
+	(tkIntStubsPtr->tkpGetAppName) /* 59 */
+#define TkpGetOtherWindow \
+	(tkIntStubsPtr->tkpGetOtherWindow) /* 60 */
+#define TkpGetWrapperWindow \
+	(tkIntStubsPtr->tkpGetWrapperWindow) /* 61 */
+#define TkpInit \
+	(tkIntStubsPtr->tkpInit) /* 62 */
+#define TkpInitializeMenuBindings \
+	(tkIntStubsPtr->tkpInitializeMenuBindings) /* 63 */
+#define TkpMakeContainer \
+	(tkIntStubsPtr->tkpMakeContainer) /* 64 */
+#define TkpMakeMenuWindow \
+	(tkIntStubsPtr->tkpMakeMenuWindow) /* 65 */
+#define TkpMakeWindow \
+	(tkIntStubsPtr->tkpMakeWindow) /* 66 */
+#define TkpMenuNotifyToplevelCreate \
+	(tkIntStubsPtr->tkpMenuNotifyToplevelCreate) /* 67 */
+#define TkpOpenDisplay \
+	(tkIntStubsPtr->tkpOpenDisplay) /* 68 */
+#define TkPointerEvent \
+	(tkIntStubsPtr->tkPointerEvent) /* 69 */
+#define TkPolygonToArea \
+	(tkIntStubsPtr->tkPolygonToArea) /* 70 */
+#define TkPolygonToPoint \
+	(tkIntStubsPtr->tkPolygonToPoint) /* 71 */
+#define TkPositionInTree \
+	(tkIntStubsPtr->tkPositionInTree) /* 72 */
+#define TkpRedirectKeyEvent \
+	(tkIntStubsPtr->tkpRedirectKeyEvent) /* 73 */
+#define TkpSetMainMenubar \
+	(tkIntStubsPtr->tkpSetMainMenubar) /* 74 */
+#define TkpUseWindow \
+	(tkIntStubsPtr->tkpUseWindow) /* 75 */
+/* Slot 76 is reserved */
+#define TkQueueEventForAllChildren \
+	(tkIntStubsPtr->tkQueueEventForAllChildren) /* 77 */
+#define TkReadBitmapFile \
+	(tkIntStubsPtr->tkReadBitmapFile) /* 78 */
+#define TkScrollWindow \
+	(tkIntStubsPtr->tkScrollWindow) /* 79 */
+#define TkSelDeadWindow \
+	(tkIntStubsPtr->tkSelDeadWindow) /* 80 */
+#define TkSelEventProc \
+	(tkIntStubsPtr->tkSelEventProc) /* 81 */
+#define TkSelInit \
+	(tkIntStubsPtr->tkSelInit) /* 82 */
+#define TkSelPropProc \
+	(tkIntStubsPtr->tkSelPropProc) /* 83 */
+/* Slot 84 is reserved */
+#define TkSetWindowMenuBar \
+	(tkIntStubsPtr->tkSetWindowMenuBar) /* 85 */
+#define TkStringToKeysym \
+	(tkIntStubsPtr->tkStringToKeysym) /* 86 */
+#define TkThickPolyLineToArea \
+	(tkIntStubsPtr->tkThickPolyLineToArea) /* 87 */
+#define TkWmAddToColormapWindows \
+	(tkIntStubsPtr->tkWmAddToColormapWindows) /* 88 */
+#define TkWmDeadWindow \
+	(tkIntStubsPtr->tkWmDeadWindow) /* 89 */
+#define TkWmFocusToplevel \
+	(tkIntStubsPtr->tkWmFocusToplevel) /* 90 */
+#define TkWmMapWindow \
+	(tkIntStubsPtr->tkWmMapWindow) /* 91 */
+#define TkWmNewWindow \
+	(tkIntStubsPtr->tkWmNewWindow) /* 92 */
+#define TkWmProtocolEventProc \
+	(tkIntStubsPtr->tkWmProtocolEventProc) /* 93 */
+#define TkWmRemoveFromColormapWindows \
+	(tkIntStubsPtr->tkWmRemoveFromColormapWindows) /* 94 */
+#define TkWmRestackToplevel \
+	(tkIntStubsPtr->tkWmRestackToplevel) /* 95 */
+#define TkWmSetClass \
+	(tkIntStubsPtr->tkWmSetClass) /* 96 */
+#define TkWmUnmapWindow \
+	(tkIntStubsPtr->tkWmUnmapWindow) /* 97 */
+#define TkDebugBitmap \
+	(tkIntStubsPtr->tkDebugBitmap) /* 98 */
+#define TkDebugBorder \
+	(tkIntStubsPtr->tkDebugBorder) /* 99 */
+#define TkDebugCursor \
+	(tkIntStubsPtr->tkDebugCursor) /* 100 */
+#define TkDebugColor \
+	(tkIntStubsPtr->tkDebugColor) /* 101 */
+#define TkDebugConfig \
+	(tkIntStubsPtr->tkDebugConfig) /* 102 */
+#define TkDebugFont \
+	(tkIntStubsPtr->tkDebugFont) /* 103 */
+#define TkFindStateNumObj \
+	(tkIntStubsPtr->tkFindStateNumObj) /* 104 */
+#define TkGetBitmapPredefTable \
+	(tkIntStubsPtr->tkGetBitmapPredefTable) /* 105 */
+#define TkGetDisplayList \
+	(tkIntStubsPtr->tkGetDisplayList) /* 106 */
+#define TkGetMainInfoList \
+	(tkIntStubsPtr->tkGetMainInfoList) /* 107 */
+#define TkGetWindowFromObj \
+	(tkIntStubsPtr->tkGetWindowFromObj) /* 108 */
+#define TkpGetString \
+	(tkIntStubsPtr->tkpGetString) /* 109 */
+#define TkpGetSubFonts \
+	(tkIntStubsPtr->tkpGetSubFonts) /* 110 */
+#define TkpGetSystemDefault \
+	(tkIntStubsPtr->tkpGetSystemDefault) /* 111 */
+#define TkpMenuThreadInit \
+	(tkIntStubsPtr->tkpMenuThreadInit) /* 112 */
+#define TkClipBox \
+	(tkIntStubsPtr->tkClipBox) /* 113 */
+#define TkCreateRegion \
+	(tkIntStubsPtr->tkCreateRegion) /* 114 */
+#define TkDestroyRegion \
+	(tkIntStubsPtr->tkDestroyRegion) /* 115 */
+#define TkIntersectRegion \
+	(tkIntStubsPtr->tkIntersectRegion) /* 116 */
+#define TkRectInRegion \
+	(tkIntStubsPtr->tkRectInRegion) /* 117 */
+#define TkSetRegion \
+	(tkIntStubsPtr->tkSetRegion) /* 118 */
+#define TkUnionRectWithRegion \
+	(tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
+/* Slot 120 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+#define TkpCreateNativeBitmap \
+	(tkIntStubsPtr->tkpCreateNativeBitmap) /* 121 */
+#endif /* AQUA */
+#ifdef MAC_OSX_TK /* AQUA */
+#define TkpDefineNativeBitmaps \
+	(tkIntStubsPtr->tkpDefineNativeBitmaps) /* 122 */
+#endif /* AQUA */
+/* Slot 123 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+#define TkpGetNativeAppBitmap \
+	(tkIntStubsPtr->tkpGetNativeAppBitmap) /* 124 */
+#endif /* AQUA */
+/* Slot 125 is reserved */
+/* Slot 126 is reserved */
+/* Slot 127 is reserved */
+/* Slot 128 is reserved */
+/* Slot 129 is reserved */
+/* Slot 130 is reserved */
+/* Slot 131 is reserved */
+/* Slot 132 is reserved */
+/* Slot 133 is reserved */
+/* Slot 134 is reserved */
+#define TkpDrawHighlightBorder \
+	(tkIntStubsPtr->tkpDrawHighlightBorder) /* 135 */
+#define TkSetFocusWin \
+	(tkIntStubsPtr->tkSetFocusWin) /* 136 */
+#define TkpSetKeycodeAndState \
+	(tkIntStubsPtr->tkpSetKeycodeAndState) /* 137 */
+#define TkpGetKeySym \
+	(tkIntStubsPtr->tkpGetKeySym) /* 138 */
+#define TkpInitKeymapInfo \
+	(tkIntStubsPtr->tkpInitKeymapInfo) /* 139 */
+#define TkPhotoGetValidRegion \
+	(tkIntStubsPtr->tkPhotoGetValidRegion) /* 140 */
+#define TkWmStackorderToplevel \
+	(tkIntStubsPtr->tkWmStackorderToplevel) /* 141 */
+#define TkFocusFree \
+	(tkIntStubsPtr->tkFocusFree) /* 142 */
+#define TkClipCleanup \
+	(tkIntStubsPtr->tkClipCleanup) /* 143 */
+#define TkGCCleanup \
+	(tkIntStubsPtr->tkGCCleanup) /* 144 */
+#define TkSubtractRegion \
+	(tkIntStubsPtr->tkSubtractRegion) /* 145 */
+#define TkStylePkgInit \
+	(tkIntStubsPtr->tkStylePkgInit) /* 146 */
+#define TkStylePkgFree \
+	(tkIntStubsPtr->tkStylePkgFree) /* 147 */
+#define TkToplevelWindowForCommand \
+	(tkIntStubsPtr->tkToplevelWindowForCommand) /* 148 */
+#define TkGetOptionSpec \
+	(tkIntStubsPtr->tkGetOptionSpec) /* 149 */
+#define TkMakeRawCurve \
+	(tkIntStubsPtr->tkMakeRawCurve) /* 150 */
+#define TkMakeRawCurvePostscript \
+	(tkIntStubsPtr->tkMakeRawCurvePostscript) /* 151 */
+#define TkpDrawFrame \
+	(tkIntStubsPtr->tkpDrawFrame) /* 152 */
+#define TkCreateThreadExitHandler \
+	(tkIntStubsPtr->tkCreateThreadExitHandler) /* 153 */
+#define TkDeleteThreadExitHandler \
+	(tkIntStubsPtr->tkDeleteThreadExitHandler) /* 154 */
+/* Slot 155 is reserved */
+#define TkpTestembedCmd \
+	(tkIntStubsPtr->tkpTestembedCmd) /* 156 */
+#define TkpTesttextCmd \
+	(tkIntStubsPtr->tkpTesttextCmd) /* 157 */
+#define TkSelGetSelection \
+	(tkIntStubsPtr->tkSelGetSelection) /* 158 */
+#define TkTextGetIndex \
+	(tkIntStubsPtr->tkTextGetIndex) /* 159 */
+#define TkTextIndexBackBytes \
+	(tkIntStubsPtr->tkTextIndexBackBytes) /* 160 */
+#define TkTextIndexForwBytes \
+	(tkIntStubsPtr->tkTextIndexForwBytes) /* 161 */
+#define TkTextMakeByteIndex \
+	(tkIntStubsPtr->tkTextMakeByteIndex) /* 162 */
+#define TkTextPrintIndex \
+	(tkIntStubsPtr->tkTextPrintIndex) /* 163 */
+#define TkTextSetMark \
+	(tkIntStubsPtr->tkTextSetMark) /* 164 */
+#define TkTextXviewCmd \
+	(tkIntStubsPtr->tkTextXviewCmd) /* 165 */
+#define TkTextChanged \
+	(tkIntStubsPtr->tkTextChanged) /* 166 */
+#define TkBTreeNumLines \
+	(tkIntStubsPtr->tkBTreeNumLines) /* 167 */
+#define TkTextInsertDisplayProc \
+	(tkIntStubsPtr->tkTextInsertDisplayProc) /* 168 */
+#define TkStateParseProc \
+	(tkIntStubsPtr->tkStateParseProc) /* 169 */
+#define TkStatePrintProc \
+	(tkIntStubsPtr->tkStatePrintProc) /* 170 */
+#define TkCanvasDashParseProc \
+	(tkIntStubsPtr->tkCanvasDashParseProc) /* 171 */
+#define TkCanvasDashPrintProc \
+	(tkIntStubsPtr->tkCanvasDashPrintProc) /* 172 */
+#define TkOffsetParseProc \
+	(tkIntStubsPtr->tkOffsetParseProc) /* 173 */
+#define TkOffsetPrintProc \
+	(tkIntStubsPtr->tkOffsetPrintProc) /* 174 */
+#define TkPixelParseProc \
+	(tkIntStubsPtr->tkPixelParseProc) /* 175 */
+#define TkPixelPrintProc \
+	(tkIntStubsPtr->tkPixelPrintProc) /* 176 */
+#define TkOrientParseProc \
+	(tkIntStubsPtr->tkOrientParseProc) /* 177 */
+#define TkOrientPrintProc \
+	(tkIntStubsPtr->tkOrientPrintProc) /* 178 */
+#define TkSmoothParseProc \
+	(tkIntStubsPtr->tkSmoothParseProc) /* 179 */
+#define TkSmoothPrintProc \
+	(tkIntStubsPtr->tkSmoothPrintProc) /* 180 */
+#define TkDrawAngledTextLayout \
+	(tkIntStubsPtr->tkDrawAngledTextLayout) /* 181 */
+#define TkUnderlineAngledTextLayout \
+	(tkIntStubsPtr->tkUnderlineAngledTextLayout) /* 182 */
+#define TkIntersectAngledTextLayout \
+	(tkIntStubsPtr->tkIntersectAngledTextLayout) /* 183 */
+#define TkDrawAngledChars \
+	(tkIntStubsPtr->tkDrawAngledChars) /* 184 */
+
+#endif /* defined(USE_TK_STUBS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+/*
+ * On X11, these macros are just wrappers for the equivalent X Region calls.
+ */
+#if !(defined(__WIN32__) || defined(__CYGWIN__) || defined(MAC_OSX_TK)) /* X11 */
+
+#undef TkClipBox
+#undef TkCreateRegion
+#undef TkDestroyRegion
+#undef TkIntersectRegion
+#undef TkRectInRegion
+#undef TkSetRegion
+#undef TkSubtractRegion
+#undef TkUnionRectWithRegion
+
+#define TkClipBox(rgn, rect) XClipBox((Region) rgn, rect)
+#define TkCreateRegion() (TkRegion) XCreateRegion()
+#define TkDestroyRegion(rgn) XDestroyRegion((Region) rgn)
+#define TkIntersectRegion(a, b, r) XIntersectRegion((Region) a, \
+	(Region) b, (Region) r)
+#define TkRectInRegion(r, x, y, w, h) XRectInRegion((Region) r, x, y, w, h)
+#define TkSetRegion(d, gc, rgn) XSetRegion(d, gc, (Region) rgn)
+#define TkSubtractRegion(a, b, r) XSubtractRegion((Region) a, \
+	(Region) b, (Region) r)
+#define TkUnionRectWithRegion(rect, src, ret) XUnionRectWithRegion(rect, \
+	(Region) src, (Region) ret)
+
+#endif /* UNIX */
+
+#endif /* _TKINTDECLS */
+
Index: src/tktext/tk8.6/tkIntPlatDecls.h
===================================================================
--- src/tktext/tk8.6/tkIntPlatDecls.h	(revision 0)
+++ src/tktext/tk8.6/tkIntPlatDecls.h	(working copy)
@@ -0,0 +1,669 @@
+/*
+ * tkIntPlatDecls.h --
+ *
+ *	This file contains the declarations for all platform dependent
+ *	unsupported functions that are exported by the Tk library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ * All rights reserved.
+ */
+
+#ifndef _TKINTPLATDECLS
+#define _TKINTPLATDECLS
+
+#ifdef BUILD_tk
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tkInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Exported function declarations:
+ */
+
+#if defined(_WIN32) || defined(__CYGWIN__) /* WIN */
+/* 0 */
+EXTERN char *		TkAlignImageData(XImage *image, int alignment,
+				int bitOrder);
+/* Slot 1 is reserved */
+/* 2 */
+EXTERN void		TkGenerateActivateEvents(TkWindow *winPtr,
+				int active);
+/* 3 */
+EXTERN unsigned long	TkpGetMS(void);
+/* 4 */
+EXTERN void		TkPointerDeadWindow(TkWindow *winPtr);
+/* 5 */
+EXTERN void		TkpPrintWindowId(char *buf, Window window);
+/* 6 */
+EXTERN int		TkpScanWindowId(Tcl_Interp *interp,
+				const char *string, Window *idPtr);
+/* 7 */
+EXTERN void		TkpSetCapture(TkWindow *winPtr);
+/* 8 */
+EXTERN void		TkpSetCursor(TkpCursor cursor);
+/* 9 */
+EXTERN int		TkpWmSetState(TkWindow *winPtr, int state);
+/* 10 */
+EXTERN void		TkSetPixmapColormap(Pixmap pixmap, Colormap colormap);
+/* 11 */
+EXTERN void		TkWinCancelMouseTimer(void);
+/* 12 */
+EXTERN void		TkWinClipboardRender(TkDisplay *dispPtr, UINT format);
+/* 13 */
+EXTERN LRESULT		TkWinEmbeddedEventProc(HWND hwnd, UINT message,
+				WPARAM wParam, LPARAM lParam);
+/* 14 */
+EXTERN void		TkWinFillRect(HDC dc, int x, int y, int width,
+				int height, int pixel);
+/* 15 */
+EXTERN COLORREF		TkWinGetBorderPixels(Tk_Window tkwin,
+				Tk_3DBorder border, int which);
+/* 16 */
+EXTERN HDC		TkWinGetDrawableDC(Display *display, Drawable d,
+				TkWinDCState *state);
+/* 17 */
+EXTERN int		TkWinGetModifierState(void);
+/* 18 */
+EXTERN HPALETTE		TkWinGetSystemPalette(void);
+/* 19 */
+EXTERN HWND		TkWinGetWrapperWindow(Tk_Window tkwin);
+/* 20 */
+EXTERN int		TkWinHandleMenuEvent(HWND *phwnd, UINT *pMessage,
+				WPARAM *pwParam, LPARAM *plParam,
+				LRESULT *plResult);
+/* 21 */
+EXTERN int		TkWinIndexOfColor(XColor *colorPtr);
+/* 22 */
+EXTERN void		TkWinReleaseDrawableDC(Drawable d, HDC hdc,
+				TkWinDCState *state);
+/* 23 */
+EXTERN LRESULT		TkWinResendEvent(WNDPROC wndproc, HWND hwnd,
+				XEvent *eventPtr);
+/* 24 */
+EXTERN HPALETTE		TkWinSelectPalette(HDC dc, Colormap colormap);
+/* 25 */
+EXTERN void		TkWinSetMenu(Tk_Window tkwin, HMENU hMenu);
+/* 26 */
+EXTERN void		TkWinSetWindowPos(HWND hwnd, HWND siblingHwnd,
+				int pos);
+/* 27 */
+EXTERN void		TkWinWmCleanup(HINSTANCE hInstance);
+/* 28 */
+EXTERN void		TkWinXCleanup(ClientData clientData);
+/* 29 */
+EXTERN void		TkWinXInit(HINSTANCE hInstance);
+/* 30 */
+EXTERN void		TkWinSetForegroundWindow(TkWindow *winPtr);
+/* 31 */
+EXTERN void		TkWinDialogDebug(int debug);
+/* 32 */
+EXTERN Tcl_Obj *	TkWinGetMenuSystemDefault(Tk_Window tkwin,
+				const char *dbName, const char *className);
+/* 33 */
+EXTERN int		TkWinGetPlatformId(void);
+/* 34 */
+EXTERN void		TkWinSetHINSTANCE(HINSTANCE hInstance);
+/* 35 */
+EXTERN int		TkWinGetPlatformTheme(void);
+/* 36 */
+EXTERN LRESULT __stdcall TkWinChildProc(HWND hwnd, UINT message,
+				WPARAM wParam, LPARAM lParam);
+/* 37 */
+EXTERN void		TkCreateXEventSource(void);
+/* 38 */
+EXTERN int		TkpCmapStressed(Tk_Window tkwin, Colormap colormap);
+/* 39 */
+EXTERN void		TkpSync(Display *display);
+/* 40 */
+EXTERN Window		TkUnixContainerId(TkWindow *winPtr);
+/* 41 */
+EXTERN int		TkUnixDoOneXEvent(Tcl_Time *timePtr);
+/* 42 */
+EXTERN void		TkUnixSetMenubar(Tk_Window tkwin, Tk_Window menubar);
+/* 43 */
+EXTERN void		TkWmCleanup(TkDisplay *dispPtr);
+/* 44 */
+EXTERN void		TkSendCleanup(TkDisplay *dispPtr);
+/* 45 */
+EXTERN int		TkpTestsendCmd(ClientData clientData,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+/* 0 */
+EXTERN void		TkGenerateActivateEvents(TkWindow *winPtr,
+				int active);
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+/* 3 */
+EXTERN void		TkPointerDeadWindow(TkWindow *winPtr);
+/* 4 */
+EXTERN void		TkpSetCapture(TkWindow *winPtr);
+/* 5 */
+EXTERN void		TkpSetCursor(TkpCursor cursor);
+/* 6 */
+EXTERN void		TkpWmSetState(TkWindow *winPtr, int state);
+/* 7 */
+EXTERN void		TkAboutDlg(void);
+/* 8 */
+EXTERN unsigned int	TkMacOSXButtonKeyState(void);
+/* 9 */
+EXTERN void		TkMacOSXClearMenubarActive(void);
+/* 10 */
+EXTERN int		TkMacOSXDispatchMenuEvent(int menuID, int index);
+/* 11 */
+EXTERN void		TkMacOSXInstallCursor(int resizeOverride);
+/* 12 */
+EXTERN void		TkMacOSXHandleTearoffMenu(void);
+/* Slot 13 is reserved */
+/* 14 */
+EXTERN int		TkMacOSXDoHLEvent(void *theEvent);
+/* Slot 15 is reserved */
+/* 16 */
+EXTERN Window		TkMacOSXGetXWindow(void *macWinPtr);
+/* 17 */
+EXTERN int		TkMacOSXGrowToplevel(void *whichWindow, XPoint start);
+/* 18 */
+EXTERN void		TkMacOSXHandleMenuSelect(short theMenu,
+				unsigned short theItem, int optionKeyPressed);
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* 21 */
+EXTERN void		TkMacOSXInvalidateWindow(MacDrawable *macWin,
+				int flag);
+/* 22 */
+EXTERN int		TkMacOSXIsCharacterMissing(Tk_Font tkfont,
+				unsigned int searchChar);
+/* 23 */
+EXTERN void		TkMacOSXMakeRealWindowExist(TkWindow *winPtr);
+/* 24 */
+EXTERN void *		TkMacOSXMakeStippleMap(Drawable d1, Drawable d2);
+/* 25 */
+EXTERN void		TkMacOSXMenuClick(void);
+/* 26 */
+EXTERN void		TkMacOSXRegisterOffScreenWindow(Window window,
+				void *portPtr);
+/* 27 */
+EXTERN int		TkMacOSXResizable(TkWindow *winPtr);
+/* 28 */
+EXTERN void		TkMacOSXSetHelpMenuItemCount(void);
+/* 29 */
+EXTERN void		TkMacOSXSetScrollbarGrow(TkWindow *winPtr, int flag);
+/* 30 */
+EXTERN void		TkMacOSXSetUpClippingRgn(Drawable drawable);
+/* 31 */
+EXTERN void		TkMacOSXSetUpGraphicsPort(GC gc, void *destPort);
+/* 32 */
+EXTERN void		TkMacOSXUpdateClipRgn(TkWindow *winPtr);
+/* 33 */
+EXTERN void		TkMacOSXUnregisterMacWindow(void *portPtr);
+/* 34 */
+EXTERN int		TkMacOSXUseMenuID(short macID);
+/* 35 */
+EXTERN TkRegion		TkMacOSXVisableClipRgn(TkWindow *winPtr);
+/* 36 */
+EXTERN void		TkMacOSXWinBounds(TkWindow *winPtr, void *geometry);
+/* 37 */
+EXTERN void		TkMacOSXWindowOffset(void *wRef, int *xOffset,
+				int *yOffset);
+/* 38 */
+EXTERN int		TkSetMacColor(unsigned long pixel, void *macColor);
+/* 39 */
+EXTERN void		TkSetWMName(TkWindow *winPtr, Tk_Uid titleUid);
+/* 40 */
+EXTERN void		TkSuspendClipboard(void);
+/* 41 */
+EXTERN int		TkMacOSXZoomToplevel(void *whichWindow,
+				short zoomPart);
+/* 42 */
+EXTERN Tk_Window	Tk_TopCoordsToWindow(Tk_Window tkwin, int rootX,
+				int rootY, int *newX, int *newY);
+/* 43 */
+EXTERN MacDrawable *	TkMacOSXContainerId(TkWindow *winPtr);
+/* 44 */
+EXTERN MacDrawable *	TkMacOSXGetHostToplevel(TkWindow *winPtr);
+/* 45 */
+EXTERN void		TkMacOSXPreprocessMenu(void);
+/* 46 */
+EXTERN int		TkpIsWindowFloating(void *window);
+/* 47 */
+EXTERN Tk_Window	TkMacOSXGetCapture(void);
+/* Slot 48 is reserved */
+/* 49 */
+EXTERN Window		TkGetTransientMaster(TkWindow *winPtr);
+/* 50 */
+EXTERN int		TkGenerateButtonEvent(int x, int y, Window window,
+				unsigned int state);
+/* 51 */
+EXTERN void		TkGenWMDestroyEvent(Tk_Window tkwin);
+/* 52 */
+EXTERN void		TkMacOSXSetDrawingEnabled(TkWindow *winPtr, int flag);
+/* 53 */
+EXTERN unsigned long	TkpGetMS(void);
+/* 54 */
+EXTERN void *		TkMacOSXDrawable(Drawable drawable);
+/* 55 */
+EXTERN int		TkpScanWindowId(Tcl_Interp *interp,
+				const char *string, Window *idPtr);
+#endif /* AQUA */
+#if !(defined(_WIN32) || defined(__CYGWIN__) || defined(MAC_OSX_TK)) /* X11 */
+/* 0 */
+EXTERN void		TkCreateXEventSource(void);
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+/* 3 */
+EXTERN int		TkpCmapStressed(Tk_Window tkwin, Colormap colormap);
+/* 4 */
+EXTERN void		TkpSync(Display *display);
+/* 5 */
+EXTERN Window		TkUnixContainerId(TkWindow *winPtr);
+/* 6 */
+EXTERN int		TkUnixDoOneXEvent(Tcl_Time *timePtr);
+/* 7 */
+EXTERN void		TkUnixSetMenubar(Tk_Window tkwin, Tk_Window menubar);
+/* 8 */
+EXTERN int		TkpScanWindowId(Tcl_Interp *interp,
+				const char *string, Window *idPtr);
+/* 9 */
+EXTERN void		TkWmCleanup(TkDisplay *dispPtr);
+/* 10 */
+EXTERN void		TkSendCleanup(TkDisplay *dispPtr);
+/* Slot 11 is reserved */
+/* 12 */
+EXTERN int		TkpWmSetState(TkWindow *winPtr, int state);
+/* 13 */
+EXTERN int		TkpTestsendCmd(ClientData clientData,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+#endif /* X11 */
+
+typedef struct TkIntPlatStubs {
+    int magic;
+    void *hooks;
+
+#if defined(_WIN32) || defined(__CYGWIN__) /* WIN */
+    char * (*tkAlignImageData) (XImage *image, int alignment, int bitOrder); /* 0 */
+    void (*reserved1)(void);
+    void (*tkGenerateActivateEvents) (TkWindow *winPtr, int active); /* 2 */
+    unsigned long (*tkpGetMS) (void); /* 3 */
+    void (*tkPointerDeadWindow) (TkWindow *winPtr); /* 4 */
+    void (*tkpPrintWindowId) (char *buf, Window window); /* 5 */
+    int (*tkpScanWindowId) (Tcl_Interp *interp, const char *string, Window *idPtr); /* 6 */
+    void (*tkpSetCapture) (TkWindow *winPtr); /* 7 */
+    void (*tkpSetCursor) (TkpCursor cursor); /* 8 */
+    int (*tkpWmSetState) (TkWindow *winPtr, int state); /* 9 */
+    void (*tkSetPixmapColormap) (Pixmap pixmap, Colormap colormap); /* 10 */
+    void (*tkWinCancelMouseTimer) (void); /* 11 */
+    void (*tkWinClipboardRender) (TkDisplay *dispPtr, UINT format); /* 12 */
+    LRESULT (*tkWinEmbeddedEventProc) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); /* 13 */
+    void (*tkWinFillRect) (HDC dc, int x, int y, int width, int height, int pixel); /* 14 */
+    COLORREF (*tkWinGetBorderPixels) (Tk_Window tkwin, Tk_3DBorder border, int which); /* 15 */
+    HDC (*tkWinGetDrawableDC) (Display *display, Drawable d, TkWinDCState *state); /* 16 */
+    int (*tkWinGetModifierState) (void); /* 17 */
+    HPALETTE (*tkWinGetSystemPalette) (void); /* 18 */
+    HWND (*tkWinGetWrapperWindow) (Tk_Window tkwin); /* 19 */
+    int (*tkWinHandleMenuEvent) (HWND *phwnd, UINT *pMessage, WPARAM *pwParam, LPARAM *plParam, LRESULT *plResult); /* 20 */
+    int (*tkWinIndexOfColor) (XColor *colorPtr); /* 21 */
+    void (*tkWinReleaseDrawableDC) (Drawable d, HDC hdc, TkWinDCState *state); /* 22 */
+    LRESULT (*tkWinResendEvent) (WNDPROC wndproc, HWND hwnd, XEvent *eventPtr); /* 23 */
+    HPALETTE (*tkWinSelectPalette) (HDC dc, Colormap colormap); /* 24 */
+    void (*tkWinSetMenu) (Tk_Window tkwin, HMENU hMenu); /* 25 */
+    void (*tkWinSetWindowPos) (HWND hwnd, HWND siblingHwnd, int pos); /* 26 */
+    void (*tkWinWmCleanup) (HINSTANCE hInstance); /* 27 */
+    void (*tkWinXCleanup) (ClientData clientData); /* 28 */
+    void (*tkWinXInit) (HINSTANCE hInstance); /* 29 */
+    void (*tkWinSetForegroundWindow) (TkWindow *winPtr); /* 30 */
+    void (*tkWinDialogDebug) (int debug); /* 31 */
+    Tcl_Obj * (*tkWinGetMenuSystemDefault) (Tk_Window tkwin, const char *dbName, const char *className); /* 32 */
+    int (*tkWinGetPlatformId) (void); /* 33 */
+    void (*tkWinSetHINSTANCE) (HINSTANCE hInstance); /* 34 */
+    int (*tkWinGetPlatformTheme) (void); /* 35 */
+    LRESULT (__stdcall *tkWinChildProc) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); /* 36 */
+    void (*tkCreateXEventSource) (void); /* 37 */
+    int (*tkpCmapStressed) (Tk_Window tkwin, Colormap colormap); /* 38 */
+    void (*tkpSync) (Display *display); /* 39 */
+    Window (*tkUnixContainerId) (TkWindow *winPtr); /* 40 */
+    int (*tkUnixDoOneXEvent) (Tcl_Time *timePtr); /* 41 */
+    void (*tkUnixSetMenubar) (Tk_Window tkwin, Tk_Window menubar); /* 42 */
+    void (*tkWmCleanup) (TkDisplay *dispPtr); /* 43 */
+    void (*tkSendCleanup) (TkDisplay *dispPtr); /* 44 */
+    int (*tkpTestsendCmd) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 45 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*tkGenerateActivateEvents) (TkWindow *winPtr, int active); /* 0 */
+    void (*reserved1)(void);
+    void (*reserved2)(void);
+    void (*tkPointerDeadWindow) (TkWindow *winPtr); /* 3 */
+    void (*tkpSetCapture) (TkWindow *winPtr); /* 4 */
+    void (*tkpSetCursor) (TkpCursor cursor); /* 5 */
+    void (*tkpWmSetState) (TkWindow *winPtr, int state); /* 6 */
+    void (*tkAboutDlg) (void); /* 7 */
+    unsigned int (*tkMacOSXButtonKeyState) (void); /* 8 */
+    void (*tkMacOSXClearMenubarActive) (void); /* 9 */
+    int (*tkMacOSXDispatchMenuEvent) (int menuID, int index); /* 10 */
+    void (*tkMacOSXInstallCursor) (int resizeOverride); /* 11 */
+    void (*tkMacOSXHandleTearoffMenu) (void); /* 12 */
+    void (*reserved13)(void);
+    int (*tkMacOSXDoHLEvent) (void *theEvent); /* 14 */
+    void (*reserved15)(void);
+    Window (*tkMacOSXGetXWindow) (void *macWinPtr); /* 16 */
+    int (*tkMacOSXGrowToplevel) (void *whichWindow, XPoint start); /* 17 */
+    void (*tkMacOSXHandleMenuSelect) (short theMenu, unsigned short theItem, int optionKeyPressed); /* 18 */
+    void (*reserved19)(void);
+    void (*reserved20)(void);
+    void (*tkMacOSXInvalidateWindow) (MacDrawable *macWin, int flag); /* 21 */
+    int (*tkMacOSXIsCharacterMissing) (Tk_Font tkfont, unsigned int searchChar); /* 22 */
+    void (*tkMacOSXMakeRealWindowExist) (TkWindow *winPtr); /* 23 */
+    void * (*tkMacOSXMakeStippleMap) (Drawable d1, Drawable d2); /* 24 */
+    void (*tkMacOSXMenuClick) (void); /* 25 */
+    void (*tkMacOSXRegisterOffScreenWindow) (Window window, void *portPtr); /* 26 */
+    int (*tkMacOSXResizable) (TkWindow *winPtr); /* 27 */
+    void (*tkMacOSXSetHelpMenuItemCount) (void); /* 28 */
+    void (*tkMacOSXSetScrollbarGrow) (TkWindow *winPtr, int flag); /* 29 */
+    void (*tkMacOSXSetUpClippingRgn) (Drawable drawable); /* 30 */
+    void (*tkMacOSXSetUpGraphicsPort) (GC gc, void *destPort); /* 31 */
+    void (*tkMacOSXUpdateClipRgn) (TkWindow *winPtr); /* 32 */
+    void (*tkMacOSXUnregisterMacWindow) (void *portPtr); /* 33 */
+    int (*tkMacOSXUseMenuID) (short macID); /* 34 */
+    TkRegion (*tkMacOSXVisableClipRgn) (TkWindow *winPtr); /* 35 */
+    void (*tkMacOSXWinBounds) (TkWindow *winPtr, void *geometry); /* 36 */
+    void (*tkMacOSXWindowOffset) (void *wRef, int *xOffset, int *yOffset); /* 37 */
+    int (*tkSetMacColor) (unsigned long pixel, void *macColor); /* 38 */
+    void (*tkSetWMName) (TkWindow *winPtr, Tk_Uid titleUid); /* 39 */
+    void (*tkSuspendClipboard) (void); /* 40 */
+    int (*tkMacOSXZoomToplevel) (void *whichWindow, short zoomPart); /* 41 */
+    Tk_Window (*tk_TopCoordsToWindow) (Tk_Window tkwin, int rootX, int rootY, int *newX, int *newY); /* 42 */
+    MacDrawable * (*tkMacOSXContainerId) (TkWindow *winPtr); /* 43 */
+    MacDrawable * (*tkMacOSXGetHostToplevel) (TkWindow *winPtr); /* 44 */
+    void (*tkMacOSXPreprocessMenu) (void); /* 45 */
+    int (*tkpIsWindowFloating) (void *window); /* 46 */
+    Tk_Window (*tkMacOSXGetCapture) (void); /* 47 */
+    void (*reserved48)(void);
+    Window (*tkGetTransientMaster) (TkWindow *winPtr); /* 49 */
+    int (*tkGenerateButtonEvent) (int x, int y, Window window, unsigned int state); /* 50 */
+    void (*tkGenWMDestroyEvent) (Tk_Window tkwin); /* 51 */
+    void (*tkMacOSXSetDrawingEnabled) (TkWindow *winPtr, int flag); /* 52 */
+    unsigned long (*tkpGetMS) (void); /* 53 */
+    void * (*tkMacOSXDrawable) (Drawable drawable); /* 54 */
+    int (*tkpScanWindowId) (Tcl_Interp *interp, const char *string, Window *idPtr); /* 55 */
+#endif /* AQUA */
+#if !(defined(_WIN32) || defined(__CYGWIN__) || defined(MAC_OSX_TK)) /* X11 */
+    void (*tkCreateXEventSource) (void); /* 0 */
+    void (*reserved1)(void);
+    void (*reserved2)(void);
+    int (*tkpCmapStressed) (Tk_Window tkwin, Colormap colormap); /* 3 */
+    void (*tkpSync) (Display *display); /* 4 */
+    Window (*tkUnixContainerId) (TkWindow *winPtr); /* 5 */
+    int (*tkUnixDoOneXEvent) (Tcl_Time *timePtr); /* 6 */
+    void (*tkUnixSetMenubar) (Tk_Window tkwin, Tk_Window menubar); /* 7 */
+    int (*tkpScanWindowId) (Tcl_Interp *interp, const char *string, Window *idPtr); /* 8 */
+    void (*tkWmCleanup) (TkDisplay *dispPtr); /* 9 */
+    void (*tkSendCleanup) (TkDisplay *dispPtr); /* 10 */
+    void (*reserved11)(void);
+    int (*tkpWmSetState) (TkWindow *winPtr, int state); /* 12 */
+    int (*tkpTestsendCmd) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 13 */
+#endif /* X11 */
+} TkIntPlatStubs;
+
+extern const TkIntPlatStubs *tkIntPlatStubsPtr;
+
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TK_STUBS)
+
+/*
+ * Inline function declarations:
+ */
+
+#if defined(_WIN32) || defined(__CYGWIN__) /* WIN */
+#define TkAlignImageData \
+	(tkIntPlatStubsPtr->tkAlignImageData) /* 0 */
+/* Slot 1 is reserved */
+#define TkGenerateActivateEvents \
+	(tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 2 */
+#define TkpGetMS \
+	(tkIntPlatStubsPtr->tkpGetMS) /* 3 */
+#define TkPointerDeadWindow \
+	(tkIntPlatStubsPtr->tkPointerDeadWindow) /* 4 */
+#define TkpPrintWindowId \
+	(tkIntPlatStubsPtr->tkpPrintWindowId) /* 5 */
+#define TkpScanWindowId \
+	(tkIntPlatStubsPtr->tkpScanWindowId) /* 6 */
+#define TkpSetCapture \
+	(tkIntPlatStubsPtr->tkpSetCapture) /* 7 */
+#define TkpSetCursor \
+	(tkIntPlatStubsPtr->tkpSetCursor) /* 8 */
+#define TkpWmSetState \
+	(tkIntPlatStubsPtr->tkpWmSetState) /* 9 */
+#define TkSetPixmapColormap \
+	(tkIntPlatStubsPtr->tkSetPixmapColormap) /* 10 */
+#define TkWinCancelMouseTimer \
+	(tkIntPlatStubsPtr->tkWinCancelMouseTimer) /* 11 */
+#define TkWinClipboardRender \
+	(tkIntPlatStubsPtr->tkWinClipboardRender) /* 12 */
+#define TkWinEmbeddedEventProc \
+	(tkIntPlatStubsPtr->tkWinEmbeddedEventProc) /* 13 */
+#define TkWinFillRect \
+	(tkIntPlatStubsPtr->tkWinFillRect) /* 14 */
+#define TkWinGetBorderPixels \
+	(tkIntPlatStubsPtr->tkWinGetBorderPixels) /* 15 */
+#define TkWinGetDrawableDC \
+	(tkIntPlatStubsPtr->tkWinGetDrawableDC) /* 16 */
+#define TkWinGetModifierState \
+	(tkIntPlatStubsPtr->tkWinGetModifierState) /* 17 */
+#define TkWinGetSystemPalette \
+	(tkIntPlatStubsPtr->tkWinGetSystemPalette) /* 18 */
+#define TkWinGetWrapperWindow \
+	(tkIntPlatStubsPtr->tkWinGetWrapperWindow) /* 19 */
+#define TkWinHandleMenuEvent \
+	(tkIntPlatStubsPtr->tkWinHandleMenuEvent) /* 20 */
+#define TkWinIndexOfColor \
+	(tkIntPlatStubsPtr->tkWinIndexOfColor) /* 21 */
+#define TkWinReleaseDrawableDC \
+	(tkIntPlatStubsPtr->tkWinReleaseDrawableDC) /* 22 */
+#define TkWinResendEvent \
+	(tkIntPlatStubsPtr->tkWinResendEvent) /* 23 */
+#define TkWinSelectPalette \
+	(tkIntPlatStubsPtr->tkWinSelectPalette) /* 24 */
+#define TkWinSetMenu \
+	(tkIntPlatStubsPtr->tkWinSetMenu) /* 25 */
+#define TkWinSetWindowPos \
+	(tkIntPlatStubsPtr->tkWinSetWindowPos) /* 26 */
+#define TkWinWmCleanup \
+	(tkIntPlatStubsPtr->tkWinWmCleanup) /* 27 */
+#define TkWinXCleanup \
+	(tkIntPlatStubsPtr->tkWinXCleanup) /* 28 */
+#define TkWinXInit \
+	(tkIntPlatStubsPtr->tkWinXInit) /* 29 */
+#define TkWinSetForegroundWindow \
+	(tkIntPlatStubsPtr->tkWinSetForegroundWindow) /* 30 */
+#define TkWinDialogDebug \
+	(tkIntPlatStubsPtr->tkWinDialogDebug) /* 31 */
+#define TkWinGetMenuSystemDefault \
+	(tkIntPlatStubsPtr->tkWinGetMenuSystemDefault) /* 32 */
+#define TkWinGetPlatformId \
+	(tkIntPlatStubsPtr->tkWinGetPlatformId) /* 33 */
+#define TkWinSetHINSTANCE \
+	(tkIntPlatStubsPtr->tkWinSetHINSTANCE) /* 34 */
+#define TkWinGetPlatformTheme \
+	(tkIntPlatStubsPtr->tkWinGetPlatformTheme) /* 35 */
+#define TkWinChildProc \
+	(tkIntPlatStubsPtr->tkWinChildProc) /* 36 */
+#define TkCreateXEventSource \
+	(tkIntPlatStubsPtr->tkCreateXEventSource) /* 37 */
+#define TkpCmapStressed \
+	(tkIntPlatStubsPtr->tkpCmapStressed) /* 38 */
+#define TkpSync \
+	(tkIntPlatStubsPtr->tkpSync) /* 39 */
+#define TkUnixContainerId \
+	(tkIntPlatStubsPtr->tkUnixContainerId) /* 40 */
+#define TkUnixDoOneXEvent \
+	(tkIntPlatStubsPtr->tkUnixDoOneXEvent) /* 41 */
+#define TkUnixSetMenubar \
+	(tkIntPlatStubsPtr->tkUnixSetMenubar) /* 42 */
+#define TkWmCleanup \
+	(tkIntPlatStubsPtr->tkWmCleanup) /* 43 */
+#define TkSendCleanup \
+	(tkIntPlatStubsPtr->tkSendCleanup) /* 44 */
+#define TkpTestsendCmd \
+	(tkIntPlatStubsPtr->tkpTestsendCmd) /* 45 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#define TkGenerateActivateEvents \
+	(tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 0 */
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+#define TkPointerDeadWindow \
+	(tkIntPlatStubsPtr->tkPointerDeadWindow) /* 3 */
+#define TkpSetCapture \
+	(tkIntPlatStubsPtr->tkpSetCapture) /* 4 */
+#define TkpSetCursor \
+	(tkIntPlatStubsPtr->tkpSetCursor) /* 5 */
+#define TkpWmSetState \
+	(tkIntPlatStubsPtr->tkpWmSetState) /* 6 */
+#define TkAboutDlg \
+	(tkIntPlatStubsPtr->tkAboutDlg) /* 7 */
+#define TkMacOSXButtonKeyState \
+	(tkIntPlatStubsPtr->tkMacOSXButtonKeyState) /* 8 */
+#define TkMacOSXClearMenubarActive \
+	(tkIntPlatStubsPtr->tkMacOSXClearMenubarActive) /* 9 */
+#define TkMacOSXDispatchMenuEvent \
+	(tkIntPlatStubsPtr->tkMacOSXDispatchMenuEvent) /* 10 */
+#define TkMacOSXInstallCursor \
+	(tkIntPlatStubsPtr->tkMacOSXInstallCursor) /* 11 */
+#define TkMacOSXHandleTearoffMenu \
+	(tkIntPlatStubsPtr->tkMacOSXHandleTearoffMenu) /* 12 */
+/* Slot 13 is reserved */
+#define TkMacOSXDoHLEvent \
+	(tkIntPlatStubsPtr->tkMacOSXDoHLEvent) /* 14 */
+/* Slot 15 is reserved */
+#define TkMacOSXGetXWindow \
+	(tkIntPlatStubsPtr->tkMacOSXGetXWindow) /* 16 */
+#define TkMacOSXGrowToplevel \
+	(tkIntPlatStubsPtr->tkMacOSXGrowToplevel) /* 17 */
+#define TkMacOSXHandleMenuSelect \
+	(tkIntPlatStubsPtr->tkMacOSXHandleMenuSelect) /* 18 */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+#define TkMacOSXInvalidateWindow \
+	(tkIntPlatStubsPtr->tkMacOSXInvalidateWindow) /* 21 */
+#define TkMacOSXIsCharacterMissing \
+	(tkIntPlatStubsPtr->tkMacOSXIsCharacterMissing) /* 22 */
+#define TkMacOSXMakeRealWindowExist \
+	(tkIntPlatStubsPtr->tkMacOSXMakeRealWindowExist) /* 23 */
+#define TkMacOSXMakeStippleMap \
+	(tkIntPlatStubsPtr->tkMacOSXMakeStippleMap) /* 24 */
+#define TkMacOSXMenuClick \
+	(tkIntPlatStubsPtr->tkMacOSXMenuClick) /* 25 */
+#define TkMacOSXRegisterOffScreenWindow \
+	(tkIntPlatStubsPtr->tkMacOSXRegisterOffScreenWindow) /* 26 */
+#define TkMacOSXResizable \
+	(tkIntPlatStubsPtr->tkMacOSXResizable) /* 27 */
+#define TkMacOSXSetHelpMenuItemCount \
+	(tkIntPlatStubsPtr->tkMacOSXSetHelpMenuItemCount) /* 28 */
+#define TkMacOSXSetScrollbarGrow \
+	(tkIntPlatStubsPtr->tkMacOSXSetScrollbarGrow) /* 29 */
+#define TkMacOSXSetUpClippingRgn \
+	(tkIntPlatStubsPtr->tkMacOSXSetUpClippingRgn) /* 30 */
+#define TkMacOSXSetUpGraphicsPort \
+	(tkIntPlatStubsPtr->tkMacOSXSetUpGraphicsPort) /* 31 */
+#define TkMacOSXUpdateClipRgn \
+	(tkIntPlatStubsPtr->tkMacOSXUpdateClipRgn) /* 32 */
+#define TkMacOSXUnregisterMacWindow \
+	(tkIntPlatStubsPtr->tkMacOSXUnregisterMacWindow) /* 33 */
+#define TkMacOSXUseMenuID \
+	(tkIntPlatStubsPtr->tkMacOSXUseMenuID) /* 34 */
+#define TkMacOSXVisableClipRgn \
+	(tkIntPlatStubsPtr->tkMacOSXVisableClipRgn) /* 35 */
+#define TkMacOSXWinBounds \
+	(tkIntPlatStubsPtr->tkMacOSXWinBounds) /* 36 */
+#define TkMacOSXWindowOffset \
+	(tkIntPlatStubsPtr->tkMacOSXWindowOffset) /* 37 */
+#define TkSetMacColor \
+	(tkIntPlatStubsPtr->tkSetMacColor) /* 38 */
+#define TkSetWMName \
+	(tkIntPlatStubsPtr->tkSetWMName) /* 39 */
+#define TkSuspendClipboard \
+	(tkIntPlatStubsPtr->tkSuspendClipboard) /* 40 */
+#define TkMacOSXZoomToplevel \
+	(tkIntPlatStubsPtr->tkMacOSXZoomToplevel) /* 41 */
+#define Tk_TopCoordsToWindow \
+	(tkIntPlatStubsPtr->tk_TopCoordsToWindow) /* 42 */
+#define TkMacOSXContainerId \
+	(tkIntPlatStubsPtr->tkMacOSXContainerId) /* 43 */
+#define TkMacOSXGetHostToplevel \
+	(tkIntPlatStubsPtr->tkMacOSXGetHostToplevel) /* 44 */
+#define TkMacOSXPreprocessMenu \
+	(tkIntPlatStubsPtr->tkMacOSXPreprocessMenu) /* 45 */
+#define TkpIsWindowFloating \
+	(tkIntPlatStubsPtr->tkpIsWindowFloating) /* 46 */
+#define TkMacOSXGetCapture \
+	(tkIntPlatStubsPtr->tkMacOSXGetCapture) /* 47 */
+/* Slot 48 is reserved */
+#define TkGetTransientMaster \
+	(tkIntPlatStubsPtr->tkGetTransientMaster) /* 49 */
+#define TkGenerateButtonEvent \
+	(tkIntPlatStubsPtr->tkGenerateButtonEvent) /* 50 */
+#define TkGenWMDestroyEvent \
+	(tkIntPlatStubsPtr->tkGenWMDestroyEvent) /* 51 */
+#define TkMacOSXSetDrawingEnabled \
+	(tkIntPlatStubsPtr->tkMacOSXSetDrawingEnabled) /* 52 */
+#define TkpGetMS \
+	(tkIntPlatStubsPtr->tkpGetMS) /* 53 */
+#define TkMacOSXDrawable \
+	(tkIntPlatStubsPtr->tkMacOSXDrawable) /* 54 */
+#define TkpScanWindowId \
+	(tkIntPlatStubsPtr->tkpScanWindowId) /* 55 */
+#endif /* AQUA */
+#if !(defined(_WIN32) || defined(__CYGWIN__) || defined(MAC_OSX_TK)) /* X11 */
+#define TkCreateXEventSource \
+	(tkIntPlatStubsPtr->tkCreateXEventSource) /* 0 */
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+#define TkpCmapStressed \
+	(tkIntPlatStubsPtr->tkpCmapStressed) /* 3 */
+#define TkpSync \
+	(tkIntPlatStubsPtr->tkpSync) /* 4 */
+#define TkUnixContainerId \
+	(tkIntPlatStubsPtr->tkUnixContainerId) /* 5 */
+#define TkUnixDoOneXEvent \
+	(tkIntPlatStubsPtr->tkUnixDoOneXEvent) /* 6 */
+#define TkUnixSetMenubar \
+	(tkIntPlatStubsPtr->tkUnixSetMenubar) /* 7 */
+#define TkpScanWindowId \
+	(tkIntPlatStubsPtr->tkpScanWindowId) /* 8 */
+#define TkWmCleanup \
+	(tkIntPlatStubsPtr->tkWmCleanup) /* 9 */
+#define TkSendCleanup \
+	(tkIntPlatStubsPtr->tkSendCleanup) /* 10 */
+/* Slot 11 is reserved */
+#define TkpWmSetState \
+	(tkIntPlatStubsPtr->tkpWmSetState) /* 12 */
+#define TkpTestsendCmd \
+	(tkIntPlatStubsPtr->tkpTestsendCmd) /* 13 */
+#endif /* X11 */
+
+#endif /* defined(USE_TK_STUBS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TKINTPLATDECLS */
Index: src/tktext/tk8.6/tkMacOSX.h
===================================================================
--- src/tktext/tk8.6/tkMacOSX.h	(revision 0)
+++ src/tktext/tk8.6/tkMacOSX.h	(working copy)
@@ -0,0 +1,34 @@
+/*
+ * tkMacOSX.h --
+ *
+ *	Declarations of Macintosh specific exported variables and procedures.
+ *
+ * Copyright (c) 1995-1997 Sun Microsystems, Inc.
+ * Copyright 2001-2009, Apple Inc.
+ * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKMAC
+#define _TKMAC
+
+#ifndef _TK
+#include "tk.h"
+#endif
+
+/*
+ * Structures and function types for handling Netscape-type in process
+ * embedding where Tk does not control the top-level
+ */
+
+typedef int (Tk_MacOSXEmbedRegisterWinProc) (long winID, Tk_Window window);
+typedef void* (Tk_MacOSXEmbedGetGrafPortProc) (Tk_Window window);
+typedef int (Tk_MacOSXEmbedMakeContainerExistProc) (Tk_Window window);
+typedef void (Tk_MacOSXEmbedGetClipProc) (Tk_Window window, TkRegion rgn);
+typedef void (Tk_MacOSXEmbedGetOffsetInParentProc) (Tk_Window window, void *ulCorner);
+
+#include "tkPlatDecls.h"
+
+#endif /* _TKMAC */
Index: src/tktext/tk8.6/tkMacOSXDefault.h
===================================================================
--- src/tktext/tk8.6/tkMacOSXDefault.h	(revision 0)
+++ src/tktext/tk8.6/tkMacOSXDefault.h	(working copy)
@@ -0,0 +1,573 @@
+/*
+ * tkMacOSXDefault.h --
+ *
+ *	This file defines the defaults for all options for all of
+ *	the Tk widgets.
+ *
+ * Copyright (c) 1991-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright 2001-2009, Apple Inc.
+ * Copyright (c) 2006-2009 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKMACDEFAULT
+#define _TKMACDEFAULT
+
+//#ifndef TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
+//#define TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS 1
+//#endif
+
+/*
+ * The definitions below provide symbolic names for the default colors.
+ * NORMAL_BG -		Normal background color.
+ * ACTIVE_BG -		Background color when widget is active.
+ * SELECT_BG -		Background color for selected text.
+ * SELECT_FG -		Foreground color for selected text.
+ * TROUGH -		Background color for troughs in scales and scrollbars.
+ * INDICATOR -		Color for indicator when button is selected.
+ * DISABLED -		Foreground color when widget is disabled.
+ */
+
+#define BLACK			"Black"
+#define WHITE			"White"
+#define NORMAL_BG		"systemWindowBody"
+#define ACTIVE_BG		"systemButtonFacePressed"
+#define ACTIVE_FG		"systemPushButtonPressedText"
+#define SELECT_BG		"systemHighlight"
+#define SELECT_FG		None
+#define INACTIVE_SELECT_BG	"systemHighlightSecondary"
+#define TROUGH			"#c3c3c3"
+#define INDICATOR		"#b03060"
+#define DISABLED		"#a3a3a3"
+
+/*
+ * Defaults for labels, buttons, checkbuttons, and radiobuttons:
+ */
+
+#define DEF_BUTTON_ANCHOR		"center"
+#define DEF_BUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_BUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_BUTTON_ACTIVE_FG_COLOR	ACTIVE_FG
+#define DEF_CHKRAD_ACTIVE_FG_COLOR	DEF_BUTTON_ACTIVE_FG_COLOR
+#define DEF_BUTTON_ACTIVE_FG_MONO	WHITE
+/* #define DEF_BUTTON_BG_COLOR	"systemButtonFace"*/
+#define DEF_BUTTON_BG_COLOR		WHITE
+#define DEF_BUTTON_BG_MONO		WHITE
+#define DEF_BUTTON_BITMAP		""
+#define DEF_BUTTON_BORDER_WIDTH		"2"
+#define DEF_BUTTON_CURSOR		""
+#define DEF_BUTTON_COMMAND		""
+#define DEF_BUTTON_COMPOUND		"none"
+#define DEF_BUTTON_DEFAULT		"disabled"
+#define DEF_BUTTON_DISABLED_FG_COLOR	DISABLED
+#define DEF_BUTTON_DISABLED_FG_MONO	""
+#define DEF_BUTTON_FG			"systemButtonText"
+#define DEF_CHKRAD_FG			DEF_BUTTON_FG
+#define DEF_BUTTON_FONT			"TkDefaultFont"
+#define DEF_BUTTON_HEIGHT		"0"
+#define DEF_BUTTON_HIGHLIGHT_BG_COLOR	DEF_BUTTON_BG_COLOR
+#define DEF_BUTTON_HIGHLIGHT_BG_MONO	DEF_BUTTON_BG_MONO
+#define DEF_BUTTON_HIGHLIGHT		"systemButtonFrame"
+#define DEF_LABEL_HIGHLIGHT_WIDTH	"0"
+//#if TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
+//#define DEF_BUTTON_HIGHLIGHT_WIDTH	"4"
+//#define DEF_BUTTON_HIGHLIGHT_WIDTH_NOCM	"1"
+//#else
+#define DEF_BUTTON_HIGHLIGHT_WIDTH	"1"
+//#endif
+#define DEF_BUTTON_IMAGE		((char *) NULL)
+#define DEF_BUTTON_INDICATOR		"1"
+#define DEF_BUTTON_JUSTIFY		"center"
+#define DEF_BUTTON_OFF_VALUE		"0"
+#define DEF_BUTTON_ON_VALUE		"1"
+#define DEF_BUTTON_TRISTATE_VALUE	""
+#define DEF_BUTTON_OVER_RELIEF		""
+//#if TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
+//#define DEF_BUTTON_PADX			"12"
+//#define DEF_BUTTON_PADX_NOCM		"1"
+//#else
+#define DEF_BUTTON_PADX			"1"
+//#endif
+#define DEF_LABCHKRAD_PADX		"1"
+//#if TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
+//#define DEF_BUTTON_PADY			"3"
+//#define DEF_BUTTON_PADY_NOCM		"1"
+//#else
+#define DEF_BUTTON_PADY			"1"
+//#endif
+#define DEF_LABCHKRAD_PADY		"1"
+#define DEF_BUTTON_RELIEF		"flat"
+#define DEF_LABCHKRAD_RELIEF		"flat"
+#define DEF_BUTTON_REPEAT_DELAY		"0"
+#define DEF_BUTTON_REPEAT_INTERVAL	"0"
+#define DEF_BUTTON_SELECT_COLOR		INDICATOR
+#define DEF_BUTTON_SELECT_MONO		BLACK
+#define DEF_BUTTON_SELECT_IMAGE		((char *) NULL)
+#define DEF_BUTTON_STATE		"normal"
+#define DEF_LABEL_TAKE_FOCUS		"0"
+#define DEF_BUTTON_TAKE_FOCUS		((char *) NULL)
+#define DEF_BUTTON_TEXT			""
+#define DEF_BUTTON_TEXT_VARIABLE	""
+#define DEF_BUTTON_UNDERLINE		"-1"
+#define DEF_BUTTON_VALUE		""
+#define DEF_BUTTON_WIDTH		"0"
+#define DEF_BUTTON_WRAP_LENGTH		"0"
+#define DEF_RADIOBUTTON_VARIABLE	"selectedButton"
+#define DEF_CHECKBUTTON_VARIABLE	""
+
+/*
+ * Defaults for canvases:
+ */
+
+#define DEF_CANVAS_BG_COLOR		NORMAL_BG
+#define DEF_CANVAS_BG_MONO		WHITE
+#define DEF_CANVAS_BORDER_WIDTH		"0"
+#define DEF_CANVAS_CLOSE_ENOUGH		"1"
+#define DEF_CANVAS_CONFINE		"1"
+#define DEF_CANVAS_CURSOR		""
+#define DEF_CANVAS_HEIGHT		"7c"
+#define DEF_CANVAS_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_CANVAS_HIGHLIGHT		BLACK
+#define DEF_CANVAS_HIGHLIGHT_WIDTH	"3"
+#define DEF_CANVAS_INSERT_BG		BLACK
+#define DEF_CANVAS_INSERT_BD_COLOR	"0"
+#define DEF_CANVAS_INSERT_BD_MONO	"0"
+#define DEF_CANVAS_INSERT_OFF_TIME	"300"
+#define DEF_CANVAS_INSERT_ON_TIME	"600"
+#define DEF_CANVAS_INSERT_WIDTH		"2"
+#define DEF_CANVAS_RELIEF		"flat"
+#define DEF_CANVAS_SCROLL_REGION	""
+#define DEF_CANVAS_SELECT_COLOR		SELECT_BG
+#define DEF_CANVAS_SELECT_MONO		BLACK
+#define DEF_CANVAS_SELECT_BD_COLOR	"1"
+#define DEF_CANVAS_SELECT_BD_MONO	"0"
+#define DEF_CANVAS_SELECT_FG_COLOR	SELECT_FG
+#define DEF_CANVAS_SELECT_FG_MONO	WHITE
+#define DEF_CANVAS_TAKE_FOCUS		((char *) NULL)
+#define DEF_CANVAS_WIDTH		"10c"
+#define DEF_CANVAS_X_SCROLL_CMD		""
+#define DEF_CANVAS_X_SCROLL_INCREMENT	"0"
+#define DEF_CANVAS_Y_SCROLL_CMD		""
+#define DEF_CANVAS_Y_SCROLL_INCREMENT	"0"
+
+/*
+ * Defaults for entries:
+ */
+
+/*
+ * I test the following two values in TkpDrawEntryBorderAndFocus
+ * to determine whether to use the native entry widget. So if
+ * you change the defaults to be different from these, then you
+ * won't get the native widget by default.
+ */
+
+#define MAC_OSX_FOCUS_WIDTH		3
+#define MAC_OSX_ENTRY_BORDER		2
+#define MAC_OSX_ENTRY_RELIEF		TK_RELIEF_SUNKEN
+#define MAC_OSX_ENTRY_SELECT_RELIEF	TK_RELIEF_FLAT
+
+#define DEF_ENTRY_BG_COLOR		NORMAL_BG
+#define DEF_ENTRY_BG_MONO		WHITE
+#define DEF_ENTRY_BORDER_WIDTH		"2"
+#define DEF_ENTRY_CURSOR		"xterm"
+#define DEF_ENTRY_DISABLED_BG_COLOR	NORMAL_BG
+#define DEF_ENTRY_DISABLED_BG_MONO	WHITE
+#define DEF_ENTRY_DISABLED_FG		DISABLED
+#define DEF_ENTRY_EXPORT_SELECTION	"1"
+#define DEF_ENTRY_FONT			"TkTextFont"
+#define DEF_ENTRY_FG			BLACK
+#define DEF_ENTRY_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_ENTRY_HIGHLIGHT		BLACK
+/* #define DEF_ENTRY_HIGHLIGHT_WIDTH	"3" */
+#define DEF_ENTRY_HIGHLIGHT_WIDTH	"3"
+#define DEF_ENTRY_INSERT_BG		BLACK
+#define DEF_ENTRY_INSERT_BD_COLOR	"0"
+#define DEF_ENTRY_INSERT_BD_MONO	"0"
+#define DEF_ENTRY_INSERT_OFF_TIME	"300"
+#define DEF_ENTRY_INSERT_ON_TIME	"600"
+/* #define DEF_ENTRY_INSERT_WIDTH		"2" */
+#define DEF_ENTRY_INSERT_WIDTH		"1"
+#define DEF_ENTRY_JUSTIFY		"left"
+#define DEF_ENTRY_READONLY_BG_COLOR	NORMAL_BG
+#define DEF_ENTRY_READONLY_BG_MONO	WHITE
+#define DEF_ENTRY_RELIEF		"sunken"
+/* #define DEF_ENTRY_RELIEF		"solid" */
+#define DEF_ENTRY_SCROLL_COMMAND	""
+#define DEF_ENTRY_SELECT_COLOR		SELECT_BG
+#define DEF_ENTRY_SELECT_MONO		BLACK
+#define DEF_ENTRY_SELECT_BD_COLOR	"1"
+#define DEF_ENTRY_SELECT_BD_MONO	"0"
+#define DEF_ENTRY_SELECT_FG_COLOR	SELECT_FG
+#define DEF_ENTRY_SELECT_FG_MONO	WHITE
+#define DEF_ENTRY_SHOW			((char *) NULL)
+#define DEF_ENTRY_STATE			"normal"
+#define DEF_ENTRY_TAKE_FOCUS		((char *) NULL)
+#define DEF_ENTRY_TEXT_VARIABLE		""
+#define DEF_ENTRY_WIDTH			"20"
+
+/*
+ * Defaults for frames:
+ */
+
+#define DEF_FRAME_BG_COLOR		NORMAL_BG
+#define DEF_FRAME_BG_MONO		WHITE
+#define DEF_FRAME_BORDER_WIDTH		"0"
+#define DEF_FRAME_CLASS			"Frame"
+#define DEF_FRAME_COLORMAP		""
+#define DEF_FRAME_CONTAINER		"0"
+#define DEF_FRAME_CURSOR		""
+#define DEF_FRAME_HEIGHT		"0"
+#define DEF_FRAME_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_FRAME_HIGHLIGHT		BLACK
+#define DEF_FRAME_HIGHLIGHT_WIDTH	"0"
+#define DEF_FRAME_PADX			"0"
+#define DEF_FRAME_PADY			"0"
+#define DEF_FRAME_RELIEF		"flat"
+#define DEF_FRAME_TAKE_FOCUS		"0"
+#define DEF_FRAME_VISUAL		""
+#define DEF_FRAME_WIDTH			"0"
+
+/*
+ * Defaults for labelframes:
+ */
+
+#define DEF_LABELFRAME_BORDER_WIDTH	"2"
+#define DEF_LABELFRAME_CLASS		"Labelframe"
+#define DEF_LABELFRAME_RELIEF		"groove"
+#define DEF_LABELFRAME_FG		"systemButtonText"
+#define DEF_LABELFRAME_FONT		"TkDefaultFont"
+#define DEF_LABELFRAME_TEXT		""
+#define DEF_LABELFRAME_LABELANCHOR	"nw"
+
+/*
+ * Defaults for listboxes:
+ */
+
+#define DEF_LISTBOX_ACTIVE_STYLE	"dotbox"
+#define DEF_LISTBOX_BG_COLOR		WHITE
+#define DEF_LISTBOX_BG_MONO		WHITE
+#define DEF_LISTBOX_BORDER_WIDTH	"1"
+#define DEF_LISTBOX_CURSOR		""
+#define DEF_LISTBOX_DISABLED_FG		DISABLED
+#define DEF_LISTBOX_EXPORT_SELECTION	"1"
+#define DEF_LISTBOX_FONT		"TkTextFont"
+#define DEF_LISTBOX_FG			BLACK
+#define DEF_LISTBOX_HEIGHT		"10"
+#define DEF_LISTBOX_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_LISTBOX_HIGHLIGHT		BLACK
+#define DEF_LISTBOX_HIGHLIGHT_WIDTH	"0"
+#define DEF_LISTBOX_RELIEF		"solid"
+#define DEF_LISTBOX_SCROLL_COMMAND	""
+#define DEF_LISTBOX_LIST_VARIABLE	""
+#define DEF_LISTBOX_SELECT_COLOR	SELECT_BG
+#define DEF_LISTBOX_SELECT_MONO		BLACK
+#define DEF_LISTBOX_SELECT_BD		"0"
+#define DEF_LISTBOX_SELECT_FG_COLOR	SELECT_FG
+#define DEF_LISTBOX_SELECT_FG_MONO	WHITE
+#define DEF_LISTBOX_SELECT_MODE		"browse"
+#define DEF_LISTBOX_SET_GRID		"0"
+#define DEF_LISTBOX_STATE		"normal"
+#define DEF_LISTBOX_TAKE_FOCUS		((char *) NULL)
+#define DEF_LISTBOX_WIDTH		"20"
+
+/*
+ * Defaults for individual entries of menus:
+ */
+
+#define DEF_MENU_ENTRY_ACTIVE_BG	((char *) NULL)
+#define DEF_MENU_ENTRY_ACTIVE_FG	((char *) NULL)
+#define DEF_MENU_ENTRY_ACCELERATOR	((char *) NULL)
+#define DEF_MENU_ENTRY_BG		((char *) NULL)
+#define DEF_MENU_ENTRY_BITMAP		None
+#define DEF_MENU_ENTRY_COLUMN_BREAK	"0"
+#define DEF_MENU_ENTRY_COMMAND		((char *) NULL)
+#define DEF_MENU_ENTRY_COMPOUND		"none"
+#define DEF_MENU_ENTRY_FG		((char *) NULL)
+#define DEF_MENU_ENTRY_FONT		((char *) NULL)
+#define DEF_MENU_ENTRY_HIDE_MARGIN	"0"
+#define DEF_MENU_ENTRY_IMAGE		((char *) NULL)
+#define DEF_MENU_ENTRY_INDICATOR	"1"
+#define DEF_MENU_ENTRY_LABEL		((char *) NULL)
+#define DEF_MENU_ENTRY_MENU		((char *) NULL)
+#define DEF_MENU_ENTRY_OFF_VALUE	"0"
+#define DEF_MENU_ENTRY_ON_VALUE		"1"
+#define DEF_MENU_ENTRY_SELECT_IMAGE	((char *) NULL)
+#define DEF_MENU_ENTRY_STATE		"normal"
+#define DEF_MENU_ENTRY_VALUE		((char *) NULL)
+#define DEF_MENU_ENTRY_CHECK_VARIABLE	((char *) NULL)
+#define DEF_MENU_ENTRY_RADIO_VARIABLE	"selectedButton"
+#define DEF_MENU_ENTRY_SELECT		((char *) NULL)
+#define DEF_MENU_ENTRY_UNDERLINE	"-1"
+
+/*
+ * Defaults for menus overall:
+ */
+
+#define DEF_MENU_ACTIVE_BG_COLOR	"systemMenuActive"
+#define DEF_MENU_ACTIVE_BG_MONO		BLACK
+#define DEF_MENU_ACTIVE_BORDER_WIDTH	"0"
+#define DEF_MENU_ACTIVE_FG_COLOR	"systemMenuActiveText"
+#define DEF_MENU_ACTIVE_FG_MONO		WHITE
+#define DEF_MENU_BG_COLOR		"systemMenu"
+#define DEF_MENU_BG_MONO		WHITE
+#define DEF_MENU_BORDER_WIDTH		"0"
+#define DEF_MENU_CURSOR			"arrow"
+#define DEF_MENU_DISABLED_FG_COLOR	"systemMenuDisabled"
+#define DEF_MENU_DISABLED_FG_MONO	""
+#define DEF_MENU_FONT			"menu" /* special: see tkMacOSXMenu.c */
+#define DEF_MENU_FG			"systemMenuText"
+#define DEF_MENU_POST_COMMAND		""
+#define DEF_MENU_RELIEF			"flat"
+#define DEF_MENU_SELECT_COLOR		"systemMenuActive"
+#define DEF_MENU_SELECT_MONO		BLACK
+#define DEF_MENU_TAKE_FOCUS		"0"
+
+/*
+ * FIXME: Turn the default back to 1 when we make tearoff menus work again.
+ */
+
+#define DEF_MENU_TEAROFF		"0"
+#define DEF_MENU_TEAROFF_CMD		((char *) NULL)
+#define DEF_MENU_TITLE			""
+#define DEF_MENU_TYPE			"normal"
+
+/*
+ * Defaults for menubuttons:
+ */
+
+#define DEF_MENUBUTTON_ANCHOR		"center"
+#define DEF_MENUBUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_MENUBUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_MENUBUTTON_ACTIVE_FG_COLOR	ACTIVE_FG
+#define DEF_MENUBUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_MENUBUTTON_BG_COLOR		NORMAL_BG
+#define DEF_MENUBUTTON_BG_MONO		WHITE
+#define DEF_MENUBUTTON_BITMAP		""
+#define DEF_MENUBUTTON_BORDER_WIDTH	"2"
+#define DEF_MENUBUTTON_CURSOR		""
+#define DEF_MENUBUTTON_DIRECTION	"below"
+#define DEF_MENUBUTTON_DISABLED_FG_COLOR DISABLED
+#define DEF_MENUBUTTON_DISABLED_FG_MONO	""
+#define DEF_MENUBUTTON_FONT		"TkDefaultFont"
+#define DEF_MENUBUTTON_FG		BLACK
+#define DEF_MENUBUTTON_HEIGHT		"0"
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_COLOR DEF_MENUBUTTON_BG_COLOR
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
+#define DEF_MENUBUTTON_HIGHLIGHT	BLACK
+#define DEF_MENUBUTTON_HIGHLIGHT_WIDTH	"0"
+#define DEF_MENUBUTTON_IMAGE		((char *) NULL)
+#define DEF_MENUBUTTON_INDICATOR	"1"
+#define DEF_MENUBUTTON_JUSTIFY		"left"
+#define DEF_MENUBUTTON_MENU		""
+#define DEF_MENUBUTTON_PADX		"4"
+#define DEF_MENUBUTTON_PADY		"3"
+#define DEF_MENUBUTTON_RELIEF		"flat"
+#define DEF_MENUBUTTON_STATE		"normal"
+#define DEF_MENUBUTTON_TAKE_FOCUS	"0"
+#define DEF_MENUBUTTON_TEXT		""
+#define DEF_MENUBUTTON_TEXT_VARIABLE	""
+#define DEF_MENUBUTTON_UNDERLINE	"-1"
+#define DEF_MENUBUTTON_WIDTH		"0"
+#define DEF_MENUBUTTON_WRAP_LENGTH	"0"
+
+/*
+ * Defaults for messages:
+ */
+
+#define DEF_MESSAGE_ANCHOR		"center"
+#define DEF_MESSAGE_ASPECT		"150"
+#define DEF_MESSAGE_BG_COLOR		NORMAL_BG
+#define DEF_MESSAGE_BG_MONO		WHITE
+#define DEF_MESSAGE_BORDER_WIDTH	"1"
+#define DEF_MESSAGE_CURSOR		""
+#define DEF_MESSAGE_FG			BLACK
+#define DEF_MESSAGE_FONT		"TkDefaultFont"
+#define DEF_MESSAGE_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_MESSAGE_HIGHLIGHT		BLACK
+#define DEF_MESSAGE_HIGHLIGHT_WIDTH	"0"
+#define DEF_MESSAGE_JUSTIFY		"left"
+#define DEF_MESSAGE_PADX		"-1"
+#define DEF_MESSAGE_PADY		"-1"
+#define DEF_MESSAGE_RELIEF		"flat"
+#define DEF_MESSAGE_TAKE_FOCUS		"0"
+#define DEF_MESSAGE_TEXT		""
+#define DEF_MESSAGE_TEXT_VARIABLE	""
+#define DEF_MESSAGE_WIDTH		"0"
+/*
+ * Defaults for panedwindows
+ */
+
+#define DEF_PANEDWINDOW_BG_COLOR	NORMAL_BG
+#define DEF_PANEDWINDOW_BG_MONO		WHITE
+#define DEF_PANEDWINDOW_BORDERWIDTH	"1"
+#define DEF_PANEDWINDOW_CURSOR		""
+#define DEF_PANEDWINDOW_HANDLEPAD	"8"
+#define DEF_PANEDWINDOW_HANDLESIZE	"8"
+#define DEF_PANEDWINDOW_HEIGHT		""
+#define DEF_PANEDWINDOW_OPAQUERESIZE	"1"
+#define DEF_PANEDWINDOW_ORIENT		"horizontal"
+#define DEF_PANEDWINDOW_RELIEF		"flat"
+#define DEF_PANEDWINDOW_SASHCURSOR	""
+#define DEF_PANEDWINDOW_SASHPAD		"0"
+#define DEF_PANEDWINDOW_SASHRELIEF	"flat"
+#define DEF_PANEDWINDOW_SASHWIDTH	"3"
+#define DEF_PANEDWINDOW_SHOWHANDLE	"0"
+#define DEF_PANEDWINDOW_WIDTH		""
+
+/*
+ * Defaults for panedwindow panes
+ */
+
+#define DEF_PANEDWINDOW_PANE_AFTER	""
+#define DEF_PANEDWINDOW_PANE_BEFORE	""
+#define DEF_PANEDWINDOW_PANE_HEIGHT	""
+#define DEF_PANEDWINDOW_PANE_MINSIZE	"0"
+#define DEF_PANEDWINDOW_PANE_PADX	"0"
+#define DEF_PANEDWINDOW_PANE_PADY	"0"
+#define DEF_PANEDWINDOW_PANE_STICKY	"nsew"
+#define DEF_PANEDWINDOW_PANE_WIDTH	""
+#define DEF_PANEDWINDOW_PANE_HIDE	"0"
+#define DEF_PANEDWINDOW_PANE_STRETCH	"last"
+
+/*
+ * Defaults for scales:
+ */
+
+#define DEF_SCALE_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCALE_ACTIVE_BG_MONO	BLACK
+#define DEF_SCALE_BG_COLOR		NORMAL_BG
+#define DEF_SCALE_BG_MONO		WHITE
+#define DEF_SCALE_BIG_INCREMENT		"0"
+#define DEF_SCALE_BORDER_WIDTH		"1"
+#define DEF_SCALE_COMMAND		""
+#define DEF_SCALE_CURSOR		""
+#define DEF_SCALE_DIGITS		"0"
+#define DEF_SCALE_FONT			"TkDefaultFont"
+#define DEF_SCALE_FG_COLOR		BLACK
+#define DEF_SCALE_FG_MONO		BLACK
+#define DEF_SCALE_FROM			"0"
+#define DEF_SCALE_HIGHLIGHT_BG_COLOR	DEF_SCALE_BG_COLOR
+#define DEF_SCALE_HIGHLIGHT_BG_MONO	DEF_SCALE_BG_MONO
+#define DEF_SCALE_HIGHLIGHT		BLACK
+#define DEF_SCALE_HIGHLIGHT_WIDTH	"0"
+#define DEF_SCALE_LABEL			""
+#define DEF_SCALE_LENGTH		"100"
+#define DEF_SCALE_ORIENT		"vertical"
+#define DEF_SCALE_RELIEF		"flat"
+#define DEF_SCALE_REPEAT_DELAY	"300"
+#define DEF_SCALE_REPEAT_INTERVAL	"100"
+#define DEF_SCALE_RESOLUTION		"1"
+#define DEF_SCALE_TROUGH_COLOR		TROUGH
+#define DEF_SCALE_TROUGH_MONO		WHITE
+#define DEF_SCALE_SHOW_VALUE		"1"
+#define DEF_SCALE_SLIDER_LENGTH		"30"
+#define DEF_SCALE_SLIDER_RELIEF		"raised"
+#define DEF_SCALE_STATE			"normal"
+#define DEF_SCALE_TAKE_FOCUS		((char *) NULL)
+#define DEF_SCALE_TICK_INTERVAL		"0"
+#define DEF_SCALE_TO			"100"
+#define DEF_SCALE_VARIABLE		""
+#define DEF_SCALE_WIDTH			"15"
+
+/*
+ * Defaults for scrollbars:
+ */
+
+#define DEF_SCROLLBAR_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCROLLBAR_ACTIVE_BG_MONO	BLACK
+#define DEF_SCROLLBAR_ACTIVE_RELIEF	"raised"
+#define DEF_SCROLLBAR_BG_COLOR		NORMAL_BG
+#define DEF_SCROLLBAR_BG_MONO		WHITE
+#define DEF_SCROLLBAR_BORDER_WIDTH	"0"
+#define DEF_SCROLLBAR_COMMAND		""
+#define DEF_SCROLLBAR_CURSOR		""
+#define DEF_SCROLLBAR_EL_BORDER_WIDTH	"-1"
+#define DEF_SCROLLBAR_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_SCROLLBAR_HIGHLIGHT		BLACK
+#define DEF_SCROLLBAR_HIGHLIGHT_WIDTH	"0"
+#define DEF_SCROLLBAR_JUMP		"0"
+#define DEF_SCROLLBAR_ORIENT		"vertical"
+#define DEF_SCROLLBAR_RELIEF		"flat"
+#define DEF_SCROLLBAR_REPEAT_DELAY	"300"
+#define DEF_SCROLLBAR_REPEAT_INTERVAL	"100"
+#define DEF_SCROLLBAR_TAKE_FOCUS	((char *) NULL)
+#define DEF_SCROLLBAR_TROUGH_COLOR	TROUGH
+#define DEF_SCROLLBAR_TROUGH_MONO	WHITE
+#define DEF_SCROLLBAR_WIDTH		"15"
+
+/*
+ * Defaults for texts:
+ */
+
+#define DEF_TEXT_AUTO_SEPARATORS	"1"
+#define DEF_TEXT_BG_COLOR		NORMAL_BG
+#define DEF_TEXT_BG_MONO		WHITE
+#define DEF_TEXT_BLOCK_CURSOR		"0"
+#define DEF_TEXT_BORDER_WIDTH		"0"
+#define DEF_TEXT_CURSOR			"xterm"
+#define DEF_TEXT_FG			BLACK
+#define DEF_TEXT_EXPORT_SELECTION	"1"
+#define DEF_TEXT_FONT			"TkFixedFont"
+#define DEF_TEXT_HEIGHT			"24"
+#define DEF_TEXT_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_TEXT_HIGHLIGHT		BLACK
+#define DEF_TEXT_HIGHLIGHT_WIDTH	"3"
+#define DEF_TEXT_INSERT_BG		BLACK
+#define DEF_TEXT_INSERT_BD_COLOR	"0"
+#define DEF_TEXT_INSERT_BD_MONO		"0"
+#define DEF_TEXT_INSERT_OFF_TIME	"300"
+#define DEF_TEXT_INSERT_ON_TIME		"600"
+#define DEF_TEXT_INSERT_UNFOCUSSED	"none"
+#define DEF_TEXT_INSERT_WIDTH		"1"
+#define DEF_TEXT_MAX_UNDO		"0"
+#define DEF_TEXT_PADX			"1"
+#define DEF_TEXT_PADY			"1"
+#define DEF_TEXT_RELIEF			"flat"
+#define DEF_TEXT_INACTIVE_SELECT_COLOR	INACTIVE_SELECT_BG
+#define DEF_TEXT_SELECT_COLOR		SELECT_BG
+#define DEF_TEXT_SELECT_MONO		BLACK
+#define DEF_TEXT_SELECT_BD_COLOR	"1"
+#define DEF_TEXT_SELECT_BD_MONO		"0"
+#define DEF_TEXT_SELECT_FG_COLOR	SELECT_FG
+#define DEF_TEXT_SELECT_FG_MONO		WHITE
+#define DEF_TEXT_SELECT_RELIEF		"flat"
+#define DEF_TEXT_SET_GRID		"0"
+#define DEF_TEXT_SPACING1		"0"
+#define DEF_TEXT_SPACING2		"0"
+#define DEF_TEXT_SPACING3		"0"
+#define DEF_TEXT_STATE			"normal"
+#define DEF_TEXT_TABS			""
+#define DEF_TEXT_TABSTYLE		"tabular"
+#define DEF_TEXT_TAKE_FOCUS		((char *) NULL)
+#define DEF_TEXT_UNDO			"0"
+#define DEF_TEXT_WIDTH			"80"
+#define DEF_TEXT_WRAP			"char"
+#define DEF_TEXT_XSCROLL_COMMAND	""
+#define DEF_TEXT_YSCROLL_COMMAND	""
+
+/*
+ * Defaults for canvas text:
+ */
+
+#define DEF_CANVTEXT_FONT		"TkDefaultFont"
+
+/*
+ * Defaults for toplevels (most of the defaults for frames also apply
+ * to toplevels):
+ */
+
+#define DEF_TOPLEVEL_CLASS		"Toplevel"
+#define DEF_TOPLEVEL_MENU		""
+#define DEF_TOPLEVEL_SCREEN		""
+#define DEF_TOPLEVEL_USE		""
+
+/*
+ * Defaults for busy windows (not really used yet):
+ */
+
+#define DEF_BUSY_CURSOR			"watch"
+
+#endif /* _TKMACDEFAULT */
Index: src/tktext/tk8.6/tkMacOSXFont.h
===================================================================
--- src/tktext/tk8.6/tkMacOSXFont.h	(revision 0)
+++ src/tktext/tk8.6/tkMacOSXFont.h	(working copy)
@@ -0,0 +1,32 @@
+/*
+ * tkMacOSXFont.h --
+ *
+ *	Contains the Macintosh implementation of the platform-independant
+ *	font package interface.
+ *
+ * Copyright (c) 1990-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright 2001-2009, Apple Inc.
+ * Copyright (c) 2006-2009 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef TKMACOSXFONT_H
+#define TKMACOSXFONT_H 1
+
+#include "tkFont.h"
+
+#ifndef _TKMACINT
+#include "tkMacOSXInt.h"
+#endif
+
+/*
+ * Function prototypes
+ */
+
+MODULE_SCOPE Tcl_Obj * TkMacOSXFontDescriptionForNSFontAndNSFontAttributes(
+	NSFont *nsFont, NSDictionary *nsAttributes);
+
+#endif /*TKMACOSXFONT_H*/
Index: src/tktext/tk8.6/tkMacOSXInt.h
===================================================================
--- src/tktext/tk8.6/tkMacOSXInt.h	(revision 0)
+++ src/tktext/tk8.6/tkMacOSXInt.h	(working copy)
@@ -0,0 +1,206 @@
+/*
+ * tkMacOSXInt.h --
+ *
+ *	Declarations of Macintosh specific shared variables and procedures.
+ *
+ * Copyright (c) 1995-1997 Sun Microsystems, Inc.
+ * Copyright 2001-2009, Apple Inc.
+ * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKMACINT
+#define _TKMACINT
+
+#ifndef _TKINT
+#include "tkInt.h"
+#endif
+
+/*
+ * Include platform specific public interfaces.
+ */
+
+#ifndef _TKMAC
+#include "tkMacOSX.h"
+#endif
+
+/*
+ * Define compatibility platform types used in the structures below so that
+ * this header can be included without pulling in the platform headers.
+ */
+
+#ifndef _TKMACPRIV
+#   ifndef CGGEOMETRY_H_
+#	ifndef CGFLOAT_DEFINED
+#	    if __LP64__
+#		define CGFloat double
+#	    else
+#		define CGFloat float
+#	    endif
+#	endif
+#	define CGSize struct {CGFloat width; CGFloat height;}
+#   endif
+#   ifndef CGCONTEXT_H_
+#	define CGContextRef void *
+#   endif
+#   ifndef CGCOLOR_H_
+#	define CGColorRef void *
+#   endif
+#   ifndef __HISHAPE__
+#	define HIShapeRef void *
+#   endif
+#   ifndef _APPKITDEFINES_H
+#	define NSView void *
+#   endif
+#endif
+
+struct TkWindowPrivate {
+    TkWindow *winPtr;		/* Ptr to tk window or NULL if Pixmap */
+    NSView *view;
+    CGContextRef context;
+    int xOff;			/* X offset from toplevel window */
+    int yOff;			/* Y offset from toplevel window */
+    CGSize size;
+    HIShapeRef visRgn;		/* Visible region of window */
+    HIShapeRef aboveVisRgn;	/* Visible region of window & its children */
+    HIShapeRef drawRgn;		/* Clipped drawing region */
+    int referenceCount;		/* Don't delete toplevel until children are
+				 * gone. */
+    struct TkWindowPrivate *toplevel;
+				/* Pointer to the toplevel datastruct. */
+    int flags;			/* Various state see defines below. */
+};
+typedef struct TkWindowPrivate MacDrawable;
+
+/*
+ * Defines use for the flags field of the MacDrawable data structure.
+ */
+
+#define TK_SCROLLBAR_GROW	0x01
+#define TK_CLIP_INVALID		0x02
+#define TK_HOST_EXISTS		0x04
+#define TK_DRAWN_UNDER_MENU	0x08
+#define TK_FOCUSED_VIEW		0x10
+#define TK_IS_PIXMAP		0x20
+#define TK_IS_BW_PIXMAP		0x40
+
+/*
+ * I am reserving TK_EMBEDDED = 0x100 in the MacDrawable flags
+ * This is defined in tk.h. We need to duplicate the TK_EMBEDDED flag in the
+ * TkWindow structure for the window, but in the MacWin. This way we can
+ * still tell what the correct port is after the TKWindow structure has been
+ * freed. This actually happens when you bind destroy of a toplevel to
+ * Destroy of a child.
+ */
+
+/*
+ * This structure is for handling Netscape-type in process
+ * embedding where Tk does not control the top-level. It contains
+ * various functions that are needed by Mac specific routines, like
+ * TkMacOSXGetDrawablePort. The definitions of the function types
+ * are in tkMacOSX.h.
+ */
+
+typedef struct {
+    Tk_MacOSXEmbedRegisterWinProc *registerWinProc;
+    Tk_MacOSXEmbedGetGrafPortProc *getPortProc;
+    Tk_MacOSXEmbedMakeContainerExistProc *containerExistProc;
+    Tk_MacOSXEmbedGetClipProc *getClipProc;
+    Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc;
+} TkMacOSXEmbedHandler;
+
+MODULE_SCOPE TkMacOSXEmbedHandler *tkMacOSXEmbedHandler;
+
+/*
+ * GC CGColorRef cache for tkMacOSXColor.c
+ */
+
+typedef struct {
+    unsigned long cachedForeground;
+    CGColorRef cachedForegroundColor;
+    unsigned long cachedBackground;
+    CGColorRef cachedBackgroundColor;
+} TkpGCCache;
+
+MODULE_SCOPE TkpGCCache *TkpGetGCCache(GC gc);
+MODULE_SCOPE void TkpInitGCCache(GC gc);
+MODULE_SCOPE void TkpFreeGCCache(GC gc);
+
+/*
+ * Undef compatibility platform types defined above.
+ */
+
+#ifndef _TKMACPRIV
+#   ifndef CGGEOMETRY_H_
+#	ifndef CGFLOAT_DEFINED
+#	    undef CGFloat
+#	endif
+#	undef CGSize
+#   endif
+#   ifndef CGCONTEXT_H_
+#	undef CGContextRef
+#   endif
+#   ifndef CGCOLOR_H_
+#	undef CGColorRef
+#   endif
+#   ifndef __HISHAPE__
+#	undef HIShapeRef
+#   endif
+#   ifndef _APPKITDEFINES_H
+#	undef NSView
+#   endif
+#endif
+
+/*
+ * Defines used for TkMacOSXInvalidateWindow
+ */
+
+#define TK_WINDOW_ONLY 0
+#define TK_PARENT_WINDOW 1
+
+/*
+ * Accessor for the privatePtr flags field for the TK_HOST_EXISTS field
+ */
+
+#define TkMacOSXHostToplevelExists(tkwin) \
+    (((TkWindow *) (tkwin))->privatePtr->toplevel->flags & TK_HOST_EXISTS)
+
+/*
+ * Defines used for the flags argument to TkGenWMConfigureEvent.
+ */
+
+#define TK_LOCATION_CHANGED	1
+#define TK_SIZE_CHANGED		2
+#define TK_BOTH_CHANGED		3
+#define TK_MACOSX_HANDLE_EVENT_IMMEDIATELY 1024
+
+/*
+ * Defines for tkTextDisp.c
+ */
+
+#define TK_LAYOUT_WITH_BASE_CHUNKS	1
+#define TK_DRAW_IN_CONTEXT		1
+
+/*
+ * Prototypes of internal procs not in the stubs table.
+ */
+
+MODULE_SCOPE void TkMacOSXDefaultStartupScript(void);
+#if 0
+MODULE_SCOPE int XSetClipRectangles(Display *d, GC gc, int clip_x_origin,
+	int clip_y_origin, XRectangle* rectangles, int n, int ordering);
+#endif
+MODULE_SCOPE void TkpClipDrawableToRect(Display *display, Drawable d, int x,
+	int y, int width, int height);
+MODULE_SCOPE void TkpRetainRegion(TkRegion r);
+MODULE_SCOPE void TkpReleaseRegion(TkRegion r);
+
+/*
+ * Include the stubbed internal platform-specific API.
+ */
+
+#include "tkIntPlatDecls.h"
+
+#endif /* _TKMACINT */
Index: src/tktext/tk8.6/tkMacOSXPort.h
===================================================================
--- src/tktext/tk8.6/tkMacOSXPort.h	(revision 0)
+++ src/tktext/tk8.6/tkMacOSXPort.h	(working copy)
@@ -0,0 +1,178 @@
+/*
+ * tkMacOSXPort.h --
+ *
+ *	This file is included by all of the Tk C files. It contains
+ *	information that may be configuration-dependent, such as
+ *	#includes for system include files and a few other things.
+ *
+ * Copyright (c) 1994-1996 Sun Microsystems, Inc.
+ * Copyright 2001-2009, Apple Inc.
+ * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKMACPORT
+#define _TKMACPORT
+
+#include <stdio.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <math.h>
+#include <pwd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/file.h>
+#ifdef HAVE_SYS_SELECT_H
+#   include <sys/select.h>
+#endif
+#include <sys/stat.h>
+#ifndef _TCL
+#   include <tcl.h>
+#endif
+#if TIME_WITH_SYS_TIME
+#   include <sys/time.h>
+#   include <time.h>
+#else
+#   if HAVE_SYS_TIME_H
+#	include <sys/time.h>
+#   else
+#	include <time.h>
+#   endif
+#endif
+#if HAVE_INTTYPES_H
+#    include <inttypes.h>
+#endif
+#include <unistd.h>
+#include <X11/Xlib.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xfuncproto.h>
+#include <X11/Xutil.h>
+#include "tkIntXlibDecls.h"
+
+/*
+ * The following macro defines the type of the mask arguments to
+ * select:
+ */
+
+#ifndef NO_FD_SET
+#   define SELECT_MASK fd_set
+#else
+#   ifndef _AIX
+	typedef long fd_mask;
+#   endif
+#   if defined(_IBMR2)
+#	define SELECT_MASK void
+#   else
+#	define SELECT_MASK int
+#   endif
+#endif
+
+/*
+ * The following macro defines the number of fd_masks in an fd_set:
+ */
+
+#ifndef FD_SETSIZE
+#   ifdef OPEN_MAX
+#	define FD_SETSIZE OPEN_MAX
+#   else
+#	define FD_SETSIZE 256
+#   endif
+#endif
+#if !defined(howmany)
+#   define howmany(x, y) (((x)+((y)-1))/(y))
+#endif
+#ifndef NFDBITS
+#   define NFDBITS NBBY*sizeof(fd_mask)
+#endif
+#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)
+
+/*
+ * Define "NBBY" (number of bits per byte) if it's not already defined.
+ */
+
+#ifndef NBBY
+#   define NBBY 8
+#endif
+
+/*
+ * The following define causes Tk to use its internal keysym hash table
+ */
+
+#define REDO_KEYSYM_LOOKUP
+
+/*
+ * Defines for X functions that are used by Tk but are treated as
+ * no-op functions on the Macintosh.
+ */
+
+#define XFlush(display)
+#define XFree(data) {if ((data) != NULL) ckfree(data);}
+#define XGrabServer(display)
+#define XNoOp(display) {display->request++;}
+#define XUngrabServer(display)
+#define XSynchronize(display, bool) {display->request++;}
+#define XVisualIDFromVisual(visual) (visual->visualid)
+
+/*
+ * The following functions are not used on the Mac, so we stub them out.
+ */
+
+#define TkpCmapStressed(tkwin,colormap) (0)
+#define TkpFreeColor(tkColPtr)
+#define TkSetPixmapColormap(p,c) {}
+#define TkpSync(display)
+
+/*
+ * The following macro returns the pixel value that corresponds to the
+ * RGB values in the given XColor structure.
+ */
+
+#define PIXEL_MAGIC ((unsigned char) 0x69)
+#define TkpGetPixel(p) ((((((PIXEL_MAGIC << 8) \
+	| (((p)->red >> 8) & 0xff)) << 8) \
+	| (((p)->green >> 8) & 0xff)) << 8) \
+	| (((p)->blue >> 8) & 0xff))
+
+/*
+ * This macro stores a representation of the window handle in a string.
+ */
+
+#define TkpPrintWindowId(buf,w) \
+	sprintf((buf), "0x%lx", (unsigned long) (w))
+
+/*
+ * Turn off Tk double-buffering as Aqua windows are already double-buffered.
+ */
+
+#define TK_NO_DOUBLE_BUFFERING 1
+
+/*
+ * Magic pixel code values for system colors.
+ *
+ * NOTE: values must be kept in sync with indices into the
+ *	 systemColorMap array in tkMacOSXColor.c !
+ */
+
+#define TRANSPARENT_PIXEL		30
+#define HIGHLIGHT_PIXEL			31
+#define HIGHLIGHT_SECONDARY_PIXEL	32
+#define HIGHLIGHT_TEXT_PIXEL		33
+#define HIGHLIGHT_ALTERNATE_PIXEL	34
+#define CONTROL_TEXT_PIXEL		35
+#define CONTROL_BODY_PIXEL		37
+#define CONTROL_FRAME_PIXEL		39
+#define WINDOW_BODY_PIXEL		41
+#define MENU_ACTIVE_PIXEL		43
+#define MENU_ACTIVE_TEXT_PIXEL		45
+#define MENU_BACKGROUND_PIXEL		47
+#define MENU_DISABLED_PIXEL		49
+#define MENU_TEXT_PIXEL			51
+#define APPEARANCE_PIXEL		52
+
+#endif /* _TKMACPORT */
Index: src/tktext/tk8.6/tkMacOSXPrivate.h
===================================================================
--- src/tktext/tk8.6/tkMacOSXPrivate.h	(revision 0)
+++ src/tktext/tk8.6/tkMacOSXPrivate.h	(working copy)
@@ -0,0 +1,347 @@
+/*
+ * tkMacOSXPrivate.h --
+ *
+ *	Macros and declarations that are purely internal & private to TkAqua.
+ *
+ * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
+ * Copyright 2008-2009, Apple Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * RCS: @(#) $Id$
+ */
+
+#ifndef _TKMACPRIV
+#define _TKMACPRIV
+
+#if !__OBJC__
+#error Objective-C compiler required
+#endif
+
+#define TextStyle MacTextStyle
+#import <ApplicationServices/ApplicationServices.h>
+#import <Cocoa/Cocoa.h>
+#ifndef NO_CARBON_H
+#import <Carbon/Carbon.h>
+#endif
+#undef TextStyle
+#import <objc/runtime.h> /* for sel_isEqual() */
+
+#ifndef _TKMACINT
+#include "tkMacOSXInt.h"
+#endif
+#ifndef _TKMACDEFAULT
+#include "tkMacOSXDefault.h"
+#endif
+
+/* Macros for Mac OS X API availability checking */
+#define TK_IF_MAC_OS_X_API(vers, symbol, ...) \
+	tk_if_mac_os_x_10_##vers(symbol != NULL, 1, __VA_ARGS__)
+#define TK_ELSE_MAC_OS_X(vers, ...) \
+	tk_else_mac_os_x_10_##vers(__VA_ARGS__)
+#define TK_IF_MAC_OS_X_API_COND(vers, symbol, cond, ...) \
+	tk_if_mac_os_x_10_##vers(symbol != NULL, cond, __VA_ARGS__)
+#define TK_ELSE(...) \
+	} else { __VA_ARGS__
+#define TK_ENDIF \
+	}
+/* Private macros that implement the checking macros above */
+#define tk_if_mac_os_x_yes(chk, cond, ...) \
+	if (cond) { __VA_ARGS__
+#define tk_else_mac_os_x_yes(...) \
+	} else {
+#define tk_if_mac_os_x_chk(chk, cond, ...) \
+	if ((chk) && (cond)) { __VA_ARGS__
+#define tk_else_mac_os_x_chk(...) \
+	} else { __VA_ARGS__
+#define tk_if_mac_os_x_no(chk, cond, ...) \
+	if (0) {
+#define tk_else_mac_os_x_no(...) \
+	} else { __VA_ARGS__
+/* Private mapping macros defined according to Mac OS X version requirements */
+/* 10.5 Leopard */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
+#define tk_if_mac_os_x_min_10_5		tk_if_mac_os_x_yes
+#define tk_else_mac_os_x_min_10_5	tk_else_mac_os_x_yes
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1050
+#define tk_if_mac_os_x_10_5		tk_if_mac_os_x_yes
+#define tk_else_mac_os_x_10_5		tk_else_mac_os_x_yes
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#else /* MAC_OS_X_VERSION_MIN_REQUIRED */
+#define tk_if_mac_os_x_min_10_5		tk_if_mac_os_x_chk
+#define tk_else_mac_os_x_min_10_5	tk_else_mac_os_x_chk
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1050
+#define tk_if_mac_os_x_10_5		tk_if_mac_os_x_chk
+#define tk_else_mac_os_x_10_5		tk_else_mac_os_x_chk
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#endif /* MAC_OS_X_VERSION_MIN_REQUIRED */
+#if MAC_OS_X_VERSION_MAX_ALLOWED < 1050
+#define tk_if_mac_os_x_10_5		tk_if_mac_os_x_no
+#define tk_else_mac_os_x_10_5		tk_else_mac_os_x_no
+#endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+
+/*
+ * Macros for DEBUG_ASSERT_MESSAGE et al from Debugging.h.
+ */
+
+#undef kComponentSignatureString
+#undef COMPONENT_SIGNATURE
+#define kComponentSignatureString "TkMacOSX"
+#define COMPONENT_SIGNATURE 'Tk  '
+
+/*
+ * Macros abstracting checks only active in a debug build.
+ */
+
+#ifdef TK_MAC_DEBUG
+#define TKLog(f, ...) NSLog(f, ##__VA_ARGS__)
+
+/*
+ * Macro to do debug message output.
+ */
+#define TkMacOSXDbgMsg(m, ...) \
+    do { \
+	TKLog(@"%s:%d: %s(): " m, strrchr(__FILE__, '/')+1, \
+		__LINE__, __func__, ##__VA_ARGS__); \
+    } while (0)
+
+/*
+ * Macro to do debug API failure message output.
+ */
+#define TkMacOSXDbgOSErr(f, err) \
+    do { \
+	TkMacOSXDbgMsg("%s failed: %d", #f, (int)(err)); \
+    } while (0)
+
+/*
+ * Macro to do very common check for noErr return from given API and output
+ * debug message in case of failure.
+ */
+#define ChkErr(f, ...) ({ \
+	OSStatus err = f(__VA_ARGS__); \
+	if (err != noErr) { \
+	    TkMacOSXDbgOSErr(f, err); \
+	} \
+	err;})
+
+#else /* TK_MAC_DEBUG */
+#define TKLog(f, ...)
+#define TkMacOSXDbgMsg(m, ...)
+#define TkMacOSXDbgOSErr(f, err)
+#define ChkErr(f, ...) ({f(__VA_ARGS__);})
+#endif /* TK_MAC_DEBUG */
+
+/*
+ * Macro abstracting use of TkMacOSXGetNamedSymbol to init named symbols.
+ */
+
+#define TkMacOSXInitNamedSymbol(module, ret, symbol, ...) \
+    static ret (* symbol)(__VA_ARGS__) = (void*)(-1L); \
+    if (symbol == (void*)(-1L)) { \
+	symbol = TkMacOSXGetNamedSymbol(STRINGIFY(module), \
+		STRINGIFY(symbol)); \
+    }
+
+/*
+ * Structure encapsulating current drawing environment.
+ */
+
+typedef struct TkMacOSXDrawingContext {
+    CGContextRef context;
+    NSView *view;
+    HIShapeRef clipRgn;
+    CGRect portBounds;
+    int focusLocked;
+} TkMacOSXDrawingContext;
+
+/*
+ * Variables internal to TkAqua.
+ */
+
+MODULE_SCOPE CGFloat tkMacOSXZeroScreenHeight;
+MODULE_SCOPE CGFloat tkMacOSXZeroScreenTop;
+MODULE_SCOPE long tkMacOSXMacOSXVersion;
+
+/*
+ * Prototypes for TkMacOSXRegion.c.
+ */
+
+#if 0
+MODULE_SCOPE void	TkMacOSXEmtpyRegion(TkRegion r);
+MODULE_SCOPE int	TkMacOSXIsEmptyRegion(TkRegion r);
+#endif
+MODULE_SCOPE HIShapeRef	TkMacOSXGetNativeRegion(TkRegion r);
+MODULE_SCOPE void	TkMacOSXSetWithNativeRegion(TkRegion r,
+			    HIShapeRef rgn);
+MODULE_SCOPE void	TkMacOSXOffsetRegion(TkRegion r, short dx, short dy);
+MODULE_SCOPE HIShapeRef	TkMacOSXHIShapeCreateEmpty(void);
+MODULE_SCOPE HIMutableShapeRef TkMacOSXHIShapeCreateMutableWithRect(
+			    const CGRect *inRect);
+MODULE_SCOPE OSStatus	TkMacOSXHIShapeSetWithShape(
+			    HIMutableShapeRef inDestShape,
+			    HIShapeRef inSrcShape);
+#if 0
+MODULE_SCOPE OSStatus	TkMacOSXHIShapeSetWithRect(HIMutableShapeRef inShape,
+			    const CGRect *inRect);
+#endif
+MODULE_SCOPE OSStatus	TkMacOSHIShapeDifferenceWithRect(
+			    HIMutableShapeRef inShape, const CGRect *inRect);
+MODULE_SCOPE OSStatus	TkMacOSHIShapeUnionWithRect(HIMutableShapeRef inShape,
+			    const CGRect *inRect);
+MODULE_SCOPE OSStatus	TkMacOSHIShapeUnion(HIShapeRef inShape1,
+			    HIShapeRef inShape2, HIMutableShapeRef outResult);
+
+/*
+ * Prototypes of TkAqua internal procs.
+ */
+
+MODULE_SCOPE void *	TkMacOSXGetNamedSymbol(const char *module,
+			    const char *symbol);
+MODULE_SCOPE void	TkMacOSXDisplayChanged(Display *display);
+MODULE_SCOPE int	TkMacOSXUseAntialiasedText(Tcl_Interp *interp,
+			    int enable);
+MODULE_SCOPE int	TkMacOSXInitCGDrawing(Tcl_Interp *interp, int enable,
+			    int antiAlias);
+MODULE_SCOPE int	TkMacOSXGenerateFocusEvent(TkWindow *winPtr,
+			    int activeFlag);
+MODULE_SCOPE WindowClass TkMacOSXWindowClass(TkWindow *winPtr);
+MODULE_SCOPE int	TkMacOSXIsWindowZoomed(TkWindow *winPtr);
+MODULE_SCOPE int	TkGenerateButtonEventForXPointer(Window window);
+MODULE_SCOPE EventModifiers TkMacOSXModifierState(void);
+MODULE_SCOPE NSBitmapImageRep* BitmapRepFromDrawableRect(Drawable drawable,
+			    int x, int y, unsigned int width, unsigned int height);
+MODULE_SCOPE int	TkMacOSXSetupDrawingContext(Drawable d, GC gc,
+			    int useCG, TkMacOSXDrawingContext *dcPtr);
+MODULE_SCOPE void	TkMacOSXRestoreDrawingContext(
+			    TkMacOSXDrawingContext *dcPtr);
+MODULE_SCOPE void	TkMacOSXSetColorInContext(GC gc, unsigned long pixel,
+			    CGContextRef context);
+MODULE_SCOPE int	TkMacOSXMakeFullscreen(TkWindow *winPtr,
+			    NSWindow *window, int fullscreen,
+			    Tcl_Interp *interp);
+MODULE_SCOPE void	TkMacOSXEnterExitFullscreen(TkWindow *winPtr,
+			    int active);
+MODULE_SCOPE NSWindow*	TkMacOSXDrawableWindow(Drawable drawable);
+MODULE_SCOPE NSView*	TkMacOSXDrawableView(MacDrawable *macWin);
+MODULE_SCOPE void	TkMacOSXWinCGBounds(TkWindow *winPtr, CGRect *bounds);
+MODULE_SCOPE HIShapeRef	TkMacOSXGetClipRgn(Drawable drawable);
+MODULE_SCOPE void	TkMacOSXInvalidateViewRegion(NSView *view,
+			    HIShapeRef rgn);
+MODULE_SCOPE CGImageRef	TkMacOSXCreateCGImageWithDrawable(Drawable drawable);
+MODULE_SCOPE NSImage*	TkMacOSXGetNSImageWithTkImage(Display *display,
+			    Tk_Image image, int width, int height);
+MODULE_SCOPE NSImage*	TkMacOSXGetNSImageWithBitmap(Display *display,
+			    Pixmap bitmap, GC gc, int width, int height);
+MODULE_SCOPE CGColorRef	TkMacOSXCreateCGColor(GC gc, unsigned long pixel);
+MODULE_SCOPE NSColor*	TkMacOSXGetNSColor(GC gc, unsigned long pixel);
+MODULE_SCOPE Tcl_Obj *	TkMacOSXGetStringObjFromCFString(CFStringRef str);
+MODULE_SCOPE TkWindow*	TkMacOSXGetTkWindow(NSWindow *w);
+MODULE_SCOPE NSFont*	TkMacOSXNSFontForFont(Tk_Font tkfont);
+MODULE_SCOPE NSDictionary* TkMacOSXNSFontAttributesForFont(Tk_Font tkfont);
+MODULE_SCOPE NSModalSession TkMacOSXGetModalSession(void);
+MODULE_SCOPE void	TkMacOSXSelDeadWindow(TkWindow *winPtr);
+MODULE_SCOPE void	TkMacOSXApplyWindowAttributes(TkWindow *winPtr,
+			    NSWindow *macWindow);
+MODULE_SCOPE int	TkMacOSXStandardAboutPanelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TkMacOSXIconBitmapObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+
+#pragma mark Private Objective-C Classes
+
+#define VISIBILITY_HIDDEN __attribute__((visibility("hidden")))
+
+enum { tkMainMenu = 1, tkApplicationMenu, tkWindowsMenu, tkHelpMenu};
+
+VISIBILITY_HIDDEN
+@interface TKMenu : NSMenu {
+@private
+    void *_tkMenu;
+    NSUInteger _tkOffset, _tkItemCount, _tkSpecial;
+}
+- (void)setSpecial:(NSUInteger)special;
+- (BOOL)isSpecial:(NSUInteger)special;
+@end
+
+VISIBILITY_HIDDEN
+@interface TKApplication : NSApplication {
+@private
+    Tcl_Interp *_eventInterp;
+    NSMenu *_servicesMenu;
+    TKMenu *_defaultMainMenu, *_defaultApplicationMenu;
+    NSArray *_defaultApplicationMenuItems, *_defaultWindowsMenuItems;
+    NSArray *_defaultHelpMenuItems;
+}
+@end
+@interface TKApplication(TKInit)
+- (NSString *)tkFrameworkImagePath:(NSString*)image;
+@end
+@interface TKApplication(TKEvent)
+- (NSEvent *)tkProcessEvent:(NSEvent *)theEvent;
+@end
+@interface TKApplication(TKMouseEvent)
+- (NSEvent *)tkProcessMouseEvent:(NSEvent *)theEvent;
+@end
+@interface TKApplication(TKKeyEvent)
+- (NSEvent *)tkProcessKeyEvent:(NSEvent *)theEvent;
+@end
+@interface TKApplication(TKMenu)
+- (void)tkSetMainMenu:(TKMenu *)menu;
+@end
+@interface TKApplication(TKClipboard)
+- (void)tkProvidePasteboard:(TkDisplay *)dispPtr;
+- (void)tkCheckPasteboard;
+@end
+
+VISIBILITY_HIDDEN
+@interface TKContentView : NSView <NSTextInput> {
+@private
+  /*Remove private API calls.*/
+   #if 0
+    id _savedSubviews;
+    BOOL _subviewsSetAside;
+    #endif
+    NSString *privateWorkingText;
+}
+@end
+
+@interface TKContentView(TKKeyEvent)
+- (void) deleteWorkingText;
+@end
+
+VISIBILITY_HIDDEN
+@interface TKWindow : NSWindow
+@end
+
+#pragma mark NSMenu & NSMenuItem Utilities
+
+@interface NSMenu(TKUtils)
++ (id)menuWithTitle:(NSString *)title;
++ (id)menuWithTitle:(NSString *)title menuItems:(NSArray *)items;
++ (id)menuWithTitle:(NSString *)title submenus:(NSArray *)submenus;
+- (NSMenuItem *)itemWithSubmenu:(NSMenu *)submenu;
+- (NSMenuItem *)itemInSupermenu;
+@end
+
+@interface NSMenuItem(TKUtils)
++ (id)itemWithSubmenu:(NSMenu *)submenu;
++ (id)itemWithTitle:(NSString *)title submenu:(NSMenu *)submenu;
++ (id)itemWithTitle:(NSString *)title action:(SEL)action;
++ (id)itemWithTitle:(NSString *)title action:(SEL)action
+	target:(id)target;
++ (id)itemWithTitle:(NSString *)title action:(SEL)action
+	keyEquivalent:(NSString *)keyEquivalent;
++ (id)itemWithTitle:(NSString *)title action:(SEL)action
+	target:(id)target keyEquivalent:(NSString *)keyEquivalent;
++ (id)itemWithTitle:(NSString *)title action:(SEL)action
+	keyEquivalent:(NSString *)keyEquivalent
+	keyEquivalentModifierMask:(NSUInteger)keyEquivalentModifierMask;
++ (id)itemWithTitle:(NSString *)title action:(SEL)action
+	target:(id)target keyEquivalent:(NSString *)keyEquivalent
+	keyEquivalentModifierMask:(NSUInteger)keyEquivalentModifierMask;
+@end
+
+#endif /* _TKMACPRIV */
Index: src/tktext/tk8.6/tkPlatDecls.h
===================================================================
--- src/tktext/tk8.6/tkPlatDecls.h	(revision 0)
+++ src/tktext/tk8.6/tkPlatDecls.h	(working copy)
@@ -0,0 +1,174 @@
+/*
+ * tkPlatDecls.h --
+ *
+ *	Declarations of functions in the platform-specific public Tcl API.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKPLATDECLS
+#define _TKPLATDECLS
+
+#ifdef BUILD_tk
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tk.decls script.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
+/* 0 */
+EXTERN Window		Tk_AttachHWND(Tk_Window tkwin, HWND hwnd);
+/* 1 */
+EXTERN HINSTANCE	Tk_GetHINSTANCE(void);
+/* 2 */
+EXTERN HWND		Tk_GetHWND(Window window);
+/* 3 */
+EXTERN Tk_Window	Tk_HWNDToWindow(HWND hwnd);
+/* 4 */
+EXTERN void		Tk_PointerEvent(HWND hwnd, int x, int y);
+/* 5 */
+EXTERN int		Tk_TranslateWinEvent(HWND hwnd, UINT message,
+				WPARAM wParam, LPARAM lParam,
+				LRESULT *result);
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+/* 0 */
+EXTERN void		Tk_MacOSXSetEmbedHandler(
+				Tk_MacOSXEmbedRegisterWinProc *registerWinProcPtr,
+				Tk_MacOSXEmbedGetGrafPortProc *getPortProcPtr,
+				Tk_MacOSXEmbedMakeContainerExistProc *containerExistProcPtr,
+				Tk_MacOSXEmbedGetClipProc *getClipProc,
+				Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc);
+/* 1 */
+EXTERN void		Tk_MacOSXTurnOffMenus(void);
+/* 2 */
+EXTERN void		Tk_MacOSXTkOwnsCursor(int tkOwnsIt);
+/* 3 */
+EXTERN void		TkMacOSXInitMenus(Tcl_Interp *interp);
+/* 4 */
+EXTERN void		TkMacOSXInitAppleEvents(Tcl_Interp *interp);
+/* 5 */
+EXTERN void		TkGenWMConfigureEvent(Tk_Window tkwin, int x, int y,
+				int width, int height, int flags);
+/* 6 */
+EXTERN void		TkMacOSXInvalClipRgns(Tk_Window tkwin);
+/* 7 */
+EXTERN void *		TkMacOSXGetDrawablePort(Drawable drawable);
+/* 8 */
+EXTERN void *		TkMacOSXGetRootControl(Drawable drawable);
+/* 9 */
+EXTERN void		Tk_MacOSXSetupTkNotifier(void);
+/* 10 */
+EXTERN int		Tk_MacOSXIsAppInFront(void);
+#endif /* AQUA */
+
+typedef struct TkPlatStubs {
+    int magic;
+    void *hooks;
+
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
+    Window (*tk_AttachHWND) (Tk_Window tkwin, HWND hwnd); /* 0 */
+    HINSTANCE (*tk_GetHINSTANCE) (void); /* 1 */
+    HWND (*tk_GetHWND) (Window window); /* 2 */
+    Tk_Window (*tk_HWNDToWindow) (HWND hwnd); /* 3 */
+    void (*tk_PointerEvent) (HWND hwnd, int x, int y); /* 4 */
+    int (*tk_TranslateWinEvent) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT *result); /* 5 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*tk_MacOSXSetEmbedHandler) (Tk_MacOSXEmbedRegisterWinProc *registerWinProcPtr, Tk_MacOSXEmbedGetGrafPortProc *getPortProcPtr, Tk_MacOSXEmbedMakeContainerExistProc *containerExistProcPtr, Tk_MacOSXEmbedGetClipProc *getClipProc, Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc); /* 0 */
+    void (*tk_MacOSXTurnOffMenus) (void); /* 1 */
+    void (*tk_MacOSXTkOwnsCursor) (int tkOwnsIt); /* 2 */
+    void (*tkMacOSXInitMenus) (Tcl_Interp *interp); /* 3 */
+    void (*tkMacOSXInitAppleEvents) (Tcl_Interp *interp); /* 4 */
+    void (*tkGenWMConfigureEvent) (Tk_Window tkwin, int x, int y, int width, int height, int flags); /* 5 */
+    void (*tkMacOSXInvalClipRgns) (Tk_Window tkwin); /* 6 */
+    void * (*tkMacOSXGetDrawablePort) (Drawable drawable); /* 7 */
+    void * (*tkMacOSXGetRootControl) (Drawable drawable); /* 8 */
+    void (*tk_MacOSXSetupTkNotifier) (void); /* 9 */
+    int (*tk_MacOSXIsAppInFront) (void); /* 10 */
+#endif /* AQUA */
+} TkPlatStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TkPlatStubs *tkPlatStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TK_STUBS)
+
+/*
+ * Inline function declarations:
+ */
+
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
+#define Tk_AttachHWND \
+	(tkPlatStubsPtr->tk_AttachHWND) /* 0 */
+#define Tk_GetHINSTANCE \
+	(tkPlatStubsPtr->tk_GetHINSTANCE) /* 1 */
+#define Tk_GetHWND \
+	(tkPlatStubsPtr->tk_GetHWND) /* 2 */
+#define Tk_HWNDToWindow \
+	(tkPlatStubsPtr->tk_HWNDToWindow) /* 3 */
+#define Tk_PointerEvent \
+	(tkPlatStubsPtr->tk_PointerEvent) /* 4 */
+#define Tk_TranslateWinEvent \
+	(tkPlatStubsPtr->tk_TranslateWinEvent) /* 5 */
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+#define Tk_MacOSXSetEmbedHandler \
+	(tkPlatStubsPtr->tk_MacOSXSetEmbedHandler) /* 0 */
+#define Tk_MacOSXTurnOffMenus \
+	(tkPlatStubsPtr->tk_MacOSXTurnOffMenus) /* 1 */
+#define Tk_MacOSXTkOwnsCursor \
+	(tkPlatStubsPtr->tk_MacOSXTkOwnsCursor) /* 2 */
+#define TkMacOSXInitMenus \
+	(tkPlatStubsPtr->tkMacOSXInitMenus) /* 3 */
+#define TkMacOSXInitAppleEvents \
+	(tkPlatStubsPtr->tkMacOSXInitAppleEvents) /* 4 */
+#define TkGenWMConfigureEvent \
+	(tkPlatStubsPtr->tkGenWMConfigureEvent) /* 5 */
+#define TkMacOSXInvalClipRgns \
+	(tkPlatStubsPtr->tkMacOSXInvalClipRgns) /* 6 */
+#define TkMacOSXGetDrawablePort \
+	(tkPlatStubsPtr->tkMacOSXGetDrawablePort) /* 7 */
+#define TkMacOSXGetRootControl \
+	(tkPlatStubsPtr->tkMacOSXGetRootControl) /* 8 */
+#define Tk_MacOSXSetupTkNotifier \
+	(tkPlatStubsPtr->tk_MacOSXSetupTkNotifier) /* 9 */
+#define Tk_MacOSXIsAppInFront \
+	(tkPlatStubsPtr->tk_MacOSXIsAppInFront) /* 10 */
+#endif /* AQUA */
+
+#endif /* defined(USE_TK_STUBS) */
+
+/* !END!: Do not edit above this line. */
+
+#ifdef __cplusplus
+}
+#endif
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* _TKPLATDECLS */
Index: src/tktext/tk8.6/tkPort.h
===================================================================
--- src/tktext/tk8.6/tkPort.h	(revision 0)
+++ src/tktext/tk8.6/tkPort.h	(working copy)
@@ -0,0 +1,31 @@
+/*
+ * tkPort.h --
+ *
+ *	This header file handles porting issues that occur because of
+ *	differences between systems.  It reads in platform specific
+ *	portability files.
+ *
+ * Copyright (c) 1995 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKPORT
+#define _TKPORT
+
+#if defined(_WIN32)
+#   include "tkWinPort.h"
+#endif
+#ifndef _TK
+#   include "tk.h"
+#endif
+#if !defined(_WIN32)
+#   if defined(MAC_OSX_TK)
+#	include "tkMacOSXPort.h"
+#   else
+#	include "tkUnixPort.h"
+#   endif
+#endif
+
+#endif /* _TKPORT */
Index: src/tktext/tk8.6/tkUnixDefault.h
===================================================================
--- src/tktext/tk8.6/tkUnixDefault.h	(revision 0)
+++ src/tktext/tk8.6/tkUnixDefault.h	(working copy)
@@ -0,0 +1,531 @@
+/*
+ * tkUnixDefault.h --
+ *
+ *	This file defines the defaults for all options for all of
+ *	the Tk widgets.
+ *
+ * Copyright (c) 1991-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKUNIXDEFAULT
+#define _TKUNIXDEFAULT
+
+/*
+ * The definitions below provide symbolic names for the default colors.
+ * NORMAL_BG -		Normal background color.
+ * ACTIVE_BG -		Background color when widget is active.
+ * SELECT_BG -		Background color for selected text.
+ * TROUGH -		Background color for troughs in scales and scrollbars.
+ * INDICATOR -		Color for indicator when button is selected.
+ * DISABLED -		Foreground color when widget is disabled.
+ */
+
+#define BLACK		"#000000"
+#define WHITE		"#ffffff"
+
+#define NORMAL_BG	"#d9d9d9"
+#define ACTIVE_BG	"#ececec"
+#define SELECT_BG	"#c3c3c3"
+#define TROUGH		"#b3b3b3"
+#define CHECK_INDICATOR	WHITE
+#define MENU_INDICATOR  BLACK
+#define DISABLED	"#a3a3a3"
+
+/*
+ * Defaults for labels, buttons, checkbuttons, and radiobuttons:
+ */
+
+#define DEF_BUTTON_ANCHOR		"center"
+#define DEF_BUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_BUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_BUTTON_ACTIVE_FG_COLOR	BLACK
+#define DEF_CHKRAD_ACTIVE_FG_COLOR	DEF_BUTTON_ACTIVE_FG_COLOR
+#define DEF_BUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_BUTTON_BG_COLOR		NORMAL_BG
+#define DEF_BUTTON_BG_MONO		WHITE
+#define DEF_BUTTON_BITMAP		""
+#define DEF_BUTTON_BORDER_WIDTH		"1"
+#define DEF_BUTTON_CURSOR		""
+#define DEF_BUTTON_COMPOUND		"none"
+#define DEF_BUTTON_COMMAND		""
+#define DEF_BUTTON_DEFAULT		"disabled"
+#define DEF_BUTTON_DISABLED_FG_COLOR	DISABLED
+#define DEF_BUTTON_DISABLED_FG_MONO	""
+#define DEF_BUTTON_FG			BLACK
+#define DEF_CHKRAD_FG			DEF_BUTTON_FG
+#define DEF_BUTTON_FONT			"TkDefaultFont"
+#define DEF_BUTTON_HEIGHT		"0"
+#define DEF_BUTTON_HIGHLIGHT_BG_COLOR	DEF_BUTTON_BG_COLOR
+#define DEF_BUTTON_HIGHLIGHT_BG_MONO	DEF_BUTTON_BG_MONO
+#define DEF_BUTTON_HIGHLIGHT		BLACK
+#define DEF_LABEL_HIGHLIGHT_WIDTH	"0"
+#define DEF_BUTTON_HIGHLIGHT_WIDTH	"1"
+#define DEF_BUTTON_IMAGE		((char *) NULL)
+#define DEF_BUTTON_INDICATOR		"1"
+#define DEF_BUTTON_JUSTIFY		"center"
+#define DEF_BUTTON_OFF_VALUE		"0"
+#define DEF_BUTTON_ON_VALUE		"1"
+#define DEF_BUTTON_TRISTATE_VALUE	""
+#define DEF_BUTTON_OVER_RELIEF		""
+#define DEF_BUTTON_PADX			"3m"
+#define DEF_LABCHKRAD_PADX		"1"
+#define DEF_BUTTON_PADY			"1m"
+#define DEF_LABCHKRAD_PADY		"1"
+#define DEF_BUTTON_RELIEF		"raised"
+#define DEF_LABCHKRAD_RELIEF		"flat"
+#define DEF_BUTTON_REPEAT_DELAY		"0"
+#define DEF_BUTTON_REPEAT_INTERVAL	"0"
+#define DEF_BUTTON_SELECT_COLOR		CHECK_INDICATOR
+#define DEF_BUTTON_SELECT_MONO		BLACK
+#define DEF_BUTTON_SELECT_IMAGE		((char *) NULL)
+#define DEF_BUTTON_STATE		"normal"
+#define DEF_LABEL_TAKE_FOCUS		"0"
+#define DEF_BUTTON_TAKE_FOCUS		((char *) NULL)
+#define DEF_BUTTON_TEXT			""
+#define DEF_BUTTON_TEXT_VARIABLE	""
+#define DEF_BUTTON_UNDERLINE		"-1"
+#define DEF_BUTTON_VALUE		""
+#define DEF_BUTTON_WIDTH		"0"
+#define DEF_BUTTON_WRAP_LENGTH		"0"
+#define DEF_RADIOBUTTON_VARIABLE	"selectedButton"
+#define DEF_CHECKBUTTON_VARIABLE	""
+
+/*
+ * Defaults for canvases:
+ */
+
+#define DEF_CANVAS_BG_COLOR		NORMAL_BG
+#define DEF_CANVAS_BG_MONO		WHITE
+#define DEF_CANVAS_BORDER_WIDTH		"0"
+#define DEF_CANVAS_CLOSE_ENOUGH		"1"
+#define DEF_CANVAS_CONFINE		"1"
+#define DEF_CANVAS_CURSOR		""
+#define DEF_CANVAS_HEIGHT		"7c"
+#define DEF_CANVAS_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_CANVAS_HIGHLIGHT		BLACK
+#define DEF_CANVAS_HIGHLIGHT_WIDTH	"1"
+#define DEF_CANVAS_INSERT_BG		BLACK
+#define DEF_CANVAS_INSERT_BD_COLOR	"0"
+#define DEF_CANVAS_INSERT_BD_MONO	"0"
+#define DEF_CANVAS_INSERT_OFF_TIME	"300"
+#define DEF_CANVAS_INSERT_ON_TIME	"600"
+#define DEF_CANVAS_INSERT_WIDTH		"2"
+#define DEF_CANVAS_RELIEF		"flat"
+#define DEF_CANVAS_SCROLL_REGION	""
+#define DEF_CANVAS_SELECT_COLOR		SELECT_BG
+#define DEF_CANVAS_SELECT_MONO		BLACK
+#define DEF_CANVAS_SELECT_BD_COLOR	"1"
+#define DEF_CANVAS_SELECT_BD_MONO	"0"
+#define DEF_CANVAS_SELECT_FG_COLOR	BLACK
+#define DEF_CANVAS_SELECT_FG_MONO	WHITE
+#define DEF_CANVAS_TAKE_FOCUS		((char *) NULL)
+#define DEF_CANVAS_WIDTH		"10c"
+#define DEF_CANVAS_X_SCROLL_CMD		""
+#define DEF_CANVAS_X_SCROLL_INCREMENT	"0"
+#define DEF_CANVAS_Y_SCROLL_CMD		""
+#define DEF_CANVAS_Y_SCROLL_INCREMENT	"0"
+
+/*
+ * Defaults for entries:
+ */
+
+#define DEF_ENTRY_BG_COLOR		WHITE
+#define DEF_ENTRY_BG_MONO		WHITE
+#define DEF_ENTRY_BORDER_WIDTH		"1"
+#define DEF_ENTRY_CURSOR		"xterm"
+#define DEF_ENTRY_DISABLED_BG_COLOR	NORMAL_BG
+#define DEF_ENTRY_DISABLED_BG_MONO	WHITE
+#define DEF_ENTRY_DISABLED_FG		DISABLED
+#define DEF_ENTRY_EXPORT_SELECTION	"1"
+#define DEF_ENTRY_FONT			"TkTextFont"
+#define DEF_ENTRY_FG			BLACK
+#define DEF_ENTRY_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_ENTRY_HIGHLIGHT		BLACK
+#define DEF_ENTRY_HIGHLIGHT_WIDTH	"1"
+#define DEF_ENTRY_INSERT_BG		BLACK
+#define DEF_ENTRY_INSERT_BD_COLOR	"0"
+#define DEF_ENTRY_INSERT_BD_MONO	"0"
+#define DEF_ENTRY_INSERT_OFF_TIME	"300"
+#define DEF_ENTRY_INSERT_ON_TIME	"600"
+#define DEF_ENTRY_INSERT_WIDTH		"2"
+#define DEF_ENTRY_JUSTIFY		"left"
+#define DEF_ENTRY_READONLY_BG_COLOR	NORMAL_BG
+#define DEF_ENTRY_READONLY_BG_MONO	WHITE
+#define DEF_ENTRY_RELIEF		"sunken"
+#define DEF_ENTRY_SCROLL_COMMAND	""
+#define DEF_ENTRY_SELECT_COLOR		SELECT_BG
+#define DEF_ENTRY_SELECT_MONO		BLACK
+#define DEF_ENTRY_SELECT_BD_COLOR	"0"
+#define DEF_ENTRY_SELECT_BD_MONO	"0"
+#define DEF_ENTRY_SELECT_FG_COLOR	BLACK
+#define DEF_ENTRY_SELECT_FG_MONO	WHITE
+#define DEF_ENTRY_SHOW			((char *) NULL)
+#define DEF_ENTRY_STATE			"normal"
+#define DEF_ENTRY_TAKE_FOCUS		((char *) NULL)
+#define DEF_ENTRY_TEXT_VARIABLE		""
+#define DEF_ENTRY_WIDTH			"20"
+
+/*
+ * Defaults for frames:
+ */
+
+#define DEF_FRAME_BG_COLOR		NORMAL_BG
+#define DEF_FRAME_BG_MONO		WHITE
+#define DEF_FRAME_BORDER_WIDTH		"0"
+#define DEF_FRAME_CLASS			"Frame"
+#define DEF_FRAME_COLORMAP		""
+#define DEF_FRAME_CONTAINER		"0"
+#define DEF_FRAME_CURSOR		""
+#define DEF_FRAME_HEIGHT		"0"
+#define DEF_FRAME_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_FRAME_HIGHLIGHT		BLACK
+#define DEF_FRAME_HIGHLIGHT_WIDTH	"0"
+#define DEF_FRAME_LABEL			""
+#define DEF_FRAME_PADX			"0"
+#define DEF_FRAME_PADY			"0"
+#define DEF_FRAME_RELIEF		"flat"
+#define DEF_FRAME_TAKE_FOCUS		"0"
+#define DEF_FRAME_VISUAL		""
+#define DEF_FRAME_WIDTH			"0"
+
+/*
+ * Defaults for labelframes:
+ */
+
+#define DEF_LABELFRAME_BORDER_WIDTH	"2"
+#define DEF_LABELFRAME_CLASS		"Labelframe"
+#define DEF_LABELFRAME_RELIEF		"groove"
+#define DEF_LABELFRAME_FG		BLACK
+#define DEF_LABELFRAME_FONT		"TkDefaultFont"
+#define DEF_LABELFRAME_TEXT		""
+#define DEF_LABELFRAME_LABELANCHOR	"nw"
+
+/*
+ * Defaults for listboxes:
+ */
+
+#define DEF_LISTBOX_ACTIVE_STYLE	"dotbox"
+#define DEF_LISTBOX_BG_COLOR		WHITE
+#define DEF_LISTBOX_BG_MONO		WHITE
+#define DEF_LISTBOX_BORDER_WIDTH	"1"
+#define DEF_LISTBOX_CURSOR		""
+#define DEF_LISTBOX_DISABLED_FG		DISABLED
+#define DEF_LISTBOX_EXPORT_SELECTION	"1"
+#define DEF_LISTBOX_FONT		"TkDefaultFont"
+#define DEF_LISTBOX_FG			BLACK
+#define DEF_LISTBOX_HEIGHT		"10"
+#define DEF_LISTBOX_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_LISTBOX_HIGHLIGHT		BLACK
+#define DEF_LISTBOX_HIGHLIGHT_WIDTH	"1"
+#define DEF_LISTBOX_RELIEF		"sunken"
+#define DEF_LISTBOX_SCROLL_COMMAND	""
+#define DEF_LISTBOX_LIST_VARIABLE	""
+#define DEF_LISTBOX_SELECT_COLOR	SELECT_BG
+#define DEF_LISTBOX_SELECT_MONO		BLACK
+#define DEF_LISTBOX_SELECT_BD		"0"
+#define DEF_LISTBOX_SELECT_FG_COLOR	BLACK
+#define DEF_LISTBOX_SELECT_FG_MONO	WHITE
+#define DEF_LISTBOX_SELECT_MODE		"browse"
+#define DEF_LISTBOX_SET_GRID		"0"
+#define DEF_LISTBOX_STATE		"normal"
+#define DEF_LISTBOX_TAKE_FOCUS		((char *) NULL)
+#define DEF_LISTBOX_WIDTH		"20"
+
+/*
+ * Defaults for individual entries of menus:
+ */
+
+#define DEF_MENU_ENTRY_ACTIVE_BG	((char *) NULL)
+#define DEF_MENU_ENTRY_ACTIVE_FG	((char *) NULL)
+#define DEF_MENU_ENTRY_ACCELERATOR	((char *) NULL)
+#define DEF_MENU_ENTRY_BG		((char *) NULL)
+#define DEF_MENU_ENTRY_BITMAP		None
+#define DEF_MENU_ENTRY_COLUMN_BREAK	"0"
+#define DEF_MENU_ENTRY_COMMAND		((char *) NULL)
+#define DEF_MENU_ENTRY_COMPOUND 	"none"
+#define DEF_MENU_ENTRY_FG		((char *) NULL)
+#define DEF_MENU_ENTRY_FONT		((char *) NULL)
+#define DEF_MENU_ENTRY_HIDE_MARGIN	"0"
+#define DEF_MENU_ENTRY_IMAGE		((char *) NULL)
+#define DEF_MENU_ENTRY_INDICATOR	"1"
+#define DEF_MENU_ENTRY_LABEL		((char *) NULL)
+#define DEF_MENU_ENTRY_MENU		((char *) NULL)
+#define DEF_MENU_ENTRY_OFF_VALUE	"0"
+#define DEF_MENU_ENTRY_ON_VALUE		"1"
+#define DEF_MENU_ENTRY_SELECT_IMAGE	((char *) NULL)
+#define DEF_MENU_ENTRY_STATE		"normal"
+#define DEF_MENU_ENTRY_VALUE		((char *) NULL)
+#define DEF_MENU_ENTRY_CHECK_VARIABLE	((char *) NULL)
+#define DEF_MENU_ENTRY_RADIO_VARIABLE	"selectedButton"
+#define DEF_MENU_ENTRY_SELECT		((char *) NULL)
+#define DEF_MENU_ENTRY_UNDERLINE	"-1"
+
+/*
+ * Defaults for menus overall:
+ */
+
+#define DEF_MENU_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_MENU_ACTIVE_BG_MONO		BLACK
+#define DEF_MENU_ACTIVE_BORDER_WIDTH	"1"
+#define DEF_MENU_ACTIVE_FG_COLOR	BLACK
+#define DEF_MENU_ACTIVE_FG_MONO		WHITE
+#define DEF_MENU_BG_COLOR		NORMAL_BG
+#define DEF_MENU_BG_MONO		WHITE
+#define DEF_MENU_BORDER_WIDTH		"1"
+#define DEF_MENU_CURSOR			"arrow"
+#define DEF_MENU_DISABLED_FG_COLOR	DISABLED
+#define DEF_MENU_DISABLED_FG_MONO	""
+#define DEF_MENU_FONT			"TkMenuFont"
+#define DEF_MENU_FG			BLACK
+#define DEF_MENU_POST_COMMAND		""
+#define DEF_MENU_RELIEF			"raised"
+#define DEF_MENU_SELECT_COLOR		MENU_INDICATOR
+#define DEF_MENU_SELECT_MONO		BLACK
+#define DEF_MENU_TAKE_FOCUS		"0"
+#define DEF_MENU_TEAROFF		"1"
+#define DEF_MENU_TEAROFF_CMD		((char *) NULL)
+#define DEF_MENU_TITLE			""
+#define DEF_MENU_TYPE			"normal"
+
+/*
+ * Defaults for menubuttons:
+ */
+
+#define DEF_MENUBUTTON_ANCHOR		"center"
+#define DEF_MENUBUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_MENUBUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_MENUBUTTON_ACTIVE_FG_COLOR	BLACK
+#define DEF_MENUBUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_MENUBUTTON_BG_COLOR		NORMAL_BG
+#define DEF_MENUBUTTON_BG_MONO		WHITE
+#define DEF_MENUBUTTON_BITMAP		""
+#define DEF_MENUBUTTON_BORDER_WIDTH	"1"
+#define DEF_MENUBUTTON_CURSOR		""
+#define DEF_MENUBUTTON_DIRECTION	"below"
+#define DEF_MENUBUTTON_DISABLED_FG_COLOR DISABLED
+#define DEF_MENUBUTTON_DISABLED_FG_MONO	""
+#define DEF_MENUBUTTON_FONT		"TkDefaultFont"
+#define DEF_MENUBUTTON_FG		BLACK
+#define DEF_MENUBUTTON_HEIGHT		"0"
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_COLOR DEF_MENUBUTTON_BG_COLOR
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
+#define DEF_MENUBUTTON_HIGHLIGHT	BLACK
+#define DEF_MENUBUTTON_HIGHLIGHT_WIDTH	"0"
+#define DEF_MENUBUTTON_IMAGE		((char *) NULL)
+#define DEF_MENUBUTTON_INDICATOR	"0"
+#define DEF_MENUBUTTON_JUSTIFY		"center"
+#define DEF_MENUBUTTON_MENU		""
+#define DEF_MENUBUTTON_PADX		"4p"
+#define DEF_MENUBUTTON_PADY		"3p"
+#define DEF_MENUBUTTON_RELIEF		"flat"
+#define DEF_MENUBUTTON_STATE		"normal"
+#define DEF_MENUBUTTON_TAKE_FOCUS	"0"
+#define DEF_MENUBUTTON_TEXT		""
+#define DEF_MENUBUTTON_TEXT_VARIABLE	""
+#define DEF_MENUBUTTON_UNDERLINE	"-1"
+#define DEF_MENUBUTTON_WIDTH		"0"
+#define DEF_MENUBUTTON_WRAP_LENGTH	"0"
+
+/*
+ * Defaults for messages:
+ */
+
+#define DEF_MESSAGE_ANCHOR		"center"
+#define DEF_MESSAGE_ASPECT		"150"
+#define DEF_MESSAGE_BG_COLOR		NORMAL_BG
+#define DEF_MESSAGE_BG_MONO		WHITE
+#define DEF_MESSAGE_BORDER_WIDTH	"1"
+#define DEF_MESSAGE_CURSOR		""
+#define DEF_MESSAGE_FG			BLACK
+#define DEF_MESSAGE_FONT		"TkDefaultFont"
+#define DEF_MESSAGE_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_MESSAGE_HIGHLIGHT		BLACK
+#define DEF_MESSAGE_HIGHLIGHT_WIDTH	"0"
+#define DEF_MESSAGE_JUSTIFY		"left"
+#define DEF_MESSAGE_PADX		"-1"
+#define DEF_MESSAGE_PADY		"-1"
+#define DEF_MESSAGE_RELIEF		"flat"
+#define DEF_MESSAGE_TAKE_FOCUS		"0"
+#define DEF_MESSAGE_TEXT		""
+#define DEF_MESSAGE_TEXT_VARIABLE	""
+#define DEF_MESSAGE_WIDTH		"0"
+
+/*
+ * Defaults for panedwindows
+ */
+
+#define DEF_PANEDWINDOW_BG_COLOR	NORMAL_BG
+#define DEF_PANEDWINDOW_BG_MONO		WHITE
+#define DEF_PANEDWINDOW_BORDERWIDTH	"1"
+#define DEF_PANEDWINDOW_CURSOR		""
+#define DEF_PANEDWINDOW_HANDLEPAD	"8"
+#define DEF_PANEDWINDOW_HANDLESIZE	"8"
+#define DEF_PANEDWINDOW_HEIGHT		""
+#define DEF_PANEDWINDOW_OPAQUERESIZE	"1"
+#define DEF_PANEDWINDOW_ORIENT		"horizontal"
+#define DEF_PANEDWINDOW_RELIEF		"flat"
+#define DEF_PANEDWINDOW_SASHCURSOR	""
+#define DEF_PANEDWINDOW_SASHPAD		"0"
+#define DEF_PANEDWINDOW_SASHRELIEF	"flat"
+#define DEF_PANEDWINDOW_SASHWIDTH	"3"
+#define DEF_PANEDWINDOW_SHOWHANDLE	"0"
+#define DEF_PANEDWINDOW_WIDTH		""
+
+/*
+ * Defaults for panedwindow panes
+ */
+
+#define DEF_PANEDWINDOW_PANE_AFTER	""
+#define DEF_PANEDWINDOW_PANE_BEFORE	""
+#define DEF_PANEDWINDOW_PANE_HEIGHT	""
+#define DEF_PANEDWINDOW_PANE_MINSIZE	"0"
+#define DEF_PANEDWINDOW_PANE_PADX	"0"
+#define DEF_PANEDWINDOW_PANE_PADY	"0"
+#define DEF_PANEDWINDOW_PANE_STICKY	"nsew"
+#define DEF_PANEDWINDOW_PANE_WIDTH	""
+#define DEF_PANEDWINDOW_PANE_HIDE	"0"
+#define DEF_PANEDWINDOW_PANE_STRETCH	"last"
+
+/*
+ * Defaults for scales:
+ */
+
+#define DEF_SCALE_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCALE_ACTIVE_BG_MONO	BLACK
+#define DEF_SCALE_BG_COLOR		NORMAL_BG
+#define DEF_SCALE_BG_MONO		WHITE
+#define DEF_SCALE_BIG_INCREMENT		"0"
+#define DEF_SCALE_BORDER_WIDTH		"1"
+#define DEF_SCALE_COMMAND		""
+#define DEF_SCALE_CURSOR		""
+#define DEF_SCALE_DIGITS		"0"
+#define DEF_SCALE_FONT			"TkDefaultFont"
+#define DEF_SCALE_FG_COLOR		BLACK
+#define DEF_SCALE_FG_MONO		BLACK
+#define DEF_SCALE_FROM			"0"
+#define DEF_SCALE_HIGHLIGHT_BG_COLOR	DEF_SCALE_BG_COLOR
+#define DEF_SCALE_HIGHLIGHT_BG_MONO	DEF_SCALE_BG_MONO
+#define DEF_SCALE_HIGHLIGHT		BLACK
+#define DEF_SCALE_HIGHLIGHT_WIDTH	"1"
+#define DEF_SCALE_LABEL			""
+#define DEF_SCALE_LENGTH		"100"
+#define DEF_SCALE_ORIENT		"vertical"
+#define DEF_SCALE_RELIEF		"flat"
+#define DEF_SCALE_REPEAT_DELAY		"300"
+#define DEF_SCALE_REPEAT_INTERVAL	"100"
+#define DEF_SCALE_RESOLUTION		"1"
+#define DEF_SCALE_TROUGH_COLOR		TROUGH
+#define DEF_SCALE_TROUGH_MONO		WHITE
+#define DEF_SCALE_SHOW_VALUE		"1"
+#define DEF_SCALE_SLIDER_LENGTH		"30"
+#define DEF_SCALE_SLIDER_RELIEF		"raised"
+#define DEF_SCALE_STATE			"normal"
+#define DEF_SCALE_TAKE_FOCUS		((char *) NULL)
+#define DEF_SCALE_TICK_INTERVAL		"0"
+#define DEF_SCALE_TO			"100"
+#define DEF_SCALE_VARIABLE		""
+#define DEF_SCALE_WIDTH			"15"
+
+/*
+ * Defaults for scrollbars:
+ */
+
+#define DEF_SCROLLBAR_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCROLLBAR_ACTIVE_BG_MONO	BLACK
+#define DEF_SCROLLBAR_ACTIVE_RELIEF	"raised"
+#define DEF_SCROLLBAR_BG_COLOR		NORMAL_BG
+#define DEF_SCROLLBAR_BG_MONO		WHITE
+#define DEF_SCROLLBAR_BORDER_WIDTH	"1"
+#define DEF_SCROLLBAR_COMMAND		""
+#define DEF_SCROLLBAR_CURSOR		""
+#define DEF_SCROLLBAR_EL_BORDER_WIDTH	"-1"
+#define DEF_SCROLLBAR_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_SCROLLBAR_HIGHLIGHT		BLACK
+#define DEF_SCROLLBAR_HIGHLIGHT_WIDTH	"0"
+#define DEF_SCROLLBAR_JUMP		"0"
+#define DEF_SCROLLBAR_ORIENT		"vertical"
+#define DEF_SCROLLBAR_RELIEF		"sunken"
+#define DEF_SCROLLBAR_REPEAT_DELAY	"300"
+#define DEF_SCROLLBAR_REPEAT_INTERVAL	"100"
+#define DEF_SCROLLBAR_TAKE_FOCUS	((char *) NULL)
+#define DEF_SCROLLBAR_TROUGH_COLOR	TROUGH
+#define DEF_SCROLLBAR_TROUGH_MONO	WHITE
+#define DEF_SCROLLBAR_WIDTH		"11"
+
+/*
+ * Defaults for texts:
+ */
+
+#define DEF_TEXT_AUTO_SEPARATORS	"1"
+#define DEF_TEXT_BG_COLOR		WHITE
+#define DEF_TEXT_BG_MONO		WHITE
+#define DEF_TEXT_BLOCK_CURSOR		"0"
+#define DEF_TEXT_BORDER_WIDTH		"1"
+#define DEF_TEXT_CURSOR			"xterm"
+#define DEF_TEXT_FG			BLACK
+#define DEF_TEXT_EXPORT_SELECTION	"1"
+#define DEF_TEXT_FONT			"TkFixedFont"
+#define DEF_TEXT_HEIGHT			"24"
+#define DEF_TEXT_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_TEXT_HIGHLIGHT		BLACK
+#define DEF_TEXT_HIGHLIGHT_WIDTH	"1"
+#define DEF_TEXT_INSERT_BG		BLACK
+#define DEF_TEXT_INSERT_BD_COLOR	"0"
+#define DEF_TEXT_INSERT_BD_MONO		"0"
+#define DEF_TEXT_INSERT_OFF_TIME	"300"
+#define DEF_TEXT_INSERT_ON_TIME		"600"
+#define DEF_TEXT_INSERT_UNFOCUSSED	"none"
+#define DEF_TEXT_INSERT_WIDTH		"2"
+#define DEF_TEXT_MAX_UNDO		"0"
+#define DEF_TEXT_PADX			"1"
+#define DEF_TEXT_PADY			"1"
+#define DEF_TEXT_RELIEF			"sunken"
+#define DEF_TEXT_INACTIVE_SELECT_COLOR	SELECT_BG
+#define DEF_TEXT_SELECT_COLOR		SELECT_BG
+#define DEF_TEXT_SELECT_MONO		BLACK
+#define DEF_TEXT_SELECT_BD_COLOR	"0"
+#define DEF_TEXT_SELECT_BD_MONO		"0"
+#define DEF_TEXT_SELECT_FG_COLOR	BLACK
+#define DEF_TEXT_SELECT_FG_MONO		WHITE
+#define DEF_TEXT_SELECT_RELIEF		"raised"
+#define DEF_TEXT_SET_GRID		"0"
+#define DEF_TEXT_SPACING1		"0"
+#define DEF_TEXT_SPACING2		"0"
+#define DEF_TEXT_SPACING3		"0"
+#define DEF_TEXT_STATE			"normal"
+#define DEF_TEXT_TABS			""
+#define DEF_TEXT_TABSTYLE		"tabular"
+#define DEF_TEXT_TAKE_FOCUS		((char *) NULL)
+#define DEF_TEXT_UNDO			"0"
+#define DEF_TEXT_WIDTH			"80"
+#define DEF_TEXT_WRAP			"char"
+#define DEF_TEXT_XSCROLL_COMMAND	""
+#define DEF_TEXT_YSCROLL_COMMAND	""
+
+/*
+ * Defaults for canvas text:
+ */
+
+#define DEF_CANVTEXT_FONT		"TkDefaultFont"
+
+/*
+ * Defaults for toplevels (most of the defaults for frames also apply
+ * to toplevels):
+ */
+
+#define DEF_TOPLEVEL_CLASS		"Toplevel"
+#define DEF_TOPLEVEL_MENU		""
+#define DEF_TOPLEVEL_SCREEN		""
+#define DEF_TOPLEVEL_USE		""
+
+/*
+ * Defaults for busy windows:
+ */
+
+#define DEF_BUSY_CURSOR			"watch"
+
+#endif /* _TKUNIXDEFAULT */
Index: src/tktext/tk8.6/tkUnixPort.h
===================================================================
--- src/tktext/tk8.6/tkUnixPort.h	(revision 0)
+++ src/tktext/tk8.6/tkUnixPort.h	(working copy)
@@ -0,0 +1,198 @@
+/*
+ * tkUnixPort.h --
+ *
+ *	This file is included by all of the Tk C files.  It contains
+ *	information that may be configuration-dependent, such as
+ *	#includes for system include files and a few other things.
+ *
+ * Copyright (c) 1991-1993 The Regents of the University of California.
+ * Copyright (c) 1994-1996 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _UNIXPORT
+#define _UNIXPORT
+
+#define __UNIX__ 1
+
+#include <stdio.h>
+#include <ctype.h>
+#include <fcntl.h>
+#ifndef NO_LIMITS_H
+#   include <limits.h>
+#else
+#   include "../compat/limits.h"
+#endif
+#include <math.h>
+#include <pwd.h>
+#ifdef NO_STDLIB_H
+#   include "../compat/stdlib.h"
+#else
+#   include <stdlib.h>
+#endif
+#include <string.h>
+#include <sys/types.h>
+#include <sys/file.h>
+#ifdef HAVE_SYS_SELECT_H
+#   include <sys/select.h>
+#endif
+#include <sys/stat.h>
+#ifndef _TCL
+#   include <tcl.h>
+#endif
+#if TIME_WITH_SYS_TIME
+#   include <sys/time.h>
+#   include <time.h>
+#else
+#   if HAVE_SYS_TIME_H
+#       include <sys/time.h>
+#   else
+#       include <time.h>
+#   endif
+#endif
+#if HAVE_INTTYPES_H
+#    include <inttypes.h>
+#endif
+#ifndef NO_UNISTD_H
+#   include <unistd.h>
+#else
+#   include "../compat/unistd.h"
+#endif
+#include <X11/Xlib.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xproto.h>
+#include <X11/Xresource.h>
+#include <X11/Xutil.h>
+
+/*
+ * The following macro defines the type of the mask arguments to
+ * select:
+ */
+
+#ifndef NO_FD_SET
+#   define SELECT_MASK fd_set
+#else
+#   ifndef _AIX
+	typedef long fd_mask;
+#   endif
+#   if defined(_IBMR2)
+#	define SELECT_MASK void
+#   else
+#	define SELECT_MASK int
+#   endif
+#endif
+
+/*
+ * The following macro defines the number of fd_masks in an fd_set:
+ */
+
+#ifndef FD_SETSIZE
+#   ifdef OPEN_MAX
+#	define FD_SETSIZE OPEN_MAX
+#   else
+#	define FD_SETSIZE 256
+#   endif
+#endif
+#if !defined(howmany)
+#   define howmany(x, y) (((x)+((y)-1))/(y))
+#endif
+#ifndef NFDBITS
+#   define NFDBITS NBBY*sizeof(fd_mask)
+#endif
+#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)
+
+/*
+ * Define "NBBY" (number of bits per byte) if it's not already defined.
+ */
+
+#ifndef NBBY
+#   define NBBY 8
+#endif
+
+#ifdef __CYGWIN__
+#   define UINT unsigned int
+#   define HWND void *
+#   define HDC void *
+#   define HINSTANCE void *
+#   define COLORREF void *
+#   define HMENU void *
+#   define TkWinDCState void
+#   define HPALETTE void *
+#   define WNDPROC void *
+#   define WPARAM void *
+#   define LPARAM void *
+#   define LRESULT void *
+
+EXTERN int TkPutImage (unsigned long *, int, Display *, Drawable, GC,
+	XImage *, int, int, int, int, unsigned int, unsigned int);
+
+#else /* !__CYGWIN__ */
+    /*
+     * The TkPutImage macro strips off the color table information, which isn't
+     * needed for X.
+     */
+
+#   define TkPutImage(colors, ncolors, display, pixels, gc, image, srcx, srcy, destx, desty, width, height) \
+		XPutImage(display, pixels, gc, image, srcx, srcy, destx, \
+		desty, width, height);
+
+#endif /* !__CYGWIN__ */
+
+/*
+ * Supply macros for seek offsets, if they're not already provided by
+ * an include file.
+ */
+
+#ifndef SEEK_SET
+#   define SEEK_SET 0
+#endif
+
+#ifndef SEEK_CUR
+#   define SEEK_CUR 1
+#endif
+
+#ifndef SEEK_END
+#   define SEEK_END 2
+#endif
+
+/*
+ * Declarations for various library procedures that may not be declared
+ * in any other header file.
+ */
+
+
+/*
+ * These functions do nothing under Unix, so we just eliminate calls to them.
+ */
+
+#define TkpButtonSetDefaults() {}
+#define TkpDestroyButton(butPtr) {}
+#define TkSelUpdateClipboard(a,b) {}
+#ifndef __CYGWIN__
+#define TkSetPixmapColormap(p,c) {}
+#endif
+
+/*
+ * These calls implement native bitmaps which are not supported under
+ * UNIX.  The macros eliminate the calls.
+ */
+
+#define TkpDefineNativeBitmaps()
+#define TkpCreateNativeBitmap(display, source) None
+#define TkpGetNativeAppBitmap(display, name, w, h) None
+
+/*
+ * This macro stores a representation of the window handle in a string.
+ * This should perhaps use the real size of an XID.
+ */
+
+#ifndef __CYGWIN__
+#define TkpPrintWindowId(buf,w) \
+	sprintf((buf), "%#08lx", (unsigned long) (w))
+#endif
+
+#endif /* _UNIXPORT */
Index: src/tktext/tk8.6/tkWin.h
===================================================================
--- src/tktext/tk8.6/tkWin.h	(revision 0)
+++ src/tktext/tk8.6/tkWin.h	(working copy)
@@ -0,0 +1,81 @@
+/*
+ * tkWin.h --
+ *
+ *	Declarations of public types and interfaces that are only
+ *	available under Windows.
+ *
+ * Copyright (c) 1996-1997 by Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKWIN
+#define _TKWIN
+
+/*
+ * We must specify the lower version we intend to support. In particular
+ * the SystemParametersInfo API doesn't like to receive structures that
+ * are larger than it expects which affects the font assignments.
+ *
+ * WINVER = 0x0500 means Windows 2000 and above
+ */
+
+#ifndef WINVER
+#define WINVER 0x0500
+#endif
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT 0x0500
+#endif
+
+#ifndef _TK
+#include <tk.h>
+#endif
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#undef WIN32_LEAN_AND_MEAN
+
+/*
+ * The following messages are used to communicate between a Tk toplevel
+ * and its container window. A Tk container may not be able to provide
+ * service to all of the following requests at the moment. But an embedded
+ * Tk window will send out these requests to support external Tk container
+ * application.
+ */
+
+#define TK_CLAIMFOCUS	    (WM_USER)	    /* an embedded window requests to focus */
+#define TK_GEOMETRYREQ	    (WM_USER+1)	    /* an embedded window requests to change size */
+#define TK_ATTACHWINDOW	    (WM_USER+2)	    /* an embedded window requests to attach */
+#define TK_DETACHWINDOW	    (WM_USER+3)	    /* an embedded window requests to detach */
+#define TK_MOVEWINDOW	    (WM_USER+4)	    /* an embedded window requests to move */
+#define TK_RAISEWINDOW	    (WM_USER+5)	    /* an embedded window requests to raise */
+#define TK_ICONIFY	    (WM_USER+6)	    /* an embedded window requests to iconify */
+#define TK_DEICONIFY	    (WM_USER+7)	    /* an embedded window requests to deiconify */
+#define TK_WITHDRAW	    (WM_USER+8)	    /* an embedded window requests to withdraw */
+#define TK_GETFRAMEWID	    (WM_USER+9)	    /* an embedded window requests a frame window id */
+#define TK_OVERRIDEREDIRECT (WM_USER+10)    /* an embedded window requests to overrideredirect */
+#define TK_SETMENU	    (WM_USER+11)    /* an embedded window requests to setup menu */
+#define TK_STATE	    (WM_USER+12)    /* an embedded window sets/gets state */
+#define TK_INFO		    (WM_USER+13)    /* an embedded window requests a container's info */
+
+/*
+ * The following are sub-messages (wParam) for TK_INFO.  An embedded window may
+ * send a TK_INFO message with one of the sub-messages to query a container
+ * for verification and availability
+ */
+#define TK_CONTAINER_VERIFY	    0x01
+#define TK_CONTAINER_ISAVAILABLE    0x02
+
+
+/*
+ *--------------------------------------------------------------
+ *
+ * Exported procedures defined for the Windows platform only.
+ *
+ *--------------------------------------------------------------
+ */
+
+#include "tkPlatDecls.h"
+
+#endif /* _TKWIN */
Index: src/tktext/tk8.6/tkWinDefault.h
===================================================================
--- src/tktext/tk8.6/tkWinDefault.h	(revision 0)
+++ src/tktext/tk8.6/tkWinDefault.h	(working copy)
@@ -0,0 +1,536 @@
+/*
+ * tkWinDefault.h --
+ *
+ *	This file defines the defaults for all options for all of
+ *	the Tk widgets.
+ *
+ * Copyright (c) 1995-1997 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKWINDEFAULT
+#define _TKWINDEFAULT
+
+/*
+ * The definitions below provide symbolic names for the default colors.
+ * NORMAL_BG -		Normal background color.
+ * ACTIVE_BG -		Background color when widget is active.
+ * SELECT_BG -		Background color for selected text.
+ * TROUGH -		Background color for troughs in scales and scrollbars.
+ * INDICATOR -		Color for indicator when button is selected.
+ * DISABLED -		Foreground color when widget is disabled.
+ */
+
+#define BLACK		"Black"
+#define WHITE		"White"
+
+#define NORMAL_BG	"SystemButtonFace"
+#define NORMAL_FG	"SystemButtonText"
+#define ACTIVE_BG	NORMAL_BG
+#define TEXT_FG		"SystemWindowText"
+#define SELECT_BG	"SystemHighlight"
+#define SELECT_FG	"SystemHighlightText"
+#define TROUGH		"SystemScrollbar"
+#define INDICATOR	"SystemWindow"
+#define DISABLED	"SystemDisabledText"
+#define MENU_BG		"SystemMenu"
+#define MENU_FG		"SystemMenuText"
+#define HIGHLIGHT	"SystemWindowFrame"
+
+/*
+ * Defaults for labels, buttons, checkbuttons, and radiobuttons:
+ */
+
+#define DEF_BUTTON_ANCHOR		"center"
+#define DEF_BUTTON_ACTIVE_BG_COLOR	NORMAL_BG
+#define DEF_BUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_BUTTON_ACTIVE_FG_COLOR	NORMAL_FG
+#define DEF_CHKRAD_ACTIVE_FG_COLOR	TEXT_FG
+#define DEF_BUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_BUTTON_BG_COLOR		NORMAL_BG
+#define DEF_BUTTON_BG_MONO		WHITE
+#define DEF_BUTTON_BITMAP		""
+#define DEF_BUTTON_BORDER_WIDTH	"2"
+#define DEF_BUTTON_CURSOR		""
+#define DEF_BUTTON_COMMAND		""
+#define DEF_BUTTON_COMPOUND		"none"
+#define DEF_BUTTON_DEFAULT		"disabled"
+#define DEF_BUTTON_DISABLED_FG_COLOR	DISABLED
+#define DEF_BUTTON_DISABLED_FG_MONO	""
+#define DEF_BUTTON_FG			NORMAL_FG
+#define DEF_CHKRAD_FG			TEXT_FG
+#define DEF_BUTTON_FONT			"TkDefaultFont"
+#define DEF_BUTTON_HEIGHT		"0"
+#define DEF_BUTTON_HIGHLIGHT_BG_COLOR	DEF_BUTTON_BG_COLOR
+#define DEF_BUTTON_HIGHLIGHT_BG_MONO	DEF_BUTTON_BG_MONO
+#define DEF_BUTTON_HIGHLIGHT		HIGHLIGHT
+#define DEF_LABEL_HIGHLIGHT_WIDTH	"0"
+#define DEF_BUTTON_HIGHLIGHT_WIDTH	"1"
+#define DEF_BUTTON_IMAGE		((char *) NULL)
+#define DEF_BUTTON_INDICATOR		"1"
+#define DEF_BUTTON_JUSTIFY		"center"
+#define DEF_BUTTON_OFF_VALUE		"0"
+#define DEF_BUTTON_ON_VALUE		"1"
+#define DEF_BUTTON_OVER_RELIEF		""
+#define DEF_BUTTON_PADX			"1"
+#define DEF_LABCHKRAD_PADX		"1"
+#define DEF_BUTTON_PADY			"1"
+#define DEF_LABCHKRAD_PADY		"1"
+#define DEF_BUTTON_RELIEF		"raised"
+#define DEF_LABCHKRAD_RELIEF		"flat"
+#define DEF_BUTTON_REPEAT_DELAY		"0"
+#define DEF_BUTTON_REPEAT_INTERVAL	"0"
+#define DEF_BUTTON_SELECT_COLOR		INDICATOR
+#define DEF_BUTTON_SELECT_MONO		BLACK
+#define DEF_BUTTON_SELECT_IMAGE		((char *) NULL)
+#define DEF_BUTTON_STATE		"normal"
+#define DEF_LABEL_TAKE_FOCUS		"0"
+#define DEF_BUTTON_TAKE_FOCUS		((char *) NULL)
+#define DEF_BUTTON_TEXT			""
+#define DEF_BUTTON_TEXT_VARIABLE	""
+#define DEF_BUTTON_TRISTATE_VALUE	""
+#define DEF_BUTTON_UNDERLINE		"-1"
+#define DEF_BUTTON_VALUE		""
+#define DEF_BUTTON_WIDTH		"0"
+#define DEF_BUTTON_WRAP_LENGTH		"0"
+#define DEF_RADIOBUTTON_VARIABLE	"selectedButton"
+#define DEF_CHECKBUTTON_VARIABLE	""
+
+/*
+ * Defaults for canvases:
+ */
+
+#define DEF_CANVAS_BG_COLOR		NORMAL_BG
+#define DEF_CANVAS_BG_MONO		WHITE
+#define DEF_CANVAS_BORDER_WIDTH		"0"
+#define DEF_CANVAS_CLOSE_ENOUGH		"1"
+#define DEF_CANVAS_CONFINE		"1"
+#define DEF_CANVAS_CURSOR		""
+#define DEF_CANVAS_HEIGHT		"7c"
+#define DEF_CANVAS_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_CANVAS_HIGHLIGHT		HIGHLIGHT
+#define DEF_CANVAS_HIGHLIGHT_WIDTH	"2"
+#define DEF_CANVAS_INSERT_BG		NORMAL_FG
+#define DEF_CANVAS_INSERT_BD_COLOR	"0"
+#define DEF_CANVAS_INSERT_BD_MONO	"0"
+#define DEF_CANVAS_INSERT_OFF_TIME	"300"
+#define DEF_CANVAS_INSERT_ON_TIME	"600"
+#define DEF_CANVAS_INSERT_WIDTH		"2"
+#define DEF_CANVAS_RELIEF		"flat"
+#define DEF_CANVAS_SCROLL_REGION	""
+#define DEF_CANVAS_SELECT_COLOR		SELECT_BG
+#define DEF_CANVAS_SELECT_MONO		BLACK
+#define DEF_CANVAS_SELECT_BD_COLOR	"1"
+#define DEF_CANVAS_SELECT_BD_MONO	"0"
+#define DEF_CANVAS_SELECT_FG_COLOR	SELECT_FG
+#define DEF_CANVAS_SELECT_FG_MONO	WHITE
+#define DEF_CANVAS_TAKE_FOCUS		((char *) NULL)
+#define DEF_CANVAS_WIDTH		"10c"
+#define DEF_CANVAS_X_SCROLL_CMD		""
+#define DEF_CANVAS_X_SCROLL_INCREMENT	"0"
+#define DEF_CANVAS_Y_SCROLL_CMD		""
+#define DEF_CANVAS_Y_SCROLL_INCREMENT	"0"
+
+/*
+ * Defaults for entries:
+ */
+
+#define DEF_ENTRY_BG_COLOR		"SystemWindow"
+#define DEF_ENTRY_BG_MONO		WHITE
+#define DEF_ENTRY_BORDER_WIDTH		"1"
+#define DEF_ENTRY_CURSOR		"xterm"
+#define DEF_ENTRY_DISABLED_BG_COLOR	"SystemButtonFace"
+#define DEF_ENTRY_DISABLED_BG_MONO	WHITE
+#define DEF_ENTRY_DISABLED_FG		DISABLED
+#define DEF_ENTRY_EXPORT_SELECTION	"1"
+#define DEF_ENTRY_FONT			"TkTextFont"
+#define DEF_ENTRY_FG			TEXT_FG
+#define DEF_ENTRY_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_ENTRY_HIGHLIGHT		HIGHLIGHT
+#define DEF_ENTRY_HIGHLIGHT_WIDTH	"0"
+#define DEF_ENTRY_INSERT_BG		TEXT_FG
+#define DEF_ENTRY_INSERT_BD_COLOR	"0"
+#define DEF_ENTRY_INSERT_BD_MONO	"0"
+#define DEF_ENTRY_INSERT_OFF_TIME	"300"
+#define DEF_ENTRY_INSERT_ON_TIME	"600"
+#define DEF_ENTRY_INSERT_WIDTH		"2"
+#define DEF_ENTRY_JUSTIFY		"left"
+#define DEF_ENTRY_READONLY_BG_COLOR	"SystemButtonFace"
+#define DEF_ENTRY_READONLY_BG_MONO	WHITE
+#define DEF_ENTRY_RELIEF		"sunken"
+#define DEF_ENTRY_SCROLL_COMMAND	""
+#define DEF_ENTRY_SELECT_COLOR		SELECT_BG
+#define DEF_ENTRY_SELECT_MONO		BLACK
+#define DEF_ENTRY_SELECT_BD_COLOR	"0"
+#define DEF_ENTRY_SELECT_BD_MONO	"0"
+#define DEF_ENTRY_SELECT_FG_COLOR	SELECT_FG
+#define DEF_ENTRY_SELECT_FG_MONO	WHITE
+#define DEF_ENTRY_SHOW			((char *) NULL)
+#define DEF_ENTRY_STATE			"normal"
+#define DEF_ENTRY_TAKE_FOCUS		((char *) NULL)
+#define DEF_ENTRY_TEXT_VARIABLE		""
+#define DEF_ENTRY_WIDTH			"20"
+
+/*
+ * Defaults for frames:
+ */
+
+#define DEF_FRAME_BG_COLOR		NORMAL_BG
+#define DEF_FRAME_BG_MONO		WHITE
+#define DEF_FRAME_BORDER_WIDTH		"0"
+#define DEF_FRAME_CLASS			"Frame"
+#define DEF_FRAME_COLORMAP		""
+#define DEF_FRAME_CONTAINER		"0"
+#define DEF_FRAME_CURSOR		""
+#define DEF_FRAME_HEIGHT		"0"
+#define DEF_FRAME_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_FRAME_HIGHLIGHT		HIGHLIGHT
+#define DEF_FRAME_HIGHLIGHT_WIDTH	"0"
+#define DEF_FRAME_PADX			"0"
+#define DEF_FRAME_PADY			"0"
+#define DEF_FRAME_RELIEF		"flat"
+#define DEF_FRAME_TAKE_FOCUS		"0"
+#define DEF_FRAME_VISUAL		""
+#define DEF_FRAME_WIDTH			"0"
+
+/*
+ * Defaults for labelframes:
+ */
+
+#define DEF_LABELFRAME_BORDER_WIDTH	"2"
+#define DEF_LABELFRAME_CLASS		"Labelframe"
+#define DEF_LABELFRAME_RELIEF		"groove"
+#define DEF_LABELFRAME_FG		NORMAL_FG
+#define DEF_LABELFRAME_FONT		"TkDefaultFont"
+#define DEF_LABELFRAME_TEXT		""
+#define DEF_LABELFRAME_LABELANCHOR	"nw"
+
+/*
+ * Defaults for listboxes:
+ */
+
+#define DEF_LISTBOX_ACTIVE_STYLE	"underline"
+#define DEF_LISTBOX_BG_COLOR		"SystemWindow"
+#define DEF_LISTBOX_BG_MONO		WHITE
+#define DEF_LISTBOX_BORDER_WIDTH	"1"
+#define DEF_LISTBOX_CURSOR		""
+#define DEF_LISTBOX_DISABLED_FG		DISABLED
+#define DEF_LISTBOX_EXPORT_SELECTION	"1"
+#define DEF_LISTBOX_FONT		"TkDefaultFont"
+#define DEF_LISTBOX_FG			NORMAL_FG
+#define DEF_LISTBOX_HEIGHT		"10"
+#define DEF_LISTBOX_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_LISTBOX_HIGHLIGHT		HIGHLIGHT
+#define DEF_LISTBOX_HIGHLIGHT_WIDTH	"1"
+#define DEF_LISTBOX_JUSTIFY		"left"
+#define DEF_LISTBOX_RELIEF		"sunken"
+#define DEF_LISTBOX_SCROLL_COMMAND	""
+#define DEF_LISTBOX_LIST_VARIABLE	""
+#define DEF_LISTBOX_SELECT_COLOR	SELECT_BG
+#define DEF_LISTBOX_SELECT_MONO		BLACK
+#define DEF_LISTBOX_SELECT_BD		"0"
+#define DEF_LISTBOX_SELECT_FG_COLOR	SELECT_FG
+#define DEF_LISTBOX_SELECT_FG_MONO	WHITE
+#define DEF_LISTBOX_SELECT_MODE		"browse"
+#define DEF_LISTBOX_SET_GRID		"0"
+#define DEF_LISTBOX_STATE		"normal"
+#define DEF_LISTBOX_TAKE_FOCUS		((char *) NULL)
+#define DEF_LISTBOX_WIDTH		"20"
+
+/*
+ * Defaults for individual entries of menus:
+ */
+
+#define DEF_MENU_ENTRY_ACTIVE_BG	((char *) NULL)
+#define DEF_MENU_ENTRY_ACTIVE_FG	((char *) NULL)
+#define DEF_MENU_ENTRY_ACCELERATOR	((char *) NULL)
+#define DEF_MENU_ENTRY_BG		((char *) NULL)
+#define DEF_MENU_ENTRY_BITMAP		None
+#define DEF_MENU_ENTRY_COLUMN_BREAK	"0"
+#define DEF_MENU_ENTRY_COMMAND		((char *) NULL)
+#define DEF_MENU_ENTRY_COMPOUND 	"none"
+#define DEF_MENU_ENTRY_FG		((char *) NULL)
+#define DEF_MENU_ENTRY_FONT		((char *) NULL)
+#define DEF_MENU_ENTRY_HIDE_MARGIN	"0"
+#define DEF_MENU_ENTRY_IMAGE		((char *) NULL)
+#define DEF_MENU_ENTRY_INDICATOR	"1"
+#define DEF_MENU_ENTRY_LABEL		((char *) NULL)
+#define DEF_MENU_ENTRY_MENU		((char *) NULL)
+#define DEF_MENU_ENTRY_OFF_VALUE	"0"
+#define DEF_MENU_ENTRY_ON_VALUE		"1"
+#define DEF_MENU_ENTRY_SELECT_IMAGE	((char *) NULL)
+#define DEF_MENU_ENTRY_STATE		"normal"
+#define DEF_MENU_ENTRY_VALUE		((char *) NULL)
+#define DEF_MENU_ENTRY_CHECK_VARIABLE	((char *) NULL)
+#define DEF_MENU_ENTRY_RADIO_VARIABLE	"selectedButton"
+#define DEF_MENU_ENTRY_SELECT		((char *) NULL)
+#define DEF_MENU_ENTRY_UNDERLINE	"-1"
+
+/*
+ * Defaults for menus overall:
+ */
+
+#define DEF_MENU_ACTIVE_BG_COLOR	SELECT_BG
+#define DEF_MENU_ACTIVE_BG_MONO		BLACK
+#define DEF_MENU_ACTIVE_BORDER_WIDTH	"0"
+#define DEF_MENU_ACTIVE_FG_COLOR	SELECT_FG
+#define DEF_MENU_ACTIVE_FG_MONO		WHITE
+#define DEF_MENU_BG_COLOR		MENU_BG
+#define DEF_MENU_BG_MONO		WHITE
+#define DEF_MENU_BORDER_WIDTH		"0"
+#define DEF_MENU_CURSOR			"arrow"
+#define DEF_MENU_DISABLED_FG_COLOR	DISABLED
+#define DEF_MENU_DISABLED_FG_MONO	""
+#define DEF_MENU_FONT			"TkMenuFont"
+#define DEF_MENU_FG			MENU_FG
+#define DEF_MENU_POST_COMMAND		""
+#define DEF_MENU_RELIEF			"flat"
+#define DEF_MENU_SELECT_COLOR		MENU_FG
+#define DEF_MENU_SELECT_MONO		BLACK
+#define DEF_MENU_TAKE_FOCUS		"0"
+#define DEF_MENU_TEAROFF		"1"
+#define DEF_MENU_TEAROFF_CMD		((char *) NULL)
+#define DEF_MENU_TITLE			""
+#define DEF_MENU_TYPE			"normal"
+
+/*
+ * Defaults for menubuttons:
+ */
+
+#define DEF_MENUBUTTON_ANCHOR		"center"
+#define DEF_MENUBUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_MENUBUTTON_ACTIVE_BG_MONO	BLACK
+#define DEF_MENUBUTTON_ACTIVE_FG_COLOR	NORMAL_FG
+#define DEF_MENUBUTTON_ACTIVE_FG_MONO	WHITE
+#define DEF_MENUBUTTON_BG_COLOR		NORMAL_BG
+#define DEF_MENUBUTTON_BG_MONO		WHITE
+#define DEF_MENUBUTTON_BITMAP		""
+#define DEF_MENUBUTTON_BORDER_WIDTH	"1"
+#define DEF_MENUBUTTON_CURSOR		""
+#define DEF_MENUBUTTON_DIRECTION	"below"
+#define DEF_MENUBUTTON_DISABLED_FG_COLOR DISABLED
+#define DEF_MENUBUTTON_DISABLED_FG_MONO	""
+#define DEF_MENUBUTTON_FONT		"TkDefaultFont"
+#define DEF_MENUBUTTON_FG		NORMAL_FG
+#define DEF_MENUBUTTON_HEIGHT		"0"
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_COLOR DEF_MENUBUTTON_BG_COLOR
+#define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
+#define DEF_MENUBUTTON_HIGHLIGHT	HIGHLIGHT
+#define DEF_MENUBUTTON_HIGHLIGHT_WIDTH	"0"
+#define DEF_MENUBUTTON_IMAGE		((char *) NULL)
+#define DEF_MENUBUTTON_INDICATOR	"0"
+#define DEF_MENUBUTTON_JUSTIFY		"center"
+#define DEF_MENUBUTTON_MENU		""
+#define DEF_MENUBUTTON_PADX		"4p"
+#define DEF_MENUBUTTON_PADY		"3p"
+#define DEF_MENUBUTTON_RELIEF		"flat"
+#define DEF_MENUBUTTON_STATE		"normal"
+#define DEF_MENUBUTTON_TAKE_FOCUS	"0"
+#define DEF_MENUBUTTON_TEXT		""
+#define DEF_MENUBUTTON_TEXT_VARIABLE	""
+#define DEF_MENUBUTTON_UNDERLINE	"-1"
+#define DEF_MENUBUTTON_WIDTH		"0"
+#define DEF_MENUBUTTON_WRAP_LENGTH	"0"
+
+/*
+ * Defaults for messages:
+ */
+
+#define DEF_MESSAGE_ANCHOR		"center"
+#define DEF_MESSAGE_ASPECT		"150"
+#define DEF_MESSAGE_BG_COLOR		NORMAL_BG
+#define DEF_MESSAGE_BG_MONO		WHITE
+#define DEF_MESSAGE_BORDER_WIDTH	"1"
+#define DEF_MESSAGE_CURSOR		""
+#define DEF_MESSAGE_FG			NORMAL_FG
+#define DEF_MESSAGE_FONT		"TkDefaultFont"
+#define DEF_MESSAGE_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_MESSAGE_HIGHLIGHT		HIGHLIGHT
+#define DEF_MESSAGE_HIGHLIGHT_WIDTH	"0"
+#define DEF_MESSAGE_JUSTIFY		"left"
+#define DEF_MESSAGE_PADX		"-1"
+#define DEF_MESSAGE_PADY		"-1"
+#define DEF_MESSAGE_RELIEF		"flat"
+#define DEF_MESSAGE_TAKE_FOCUS		"0"
+#define DEF_MESSAGE_TEXT		""
+#define DEF_MESSAGE_TEXT_VARIABLE	""
+#define DEF_MESSAGE_WIDTH		"0"
+
+/*
+ * Defaults for panedwindows
+ */
+
+#define DEF_PANEDWINDOW_BG_COLOR	NORMAL_BG
+#define DEF_PANEDWINDOW_BG_MONO		WHITE
+#define DEF_PANEDWINDOW_BORDERWIDTH	"1"
+#define DEF_PANEDWINDOW_CURSOR		""
+#define DEF_PANEDWINDOW_HANDLEPAD	"8"
+#define DEF_PANEDWINDOW_HANDLESIZE	"8"
+#define DEF_PANEDWINDOW_HEIGHT		""
+#define DEF_PANEDWINDOW_OPAQUERESIZE	"1"
+#define DEF_PANEDWINDOW_ORIENT		"horizontal"
+#define DEF_PANEDWINDOW_PROXYBORDER	"2"
+#define DEF_PANEDWINDOW_RELIEF		"flat"
+#define DEF_PANEDWINDOW_SASHCURSOR	""
+#define DEF_PANEDWINDOW_SASHPAD		"0"
+#define DEF_PANEDWINDOW_SASHRELIEF	"flat"
+#define DEF_PANEDWINDOW_SASHWIDTH	"3"
+#define DEF_PANEDWINDOW_SHOWHANDLE	"0"
+#define DEF_PANEDWINDOW_WIDTH		""
+
+/*
+ * Defaults for panedwindow panes
+ */
+
+#define DEF_PANEDWINDOW_PANE_AFTER	""
+#define DEF_PANEDWINDOW_PANE_BEFORE	""
+#define DEF_PANEDWINDOW_PANE_HEIGHT	""
+#define DEF_PANEDWINDOW_PANE_MINSIZE	"0"
+#define DEF_PANEDWINDOW_PANE_PADX	"0"
+#define DEF_PANEDWINDOW_PANE_PADY	"0"
+#define DEF_PANEDWINDOW_PANE_STICKY	"nsew"
+#define DEF_PANEDWINDOW_PANE_WIDTH	""
+#define DEF_PANEDWINDOW_PANE_HIDE	"0"
+#define DEF_PANEDWINDOW_PANE_STRETCH	"last"
+
+/*
+ * Defaults for scales:
+ */
+
+#define DEF_SCALE_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCALE_ACTIVE_BG_MONO	BLACK
+#define DEF_SCALE_BG_COLOR		NORMAL_BG
+#define DEF_SCALE_BG_MONO		WHITE
+#define DEF_SCALE_BIG_INCREMENT		"0"
+#define DEF_SCALE_BORDER_WIDTH		"1"
+#define DEF_SCALE_COMMAND		""
+#define DEF_SCALE_CURSOR		""
+#define DEF_SCALE_DIGITS		"0"
+#define DEF_SCALE_FONT			"TkDefaultFont"
+#define DEF_SCALE_FG_COLOR		NORMAL_FG
+#define DEF_SCALE_FG_MONO		BLACK
+#define DEF_SCALE_FROM			"0"
+#define DEF_SCALE_HIGHLIGHT_BG_COLOR	DEF_SCALE_BG_COLOR
+#define DEF_SCALE_HIGHLIGHT_BG_MONO	DEF_SCALE_BG_MONO
+#define DEF_SCALE_HIGHLIGHT		HIGHLIGHT
+#define DEF_SCALE_HIGHLIGHT_WIDTH	"2"
+#define DEF_SCALE_LABEL			""
+#define DEF_SCALE_LENGTH		"100"
+#define DEF_SCALE_ORIENT		"vertical"
+#define DEF_SCALE_RELIEF		"flat"
+#define DEF_SCALE_REPEAT_DELAY		"300"
+#define DEF_SCALE_REPEAT_INTERVAL	"100"
+#define DEF_SCALE_RESOLUTION		"1"
+#define DEF_SCALE_TROUGH_COLOR		TROUGH
+#define DEF_SCALE_TROUGH_MONO		WHITE
+#define DEF_SCALE_SHOW_VALUE		"1"
+#define DEF_SCALE_SLIDER_LENGTH		"30"
+#define DEF_SCALE_SLIDER_RELIEF		"raised"
+#define DEF_SCALE_STATE			"normal"
+#define DEF_SCALE_TAKE_FOCUS		((char *) NULL)
+#define DEF_SCALE_TICK_INTERVAL		"0"
+#define DEF_SCALE_TO			"100"
+#define DEF_SCALE_VARIABLE		""
+#define DEF_SCALE_WIDTH			"15"
+
+/*
+ * Defaults for scrollbars:
+ */
+
+#define DEF_SCROLLBAR_ACTIVE_BG_COLOR	ACTIVE_BG
+#define DEF_SCROLLBAR_ACTIVE_BG_MONO	BLACK
+#define DEF_SCROLLBAR_ACTIVE_RELIEF	"raised"
+#define DEF_SCROLLBAR_BG_COLOR		NORMAL_BG
+#define DEF_SCROLLBAR_BG_MONO		WHITE
+#define DEF_SCROLLBAR_BORDER_WIDTH	"0"
+#define DEF_SCROLLBAR_COMMAND		""
+#define DEF_SCROLLBAR_CURSOR		""
+#define DEF_SCROLLBAR_EL_BORDER_WIDTH	"-1"
+#define DEF_SCROLLBAR_HIGHLIGHT_BG	NORMAL_BG
+#define DEF_SCROLLBAR_HIGHLIGHT	HIGHLIGHT
+#define DEF_SCROLLBAR_HIGHLIGHT_WIDTH	"0"
+#define DEF_SCROLLBAR_JUMP		"0"
+#define DEF_SCROLLBAR_ORIENT		"vertical"
+#define DEF_SCROLLBAR_RELIEF		"sunken"
+#define DEF_SCROLLBAR_REPEAT_DELAY	"300"
+#define DEF_SCROLLBAR_REPEAT_INTERVAL	"100"
+#define DEF_SCROLLBAR_TAKE_FOCUS	((char *) NULL)
+#define DEF_SCROLLBAR_TROUGH_COLOR	TROUGH
+#define DEF_SCROLLBAR_TROUGH_MONO	WHITE
+#define DEF_SCROLLBAR_WIDTH		"10"
+
+/*
+ * Defaults for texts:
+ */
+
+#define DEF_TEXT_AUTO_SEPARATORS	"1"
+#define DEF_TEXT_BG_COLOR		"SystemWindow"
+#define DEF_TEXT_BG_MONO		WHITE
+#define DEF_TEXT_BLOCK_CURSOR		"0"
+#define DEF_TEXT_BORDER_WIDTH		"1"
+#define DEF_TEXT_CURSOR			"xterm"
+#define DEF_TEXT_FG			TEXT_FG
+#define DEF_TEXT_EXPORT_SELECTION	"1"
+#define DEF_TEXT_FONT			"TkFixedFont"
+#define DEF_TEXT_HEIGHT			"24"
+#define DEF_TEXT_HIGHLIGHT_BG		NORMAL_BG
+#define DEF_TEXT_HIGHLIGHT		HIGHLIGHT
+#define DEF_TEXT_HIGHLIGHT_WIDTH	"0"
+#define DEF_TEXT_INSERT_BG		TEXT_FG
+#define DEF_TEXT_INSERT_BD_COLOR	"0"
+#define DEF_TEXT_INSERT_BD_MONO		"0"
+#define DEF_TEXT_INSERT_OFF_TIME	"300"
+#define DEF_TEXT_INSERT_ON_TIME		"600"
+#define DEF_TEXT_INSERT_UNFOCUSSED	"none"
+#define DEF_TEXT_INSERT_WIDTH		"2"
+#define DEF_TEXT_MAX_UNDO		"0"
+#define DEF_TEXT_PADX			"1"
+#define DEF_TEXT_PADY			"1"
+#define DEF_TEXT_RELIEF			"sunken"
+#define DEF_TEXT_INACTIVE_SELECT_COLOR	NULL
+#define DEF_TEXT_SELECT_COLOR		SELECT_BG
+#define DEF_TEXT_SELECT_MONO		BLACK
+#define DEF_TEXT_SELECT_BD_COLOR	"0"
+#define DEF_TEXT_SELECT_BD_MONO		"0"
+#define DEF_TEXT_SELECT_FG_COLOR	SELECT_FG
+#define DEF_TEXT_SELECT_FG_MONO		WHITE
+#define DEF_TEXT_SELECT_RELIEF		"flat"
+#define DEF_TEXT_SET_GRID		"0"
+#define DEF_TEXT_SPACING1		"0"
+#define DEF_TEXT_SPACING2		"0"
+#define DEF_TEXT_SPACING3		"0"
+#define DEF_TEXT_STATE			"normal"
+#define DEF_TEXT_TABS			""
+#define DEF_TEXT_TABSTYLE		"tabular"
+#define DEF_TEXT_TAKE_FOCUS		((char *) NULL)
+#define DEF_TEXT_UNDO			"0"
+#define DEF_TEXT_WIDTH			"80"
+#define DEF_TEXT_WRAP			"char"
+#define DEF_TEXT_XSCROLL_COMMAND	""
+#define DEF_TEXT_YSCROLL_COMMAND	""
+
+/*
+ * Defaults for canvas text:
+ */
+
+#define DEF_CANVTEXT_FONT		"TkDefaultFont"
+
+/*
+ * Defaults for toplevels (most of the defaults for frames also apply
+ * to toplevels):
+ */
+
+#define DEF_TOPLEVEL_CLASS		"Toplevel"
+#define DEF_TOPLEVEL_MENU		""
+#define DEF_TOPLEVEL_SCREEN		""
+#define DEF_TOPLEVEL_USE		""
+
+/*
+ * Defaults for busy windows:
+ */
+
+#define DEF_BUSY_CURSOR			"wait"
+
+#endif /* _TKWINDEFAULT */
Index: src/tktext/tk8.6/tkWinInt.h
===================================================================
--- src/tktext/tk8.6/tkWinInt.h	(revision 0)
+++ src/tktext/tk8.6/tkWinInt.h	(working copy)
@@ -0,0 +1,250 @@
+/*
+ * tkWinInt.h --
+ *
+ *	This file contains declarations that are shared among the
+ *	Windows-specific parts of Tk, but aren't used by the rest of Tk.
+ *
+ * Copyright (c) 1995-1997 Sun Microsystems, Inc.
+ * Copyright (c) 1998-2000 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKWININT
+#define _TKWININT
+
+#ifndef _TKINT
+#include "tkInt.h"
+#endif
+
+/*
+ * Include platform specific public interfaces.
+ */
+
+#ifndef _TKWIN
+#include "tkWin.h"
+#endif
+
+/*
+ * Define constants missing from older Win32 SDK header files.
+ */
+
+#ifndef WS_EX_TOOLWINDOW
+#define WS_EX_TOOLWINDOW	0x00000080L
+#endif
+#ifndef SPI_SETKEYBOARDCUES
+#define SPI_SETKEYBOARDCUES 0x100B
+#endif
+
+/*
+ * The TkWinDCState is used to save the state of a device context so that it
+ * can be restored later.
+ */
+
+typedef struct TkWinDCState {
+    HPALETTE palette;
+    int bkmode;
+} TkWinDCState;
+
+/*
+ * The TkWinDrawable is the internal implementation of an X Drawable (either a
+ * Window or a Pixmap). The following constants define the valid Drawable
+ * types.
+ */
+
+#define TWD_BITMAP	1
+#define TWD_WINDOW	2
+#define TWD_WINDC	3
+
+typedef struct {
+    int type;
+    HWND handle;
+    TkWindow *winPtr;
+} TkWinWindow;
+
+typedef struct {
+    int type;
+    HBITMAP handle;
+    Colormap colormap;
+    int depth;
+} TkWinBitmap;
+
+typedef struct {
+    int type;
+    HDC hdc;
+}TkWinDC;
+
+typedef union {
+    int type;
+    TkWinWindow window;
+    TkWinBitmap bitmap;
+    TkWinDC winDC;
+} TkWinDrawable;
+
+/*
+ * The following macros are used to retrieve internal values from a Drawable.
+ */
+
+#define TkWinGetHWND(w)		(((TkWinDrawable *) w)->window.handle)
+#define TkWinGetWinPtr(w)	(((TkWinDrawable *) w)->window.winPtr)
+#define TkWinGetHBITMAP(w)	(((TkWinDrawable *) w)->bitmap.handle)
+#define TkWinGetColormap(w)	(((TkWinDrawable *) w)->bitmap.colormap)
+#define TkWinGetHDC(w)		(((TkWinDrawable *) w)->winDC.hdc)
+
+/*
+ * The following structure is used to encapsulate palette information.
+ */
+
+typedef struct {
+    HPALETTE palette;		/* Palette handle used when drawing. */
+    UINT size;			/* Number of entries in the palette. */
+    int stale;			/* 1 if palette needs to be realized,
+				 * otherwise 0. If the palette is stale, then
+				 * an idle handler is scheduled to realize the
+				 * palette. */
+    Tcl_HashTable refCounts;	/* Hash table of palette entry reference
+				 * counts indexed by pixel value. */
+} TkWinColormap;
+
+/*
+ * The following macro retrieves the Win32 palette from a colormap.
+ */
+
+#define TkWinGetPalette(colormap) (((TkWinColormap *) colormap)->palette)
+
+/*
+ * The following macros define the class names for Tk Window types.
+ */
+
+#define TK_WIN_TOPLEVEL_CLASS_NAME TEXT("TkTopLevel")
+#define TK_WIN_CHILD_CLASS_NAME TEXT("TkChild")
+
+/*
+ * The following variable is a translation table between X gc functions and
+ * Win32 raster and BitBlt op modes.
+ */
+
+MODULE_SCOPE const int tkpWinRopModes[];
+MODULE_SCOPE const int tkpWinBltModes[];
+
+/*
+ * The following defines are used with TkWinGetBorderPixels to get the extra 2
+ * border colors from a Tk_3DBorder.
+ */
+
+#define TK_3D_LIGHT2 TK_3D_DARK_GC+1
+#define TK_3D_DARK2 TK_3D_DARK_GC+2
+
+/*
+ * Internal functions used by more than one source file.
+ */
+
+#include "tkIntPlatDecls.h"
+
+/*
+ * Special proc needed as tsd accessor function between
+ * tkWinX.c:GenerateXEvent and tkWinClipboard.c:UpdateClipboard
+ */
+
+MODULE_SCOPE void TkWinUpdatingClipboard(int mode);
+
+/*
+ * Used by tkWinDialog.c to associate the right icon with tk_messageBox
+ */
+
+MODULE_SCOPE HICON TkWinGetIcon(Tk_Window tkw, DWORD iconsize);
+
+/*
+ * Used by tkWinX.c on for certain system display change messages and cleanup
+ * up containers
+ */
+
+MODULE_SCOPE void TkWinDisplayChanged(Display *display);
+MODULE_SCOPE void TkWinCleanupContainerList(void);
+
+/*
+ * Used by tkWinWm.c for embedded menu handling. May become public.
+ */
+
+MODULE_SCOPE HWND Tk_GetMenuHWND(Tk_Window tkwin);
+MODULE_SCOPE HWND Tk_GetEmbeddedMenuHWND(Tk_Window tkwin);
+
+/*
+ * The following allows us to cache these encoding for multiple functions.
+ */
+
+
+MODULE_SCOPE Tcl_Encoding	TkWinGetKeyInputEncoding(void);
+MODULE_SCOPE Tcl_Encoding	TkWinGetUnicodeEncoding(void);
+MODULE_SCOPE void		TkWinSetupSystemFonts(TkMainInfo *mainPtr);
+
+/*
+ * Values returned by TkWinGetPlatformTheme.
+ */
+
+#define TK_THEME_WIN_CLASSIC    1
+#define TK_THEME_WIN_XP         2
+
+/*
+ * The following is implemented in tkWinWm and used by tkWinEmbed.c
+ */
+
+MODULE_SCOPE void		TkpWinToplevelWithDraw(TkWindow *winPtr);
+MODULE_SCOPE void		TkpWinToplevelIconify(TkWindow *winPtr);
+MODULE_SCOPE void		TkpWinToplevelDeiconify(TkWindow *winPtr);
+MODULE_SCOPE long		TkpWinToplevelIsControlledByWm(TkWindow *winPtr);
+MODULE_SCOPE long		TkpWinToplevelMove(TkWindow *winPtr, int x, int y);
+MODULE_SCOPE long		TkpWinToplevelOverrideRedirect(TkWindow *winPtr,
+			    int reqValue);
+MODULE_SCOPE void		TkpWinToplevelDetachWindow(TkWindow *winPtr);
+MODULE_SCOPE int		TkpWmGetState(TkWindow *winPtr);
+
+/*
+ * The following functions are not present in old versions of Windows
+ * API headers but are used in the Tk source to ensure 64bit 
+ * compatability.
+ */
+
+#ifndef GetClassLongPtr
+#   define GetClassLongPtrA	GetClassLongA
+#   define GetClassLongPtrW	GetClassLongW
+#   define SetClassLongPtrA	SetClassLongA
+#   define SetClassLongPtrW	SetClassLongW
+#   ifdef UNICODE
+#	define GetClassLongPtr	GetClassLongPtrW
+#	define SetClassLongPtr	SetClassLongPtrW
+#   else
+#	define GetClassLongPtr	GetClassLongPtrA
+#	define SetClassLongPtr	SetClassLongPtrA
+#   endif /* !UNICODE */
+#endif /* !GetClassLongPtr */
+#ifndef GCLP_HICON
+#   define GCLP_HICON		GCL_HICON
+#endif /* !GCLP_HICON */
+#ifndef GCLP_HICONSM
+#   define GCLP_HICONSM		(-34)
+#endif /* !GCLP_HICONSM */
+
+#ifndef GetWindowLongPtr
+#   define GetWindowLongPtrA	GetWindowLongA
+#   define GetWindowLongPtrW	GetWindowLongW
+#   define SetWindowLongPtrA	SetWindowLongA
+#   define SetWindowLongPtrW	SetWindowLongW
+#   ifdef UNICODE
+#	define GetWindowLongPtr	GetWindowLongPtrW
+#	define SetWindowLongPtr	SetWindowLongPtrW
+#   else
+#	define GetWindowLongPtr	GetWindowLongPtrW
+#	define SetWindowLongPtr	SetWindowLongPtrW
+#   endif /* !UNICODE */
+#endif /* !GetWindowLongPtr */
+#ifndef GWLP_WNDPROC
+#define GWLP_WNDPROC		GWL_WNDPROC
+#define GWLP_HINSTANCE		GWL_HINSTANCE
+#define GWLP_HWNDPARENT		GWL_HWNDPARENT
+#define GWLP_USERDATA		GWL_USERDATA
+#define GWLP_ID			GWL_ID
+#endif /* !GWLP_WNDPROC */
+
+#endif /* _TKWININT */
Index: src/tktext/tk8.6/tkWinPort.h
===================================================================
--- src/tktext/tk8.6/tkWinPort.h	(revision 0)
+++ src/tktext/tk8.6/tkWinPort.h	(working copy)
@@ -0,0 +1,123 @@
+/*
+ * tkWinPort.h --
+ *
+ *	This header file handles porting issues that occur because of
+ *	differences between Windows and Unix. It should be the only
+ *	file that contains #ifdefs to handle different flavors of OS.
+ *
+ * Copyright (c) 1995-1996 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _WINPORT
+#define _WINPORT
+
+/*
+ *---------------------------------------------------------------------------
+ * The following sets of #includes and #ifdefs are required to get Tcl to
+ * compile under the windows compilers.
+ *---------------------------------------------------------------------------
+ */
+
+#include <wchar.h>
+#include <io.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <malloc.h>
+#include <ctype.h>
+#include <math.h>
+#include <string.h>
+#include <limits.h>
+
+/*
+ * Need to block out this include for building extensions with MetroWerks
+ * compiler for Win32.
+ */
+
+#ifndef __MWERKS__
+#include <sys/stat.h>
+#endif
+
+#include <time.h>
+
+#ifdef _MSC_VER
+#   ifndef hypot
+#	define hypot _hypot
+#   endif
+#endif /* _MSC_VER */
+
+/*
+ *  Pull in the typedef of TCHAR for windows.
+ */
+#include <tchar.h>
+#ifndef _TCHAR_DEFINED
+    /* Borland seems to forget to set this. */
+    typedef _TCHAR TCHAR;
+#   define _TCHAR_DEFINED
+#endif
+#if defined(_MSC_VER) && defined(__STDC__)
+    /* VS2005 SP1 misses this. See [Bug #3110161] */
+    typedef _TCHAR TCHAR;
+#endif
+
+#include <X11/Xlib.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xutil.h>
+
+#ifndef __GNUC__
+#    define strncasecmp _strnicmp
+#    define strcasecmp _stricmp
+#endif
+
+#define NBBY 8
+
+#ifndef OPEN_MAX
+#define OPEN_MAX 32
+#endif
+
+/*
+ * The following define causes Tk to use its internal keysym hash table
+ */
+
+#define REDO_KEYSYM_LOOKUP
+
+/*
+ * See ticket [916c1095438eae56]: GetVersionExW triggers warnings
+ */
+#if defined(_MSC_VER)
+#   pragma warning(disable:4996)
+#endif
+
+/*
+ * The following macro checks to see whether there is buffered
+ * input data available for a stdio FILE.
+ */
+
+#ifdef _MSC_VER
+#    define TK_READ_DATA_PENDING(f) ((f)->_cnt > 0)
+#else /* _MSC_VER */
+#    define TK_READ_DATA_PENDING(f) ((f)->level > 0)
+#endif /* _MSC_VER */
+
+/*
+ * The following Tk functions are implemented as macros under Windows.
+ */
+
+#define TkpGetPixel(p) (((((p)->red >> 8) & 0xff) \
+	| ((p)->green & 0xff00) | (((p)->blue << 8) & 0xff0000)) | 0x20000000)
+
+/*
+ * These calls implement native bitmaps which are not currently
+ * supported under Windows.  The macros eliminate the calls.
+ */
+
+#define TkpDefineNativeBitmaps()
+#define TkpCreateNativeBitmap(display, source) None
+#define TkpGetNativeAppBitmap(display, name, w, h) None
+
+#endif /* _WINPORT */
Index: src/tktext/tkBitField.c
===================================================================
--- src/tktext/tkBitField.c	(revision 0)
+++ src/tktext/tkBitField.c	(working copy)
@@ -0,0 +1,1536 @@
+/*
+ * tkBitField.c --
+ *
+ *	This module implements bit field operations.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkBitField.h"
+#include "tkIntSet.h"
+#include "tkAlloc.h"
+#include <string.h>
+#include <assert.h>
+
+#if !(__STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900))
+# define _TK_NEED_IMPLEMENTATION
+# include "tkBitFieldPriv.h"
+#endif
+
+#ifndef MAX
+# define MAX(a,b) (((int) a) < ((int) b) ? b : a)
+#endif
+#ifndef MIN
+# define MIN(a,b) (((int) a) < ((int) b) ? a : b)
+#endif
+
+#if TK_CHECK_ALLOCS
+# define DEBUG_ALLOC(expr) expr
+#else
+# define DEBUG_ALLOC(expr)
+#endif
+
+
+#define NBITS		TK_BIT_NBITS
+#define NWORDS(size)	TK_BIT_COUNT_WORDS(size)
+#define BIT_INDEX(n)	TK_BIT_INDEX(n)
+#define WORD_INDEX(n)	TK_BIT_WORD_INDEX(n)
+
+#define NBYTES(words)	((words)*sizeof(TkBitWord))
+#define BYTE_SIZE(size)	NBYTES(NWORDS(size))
+#define BF_SIZE(size)	((unsigned) (Tk_Offset(TkBitField, bits) + BYTE_SIZE(size)))
+#define BIT_SPAN(f,t)	((~((TkBitWord) 0) << (f)) & (~((TkBitWord) 0) >> ((NBITS - 1) - (t))))
+
+
+DEBUG_ALLOC(unsigned tkBitCountNew = 0);
+DEBUG_ALLOC(unsigned tkBitCountDestroy = 0);
+
+
+#ifdef TCL_WIDE_INT_IS_LONG
+
+/* ****************************************************************************/
+/*                 64 bit implementation                                      */
+/* ****************************************************************************/
+
+# if defined(__GNUC__) || defined(__clang__)
+
+#  define LsbIndex(x) __builtin_ctzll(x)
+#  define MsbIndex(x) ((sizeof(unsigned long long)*8 - 1) - __builtin_clzll(x))
+
+# else /* !(defined(__GNUC__) || defined(__clang__)) */
+
+static unsigned
+LsbIndex(uint64_t x)
+{
+    /* Source: http://chessprogramming.wikispaces.com/BitScan */
+    static const unsigned MultiplyDeBruijnBitPosition[64] = {
+	 0,  1, 48,  2, 57, 49, 28,  3, 61, 58, 50, 42, 38, 29, 17,  4,
+	62, 55, 59, 36, 53, 51, 43, 22, 45, 39, 33, 30, 24, 18, 12,  5,
+	63, 47, 56, 27, 60, 41, 37, 16, 54, 35, 52, 21, 44, 32, 23, 11,
+	46, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19,  9, 13,  8,  7,  6
+    };
+    return MultiplyDeBruijnBitPosition[((uint64_t) ((x & -x)*UINT64_C(0x03f79d71b4cb0a89))) >> 58];
+}
+
+static unsigned
+MsbIndex(uint64_t x)
+{
+    /* Source: http://stackoverflow.com/questions/671815/what-is-the-fastest-most-efficient-way-to-find-the-highest-set-bit-msb-in-an-i (extended to 64 bit by GC) */
+   static const uint8_t Table[16] = { -1, 0, 1,1, 2,2,2,2, 3,3,3,3,3,3,3,3 };
+
+   unsigned r = 0;
+   uint64_t xk;
+
+   if ((xk = x >> 32)) { r =  32; x = xk; }
+   if ((xk = x >> 16)) { r += 16; x = xk; }
+   if ((xk = x >>  8)) { r +=  8; x = xk; }
+   if ((xk = x >>  4)) { r +=  4; x = xk; }
+
+   return r + Table[x];
+}
+
+# endif /* defined(__GNUC__) || defined(__clang__) */
+
+static unsigned
+PopCount(uint64_t x)
+{
+    /* Source: http://chessprogramming.wikispaces.com/Population+Count */
+    x -=  (x >> 1) & UINT64_C(0x5555555555555555);
+    x  = ((x >> 2) & UINT64_C(0x3333333333333333)) + (x & UINT64_C(0x3333333333333333));
+    x  = ((x >> 4) + x) & UINT64_C(0x0F0F0F0F0F0F0F0F);
+    return (x * UINT64_C(0x0101010101010101)) >> 56;
+}
+
+#else /* TCL_WIDE_INT_IS_LONG */
+
+/* ****************************************************************************/
+/*                 32 bit implementation                                      */
+/* ****************************************************************************/
+
+# if defined(__GNUC__) || defined(__clang__)
+
+#  define LsbIndex(x) __builtin_ctz(x)
+#  define MsbIndex(x) ((sizeof(unsigned)*8 - 1) - __builtin_clz(x))
+
+# else /* defined(__GNUC__) || defined(__clang__) */
+
+#  if 1
+/* On my system this is the fastest method, only about 5% slower than __builtin_ctz(). */
+static unsigned
+LsbIndex(uint32_t x)
+{
+    /* Source: http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightLinear */
+    static const unsigned MultiplyDeBruijnBitPosition[32] = {
+	 0,  1, 28,  2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17,  4, 8,
+	31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18,  6, 11,  5, 10, 9
+    };
+    return MultiplyDeBruijnBitPosition[((uint32_t) ((x & -x)*0x077cb531)) >> 27];
+}
+#  else
+/* The "classical" method, but about 20% slower than the DeBruijn method on my system. */
+static unsigned
+LsbIndex(uint32_t x)
+{
+    unsigned ctz = 32;
+    x &= -((int32_t ) x);
+    if (x) --ctz;
+    if (x & 0x0000ffff) ctz -= 16;
+    if (x & 0x00ff00ff) ctz -= 8;
+    if (x & 0x0f0f0f0f) ctz -= 4;
+    if (x & 0x33333333) ctz -= 2;
+    if (x & 0x55555555) ctz -= 1;
+    return ctz;
+}
+#  endif
+
+static unsigned
+MsbIndex(uint32_t x)
+{
+    /* Source: http://stackoverflow.com/questions/671815/what-is-the-fastest-most-efficient-way-to-find-the-highest-set-bit-msb-in-an-i */
+   static const uint8_t Table[16] = { -1 ,0, 1,1, 2,2,2,2, 3,3,3,3,3,3,3,3 };
+
+   unsigned r = 0;
+   uint32_t xk;
+
+   if ((xk = x >> 16)) { r = 16; x = xk; }
+   if ((xk = x >>  8)) { r += 8; x = xk; }
+   if ((xk = x >>  4)) { r += 4; x = xk; }
+
+   return r + Table[x];
+}
+
+# endif /* defined(__GNUC__) || defined(__clang__) */
+
+static unsigned
+PopCount(uint32_t x)
+{
+    /* Source: http://graphics.stanford.edu/~seander/bithacks.html */
+    /* NOTE: the GCC function __builtin_popcount() is slower on my system. */
+    x -=  (x >> 1) & 0x55555555;
+    x  = ((x >> 2) & 0x33333333) + (x & 0x33333333);
+    x  = ((x >> 4) + x) & 0x0f0f0f0f;
+    return (x*0x01010101) >> 24;
+}
+
+#endif /* !TCL_WIDE_INT_IS_LONG */
+
+
+#if TK_CHECK_ALLOCS
+/*
+ * Some useful functions for finding memory leaks.
+ */
+
+static TkBitField *Used = NULL;
+static TkBitField *Last = NULL;
+
+
+static void
+Use(
+    TkBitField *bf)
+{
+    static int N = 0;
+    if (!Used) { Used = bf; }
+    if (Last) { Last->next = bf; }
+    bf->number = N++;
+    bf->next = NULL;
+    bf->prev = Last;
+    Last = bf;
+}
+
+
+static void
+Free(
+    TkBitField *bf)
+{
+    assert(bf->prev || Used == bf);
+    assert(bf->next || Last == bf);
+    if (Last == bf) { Last = bf->prev; }
+    if (Used == bf) { Used = bf->next; }
+    if (bf->prev) { bf->prev->next = bf->next; }
+    if (bf->next) { bf->next->prev = bf->prev; }
+    bf->prev = NULL;
+    bf->next = NULL;
+}
+
+
+void
+TkBitCheckAllocs()
+{
+    for ( ; Used; Used = Used->next) {
+	printf("TkBitField(number): %d\n", Used->number);
+    }
+}
+
+#endif /* TK_CHECK_ALLOCS */
+
+
+static bool
+IsEqual(
+    const TkBitWord *s,
+    const TkBitWord *t,
+    unsigned numBytes)
+{
+    const TkBitWord *e = s + numBytes;
+
+    for ( ; s < e; ++s, ++t) {
+	if (*s != *t) {
+	    return false;
+	}
+    }
+    return true;
+}
+
+
+static void
+ResetUnused(
+    TkBitField *bf)
+{
+    unsigned bitIndex = BIT_INDEX(bf->size);
+
+    if (bitIndex) {
+	bf->bits[NWORDS(bf->size) - 1] &= ~BIT_SPAN(bitIndex, NBITS - 1);
+    }
+}
+
+
+void
+TkBitDestroy(
+    TkBitField **bfPtr)
+{
+    assert(bfPtr);
+
+    if (*bfPtr) {
+	DEBUG_ALLOC(Free(*bfPtr));
+	free(*bfPtr);
+	*bfPtr = NULL;
+	DEBUG_ALLOC(tkBitCountDestroy++);
+    }
+}
+
+
+TkBitField *
+TkBitResize(
+    TkBitField *bf,
+    unsigned newSize)
+{
+    if (!bf) {
+	bf = malloc(BF_SIZE(newSize));
+	DEBUG_ALLOC(Use(bf));
+	bf->size = newSize;
+	bf->refCount = 1;
+	bf->isSetFlag = false;
+	memset(bf->bits, 0, BYTE_SIZE(newSize));
+	DEBUG_ALLOC(tkBitCountNew++);
+    } else {
+	unsigned newWords;
+	unsigned oldWords;
+
+	newWords = NWORDS(newSize);
+	oldWords = NWORDS(bf->size);
+
+	if (newWords == oldWords) {
+	    bf->size = newSize;
+	    ResetUnused(bf);
+	    return bf;
+	}
+
+	if (bf->refCount <= 1) {
+	    DEBUG_ALLOC(Free(bf));
+	    bf = realloc((char *) bf, BF_SIZE(newSize));
+	    DEBUG_ALLOC(Use(bf));
+	} else {
+	    TkBitField *newBF = malloc(BF_SIZE(newSize));
+	    DEBUG_ALLOC(Use(newBF));
+	    memcpy(newBF->bits, bf->bits, NBYTES(MIN(oldWords, newWords)));
+	    newBF->refCount = 1;
+	    newBF->isSetFlag = false;
+	    bf->refCount -= 1;
+	    bf = newBF;
+	    DEBUG_ALLOC(tkBitCountNew++);
+	}
+
+	bf->size = newSize;
+
+	if (oldWords < newWords) {
+	    memset(bf->bits + oldWords, 0, NBYTES(newWords - oldWords));
+	} else {
+	    ResetUnused(bf);
+	}
+    }
+
+    return bf;
+}
+
+
+TkBitField *
+TkBitFromSet(
+    const TkIntSet *set,
+    unsigned size)
+{
+    unsigned numEntries = TkIntSetSize(set);
+    TkBitField *bf = TkBitResize(NULL, size);
+    unsigned i;
+
+    for (i = 0; i < numEntries; ++i) {
+	TkIntSetType value = TkIntSetAccess(set, i);
+
+	if (value >= size) {
+	    break;
+	}
+	TkBitSet(bf, value);
+    }
+
+    return bf;
+}
+
+
+unsigned
+TkBitCount(
+    const TkBitField *bf)
+{
+    unsigned words, i;
+    unsigned count = 0;
+
+    assert(bf);
+
+    words = NWORDS(bf->size);
+
+    for (i = 0; i < words; ++i) {
+	count += PopCount(bf->bits[i]);
+    }
+
+    return count;
+}
+
+
+TkBitField *
+TkBitCopy(
+    const TkBitField *bf,
+    int size)
+{
+    TkBitField *copy;
+    unsigned oldWords, newWords;
+
+    assert(bf);
+
+    if (size < 0) {
+	size = bf->size;
+    }
+
+    copy = malloc(BF_SIZE(size));
+    DEBUG_ALLOC(Use(copy));
+    oldWords = NWORDS(bf->size);
+    newWords = NWORDS(size);
+    memcpy(copy->bits, bf->bits, NBYTES(MIN(oldWords, newWords)));
+    if (newWords > oldWords) {
+	memset(copy->bits + oldWords, 0, NBYTES(newWords - oldWords));
+    }
+    copy->size = size;
+    copy->refCount = 1;
+    copy->isSetFlag = false;
+    ResetUnused(copy);
+    DEBUG_ALLOC(tkBitCountNew++);
+    return copy;
+}
+
+
+void
+TkBitJoin(
+    TkBitField *dst,
+    const TkBitField *src)
+{
+    unsigned words, i;
+
+    assert(dst);
+    assert(src);
+    assert(TkBitSize(src) <= TkBitSize(dst));
+
+    if (src != dst && src->size > 0) {
+	for (i = 0, words = NWORDS(src->size); i < words; ++i) {
+	    dst->bits[i] |= src->bits[i];
+	}
+    }
+}
+
+
+void
+TkBitJoin2(
+    TkBitField *dst,
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    unsigned words1, words2, words, i;
+
+    assert(dst);
+    assert(bf1);
+    assert(bf2);
+    assert(TkBitSize(dst) >= TkBitSize(bf1));
+    assert(TkBitSize(dst) >= TkBitSize(bf2));
+
+    words1 = NWORDS(bf1->size);
+    words2 = NWORDS(bf2->size);
+    words = MIN(words1, words2);
+
+    for (i = 0; i < words; ++i) {
+	dst->bits[i] |= bf1->bits[i] | bf2->bits[i];
+    }
+    for ( ; i < words1; ++i) {
+	dst->bits[i] |= bf1->bits[i];
+    }
+    for ( ; i < words2; ++i) {
+	dst->bits[i] |= bf2->bits[i];
+    }
+}
+
+
+void
+TkBitIntersect(
+    TkBitField *dst,
+    const TkBitField *src)
+{
+    unsigned srcWords, dstWords, i;
+
+    assert(dst);
+    assert(src);
+
+    if (src == dst || dst->size == 0) {
+	return;
+    }
+
+    srcWords = NWORDS(src->size);
+    dstWords = NWORDS(dst->size);
+
+    if (dstWords > srcWords) {
+	memset(dst->bits + srcWords, 0, NBYTES(dstWords - srcWords));
+	dstWords = srcWords;
+    }
+
+    for (i = 0; i < dstWords; ++i) {
+	dst->bits[i] &= src->bits[i];
+    }
+
+    return;
+}
+
+
+void
+TkBitRemove(
+    TkBitField *dst,
+    const TkBitField *src)
+{
+    unsigned dstWords;
+
+    assert(dst);
+    assert(src);
+
+    if (dst->size == 0 || src->size == 0) {
+	return;
+    }
+
+    dstWords = NWORDS(dst->size);
+
+    if (src == dst) {
+	memset(dst->bits, 0, NBYTES(dstWords));
+    } else {
+	unsigned words = MIN(NWORDS(src->size), dstWords);
+	unsigned i;
+
+	for (i = 0; i < words; ++i) {
+	    dst->bits[i] &= ~src->bits[i];
+	}
+    }
+}
+
+
+void
+TkBitComplementTo(
+    TkBitField *dst,
+    const TkBitField *src)
+{
+    unsigned srcWords, dstWords;
+
+    assert(dst);
+    assert(src);
+    assert(TkBitSize(src) <= TkBitSize(dst));
+
+    if (dst->size == 0) {
+	return;
+    }
+
+    dstWords = NWORDS(dst->size);
+
+    if (src == dst || src->size == 0) {
+	srcWords = 0;
+    } else {
+	unsigned i;
+
+	srcWords = NWORDS(src->size);
+
+	for (i = 0; i < srcWords; ++i) {
+	    dst->bits[i] = src->bits[i] & ~dst->bits[i];
+	}
+    }
+
+    memset(dst->bits + srcWords, 0, NBYTES(dstWords - srcWords));
+}
+
+
+void
+TkBitJoinComplementTo(
+    TkBitField *dst,
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    unsigned i, words, words2;
+
+    assert(dst);
+    assert(bf1);
+    assert(bf2);
+    assert(TkBitSize(dst) >= TkBitSize(bf1));
+    assert(TkBitSize(dst) >= TkBitSize(bf2));
+    assert(TkBitSize(bf2) >= TkBitSize(bf1));
+
+    if (dst == bf2 || bf2->size == 0) {
+	return;
+    }
+
+    words2 = NWORDS(bf2->size);
+    words = MIN(NWORDS(bf1->size), words2);
+
+    for (i = 0; i < words; ++i) {
+	dst->bits[i] |= bf2->bits[i] & ~bf1->bits[i];
+    }
+    for ( ; i < words2; ++i) {
+	dst->bits[i] |= bf2->bits[i];
+    }
+}
+
+
+void
+TkBitJoinNonIntersection(
+    TkBitField *dst,
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    assert(dst);
+    assert(bf1);
+    assert(bf2);
+    assert(TkBitSize(dst) >= TkBitSize(bf1));
+    assert(TkBitSize(dst) >= TkBitSize(bf2));
+
+    if (bf1 == bf2) {
+	return;
+    }
+
+    if (bf1->size == 0) {
+	TkBitJoin(dst, bf2);
+    } else if (bf2->size == 0) {
+	TkBitJoin(dst, bf1);
+    } else {
+	unsigned i, words = MIN(NWORDS(bf1->size), NWORDS(bf2->size));
+
+	for (i = 0; i < words; ++i) {
+	    TkBitWord bf1Bits = bf1->bits[i];
+	    TkBitWord bf2Bits = bf2->bits[i];
+
+	    dst->bits[i] |= (bf1Bits & ~bf2Bits) | (bf2Bits & ~bf1Bits);
+	}
+    }
+}
+
+
+void
+TkBitJoin2ComplementToIntersection(
+    TkBitField *dst,
+    const TkBitField *add,
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    assert(dst);
+    assert(add);
+    assert(bf1);
+    assert(bf2);
+    assert(TkBitSize(dst) >= TkBitSize(add));
+    assert(TkBitSize(dst) >= TkBitSize(bf1));
+    assert(TkBitSize(bf1) == TkBitSize(bf2));
+
+    /* dst := dst + add + ((bf1 + bf2) - (bf1 & bf2)) */
+
+    if (bf1 == bf2) {
+	TkBitJoin(dst, add);
+    } else {
+	unsigned words1 = NWORDS(add->size);
+	unsigned words2 = NWORDS(bf1->size);
+	unsigned words = MIN(words1, words2);
+	unsigned i;
+
+	for (i = 0; i < words; ++i) {
+	    TkBitWord bf1Bits = bf1->bits[i];
+	    TkBitWord bf2Bits = bf2->bits[i];
+
+	    dst->bits[i] |= add->bits[i] | ((bf1Bits | bf2Bits) & ~(bf1Bits & bf2Bits));
+	}
+	for ( ; i < words2; ++i) {
+	    TkBitWord bf1Bits = bf1->bits[i];
+	    TkBitWord bf2Bits = bf2->bits[i];
+
+	    dst->bits[i] |= (bf1Bits | bf2Bits) & ~(bf1Bits & bf2Bits);
+	}
+	for ( ; i < words1; ++i) {
+	    dst->bits[i] |= add->bits[i];
+	}
+    }
+}
+
+
+void
+TkBitJoinOfDifferences(
+    TkBitField *dst,
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    unsigned words, words1, words2, i;
+
+    assert(dst);
+    assert(bf1);
+    assert(bf2);
+    assert(TkBitSize(dst) >= TkBitSize(bf1));
+
+    words1 = NWORDS(bf1->size);
+    words2 = NWORDS(bf2->size);
+
+    words = MIN(words1, words2);
+
+    for (i = 0; i < words; ++i) {
+	TkBitWord bf1Bits = bf1->bits[i];
+	TkBitWord bf2Bits = bf2->bits[i];
+
+	/* dst := (dst - bf1) + (bf1 - bf2) */
+	dst->bits[i] = (dst->bits[i] & ~bf1Bits) | (bf1Bits & ~bf2Bits);
+    }
+
+    for ( ; i < words1; ++i) {
+	/* dst := dst + bf1 */
+	dst->bits[i] |= bf1->bits[i];
+    }
+}
+
+
+void
+TkBitClear(
+    TkBitField *bf)
+{
+    assert(bf);
+    memset(bf->bits, 0, BYTE_SIZE(bf->size));
+}
+
+
+bool
+TkBitNone_(
+    const TkBitWord *bits,
+    unsigned words)
+{
+    unsigned i;
+
+    assert(bits);
+
+    for (i = 0; i < words; ++i) {
+	if (bits[i]) {
+	    return false;
+	}
+    }
+    return true;
+}
+
+
+bool
+TkBitAny(
+    const TkBitField *bf)
+{
+    unsigned words, i;
+
+    assert(bf);
+
+    words = NWORDS(bf->size);
+
+    for (i = 0; i < words; ++i) {
+	if (bf->bits[i]) {
+	    return true;
+	}
+    }
+
+    return false;
+}
+
+
+bool
+TkBitComplete(
+    const TkBitField *bf)
+{
+    unsigned words;
+
+    assert(bf);
+
+    words = NWORDS(bf->size);
+
+    if (words)
+    {
+	unsigned i, n = words - 1;
+
+	for (i = 0; i < n; ++i) {
+	    if (bf->bits[i] != ~((TkBitWord) 0)) {
+		return false;
+	    }
+	}
+
+	if (bf->bits[words - 1] != BIT_SPAN(0, BIT_INDEX(bf->size - 1))) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkBitIsEqual(
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    unsigned words1;
+
+    assert(bf1);
+    assert(bf2);
+
+    if (bf1 == bf2) {
+	return true;
+    }
+
+    if (bf1->size > bf2->size) {
+	const TkBitField *bf = bf1;
+	bf1 = bf2;
+	bf2 = bf;
+    }
+
+    words1 = NWORDS(bf1->size);
+
+    if (!IsEqual(bf1->bits, bf2->bits, words1)) {
+	return false;
+    }
+
+    return TkBitNone_(bf2->bits + words1, NWORDS(bf2->size) - words1);
+}
+
+
+bool
+TkBitContains(
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    unsigned words1, words2, i;
+
+    assert(bf1);
+    assert(bf2);
+
+    if (bf1 == bf2) {
+	return true;
+    }
+
+    words1 = NWORDS(bf1->size);
+    words2 = NWORDS(bf2->size);
+
+    if (words1 < words2) {
+	if (!TkBitNone_(bf2->bits + words1, words2 - words1)) {
+	    return false;
+	}
+	words2 = words1;
+    }
+
+    for (i = 0; i < words2; ++i) {
+	TkBitWord bits2 = bf2->bits[i];
+
+	if (bits2 != (bf1->bits[i] & bits2)) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkBitDisjunctive(
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    unsigned words, i;
+
+    assert(bf1);
+    assert(bf2);
+
+    if (bf1 == bf2) {
+	return TkBitNone(bf1);
+    }
+
+    words = MIN(NWORDS(bf1->size), NWORDS(bf2->size));
+
+    for (i = 0; i < words; ++i) {
+	if (bf1->bits[i] & bf2->bits[i]) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkBitIntersectionIsEqual(
+    const TkBitField *bf1,
+    const TkBitField *bf2,
+    const TkBitField *del)
+{
+    unsigned words, words1, words2, i;
+
+    assert(bf1);
+    assert(bf2);
+    assert(del);
+    assert(TkBitSize(bf1) <= TkBitSize(del));
+    assert(TkBitSize(bf2) <= TkBitSize(del));
+
+    if (bf1 == bf2) {
+	return true;
+    }
+    if (bf1->size == 0) {
+	return TkBitNone(bf2);
+    }
+    if (bf2->size == 0) {
+	return TkBitNone(bf1);
+    }
+
+    words1 = NWORDS(bf1->size);
+    words2 = NWORDS(bf2->size);
+    words = MIN(words1, words2);
+
+    for (i = 0; i < words; ++i) {
+	TkBitWord bits = del->bits[i];
+	if ((bf1->bits[i] & bits) != (bf2->bits[i] & bits)) {
+	    return false;
+	}
+    }
+
+    for (i = words; i < words1; ++i) {
+	if (bf1->bits[i] & del->bits[i]) {
+	    return false;
+	}
+    }
+
+    for (i = words; i < words2; ++i) {
+	if (bf2->bits[i] & del->bits[i]) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+unsigned
+TkBitFindFirst(
+    const TkBitField *bf)
+{
+    unsigned words, i;
+
+    assert(bf);
+
+    words = NWORDS(bf->size);
+
+    for (i = 0; i < words; ++i) {
+	TkBitWord bits = bf->bits[i];
+
+	if (bits) {
+	    return NBITS*i + LsbIndex(bits);
+	}
+    }
+
+    return TK_BIT_NPOS;
+}
+
+
+unsigned
+TkBitFindLast(
+    const TkBitField *bf)
+{
+    int i;
+
+    assert(bf);
+
+    for (i = NWORDS(bf->size) - 1; i >= 0; --i) {
+	TkBitWord bits = bf->bits[i];
+
+	if (bits) {
+	    return NBITS*i + MsbIndex(bits);
+	}
+    }
+
+    return TK_BIT_NPOS;
+}
+
+
+unsigned
+TkBitFindFirstNot(
+    const TkBitField *bf)
+{
+    unsigned words, mask, bits, i;
+
+    assert(bf);
+
+    if (bf->size > 0) {
+	words = NWORDS(bf->size) - 1;
+
+	for (i = 0; i < words; ++i) {
+	    TkBitWord bits = bf->bits[i];
+
+	    if (bits != ~((TkBitWord) 0)) {
+		return NBITS*i + LsbIndex(~bits);
+	    }
+	}
+
+	mask = BIT_SPAN(0, BIT_INDEX(bf->size - 1));
+	bits = bf->bits[words];
+
+	if (bits != mask) {
+	    return NBITS*words + LsbIndex(~bits & mask);
+	}
+    }
+
+    return TK_BIT_NPOS;
+}
+
+
+unsigned
+TkBitFindLastNot(
+    const TkBitField *bf)
+{
+    assert(bf);
+
+    if (bf->size > 0) {
+	TkBitWord bits,mask;
+	unsigned words;
+	int i;
+
+	words = NWORDS(bf->size) - 1;
+	mask = BIT_SPAN(0, BIT_INDEX(bf->size - 1));
+	bits = bf->bits[words];
+
+	if (bits != mask) {
+	    return NBITS*words + MsbIndex(~bits & mask);
+	}
+
+	for (i = words - 1; i >= 0; --i) {
+	    if ((bits = bf->bits[i]) != ~((TkBitWord) 0)) {
+		return NBITS*i + MsbIndex(~bits);
+	    }
+	}
+    }
+
+    return TK_BIT_NPOS;
+}
+
+
+unsigned
+TkBitFindNext(
+    const TkBitField *bf,
+    unsigned prev)
+{
+    TkBitWord bits;
+    unsigned i, words;
+
+    assert(bf);
+    assert(prev < TkBitSize(bf));
+
+    i = WORD_INDEX(prev);
+    bits = bf->bits[i] & ~BIT_SPAN(0, BIT_INDEX(prev));
+
+    if (bits) {
+	return NBITS*i + LsbIndex(bits);
+    }
+
+    words = NWORDS(bf->size);
+
+    for (++i; i < words; ++i) {
+	if ((bits = bf->bits[i])) {
+	    return NBITS*i + LsbIndex(bits);
+	}
+    }
+
+    return TK_BIT_NPOS;
+}
+
+
+unsigned
+TkBitFindNextNot(
+    const TkBitField *bf,
+    unsigned prev)
+{
+    TkBitWord bits;
+    unsigned i, words;
+
+    assert(bf);
+    assert(prev < TkBitSize(bf));
+
+    i = WORD_INDEX(prev);
+    bits = bf->bits[i] & ~BIT_SPAN(0, BIT_INDEX(prev));
+
+    if (~bits != ~((TkBitWord) 0)) {
+	return NBITS*i + LsbIndex(bits);
+    }
+
+    words = NWORDS(bf->size);
+
+    for (++i; i < words; ++i) {
+	if (bits != ~((TkBitWord) 0)) {
+	    return NBITS*i + LsbIndex(~bits);
+	}
+    }
+
+    return TK_BIT_NPOS;
+}
+
+
+unsigned
+TkBitFindPrev(
+    const TkBitField *bf,
+    unsigned next)
+{
+    TkBitWord bits;
+    int i;
+
+    assert(bf);
+    assert(next < TkBitSize(bf));
+
+    i = WORD_INDEX(next);
+    bits = bf->bits[i] & ~BIT_SPAN(BIT_INDEX(next), NBITS - 1);
+
+    if (bits) {
+	return NBITS*i + MsbIndex(bits);
+    }
+
+    for (--i; i >= 0; --i) {
+	if ((bits = bf->bits[i])) {
+	    return NBITS*i + MsbIndex(bits);
+	}
+    }
+
+    return TK_BIT_NPOS;
+}
+
+
+unsigned
+TkBitFindFirstInIntersection(
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    unsigned words, i;
+
+    assert(bf1);
+    assert(bf2);
+
+    words = NWORDS(MIN(bf1->size, bf2->size));
+
+    for (i = 0; i < words; ++i) {
+	TkBitWord bits = bf1->bits[i] & bf2->bits[i];
+
+	if (bits) {
+	    return LsbIndex(bits);
+	}
+    }
+
+    return TK_BIT_NPOS;
+}
+
+
+bool
+TkBitTestAndSet(
+    TkBitField *bf,
+    unsigned n)
+{
+    TkBitWord *word;
+    TkBitWord mask;
+
+    assert(bf);
+    assert(n < TkBitSize(bf));
+
+    word = bf->bits + WORD_INDEX(n);
+    mask = TK_BIT_MASK(BIT_INDEX(n));
+
+    if (*word & mask) {
+	return false;
+    }
+    *word |= mask;
+    return true;
+}
+
+
+bool
+TkBitTestAndUnset(
+    TkBitField *bf,
+    unsigned n)
+{
+    TkBitWord *word;
+    TkBitWord mask;
+
+    assert(bf);
+    assert(n < TkBitSize(bf));
+
+    word = bf->bits + WORD_INDEX(n);
+    mask = TK_BIT_MASK(BIT_INDEX(n));
+
+    if (!(*word & mask)) {
+	return false;
+    }
+    *word &= ~mask;
+    return true;
+}
+
+
+void
+TkBitFill(
+    TkBitField *bf)
+{
+    memset(bf->bits, 0xff, BYTE_SIZE(bf->size));
+    ResetUnused(bf);
+}
+
+
+#if !NDEBUG
+
+# include <stdio.h>
+
+void
+TkBitPrint(
+    const TkBitField *bf)
+{
+    unsigned i;
+    const char *comma = "";
+
+    assert(bf);
+
+    printf("%d:{ ", TkBitCount(bf));
+    for (i = TkBitFindFirst(bf); i != TK_BIT_NPOS; i = TkBitFindNext(bf, i)) {
+	printf("%s%d", comma, i);
+	comma = ", ";
+    }
+    printf(" }\n");
+}
+
+#endif /* !NDEBUG */
+
+#if TK_UNUSED_BITFIELD_FUNCTIONS
+
+/*
+ * These functions are not needed anymore, but shouldn't be removed, because sometimes
+ * any of these functions might be useful.
+ */
+
+void
+TkBitInnerJoinDifference(
+    TkBitField *dst,
+    const TkBitField *add,
+    const TkBitField *sub)
+{
+    unsigned words1, words2, i;
+
+    assert(dst);
+    assert(add);
+    assert(sub);
+    assert(TkBitSize(add) <= TkBitSize(dst));
+
+    words2 = NWORDS(add->size);
+    words1 = MIN(words2, NWORDS(sub->size));
+
+    for (i = 0; i < words1; ++i) {
+	TkBitWord addBits = add->bits[i];
+	dst->bits[i] = (dst->bits[i] & addBits) | (addBits & ~sub->bits[i]);
+    }
+
+    for ( ; i < words2; ++i) {
+	TkBitWord addBits = add->bits[i];
+	dst->bits[i] = (dst->bits[i] & addBits) | addBits;
+    }
+}
+
+
+bool
+TkBitInnerJoinDifferenceIsEmpty(
+    const TkBitField *bf,
+    const TkBitField *add,
+    const TkBitField *sub)
+{
+    unsigned words, i;
+    unsigned bfWords, addWords, subWords;
+
+    assert(bf);
+    assert(add);
+    assert(sub);
+
+    /* (bf & add) + (add - sub) == nil */
+
+    if (add->size == 0) {
+	/* nil */
+	return true;
+    }
+
+    if (add == bf) {
+	/* add == nil */
+	return TkBitNone(add);
+    }
+
+    bfWords = NWORDS(bf->size);
+    addWords = NWORDS(add->size);
+    subWords = NWORDS(sub->size);
+
+    words = MIN(bfWords, MIN(addWords, subWords));
+
+    for (i = 0; i < words; ++i) {
+	TkBitWord addBits = add->bits[i];
+	if ((bf->bits[i] & addBits) | (addBits & ~sub->bits[i])) {
+	    return false;
+	}
+    }
+
+    if (addWords == words) {
+	/* nil */
+	return true;
+    }
+
+    if (bfWords > words) {
+	assert(subWords == words);
+	/* add == nil */
+
+	for ( ; i < addWords; ++i) {
+	    if (add->bits[i]) {
+		return false;
+	    }
+	}
+    } else {
+	assert(bfWords == words);
+	words = MIN(addWords, subWords);
+
+	/* (add - sub) == nil */
+
+	for ( ; i < words; ++i) {
+	    if (add->bits[i] & ~sub->bits[i]) {
+		return false;
+	    }
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkBitIsEqualToDifference(
+    const TkBitField *bf1,
+    const TkBitField *bf2,
+    const TkBitField *sub2)
+{
+    unsigned words0, words1, words2, i;
+
+    assert(bf1);
+    assert(bf2);
+    assert(sub2);
+    assert(TkBitSize(bf2) == TkBitSize(sub2));
+
+    if (bf2->size == 0) {
+	return TkBitNone(bf1);
+    }
+    if (bf1->size == 0) {
+	return TkBitContains(sub2, bf2);
+    }
+
+    words1 = NWORDS(bf1->size);
+    words2 = NWORDS(bf2->size);
+    words0 = MIN(words1, words2);
+
+    /* bf1 == bf2 - sub2 */
+
+    for (i = 0; i < words0; ++i) {
+	if (bf1->bits[i] != (bf2->bits[i] & ~sub2->bits[i])) {
+	    return false;
+	}
+    }
+
+    if (words1 > words2) {
+	return TkBitNone_(bf1->bits + words2, words1 - words2);
+    }
+
+    for ( ; i < words2; ++i) {
+	if (bf2->bits[i] & ~sub2->bits[i]) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkBitIsEqualToInnerJoin(
+    const TkBitField *bf1,
+    const TkBitField *bf2,
+    const TkBitField *add2)
+{
+    unsigned words0, words1, words2, i;
+
+    assert(bf1);
+    assert(bf2);
+    assert(add2);
+    assert(TkBitSize(bf2) == TkBitSize(add2));
+
+    if (bf1 == bf2) {
+	return true;
+    }
+    if (bf2 == add2) {
+	return TkBitIsEqual(bf1, bf2);
+    }
+    if (bf1->size == 0) {
+	return TkBitNone(bf2);
+    }
+    if (bf2->size == 0) {
+	return TkBitNone(bf1);
+    }
+
+    words1 = NWORDS(bf1->size);
+    words2 = NWORDS(bf2->size);
+    words0 = MIN(words1, words2);
+
+    for (i = 0; i < words0; ++i) {
+	TkBitWord bf2Bits = bf2->bits[i];
+	if (bf1->bits[i] != (bf2Bits | (add2->bits[i] & bf2Bits))) {
+	    return false;
+	}
+    }
+
+    if (words1 > words2) {
+	return TkBitNone_(bf1->bits + words2, words1 - words2);
+    }
+
+    for ( ; i < words2; ++i) {
+	TkBitWord bf2Bits = bf2->bits[i];
+	if (bf2Bits | (add2->bits[i] & bf2Bits)) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkBitIsEqualToInnerJoinDifference(
+    const TkBitField *bf1,
+    const TkBitField *bf2,
+    const TkBitField *add2,
+    const TkBitField *sub2)
+{
+    unsigned words0, words1, words2, i;
+
+    assert(bf1);
+    assert(bf2);
+    assert(add2);
+    assert(sub2);
+    assert(TkBitSize(bf2) == TkBitSize(add2));
+    assert(TkBitSize(bf2) == TkBitSize(sub2));
+
+    if (add2->size == 0) {
+	return TkBitNone(bf1);
+    }
+    if (sub2->size == 0) {
+	return TkBitIsEqual(bf1, add2);
+    }
+
+    words1 = NWORDS(bf1->size);
+    words2 = NWORDS(bf2->size);
+    words0 = MIN(words1, words2);
+
+    for (i = 0; i < words0; ++i) {
+	TkBitWord addBits = add2->bits[i];
+	if (bf1->bits[i] != ((bf2->bits[i] & addBits) | (addBits & ~sub2->bits[i]))) {
+	    return false;
+	}
+    }
+
+    if (words1 > words2) {
+	return TkBitNone_(bf1->bits + words2, words1 - words2);
+    }
+
+    for ( ; i < words2; ++i) {
+	TkBitWord addBits = add2->bits[i];
+	if ((bf2->bits[i] & addBits) | (addBits & ~sub2->bits[i])) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+static bool
+IntersectionIsDisjunctive(
+    const TkBitField *bf1,
+    const TkBitField *bf2,
+    const TkBitField *del)
+{
+    unsigned words = NWORDS(bf1->size);
+
+    assert(TkBitSize(bf1) == TkBitSize(bf2));
+    assert(TkBitSize(bf1) == TkBitSize(del));
+
+    for (i = 0; i < words; ++i) {
+	TkBitWord delBits = del->bits[i];
+
+	if ((bf1->bits[i] & delBits) != (bf2->bits[i] & delBits)) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkBitInnerJoinDifferenceIsEqual(
+    const TkBitField *bf1,
+    const TkBitField *bf2,
+    const TkBitField *add,
+    const TkBitField *sub)
+{
+    unsigned words, i;
+
+    assert(bf1);
+    assert(bf2);
+    assert(add);
+    assert(sub);
+    assert(TkBitSize(bf1) == TkBitSize(bf2));
+    assert(TkBitSize(bf1) == TkBitSize(add));
+    assert(TkBitSize(bf1) == TkBitSize(sub));
+
+    if (add->size == 0) {
+	return true;
+    }
+
+    if (bf1->size == 0) {
+	 /*
+	  * We have to show: sub & add == bf1 & add
+	  * (see InnerJoinDifferenceIsEqual [tkIntSet.c]).
+	  */
+	 return IntersectionIsDisjunctive(bf1, sub, add);
+    }
+
+    if (bf2->size == 0) {
+	 return IntersectionIsDisjunctive(bf2, sub, add);
+    }
+
+    words = NWORDS(bf1->size);
+
+    for (i = 0; i < words; ++i) {
+	TkBitWord addBits = add->bits[i];
+	TkBitWord sumBits = addBits & ~sub->bits[i];
+
+	if (((bf1->bits[i] & addBits) | sumBits) != ((bf2->bits[i] & addBits) | sumBits)) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+#endif /* TK_UNUSED_BITFIELD_FUNCTIONS */
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+/* Additionally we need stand-alone object code. */
+#define inline extern
+inline TkBitField *TkBitNew(unsigned size);
+inline const unsigned char *TkBitData(const TkBitField *bf);
+inline unsigned TkBitByteSize(const TkBitField *bf);
+inline unsigned TkBitRefCount(const TkBitField *bf);
+inline void TkBitIncrRefCount(TkBitField *bf);
+inline unsigned TkBitDecrRefCount(TkBitField *bf);
+inline bool TkBitIsEmpty(const TkBitField *bf);
+inline unsigned TkBitSize(const TkBitField *bf);
+inline bool TkBitTest(const TkBitField *bf, unsigned n);
+inline bool TkBitNone(const TkBitField *bf);
+inline bool TkBitIntersects(const TkBitField *bf1, const TkBitField *bf2);
+inline void TkBitSet(TkBitField *bf, unsigned n);
+inline void TkBitUnset(TkBitField *bf, unsigned n);
+inline void TkBitPut(TkBitField *bf, unsigned n, bool value);
+inline unsigned TkBitAdjustSize(unsigned size);
+#endif /* __STDC_VERSION__ >= 199901L */
+
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkBitField.h
===================================================================
--- src/tktext/tkBitField.h	(revision 0)
+++ src/tktext/tkBitField.h	(working copy)
@@ -0,0 +1,188 @@
+/*
+ * tkBitField.h --
+ *
+ *	This module implements bit field operations.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKBITFIELD
+#define _TKBITFIELD
+
+#ifndef _TK
+#include "tk.h"
+#endif
+
+#include "tkBool.h"
+#include <stdint.h>
+
+#ifdef _MSC_VER
+# if _MSC_VER >= 1900
+#  define inline __inline
+# else
+#  define inline
+# endif
+#elif __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+#ifdef TCL_WIDE_INT_IS_LONG
+typedef uint64_t TkBitWord;
+#else
+typedef uint32_t TkBitWord;
+#endif
+
+#define TK_BIT_NBITS (sizeof(TkBitWord)*8) /* Number of bits in one word. */
+
+struct TkIntSet;
+
+
+/*
+ * The struct below will be shared with the struct TkIntSet, so the first two
+ * members must exactly match the first two members in struct TkIntSet. In this
+ * way we have a struct inheritance, based on the first two members. This
+ * is portable due to C99 section 6.7.2.1 bullet point 13:
+ *
+ *	Within a structure object, the non-bit-field members and the units 
+ *	in which bit-fields reside have addresses that increase in the order
+ *	in which they are declared. A pointer to a structure object, suitably
+ *	converted, points to its initial member (or if that member is a
+ *	bit-field, then to the unit in which it resides), and vice versa.
+ *	There may be unnamed padding within a structure object, but not at
+ *	beginning.
+ *
+ * This inheritance concept is also used in the portable GTK library.
+ */
+
+typedef struct TkBitField {
+    uint32_t refCount:31;
+    uint32_t isSetFlag:1;
+    uint32_t size;
+#if TK_CHECK_ALLOCS
+    struct TkBitField *next;
+    struct TkBitField *prev;
+    unsigned number;
+#endif
+    TkBitWord bits[1];
+} TkBitField;
+
+
+/*
+ * This value will be returned in case of end of iteration.
+ */
+#define TK_BIT_NPOS ((unsigned) -1)
+
+
+inline TkBitField *TkBitNew(unsigned size);
+TkBitField *TkBitResize(TkBitField *bf, unsigned newSize);
+TkBitField *TkBitFromSet(const struct TkIntSet *set, unsigned size);
+void TkBitDestroy(TkBitField **bfPtr);
+
+inline const unsigned char *TkBitData(const TkBitField *bf);
+inline unsigned TkBitByteSize(const TkBitField *bf);
+
+inline unsigned TkBitRefCount(const TkBitField *bf);
+inline void TkBitIncrRefCount(TkBitField *bf);
+inline unsigned TkBitDecrRefCount(TkBitField *bf);
+
+TkBitField *TkBitCopy(const TkBitField *bf, int size);
+
+void TkBitJoin(TkBitField *dst, const TkBitField *src);
+void TkBitIntersect(TkBitField *dst, const TkBitField *src);
+void TkBitRemove(TkBitField *dst, const TkBitField *src);
+
+/* dst := dst + bf1 + bf2 */
+void TkBitJoin2(TkBitField *dst, const TkBitField *bf1, const TkBitField *bf2);
+/* dst := src - dst */
+void TkBitComplementTo(TkBitField *dst, const TkBitField *src);
+/* dst := dst + (bf2 - bf1) */
+void TkBitJoinComplementTo(TkBitField *dst, const TkBitField *bf1, const TkBitField *bf2);
+/* dst := dst + (bf1 - bf2) + (bf2 - bf1) */
+void TkBitJoinNonIntersection(TkBitField *dst, const TkBitField *bf1, const TkBitField *bf2);
+/* dst := dst + add + ((bf1 + bf2) - (bf1 & bf2)) */
+void TkBitJoin2ComplementToIntersection(TkBitField *dst,
+    const TkBitField *add, const TkBitField *bf1, const TkBitField *bf2);
+/* dst := (dst - bf1) + (bf1 - bf2) */
+void TkBitJoinOfDifferences(TkBitField *dst, const TkBitField *bf1, const TkBitField *bf2);
+
+inline bool TkBitIsEmpty(const TkBitField *bf);
+inline unsigned TkBitSize(const TkBitField *bf);
+unsigned TkBitCount(const TkBitField *bf);
+
+inline bool TkBitTest(const TkBitField *bf, unsigned n);
+inline bool TkBitNone(const TkBitField *bf);
+bool TkBitAny(const TkBitField *bf);
+bool TkBitComplete(const TkBitField *bf);
+
+bool TkBitIsEqual(const TkBitField *bf1, const TkBitField *bf2);
+bool TkBitContains(const TkBitField *bf1, const TkBitField *bf2);
+bool TkBitDisjunctive(const TkBitField *bf1, const TkBitField *bf2);
+inline bool TkBitIntersects(const TkBitField *bf1, const TkBitField *bf2);
+bool TkBitIntersectionIsEqual(const TkBitField *bf1, const TkBitField *bf2, const TkBitField *del);
+
+unsigned TkBitFindFirst(const TkBitField *bf);
+unsigned TkBitFindLast(const TkBitField *bf);
+unsigned TkBitFindFirstNot(const TkBitField *bf);
+unsigned TkBitFindLastNot(const TkBitField *bf);
+unsigned TkBitFindNext(const TkBitField *bf, unsigned prev);
+unsigned TkBitFindNextNot(const TkBitField *bf, unsigned prev);
+unsigned TkBitFindPrev(const TkBitField *bf, unsigned prev);
+unsigned TkBitFindFirstInIntersection(const TkBitField *bf1, const TkBitField *bf2);
+
+inline void TkBitSet(TkBitField *bf, unsigned n);
+inline void TkBitUnset(TkBitField *bf, unsigned n);
+inline void TkBitPut(TkBitField *bf, unsigned n, bool value);
+bool TkBitTestAndSet(TkBitField *bf, unsigned n);
+bool TkBitTestAndUnset(TkBitField *bf, unsigned n);
+void TkBitFill(TkBitField *bf);
+void TkBitClear(TkBitField *bf);
+
+/* Return nearest multiple of TK_BIT_NBITS which is greater or equal to given argument. */
+inline unsigned TkBitAdjustSize(unsigned size);
+
+#if !NDEBUG
+void TkBitPrint(const TkBitField *bf);
+#endif
+
+#if TK_CHECK_ALLOCS
+void TkBitCheckAllocs();
+#endif
+
+
+#if TK_UNUSED_BITFIELD_FUNCTIONS
+
+/*
+ * These functions are not needed anymore, but shouldn't be removed, because sometimes
+ * any of these functions might be useful.
+ */
+
+/* dst := (dst + (add - sub)) & add */
+void TkBitInnerJoinDifference(TkBitField *dst, const TkBitField *add, const TkBitField *sub);
+/* ((bf + (add - sub)) & add) == nil */
+bool TkBitInnerJoinDifferenceIsEmpty(const TkBitField *bf, const TkBitField *add, const TkBitField *sub);
+/* bf1 == bf2 - sub2 */
+bool TkBitIsEqualToDifference(const TkBitField *bf1, const TkBitField *bf2, const TkBitField *sub2);
+/* bf1 == ((bf2 + add2) & bf2) */
+bool TkBitIsEqualToInnerJoin(const TkBitField *bf1, const TkBitField *bf2, const TkBitField *add2);
+/* bf1 == ((bf2 + (add2 - sub2) & add) */
+bool TkBitIsEqualToInnerJoinDifference(const TkBitField *bf1, const TkBitField *bf2,
+    const TkBitField *add2, const TkBitField *sub2);
+/* ((bf1 + (add - sub)) & add) == ((bf2 + (add - sub)) & add) */
+bool TkBitInnerJoinDifferenceIsEqual(const TkBitField *bf1, const TkBitField *bf2,
+    const TkBitField *add, const TkBitField *sub);
+
+#endif /* 0 */
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+# define _TK_NEED_IMPLEMENTATION
+# include "tkBitFieldPriv.h"
+#else
+# undef inline
+#endif
+
+#endif /* _TKBITFIELD */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkBitFieldPriv.h
===================================================================
--- src/tktext/tkBitFieldPriv.h	(revision 0)
+++ src/tktext/tkBitFieldPriv.h	(working copy)
@@ -0,0 +1,209 @@
+/*
+ * tkBitFieldPriv.h --
+ *
+ *	Private implementation for bit field.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKBITFIELD
+# error "do not include this private header file"
+#endif
+
+
+#ifndef _TKBITFIELDPRIV
+#define _TKBITFIELDPRIV
+
+MODULE_SCOPE bool TkBitNone_(const TkBitWord *buf, unsigned words);
+
+#endif /* _TKBITFIELDPRIV */
+
+
+#ifdef _TK_NEED_IMPLEMENTATION
+
+#include <assert.h>
+
+#if __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+#define TK_BIT_WORD_INDEX(n)	((n) >> ((TK_BIT_NBITS + 128) >> 5))
+#define TK_BIT_INDEX(n)		((n) & (TK_BIT_NBITS - 1))
+#define TK_BIT_MASK(n)		(((TkBitWord) 1) << (n))
+#define TK_BIT_COUNT_WORDS(n)	((n + TK_BIT_NBITS - 1)/TK_BIT_NBITS)
+
+
+inline
+const unsigned char *
+TkBitData(
+    const TkBitField *bf)
+{
+    assert(bf);
+    return (const void *) bf->bits;
+}
+
+
+inline
+unsigned
+TkBitByteSize(
+    const TkBitField *bf)
+{
+    assert(bf);
+    return TK_BIT_COUNT_WORDS(bf->size);
+}
+
+
+inline
+unsigned
+TkBitAdjustSize(
+    unsigned size)
+{
+    return ((size + (TK_BIT_NBITS - 1))/TK_BIT_NBITS)*TK_BIT_NBITS;
+}
+
+
+inline
+TkBitField *
+TkBitNew(
+    unsigned size)
+{
+    TkBitField *bf = TkBitResize(NULL, size);
+    bf->refCount = 0;
+    return bf;
+}
+
+
+inline
+unsigned
+TkBitRefCount(
+    const TkBitField *bf)
+{
+    assert(bf);
+    return bf->refCount;
+}
+
+
+inline
+void
+TkBitIncrRefCount(
+    TkBitField *bf)
+{
+    assert(bf);
+    bf->refCount += 1;
+}
+
+
+inline
+unsigned
+TkBitDecrRefCount(
+    TkBitField *bf)
+{
+    unsigned refCount;
+
+    assert(bf);
+    assert(TkBitRefCount(bf) > 0);
+
+    if ((refCount = --bf->refCount) == 0) {
+	TkBitDestroy(&bf);
+    }
+    return refCount;
+}
+
+
+inline
+unsigned
+TkBitSize(
+    const TkBitField *bf)
+{
+    assert(bf);
+    return bf->size;
+}
+
+
+inline
+bool
+TkBitIsEmpty(
+    const TkBitField *bf)
+{
+    assert(bf);
+    return bf->size == 0;
+}
+
+
+inline
+bool
+TkBitNone(
+    const TkBitField *bf)
+{
+    assert(bf);
+    return bf->size == 0 || TkBitNone_(bf->bits, TK_BIT_COUNT_WORDS(bf->size));
+}
+
+
+inline
+bool
+TkBitIntersects(
+    const TkBitField *bf1,
+    const TkBitField *bf2)
+{
+    return !TkBitDisjunctive(bf1, bf2);
+}
+
+
+inline
+bool
+TkBitTest(
+    const TkBitField *bf,
+    unsigned n)
+{
+    assert(bf);
+    assert(n < TkBitSize(bf));
+    return !!(bf->bits[TK_BIT_WORD_INDEX(n)] & TK_BIT_MASK(TK_BIT_INDEX(n)));
+}
+
+
+inline
+void
+TkBitSet(
+    TkBitField *bf,
+    unsigned n)
+{
+    assert(bf);
+    assert(n < TkBitSize(bf));
+    bf->bits[TK_BIT_WORD_INDEX(n)] |= TK_BIT_MASK(TK_BIT_INDEX(n));
+}
+
+
+inline
+void
+TkBitUnset(
+    TkBitField *bf,
+    unsigned n)
+{
+    assert(bf);
+    assert(n < TkBitSize(bf));
+    bf->bits[TK_BIT_WORD_INDEX(n)] &= ~TK_BIT_MASK(TK_BIT_INDEX(n));
+}
+
+
+inline
+void
+TkBitPut(
+    TkBitField *bf,
+    unsigned n,
+    bool value)
+{
+    if (value) {
+	TkBitSet(bf, n);
+    } else {
+	TkBitUnset(bf, n);
+    }
+}
+
+#undef _TK_NEED_IMPLEMENTATION
+#endif /* _TK_NEED_IMPLEMENTATION */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkIntSet.c
===================================================================
--- src/tktext/tkIntSet.c	(revision 0)
+++ src/tktext/tkIntSet.c	(working copy)
@@ -0,0 +1,2151 @@
+/*
+ * tkIntSet.c --
+ *
+ *	This module implements an integer set.
+ *
+ *	NOTE: the current implementation is for TkTextTagSet, so in general these
+ *	functions are not modifying the arguments, except if this is expected.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkIntSet.h"
+#include "tkBitField.h"
+#include "tkAlloc.h"
+
+#if !(__STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900))
+# define _TK_NEED_IMPLEMENTATION
+# include "tkIntSetPriv.h"
+#endif
+
+#include <string.h>
+#include <assert.h>
+
+#ifndef MIN
+# define MIN(a,b) (((int) a) < ((int) b) ? a : b)
+#endif
+#ifndef MAX
+# define MAX(a,b) (((int) a) < ((int) b) ? b : a)
+#endif
+
+#if TK_CHECK_ALLOCS
+# define DEBUG_ALLOC(expr) expr
+#else
+# define DEBUG_ALLOC(expr)
+#endif
+
+
+#define TestIfEqual TkIntSetIsEqual__
+
+#define SET_SIZE(size) ((unsigned) (Tk_Offset(TkIntSet, buf) + (size)*sizeof(TkIntSetType)))
+
+
+DEBUG_ALLOC(unsigned tkIntSetCountNew = 0);
+DEBUG_ALLOC(unsigned tkIntSetCountDestroy = 0);
+
+
+static bool IsPowerOf2(unsigned n) { return !(n & (n - 1)); }
+
+
+static unsigned
+NextPowerOf2(
+    unsigned n)
+{
+    --n;
+    n |= n >> 1;
+    n |= n >> 2;
+    n |= n >> 4;
+    n |= n >> 8;
+    n |= n >> 16;
+
+#if !(UINT_MAX <= 4294967295u)
+    /* unsigned is 64 bit wide, this is unusual, but possible */
+    n |= n >> 32;
+#endif
+
+    return ++n;
+}
+
+
+bool
+TkIntSetIsEqual__(
+    const TkIntSetType *set1, const TkIntSetType *end1,
+    const TkIntSetType *set2, const TkIntSetType *end2)
+{
+    if (end1 - set1 != end2 - set2) {
+	return false;
+    }
+    for ( ; set1 < end1; ++set1, ++set2) {
+	if (*set1 != *set2) {
+	    return false;
+	}
+    }
+    return true;
+}
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+
+unsigned
+TkIntSetFindFirstInIntersection(
+    const TkIntSet *set,
+    const TkBitField *bf)
+{
+    unsigned size, i;
+
+    assert(set);
+    assert(bf);
+
+    if (!TkBitNone(bf)) {
+	size = TkIntSetSize(set);
+
+	for (i = 0; i < size; ++i) {
+	    TkIntSetType value = TkIntSetAccess(set, i);
+
+	    if (TkBitTest(bf, value)) {
+		return value;
+	    }
+	}
+    }
+
+    return TK_SET_NPOS;
+}
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+
+TkIntSetType *
+TkIntSetLowerBound(
+    TkIntSetType *first,
+    TkIntSetType *last,
+    TkIntSetType value)
+{
+    while (first != last) {
+	TkIntSetType *mid = first + (last - first)/2;
+
+	if (*mid < value) {
+	    first = mid + 1;
+	} else {
+	    last = mid;
+	}
+    }
+
+    return first;
+}
+
+
+TkIntSet *
+TkIntSetNew()
+{
+    TkIntSet *set = malloc(SET_SIZE(0));
+    set->end = set->buf;
+    set->refCount = 0;
+    set->isSetFlag = true;
+    DEBUG_ALLOC(tkIntSetCountNew++);
+    return set;
+}
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+
+TkIntSet *
+TkIntSetFromBits(
+    const TkBitField *bf)
+{
+    unsigned size;
+    TkIntSet *set;
+    unsigned index = 0, i;
+
+    size = TkBitCount(bf);
+    set = malloc(SET_SIZE(NextPowerOf2(size)));
+    set->end = set->buf + size;
+    set->refCount = 1;
+    set->isSetFlag = true;
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    for (i = TkBitFindFirst(bf); i != TK_BIT_NPOS; i = TkBitFindNext(bf, i)) {
+	set->buf[index++] = i;
+    }
+
+    return set;
+}
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+
+void
+TkIntSetDestroy(
+    TkIntSet **setPtr)
+{
+    assert(setPtr);
+
+    if (*setPtr) {
+	free(*setPtr);
+	*setPtr = NULL;
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+}
+
+
+TkIntSet *
+TkIntSetCopy(
+    const TkIntSet *set)
+{
+    TkIntSet *newSet;
+    unsigned size;
+
+    assert(set);
+
+    size = TkIntSetSize(set);
+    newSet = malloc(SET_SIZE(NextPowerOf2(size)));
+    newSet->end = newSet->buf + size;
+    newSet->refCount = 1;
+    newSet->isSetFlag = true;
+    memcpy(newSet->buf, set->buf, size*sizeof(TkIntSetType));
+    DEBUG_ALLOC(tkIntSetCountNew++);
+    return newSet;
+}
+
+
+static TkIntSetType *
+Join(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkIntSetType *add, const TkIntSetType *addEnd)
+{
+    unsigned size;
+
+    while (src < srcEnd && add < addEnd) {
+	if (*src < *add) {
+	    *dst++ = *src++;
+	} else {
+	    if (*src == *add) {
+		++src;
+	    }
+	    *dst++ = *add++;
+	}
+    }
+
+    if ((size = srcEnd - src) > 0) {
+	memcpy(dst, src, size*sizeof(TkIntSetType));
+	dst += size;
+    } else if ((size = addEnd - add) > 0) {
+	memcpy(dst, add, size*sizeof(TkIntSetType));
+	dst += size;
+    }
+
+    return dst;
+}
+
+
+TkIntSet *
+TkIntSetJoin(
+    TkIntSet *dst,
+    const TkIntSet *src)
+{
+    TkIntSet *set;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(src);
+    assert(dst);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity1 = NextPowerOf2(TkIntSetSize(dst) + TkIntSetSize(src));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = Join(set->buf, dst->buf, dst->end, src->buf, src->end);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+static TkIntSetType *
+JoinBits(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkBitField *bf)
+{
+    unsigned size, i;
+
+    i = TkBitFindFirst(bf);
+
+    while (src < srcEnd && i != TK_BIT_NPOS) {
+	if (*src < i) {
+	    *dst++ = *src++;
+	} else {
+	    if (*src == i) {
+		++src;
+	    }
+	    *dst++ = i;
+	    i = TkBitFindNext(bf, i);
+	}
+    }
+
+    if ((size = srcEnd - src) > 0) {
+	memcpy(dst, src, size*sizeof(TkIntSetType));
+	dst += size;
+    } else {
+	for ( ; i != TK_BIT_NPOS; i = TkBitFindNext(bf, i)) {
+	    *dst++ = i;
+	}
+    }
+
+    return dst;
+}
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+
+TkIntSet *
+TkIntSetJoinBits(
+    TkIntSet *dst,
+    const TkBitField *src)
+{
+    TkIntSet *set;
+
+    assert(src);
+    assert(dst);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    if (dst->buf == dst->end) {
+	set = TkIntSetNew();
+    } else {
+	unsigned capacity1, capacity2, size;
+
+	capacity1 = NextPowerOf2(TkIntSetSize(dst) + TkBitSize(src));
+	set = malloc(SET_SIZE(capacity1));
+	set->end = JoinBits(set->buf, dst->buf, dst->end, src);
+	size = set->end - set->buf;
+	capacity2 = NextPowerOf2(size);
+	assert(capacity2 <= capacity1);
+	DEBUG_ALLOC(tkIntSetCountNew++);
+
+	if (capacity2 < capacity1) {
+	    set = realloc(set, SET_SIZE(capacity2));
+	    set->end = set->buf + size;
+	}
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+
+static TkIntSetType *
+Join2(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkIntSetType *set1, const TkIntSetType *set1End,
+    const TkIntSetType *set2, const TkIntSetType *set2End)
+{
+    unsigned size;
+
+    while (src < srcEnd && set1 < set1End && set2 < set2End) {
+	if (*set1 < *set2) {
+	    if (*src < *set1) {
+		*dst++ = *src++;
+	    } else {
+		if (*src == *set1) {
+		    src++;
+		}
+		*dst++ = *set1++;
+	    }
+	} else {
+	    if (*src < *set2) {
+		*dst++ = *src++;
+	    } else {
+		if (*src == *set2) {
+		    src++;
+		}
+		if (*set1 == *set2)
+		    set1++;
+		*dst++ = *set2++;
+	    }
+	}
+    }
+
+    if (src == srcEnd) {
+	dst = Join(dst, set1, set1End, set2, set2End);
+    } else if (set1 < set1End) {
+	dst = Join(dst, src, srcEnd, set1, set1End);
+    } else if (set2 < set2End) {
+	dst = Join(dst, src, srcEnd, set2, set2End);
+    } else if ((size = srcEnd - src) > 0) {
+	memcpy(dst, src, size*sizeof(TkIntSetType));
+	dst += size;
+    }
+
+    return dst;
+}
+
+
+TkIntSet *
+TkIntSetJoin2(
+    TkIntSet *dst,
+    const TkIntSet *set1,
+    const TkIntSet *set2)
+{
+    TkIntSet *set;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(dst);
+    assert(set1);
+    assert(set2);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity1 = NextPowerOf2(TkIntSetSize(dst) + TkIntSetSize(set1) + TkIntSetSize(set2));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = Join2(set->buf, dst->buf, dst->end, set1->buf, set1->end, set2->buf, set2->end);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+static TkIntSetType *
+Intersect(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkIntSetType *isc, const TkIntSetType *iscEnd)
+{
+    while (src < srcEnd && isc < iscEnd) {
+	if (*src < *isc) {
+	    ++src;
+	} else {
+	    if (*src == *isc) {
+		*dst++ = *src++;
+	    }
+	    ++isc;
+	}
+    }
+
+    return dst;
+}
+
+
+TkIntSet *
+TkIntSetIntersect(
+    TkIntSet *dst,
+    const TkIntSet *src)
+{
+    TkIntSet *set;
+    unsigned size;
+    unsigned capacity1, capacity2;
+
+    assert(src);
+    assert(dst);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    size = MIN(TkIntSetSize(src), TkIntSetSize(dst));
+    capacity1 = NextPowerOf2(size);
+    set = malloc(SET_SIZE(capacity1));
+    set->end = Intersect(set->buf, dst->buf, dst->end, src->buf, src->end);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+static TkIntSetType *
+IntersectBits(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkBitField *isc)
+{
+    unsigned size = TkBitSize(isc);
+
+    for ( ; src < srcEnd; ++src) {
+	if (*src >= size) {
+	    break;
+	}
+	if (TkBitTest(isc, *src)) {
+	    *dst++ = *src;
+	}
+    }
+
+    return dst;
+}
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+
+TkIntSet *
+TkIntSetIntersectBits(
+    TkIntSet *dst,
+    const TkBitField *src)
+{
+    TkIntSet *set;
+    unsigned size;
+    unsigned capacity1, capacity2;
+
+    assert(src);
+    assert(dst);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    size = TkBitCount(src);
+
+    size = MIN(TkIntSetSize(dst), TkBitCount(src));
+    capacity1 = NextPowerOf2(size);
+    set = malloc(SET_SIZE(capacity1));
+    set->end = IntersectBits(set->buf, dst->buf, dst->end, src);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+
+static TkIntSetType *
+Remove(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkIntSetType *sub, const TkIntSetType *subEnd)
+{
+    while (src < srcEnd && sub < subEnd) {
+	if (*src < *sub) {
+	    *dst++ = *src++;
+	} else {
+	    if (*src == *sub) {
+		++src;
+	    }
+	    ++sub;
+	}
+    }
+
+    if (src < srcEnd) {
+	unsigned size = srcEnd - src;
+	memcpy(dst, src, size*sizeof(TkIntSetType));
+	dst += size;
+    }
+
+    return dst;
+}
+
+
+TkIntSet *
+TkIntSetRemove(
+    TkIntSet *dst,
+    const TkIntSet *src)
+{
+    TkIntSet *set;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(src);
+    assert(dst);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity1 = NextPowerOf2(TkIntSetSize(dst));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = Remove(set->buf, dst->buf, dst->end, src->buf, src->end);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+static TkIntSetType *
+RemoveBits(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkBitField *sub)
+{
+    unsigned size = TkBitSize(sub);
+
+    for ( ; src < srcEnd; ++src) {
+	if (*src >= size) {
+	    break;
+	}
+	if (!TkBitTest(sub, *src)) {
+	    *dst++ = *src;
+	}
+    }
+
+    if ((size = srcEnd - src) > 0) {
+	memcpy(dst, src, size*sizeof(TkIntSetType));
+	dst += size;
+    }
+
+    return dst;
+}
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+
+TkIntSet *
+TkIntSetRemoveBits(
+    TkIntSet *dst,
+    const TkBitField *src)
+{
+    TkIntSet *set;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(src);
+    assert(dst);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity1 = NextPowerOf2(TkIntSetSize(dst));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = RemoveBits(set->buf, dst->buf, dst->end, src);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+
+static TkIntSetType *
+ComplementTo(
+    TkIntSetType *dst,
+    const TkIntSetType *sub, const TkIntSetType *subEnd,
+    const TkIntSetType *src, const TkIntSetType *srcEnd)
+{
+    return Remove(dst, src, srcEnd, sub, subEnd);
+}
+
+
+TkIntSet *
+TkIntSetComplementTo(
+    TkIntSet *dst,
+    const TkIntSet *src)
+{
+    TkIntSet *set;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(src);
+    assert(dst);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity1 = NextPowerOf2(TkIntSetSize(src));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = ComplementTo(set->buf, dst->buf, dst->end, src->buf, src->end);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+static TkIntSetType *
+ComplementToBits(
+    TkIntSetType *dst,
+    const TkIntSetType *sub, const TkIntSetType *subEnd,
+    const TkBitField *src)
+{
+    unsigned i = TkBitFindFirst(src);
+
+    /* dst := src - sub */
+
+    while (sub < subEnd && i != TK_BIT_NPOS) {
+	if (*sub < i) {
+	    ++sub;
+	} else {
+	    if (i < *sub) {
+		*dst++ = i;
+	    } else {
+		++sub;
+	    }
+	    i = TkBitFindNext(src, i);
+	}
+    }
+    for ( ; i != TK_BIT_NPOS; i = TkBitFindNext(src, i)) {
+	*dst++ = i;
+    }
+
+    return dst;
+}
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+
+TkIntSet *
+TkIntSetComplementToBits(
+    TkIntSet *dst,
+    const TkBitField *src)
+{
+    TkIntSet *set;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(src);
+    assert(dst);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity1 = NextPowerOf2(TkBitSize(src));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = ComplementToBits(set->buf, dst->buf, dst->end, src);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+
+static TkIntSetType *
+JoinComplementTo(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkIntSetType *set1, const TkIntSetType *set1End,
+    const TkIntSetType *set2, const TkIntSetType *set2End)
+{
+    /* dst = src + (set2 - set1) */
+
+    while (src < srcEnd && set1 < set1End && set2 < set2End) {
+	if (*set2 < *set1) {
+	    if (*src < *set2) {
+		*dst++ = *src++;
+	    } else if (*src == *set2) {
+		*dst++ = *src++;
+		set2++;
+	    } else {
+		if (*src == *set2) {
+		    ++src;
+		}
+		*dst++ = *set2++;
+	    }
+	} else if (*src < *set1) {
+	    *dst++ = *src++;
+	} else {
+	    if (*set2 == *set1) {
+		set2++;
+	    }
+	    if (*src == *set1) {
+		*dst++ = *src++;
+	    }
+	    set1++;
+	}
+    }
+
+    if (src == srcEnd) {
+	dst = ComplementTo(dst, set1, set1End, set2, set2End);
+    } else if (set2 < set2End) {
+	dst = Join(dst, src, srcEnd, set2, set2End);
+    } else {
+	unsigned size = srcEnd - src;
+	memcpy(dst, src, size*sizeof(TkIntSetType));
+	dst += size;
+    }
+
+    return dst;
+}
+
+
+TkIntSet *
+TkIntSetJoinComplementTo(
+    TkIntSet *dst,
+    const TkIntSet *set1,
+    const TkIntSet *set2)
+{
+    TkIntSet *set;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(dst);
+    assert(set1);
+    assert(set2);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity1 = NextPowerOf2(TkIntSetSize(dst) + TkIntSetSize(set1));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = JoinComplementTo(
+	    set->buf, dst->buf, dst->end, set1->buf, set1->end, set2->buf, set2->end);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+static TkIntSetType *
+JoinNonIntersection(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkIntSetType *set1, const TkIntSetType *set1End,
+    const TkIntSetType *set2, const TkIntSetType *set2End)
+{
+    unsigned size;
+
+    /* dst += src + (set1 - set2) + (set2 - set1) */
+
+    while (src != srcEnd && set1 != set1End && set2 != set2End) {
+	if (*set1 < *set2) {
+	    /* dst += src + set1 */
+	    if (*set1 < *src) {
+		*dst++ = *set1++;
+	    } else {
+		if (*src == *set1) {
+		    ++set1;
+		}
+		*dst++ = *src++;
+	    }
+	} else if (*set2 < *set1) {
+	    /* dst += src + set2 */
+	    if (*set2 < *src) {
+		*dst++ = *set2++;
+	    } else {
+		if (*src == *set2) {
+		    ++set2;
+		}
+		*dst++ = *src++;
+	    }
+	} else {
+	    ++set1;
+	    ++set2;
+	}
+    }
+
+    if (src == srcEnd) {
+	/* dst += (set1 - set2) + (set2 - set1) */
+
+	while (set1 != set1End && set2 != set2End) {
+	    if (*set1 < *set2) {
+		*dst++ = *set1++;
+	    } else if (*set2 < *set1) {
+		*dst++ = *set2++;
+	    } else {
+		++set1;
+		++set2;
+	    }
+	}
+	if (set1 == set1End) {
+	    set1 = set2;
+	    set1End = set2End;
+	}
+
+	/* dst += set1 */
+
+	if ((size = set1End - set1)) {
+	    memcpy(dst, set1, size*sizeof(TkIntSetType));
+	    dst += size;
+	}
+    } else {
+	if (set1 == set1End) {
+	    set1 = set2;
+	    set1End = set2End;
+	}
+
+	/* dst += src + set1 */
+
+	dst = Join(dst, src, srcEnd, set1, set1End);
+    }
+
+    return dst;
+}
+
+
+TkIntSet *
+TkIntSetJoinNonIntersection(
+    TkIntSet *dst,
+    const TkIntSet *set1,
+    const TkIntSet *set2)
+{
+    TkIntSet *set;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(dst);
+    assert(set1);
+    assert(set2);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity1 = NextPowerOf2(TkIntSetSize(dst) + TkIntSetSize(set1) + TkIntSetSize(set2));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = JoinNonIntersection(
+	    set->buf, dst->buf, dst->end, set1->buf, set1->end, set2->buf, set2->end);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+TkIntSet *
+TkIntSetJoin2ComplementToIntersection(
+    TkIntSet *dst,
+    const TkIntSet *add,
+    const TkIntSet *set1,
+    const TkIntSet *set2)
+{
+    TkIntSet *set;
+    const TkIntSetType *set1P;
+    const TkIntSetType *set2P;
+    const TkIntSetType *set1End;
+    const TkIntSetType *set2End;
+    TkIntSetType *res1, *res2, *res3, *res1End, *res2End, *res3End;
+    TkIntSetType buffer[512];
+    unsigned capacity1, capacity2;
+    unsigned size, size1, size2;
+
+    assert(dst);
+    assert(add);
+    assert(set1);
+    assert(set2);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    set1P = set1->buf;
+    set2P = set2->buf;
+    set1End = set1->end;
+    set2End = set2->end;
+
+    size1 = TkIntSetSize(set1) + TkIntSetSize(set2);
+    size2 = MIN(TkIntSetSize(set1), TkIntSetSize(set2));
+    size = size1 + 2*size2;
+    res1 = size <= sizeof(buffer)/sizeof(buffer[0]) ? buffer : malloc(size*sizeof(TkIntSetType));
+    res2 = res1 + size1;
+    res3 = res2 + size2;
+
+    res1End = Join(res1, set1P, set1End, set2P, set2End);
+    res2End = Intersect(res2, set1P, set1End, set2P, set2End);
+    res3End = ComplementTo(res3, res1, res1End, res2, res2End);
+
+    capacity1 = NextPowerOf2(TkIntSetSize(dst) + TkIntSetSize(add) + (res3End - res3));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = Join2(set->buf, dst->buf, dst->end, add->buf, add->end, res3, res3End);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    if (res1 != buffer) {
+	free(res1);
+    }
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+TkIntSet *
+TkIntSetJoinOfDifferences(
+    TkIntSet *dst,
+    const TkIntSet *set1,
+    const TkIntSet *set2)
+{
+    TkIntSet *set;
+    TkIntSetType *buf1, *buf2, *end1, *end2;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(dst);
+    assert(set1);
+    assert(set2);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity2 = TkIntSetSize(dst) + TkIntSetSize(set1);
+    capacity1 = NextPowerOf2(2*capacity2);
+    set = malloc(SET_SIZE(capacity1));
+    buf1 = set->buf + capacity2;
+    buf2 = buf1 + TkIntSetSize(dst);
+    end1 = Remove(buf1, dst->buf, dst->end, set1->buf, set1->end);
+    end2 = Remove(buf2, set1->buf, set1->end, set2->buf, set2->end);
+    set->end = Join(set->buf, buf1, end1, buf2, end2);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+bool
+TkIntSetDisjunctive__(
+    const TkIntSetType *set1, const TkIntSetType *end1,
+    const TkIntSetType *set2, const TkIntSetType *end2)
+{
+    while (set1 != end1 && set2 != end2) {
+	if (*set1 == *set2) {
+	    return false;
+	}
+	if (*set1 < *set2) {
+	    ++set1;
+	} else {
+	    ++set2;
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkIntSetContains__(
+    const TkIntSetType *set1, const TkIntSetType *end1,
+    const TkIntSetType *set2, const TkIntSetType *end2)
+{
+    /*
+     * a in set1, not in set2 -> skip
+     * a in set1, and in set2 -> skip
+     * a in set2, not in set1 -> false
+     */
+
+    if (end1 - set1 < end2 - set2) {
+	return false;
+    }
+
+    while (set1 != end1 && set2 != end2) {
+	if (*set2 < *set1) {
+	    return false;
+	} else if (*set1 == *set2) {
+	    ++set2;
+	}
+	++set1;
+    }
+
+    return set2 == end2;
+}
+
+
+bool
+TkIntSetIsContainedBits(
+    const TkIntSet *set,
+    const TkBitField *bf)
+{
+    unsigned setSize, bitSize, i;
+
+    assert(bf);
+    assert(set);
+
+    setSize = TkIntSetSize(set);
+    bitSize = TkBitSize(bf);
+
+    for (i = 0; i < setSize; ++i) {
+	TkIntSetType value = set->buf[i];
+	if (value >= bitSize || !TkBitTest(bf, value)) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+
+bool
+TkIntSetIntersectionIsEqual(
+    const TkIntSet *set1,
+    const TkIntSet *set2,
+    const TkBitField *del)
+{
+    const TkIntSetType *s1;
+    const TkIntSetType *e1;
+    const TkIntSetType *s2;
+    const TkIntSetType *e2;
+
+    assert(set1);
+    assert(set2);
+    assert(del);
+    assert(TkIntSetMax(set1) < TkBitSize(del));
+    assert(TkIntSetMax(set2) < TkBitSize(del));
+
+    if (set1 == set2) {
+	return true;
+    }
+
+    s1 = set1->buf; e1 = set1->end;
+    s2 = set2->buf; e2 = set2->end;
+
+    while (s1 != e1 && s2 != e2) {
+	if (*s1 == *s2) {
+	    ++s1;
+	    ++s2;
+	} else if (*s1 < *s2) {
+	    if (!TkBitTest(del, *s1)) {
+		return false;
+	    }
+	    ++s1;
+	} else { /* if (*s2 < *s1) */
+	    if (!TkBitTest(del, *s2)) {
+		return false;
+	    }
+	    ++s2;
+	}
+    }
+    for ( ; s1 != e1; ++s1) {
+	if (!TkBitTest(del, *s1)) {
+	    return false;
+	}
+    }
+    for ( ; s2 != e2; ++s2) {
+	if (!TkBitTest(del, *s2)) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkIntSetIntersectionIsEqualBits(
+    const TkIntSet *set,
+    const TkBitField *bf,
+    const TkBitField *del)
+{
+    TkBitField *cp = TkBitCopy(del, -1);
+    bool test;
+
+    assert(set);
+    assert(bf);
+    assert(del);
+    assert(TkIntSetMax(set) < TkBitSize(del));
+    assert(TkBitSize(bf) <= TkBitSize(del));
+
+    TkBitIntersect(cp, bf);
+    test = TkIntSetIsEqualBits(set, cp);
+    TkBitDestroy(&cp);
+    return test;
+}
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+
+static TkIntSet *
+Add(
+    TkIntSet *set,
+    TkIntSetType *pos,
+    unsigned n)
+{
+    unsigned size = set->end - set->buf;
+
+    if (IsPowerOf2(size)) {
+	TkIntSet *newSet = malloc(SET_SIZE(MAX(2*size, 1)));
+	unsigned offs = pos - set->buf;
+
+	assert(offs <= size);
+	memcpy(newSet->buf, set->buf, offs*sizeof(TkIntSetType));
+	memcpy(newSet->buf + offs + 1, pos, (size - offs)*sizeof(TkIntSetType));
+	newSet->end = newSet->buf + size + 1;
+	newSet->refCount = 1;
+	newSet->isSetFlag = true;
+	DEBUG_ALLOC(tkIntSetCountNew++);
+
+	if (--set->refCount == 0) {
+	    free(set);
+	    DEBUG_ALLOC(tkIntSetCountDestroy++);
+	}
+
+	set = newSet;
+	pos = set->buf + offs;
+    } else {
+	memmove(pos + 1, pos, (set->end - pos)*sizeof(TkIntSetType));
+	set->end += 1;
+    }
+
+    *pos = n;
+    return set;
+}
+
+
+TkIntSet *
+TkIntSetAdd(
+    TkIntSet *set,
+    unsigned n)
+{
+    TkIntSetType *pos;
+
+    assert(set);
+    assert(TkIntSetRefCount(set) > 0);
+
+    pos = TkIntSetLowerBound(set->buf, set->end, n);
+
+    if (pos < set->end && *pos == n) {
+	return set;
+    }
+
+    return Add(set, pos, n);
+}
+
+
+static TkIntSet *
+Erase(
+    TkIntSet *set,
+    TkIntSetType *pos,
+    unsigned n)
+{
+    unsigned size = set->end - set->buf - 1;
+
+    if (IsPowerOf2(size)) {
+	TkIntSet *newSet = malloc(SET_SIZE(size));
+	unsigned offs = pos - set->buf;
+
+	memcpy(newSet->buf, set->buf, offs*sizeof(TkIntSetType));
+	memcpy(newSet->buf + offs, pos + 1, (size - offs)*sizeof(TkIntSetType));
+	newSet->end = newSet->buf + size;
+	newSet->refCount = 1;
+	newSet->isSetFlag = true;
+	DEBUG_ALLOC(tkIntSetCountNew++);
+
+	if (--set->refCount == 0) {
+	    free(set);
+	    DEBUG_ALLOC(tkIntSetCountDestroy++);
+	}
+
+	set = newSet;
+    } else {
+	memmove(pos, pos + 1, (set->end - pos - 1)*sizeof(TkIntSetType));
+	set->end -= 1;
+    }
+
+    return set;
+}
+
+
+TkIntSet *
+TkIntSetErase(
+    TkIntSet *set,
+    unsigned n)
+{
+    TkIntSetType *pos;
+
+    assert(set);
+    assert(TkIntSetRefCount(set) > 0);
+
+    pos = TkIntSetLowerBound(set->buf, set->end, n);
+
+    if (pos == set->end || *pos != n) {
+	return set;
+    }
+
+    return Erase(set, pos, n);
+}
+
+
+TkIntSet *
+TkIntSetTestAndSet(
+    TkIntSet *set,
+    unsigned n)
+{
+    TkIntSetType *pos;
+
+    assert(set);
+    assert(TkIntSetRefCount(set) > 0);
+
+    pos = TkIntSetLowerBound(set->buf, set->end, n);
+
+    if (pos < set->end && *pos == n) {
+	return NULL;
+    }
+
+    return Add(set, pos, n);
+}
+
+
+TkIntSet *
+TkIntSetTestAndUnset(
+    TkIntSet *set,
+    unsigned n)
+{
+    TkIntSetType *pos;
+
+    assert(set);
+    assert(TkIntSetRefCount(set) > 0);
+
+    pos = TkIntSetLowerBound(set->buf, set->end, n);
+
+    if (pos == set->end || *pos != n) {
+	return NULL;
+    }
+
+    return Erase(set, pos, n);
+}
+
+
+TkIntSet *
+TkIntSetClear(
+    TkIntSet *set)
+{
+    TkIntSet *newSet;
+
+    assert(set);
+    assert(TkIntSetRefCount(set) > 0);
+
+    if (set->buf == set->end) {
+	return set;
+    }
+
+    newSet = malloc(SET_SIZE(0));
+    newSet->end = newSet->buf;
+    newSet->refCount = 1;
+    newSet->isSetFlag = true;
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (--set->refCount == 0) {
+	free(set);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    return newSet;
+}
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+
+bool
+TkIntSetIsEqualBits(
+    const TkIntSet *set,
+    const TkBitField *bf)
+{
+    unsigned sizeSet, sizeBf, i;
+
+    assert(set);
+    assert(bf);
+
+    sizeSet = TkIntSetSize(set);
+
+    if (sizeSet != TkBitCount(bf)) {
+	return false;
+    }
+
+    sizeBf = TkBitSize(bf);
+
+    for (i = 0; i < sizeSet; ++i) {
+	TkIntSetType value = set->buf[i];
+
+	if (value >= sizeBf || !TkBitTest(bf, value)) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkIntSetContainsBits(
+    const TkIntSet *set,
+    const TkBitField *bf)
+{
+    unsigned sizeSet, sizeBf, i;
+    unsigned count = 0;
+
+    assert(set);
+    assert(bf);
+
+    sizeSet = TkIntSetSize(set);
+    sizeBf = TkBitSize(bf);
+
+    for (i = 0; i < sizeSet; ++i) {
+	TkIntSetType value = set->buf[i];
+
+	if (value >= sizeBf) {
+	    break;
+	}
+
+	if (TkBitTest(bf, value)) {
+	    count += 1;
+	}
+    }
+
+    return count == TkBitCount(bf);
+}
+
+
+bool
+TkIntSetDisjunctiveBits(
+    const TkIntSet *set,
+    const TkBitField *bf)
+{
+    unsigned sizeSet, sizeBf, i;
+
+    assert(set);
+    assert(bf);
+
+    sizeSet = TkIntSetSize(set);
+    sizeBf = TkBitSize(bf);
+
+    for (i = 0; i < sizeSet; ++i) {
+	TkIntSetType value = set->buf[i];
+
+	if (value >= sizeBf) {
+	    return true;
+	}
+	if (TkBitTest(bf, value)) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+
+#if !NDEBUG
+
+# include <stdio.h>
+
+void
+TkIntSetPrint(
+    const TkIntSet *set)
+{
+    unsigned i, n;
+    const char *comma = "";
+
+    assert(set);
+
+    n = TkIntSetSize(set);
+    printf("%d:{ ", n);
+    for (i = 0; i < n; ++i) {
+	printf("%s%d", comma, set->buf[i]);
+	comma = ", ";
+    }
+    printf(" }\n");
+}
+
+#endif /* !NDEBUG */
+
+#if TK_UNUSED_INTSET_FUNCTIONS
+
+/*
+ * These functions are not needed anymore, but shouldn't be removed, because sometimes
+ * any of these functions might be useful.
+ */
+
+static TkIntSetType *
+InnerJoinDifference(
+    TkIntSetType *dst,
+    const TkIntSetType *src, const TkIntSetType *srcEnd,
+    const TkIntSetType *add, const TkIntSetType *addEnd,
+    const TkIntSetType *sub, const TkIntSetType *subEnd)
+{
+    /* dst = (src & add) + (add - sub) */
+
+    while (src != srcEnd && add != addEnd) {
+	if (*src < *add) {
+	    ++src;
+	} else {
+	    if (*src == *add) {
+		*dst++ = *add;
+		++src;
+	    } else {
+		for ( ; sub != subEnd && *sub < *add; ++sub) {
+		    /* empty loop body */
+		}
+		if (sub == subEnd) {
+		    break;
+		}
+		if (*add != *sub) {
+		    *dst++ = *add;
+		}
+	    }
+	    ++add;
+	}
+    }
+
+    if (sub == subEnd) {
+	/* dst += add */
+	unsigned size = addEnd - add;
+	memcpy(dst, add, size*sizeof(TkIntSetType));
+	dst += size;
+    } else if (src == srcEnd) {
+	/* dst += add - sub */
+	dst = Remove(dst, add, addEnd, sub, subEnd);
+    } else { /* if (add == addEnd) */
+	/* dst += nil */
+    }
+
+    return dst;
+}
+
+
+TkIntSet *
+TkIntSetInnerJoinDifference(
+    TkIntSet *dst,
+    const TkIntSet *add,
+    const TkIntSet *sub)
+{
+    TkIntSet *set;
+    unsigned capacity1, capacity2;
+    unsigned size;
+
+    assert(dst);
+    assert(add);
+    assert(sub);
+    assert(TkIntSetRefCount(dst) > 0);
+
+    capacity1 = NextPowerOf2(TkIntSetSize(dst) + TkIntSetSize(add));
+    set = malloc(SET_SIZE(capacity1));
+    set->end = InnerJoinDifference(set->buf, dst->buf, dst->end, add->buf, add->end, sub->buf, sub->end);
+    size = set->end - set->buf;
+    capacity2 = NextPowerOf2(size);
+    assert(capacity2 <= capacity1);
+    DEBUG_ALLOC(tkIntSetCountNew++);
+
+    if (capacity2 < capacity1) {
+	set = realloc(set, SET_SIZE(capacity2));
+	set->end = set->buf + size;
+    }
+
+    if (--dst->refCount == 0) {
+	free(dst);
+	DEBUG_ALLOC(tkIntSetCountDestroy++);
+    }
+
+    set->refCount = 1;
+    set->isSetFlag = true;
+    return set;
+}
+
+
+bool
+TkIntSetInnerJoinDifferenceIsEmpty(
+    const TkIntSet *set,
+    const TkIntSet *add,
+    const TkIntSet *sub)
+{
+    const TkIntSetType *setP, *setEnd;
+    const TkIntSetType *addP, *addEnd;
+    const TkIntSetType *subP, *subEnd;
+
+    assert(set);
+    assert(add);
+    assert(sub);
+
+    /* (set & add) + (add - sub) == nil */
+
+    if (add->buf == add->end) {
+	/* nil */
+	return true;
+    }
+
+    if (add == set) {
+	/* add == nil */
+	return TkIntSetIsEmpty(add);
+    }
+
+    setP = set->buf; setEnd = set->end;
+    addP = add->buf; addEnd = add->end;
+
+    /* (set & add) == nil */
+
+    while (setP != setEnd && addP < addEnd) {
+	if (*setP == *addP) {
+	    return false;
+	} else if (*setP < *addP) {
+	    ++setP;
+	} else {
+	    ++addP;
+	}
+    }
+
+    /* (add - sub) == nil */
+
+    addP = add->buf; addEnd = add->end;
+    subP = sub->buf; subEnd = sub->end;
+
+    while (addP != addEnd && subP != subEnd) {
+	if (*addP < *subP) {
+	    return false;
+	} else if (*addP == *subP) {
+	    ++addP;
+	}
+	++subP;
+    }
+
+    return addP == addEnd;
+}
+
+
+static bool
+DifferenceIsEmpty(
+    const TkIntSetType *set, const TkIntSetType *setEnd,
+    const TkIntSetType *sub, const TkIntSetType *subEnd)
+{
+    while (set != setEnd && sub != subEnd) {
+	if (*set < *sub) {
+	    return false;
+	} else {
+	    if (*set == *sub) {
+		++set;
+	    }
+	    ++sub;
+	}
+    }
+
+    return set == setEnd;
+}
+
+
+bool
+TkIntSetIsEqualToDifference(
+    const TkIntSet *set1,
+    const TkIntSet *set2,
+    const TkIntSet *sub2)
+{
+    const TkIntSetType *set1P, *set1End;
+    const TkIntSetType *set2P, *set2End;
+    const TkIntSetType *sub2P, *sub2End;
+
+    assert(set1);
+    assert(set2);
+    assert(sub2);
+
+    if (set2->buf == set2->end) {
+	return set1->buf == set1->end;
+    }
+
+    set1P = set1->buf; set1End = set1->end;
+    set2P = set2->buf; set2End = set2->end;
+    sub2P = sub2->buf; sub2End = sub2->end;
+
+    if (set1P == set1End) {
+	return DifferenceIsEmpty(set2P, set2End, sub2P, sub2End);
+    }
+
+    /* set1 == set2 - sub2 */
+
+    while (set1P != set1End && set2P != set2End) {
+	if (*set1P < *set2P) {
+	    return false;
+	}
+	for ( ; sub2P != sub2End && *sub2P < *set2P; ++sub2P) {
+	    /* empty loop body */
+	}
+	if (sub2P == sub2End) {
+	    break;
+	}
+	if (*set1P == *set2P) {
+	    if (*set2P == *sub2P) {
+		return false;
+	    }
+	    ++set1P;
+	} else {
+	    if (*set2P != *sub2P) {
+		return false;
+	    }
+	}
+	++set2P;
+    }
+
+    if (set2P == set2End) {
+	/* set1 == nil */
+	return set1P == set1End;
+    }
+
+    if (sub2P == sub2End) {
+	/* set1 == set2 */
+	return TestIfEqual(set1P, set1End, set2P, set2End);
+    }
+
+    assert(set1P == set1End);
+    /* set2 - sub2 == nil */
+
+    return DifferenceIsEmpty(set2P, set2End, sub2P, sub2End);
+}
+
+
+bool
+TkIntSetIsEqualToInnerJoin(
+    const TkIntSet *set1,
+    const TkIntSet *set2,
+    const TkIntSet *add2)
+{
+    const TkIntSetType *set1P, *set1End;
+    const TkIntSetType *set2P, *set2End;
+    const TkIntSetType *add2P, *add2End;
+
+    assert(set1);
+    assert(set2);
+    assert(add2);
+
+    if (set1 == set2) {
+	/* set1 == (set1 + (add2 & set1)) */
+	return true;
+    }
+
+    set1P = set1->buf; set1End = set1->end;
+    set2P = set2->buf; set2End = set2->end;
+
+    if (set2P == set2End) {
+	/* set1 == nil */
+	return set1P == set1End;
+    }
+
+    if (set2 == add2) {
+	/* set1 == set2 */
+	return TestIfEqual(set1P, set1End, set2P, set2End);
+    }
+
+    add2P = add2->buf; add2End = add2->end;
+
+    /* set1 == (set2 + (add2 & set2)) */
+
+    while (set1P != set1End && set2P != set2End && add2P != add2End) {
+	if (*set2P < *set1P) {
+	    return false;
+	} else if (*set1P == *set2P) {
+	    ++set1P;
+	    ++set2P;
+	/* now: *set1P < *set2P */
+	} else if (*add2P < *set2P) {
+	    ++add2P;
+	} else if (*set2P < *add2P) {
+	    ++set2P;
+	} else {
+	    return false;
+	}
+    }
+
+    if (add2P == add2End) {
+	/* set1 == set2 */
+	return TestIfEqual(set1P, set1End, set2P, set2End);
+    }
+
+    if (set1P == set1End) {
+	/* set2 == nil */
+	return set2P == set2End;
+    }
+
+    /* set2P == set2End: set1 == nil */
+    return set1P == set1End;
+}
+
+
+static bool
+EqualToJoin(
+    const TkIntSetType *src, const TkIntSetType *send,
+    const TkIntSetType *set1, const TkIntSetType *end1,
+    const TkIntSetType *set2, const TkIntSetType *end2)
+{
+    /* src == set1 + set2 */
+
+    assert(src != send);
+
+    while (set1 != end1 && set2 != end2) {
+	if (*src == *set1) {
+	    if (*src == *set2) {
+		++set2;
+	    }
+	    ++set1;
+	} else if (*src == *set2) {
+	    ++set2;
+	} else {
+	    return false;
+	}
+	if (++src == send) {
+	    return set1 == end1 && set2 == end2;
+	}
+    }
+
+    if (set1 == end1) {
+	set1 = set2;
+	end1 = end2;
+    }
+
+    return TestIfEqual(src, send, set1, end1);
+}
+
+
+bool
+TkIntSetIsEqualToInnerJoinDifference(
+    const TkIntSet *set1,
+    const TkIntSet *set2,
+    const TkIntSet *add2,
+    const TkIntSet *sub2)
+{
+    TkIntSetType buf1[100];
+    TkIntSetType buf2[100];
+    TkIntSetType *inscBuf; /* set2 & add2 */
+    TkIntSetType *diffBuf; /* add2 - sub2 */
+    TkIntSetType *inscP, *inscEnd;
+    TkIntSetType *diffP, *diffEnd;
+    unsigned inscSize;
+    unsigned diffSize;
+    bool isEqual;
+
+    assert(set1);
+    assert(set2);
+    assert(add2);
+    assert(sub2);
+
+    /* set1 == (set2 & add2) + (add2 - sub2) */
+
+    if (add2->buf == add2->end) {
+	/* set1 == nil */
+	return TkIntSetIsEmpty(set1);
+    }
+
+    if (sub2->buf == sub2->end) {
+	/* set1 == (set2 & add2) + add2 */
+	return TkIntSetIsEqualToInnerJoin(set1, add2, set2);
+    }
+
+    if (set1->buf == set1->end) {
+	/* (set2 & add2) + (add2 - sub2) == nil */
+	return TkIntSetDisjunctive(set2, add2)
+		&& DifferenceIsEmpty(add2->buf, add2->end, sub2->buf, sub2->end);
+    }
+
+    diffSize = TkIntSetSize(add2);
+    inscSize = MIN(TkIntSetSize(set2), diffSize);
+    inscBuf = inscSize <= sizeof(buf1)/sizeof(buf1[0]) ? buf1 : malloc(inscSize*sizeof(buf1[0]));
+    inscEnd = Intersect(inscP = inscBuf, set2->buf, set2->end, add2->buf, add2->end);
+
+    if (inscP == inscEnd) {
+	/* set1 == (add2 - sub2) */
+	isEqual = TkIntSetIsEqualToDifference(set1, add2, sub2);
+    } else {
+	diffBuf = diffSize <= sizeof(buf2)/sizeof(buf2[0]) ? buf2 : malloc(diffSize*sizeof(buf2[0]));
+	diffEnd = Remove(diffP = diffBuf, add2->buf, add2->end, sub2->buf, sub2->end);
+
+	if (diffP == diffEnd) {
+	    /* set1 == inscP */
+	    isEqual = TestIfEqual(set1->buf, set1->end, inscP, inscEnd);
+	} else {
+	    /* set1 == inscP + diffP */
+	    isEqual = EqualToJoin(set1->buf, set1->end, inscP, inscEnd, diffP, diffEnd);
+	}
+
+	if (diffBuf != buf2) { free(diffBuf); }
+    }
+
+    if (inscBuf != buf1) { free(inscBuf); }
+
+    return isEqual;
+}
+
+
+static bool
+InnerJoinDifferenceIsEqual(
+    const TkIntSetType *set, const TkIntSetType *setEnd,
+    const TkIntSetType *add, const TkIntSetType *addEnd,
+    const TkIntSetType *sub, const TkIntSetType *subEnd)
+{
+    /*
+     * (add - sub) == (set & add) + (add - sub)
+     *
+     * This is equivalent to:
+     * (add - sub) & add == (set + (add - sub)) & add
+     *
+     * This means we have to show:
+     * For any x in add: x in (add - sub) <=> x in (set + (add - sub))
+     *
+     * So it's sufficient to show:
+     * For any x in add: x in sub => x not in set
+     * For any x in add: x in set => x not in sub
+     *
+     * But this is equivalent to:
+     * (sub & add) & (set & add) == nil
+     */
+
+    if (add != addEnd) {
+	while (set != setEnd && sub != subEnd) {
+	    if (*set == *sub) {
+		while (*add < *set) {
+		    if (++add == addEnd) {
+			return true;
+		    }
+		}
+		if (*add == *set) {
+		    return false;
+		}
+		++set;
+		++sub;
+	    } else if (*set < *sub) {
+		++set;
+	    } else {
+		++sub;
+	    }
+	}
+    }
+
+    return true;
+}
+
+
+bool
+TkIntSetInnerJoinDifferenceIsEqual(
+    const TkIntSet *set1,
+    const TkIntSet *set2,
+    const TkIntSet *add,
+    const TkIntSet *sub)
+{
+    const TkIntSetType *set1P, *set1End;
+    const TkIntSetType *set2P, *set2End;
+    const TkIntSetType *addP, *addEnd;
+    const TkIntSetType *subP, *subEnd;
+
+    if (add->buf == add->end) {
+	return true;
+    }
+
+    set1P = set1->buf; set1End = set1->end;
+    set2P = set2->buf; set2End = set2->end;
+    addP = add->buf; addEnd = add->end;
+    subP = sub->buf; subEnd = sub->end;
+
+    if (set1P == set1End) {
+	return InnerJoinDifferenceIsEqual(set2P, set2End, addP, addEnd, subP, subEnd);
+    }
+    if (set2P == set2End) {
+	return InnerJoinDifferenceIsEqual(set1P, set1End, addP, addEnd, subP, subEnd);
+    }
+
+    /*
+     * (set1 & add) + (add - sub) == (set2 & add) + (add - sub)
+     *
+     * This is equivalent to:
+     * (set1 + (add - sub)) & add == (set2 + (add - sub)) & add
+     *
+     * This means we have to show:
+     * For any x in add: x in (set1 + (add - sub)) <=> x in (set2 + (add - sub))
+     *
+     * x in (add & sub): Proof: x in set1 <=> x in set2.
+     * x in (add - sub): Nothing to proof.
+     */
+
+    while (addP != addEnd && subP != subEnd) {
+	if (*addP < *subP) {
+	    ++addP;
+	} else {
+	    if (*addP == *subP) {
+		/* x in (add & sub): Proof: x in set1 <=> x in set2. */
+		for ( ; set1P != set1End && *set1P < *addP; ++set1P) {
+		    /* empty loop body */
+		}
+		if (set1P == set1End) {
+		    /* (add - sub) == (set2 & add) + (add - sub) */
+		    return InnerJoinDifferenceIsEqual(set2P, set2End, addP, addEnd, subP, subEnd);
+		}
+		for ( ; set2P != set2End && *set2P < *addP; ++set2P) {
+		    /* empty loop body */
+		}
+		if (set2P == set2End) {
+		    /* (add - sub) == (set1 & add) + (add - sub) */
+		    return InnerJoinDifferenceIsEqual(set1P, set1End, addP, addEnd, subP, subEnd);
+		}
+		if (*addP == *set1P) {
+		    if (*addP != *set2P) {
+			return false;
+		    }
+		    ++set1P;
+		    ++set2P;
+		} else if (*addP == *set2P) {
+		    return false;
+		}
+		++addP;
+	    }
+	    ++subP;
+	}
+    }
+
+    return true;
+}
+
+#endif /* TK_UNUSED_INTSET_FUNCTIONS */
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+/* Additionally we need stand-alone object code. */
+#define inline extern
+inline unsigned TkIntSetByteSize(const TkIntSet *set);
+inline const unsigned char *TkIntSetData(const TkIntSet *set);
+inline bool TkIntSetIsEmpty(const TkIntSet *set);
+inline unsigned TkIntSetSize(const TkIntSet *set);
+inline unsigned TkIntSetMax(const TkIntSet *set);
+inline unsigned TkIntSetRefCount(const TkIntSet *set);
+inline void TkIntSetIncrRefCount(TkIntSet *set);
+inline unsigned TkIntSetDecrRefCount(TkIntSet *set);
+inline TkIntSetType TkIntSetAccess(const TkIntSet *set, unsigned index);
+inline bool TkIntSetTest(const TkIntSet *set, unsigned n);
+inline bool TkIntSetNone(const TkIntSet *set);
+inline bool TkIntSetAny(const TkIntSet *set);
+inline bool TkIntSetIsEqual(const TkIntSet *set1, const TkIntSet *set2);
+inline bool TkIntSetContains(const TkIntSet *set1, const TkIntSet *set2);
+inline bool TkIntSetDisjunctive(const TkIntSet *set1, const TkIntSet *set2);
+inline bool TkIntSetIntersects(const TkIntSet *set1, const TkIntSet *set2);
+inline unsigned TkIntSetFindFirst(const TkIntSet *set);
+inline unsigned TkIntSetFindNext(const TkIntSet *set);
+inline TkIntSet *TkIntSetAddOrErase(TkIntSet *set, unsigned n, bool add);
+#endif /* __STDC_VERSION__ >= 199901L */
+
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkIntSet.h
===================================================================
--- src/tktext/tkIntSet.h	(revision 0)
+++ src/tktext/tkIntSet.h	(working copy)
@@ -0,0 +1,199 @@
+/*
+ * tkSet.h --
+ *
+ *	This module implements an integer set.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKINTSET
+#define _TKINTSET
+
+#ifndef _TK
+#include "tk.h"
+#endif
+
+#include "tkBool.h"
+#include <stdint.h>
+
+#if defined(__GNUC__) || defined(__clang__)
+# define __warn_unused__ __attribute__((warn_unused_result))
+#else
+# define __warn_unused__
+#endif
+
+#ifdef _MSC_VER
+# if _MSC_VER >= 1900
+#  define inline __inline
+# else
+#  define inline
+# endif
+#elif __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+struct TkBitField;
+
+
+typedef uint32_t TkIntSetType;
+
+/*
+ * The struct below will be shared with the struct TkBitField, so the first two
+ * members must exactly match the first two members in struct TkBitField. In this
+ * way we have a struct inheritance, based on the first two members. This
+ * is portable due to C99 section 6.7.2.1 bullet point 13:
+ *
+ *	Within a structure object, the non-bit-field members and the units 
+ *	in which bit-fields reside have addresses that increase in the order
+ *	in which they are declared. A pointer to a structure object, suitably
+ *	converted, points to its initial member (or if that member is a
+ *	bit-field, then to the unit in which it resides), and vice versa.
+ *	There may be unnamed padding within a structure object, but not at
+ *	beginning.
+ *
+ * This inheritance concept is also used in the portable GTK library.
+ */
+
+typedef struct TkIntSet {
+    uint32_t refCount:31;
+    uint32_t isSetFlag:1;
+    TkIntSetType *end;
+    TkIntSetType *curr; /* mutable */
+    TkIntSetType buf[1];
+} TkIntSet;
+
+
+#define TK_SET_NPOS ((unsigned) -1)
+
+
+TkIntSet *TkIntSetNew();
+#if !TK_TEXT_DONT_USE_BITFIELDS
+TkIntSet *TkIntSetFromBits(const struct TkBitField *bf);
+#endif
+void TkIntSetDestroy(TkIntSet **setPtr);
+
+inline unsigned TkIntSetByteSize(const TkIntSet *set);
+inline const unsigned char *TkIntSetData(const TkIntSet *set);
+
+TkIntSet *TkIntSetCopy(const TkIntSet *set) __warn_unused__;
+
+TkIntSet *TkIntSetJoin(TkIntSet *dst, const TkIntSet *src) __warn_unused__;
+TkIntSet *TkIntSetIntersect(TkIntSet *dst, const TkIntSet *src) __warn_unused__;
+TkIntSet *TkIntSetRemove(TkIntSet *dst, const TkIntSet *src) __warn_unused__;
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+TkIntSet *TkIntSetJoinBits(TkIntSet *dst, const struct TkBitField *src) __warn_unused__;
+TkIntSet *TkIntSetIntersectBits(TkIntSet *dst, const struct TkBitField *src) __warn_unused__;
+TkIntSet *TkIntSetRemoveBits(TkIntSet *dst, const struct TkBitField *src) __warn_unused__;
+/* dst := src - dst */
+TkIntSet *TkIntSetComplementToBits(TkIntSet *dst, const struct TkBitField *src) __warn_unused__;
+#endif
+
+/* dst := dst + set1 + set2 */
+TkIntSet *TkIntSetJoin2(TkIntSet *dst, const TkIntSet *set1, const TkIntSet *set2) __warn_unused__;
+/* dst := src - dst */
+TkIntSet *TkIntSetComplementTo(TkIntSet *dst, const TkIntSet *src) __warn_unused__;
+/* dst := dst + (set2 - set1) */
+TkIntSet *TkIntSetJoinComplementTo(TkIntSet *dst, const TkIntSet *set1, const TkIntSet *set2)
+    __warn_unused__;
+/* dst := dst + (set1 - set2) + (set2 - set1) */
+TkIntSet *TkIntSetJoinNonIntersection(TkIntSet *dst, const TkIntSet *set1, const TkIntSet *set2)
+    __warn_unused__;
+/* dst := dst + add + ((set1 + set2) - (set1 & set2)) */
+TkIntSet *TkIntSetJoin2ComplementToIntersection(TkIntSet *dst,
+    const TkIntSet *add, const TkIntSet *set1, const TkIntSet *set2) __warn_unused__;
+/* dst := (dst - set1) + (set1 - set2) */
+TkIntSet *TkIntSetJoinOfDifferences(TkIntSet *dst, const TkIntSet *set1, const TkIntSet *set2)
+    __warn_unused__;
+
+inline bool TkIntSetIsEmpty(const TkIntSet *set);
+inline unsigned TkIntSetSize(const TkIntSet *set);
+inline unsigned TkIntSetMax(const TkIntSet *set);
+
+inline unsigned TkIntSetRefCount(const TkIntSet *set);
+inline void TkIntSetIncrRefCount(TkIntSet *set);
+inline unsigned TkIntSetDecrRefCount(TkIntSet *set);
+
+inline TkIntSetType TkIntSetAccess(const TkIntSet *set, unsigned index);
+
+inline bool TkIntSetTest(const TkIntSet *set, unsigned n);
+inline bool TkIntSetNone(const TkIntSet *set);
+inline bool TkIntSetAny(const TkIntSet *set);
+
+inline bool TkIntSetIsEqual(const TkIntSet *set1, const TkIntSet *set2);
+inline bool TkIntSetContains(const TkIntSet *set1, const TkIntSet *set2);
+inline bool TkIntSetDisjunctive(const TkIntSet *set1, const TkIntSet *set2);
+inline bool TkIntSetIntersects(const TkIntSet *set1, const TkIntSet *set2);
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+bool TkIntSetIntersectionIsEqual(const TkIntSet *set1, const TkIntSet *set2,
+    const struct TkBitField *del);
+bool TkIntSetIsEqualBits(const TkIntSet *set, const struct TkBitField *bf);
+bool TkIntSetContainsBits(const TkIntSet *set, const struct TkBitField *bf);
+bool TkIntSetDisjunctiveBits(const TkIntSet *set, const struct TkBitField *bf);
+bool TkIntSetIntersectionIsEqualBits(const TkIntSet *set, const struct TkBitField *bf,
+    const struct TkBitField *del);
+bool TkIntSetIsContainedBits(const TkIntSet *set, const struct TkBitField *bf);
+#endif
+
+inline unsigned TkIntSetFindFirst(const TkIntSet *set);
+inline unsigned TkIntSetFindNext(const TkIntSet *set);
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+unsigned TkIntSetFindFirstInIntersection(const TkIntSet *set, const struct TkBitField *bf);
+#endif
+
+TkIntSet *TkIntSetAdd(TkIntSet *set, unsigned n) __warn_unused__;
+TkIntSet *TkIntSetErase(TkIntSet *set, unsigned n) __warn_unused__;
+TkIntSet *TkIntSetTestAndSet(TkIntSet *set, unsigned n) __warn_unused__;
+TkIntSet *TkIntSetTestAndUnset(TkIntSet *set, unsigned n) __warn_unused__;
+inline TkIntSet *TkIntSetAddOrErase(TkIntSet *set, unsigned n, bool add) __warn_unused__;
+TkIntSet *TkIntSetClear(TkIntSet *set) __warn_unused__;
+
+#if !NDEBUG
+void TkIntSetPrint(const TkIntSet *set);
+#endif
+
+
+#if TK_UNUSED_INTSET_FUNCTIONS
+
+/*
+ * These functions are not needed anymore, but shouldn't be removed, because sometimes
+ * any of these functions might be useful.
+ */
+
+/* dst := (dst + (set - sub)) & set */
+TkIntSet *TkIntSetInnerJoinDifference(TkIntSet *dst, const TkIntSet *set, const TkIntSet *sub)
+    __warn_unused__;
+/* ((set + (add - sub)) & add) == nil */
+bool TkIntSetInnerJoinDifferenceIsEmpty(const TkIntSet *set, const TkIntSet *add, const TkIntSet *sub);
+/* set1 == set2 - sub2 */
+bool TkIntSetIsEqualToDifference(const TkIntSet *set1, const TkIntSet *set2, const TkIntSet *sub2);
+/* set1 == set2 + (add2 & set2) */
+bool TkIntSetIsEqualToInnerJoin(const TkIntSet *set1, const TkIntSet *set2, const TkIntSet *add2);
+/* set1 == ((set2 + (add2 - sub2)) & add2) */
+bool TkIntSetIsEqualToInnerJoinDifference(const TkIntSet *set1, const TkIntSet *set2,
+    const TkIntSet *add2, const TkIntSet *sub2);
+/* ((set1 + (add - sub)) & add) == ((set2 + (add - sub)) & add) */
+bool TkIntSetInnerJoinDifferenceIsEqual(const TkIntSet *set1, const TkIntSet *set2,
+    const TkIntSet *add, const TkIntSet *sub);
+
+#endif /* TK_UNUSED_INTSET_FUNCTIONS */
+
+
+#undef __warn_unused__
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+# define _TK_NEED_IMPLEMENTATION
+#include "tkIntSetPriv.h"
+# undef _TK_NEED_IMPLEMENTATION
+#else
+# undef inline
+#endif
+
+#endif /* _TKINTSET */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkIntSetPriv.h
===================================================================
--- src/tktext/tkIntSetPriv.h	(revision 0)
+++ src/tktext/tkIntSetPriv.h	(working copy)
@@ -0,0 +1,280 @@
+/*
+ * tkIntSetPriv.h --
+ *
+ *	Private implementation for integer set.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKINTSET
+# error "do not include this private header file"
+#endif
+
+
+#ifndef _TKINTSETPRIV
+#define _TKINTSETPRIV
+
+MODULE_SCOPE bool TkIntSetContains__(
+    const TkIntSetType *set1, const TkIntSetType *end1,
+    const TkIntSetType *set2, const TkIntSetType *end2);
+MODULE_SCOPE bool TkIntSetDisjunctive__(
+    const TkIntSetType *set1, const TkIntSetType *end1,
+    const TkIntSetType *set2, const TkIntSetType *end2);
+MODULE_SCOPE bool TkIntSetIsEqual__(
+    const TkIntSetType *set1, const TkIntSetType *end1,
+    const TkIntSetType *set2, const TkIntSetType *end2);
+
+#endif /* _TKINTSETPRIV */
+
+
+#ifdef _TK_NEED_IMPLEMENTATION
+
+#include <assert.h>
+
+#if __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+extern TkIntSetType *
+TkIntSetLowerBound(
+    TkIntSetType *first,
+    TkIntSetType *last,
+    TkIntSetType value);
+
+
+inline
+const unsigned char *
+TkIntSetData(
+    const TkIntSet *set)
+{
+    assert(set);
+    return (const void *) set->buf;
+}
+
+
+inline
+unsigned
+TkIntSetByteSize(
+    const TkIntSet *set)
+{
+    assert(set);
+    return (set->end - set->buf)*sizeof(TkIntSetType);
+}
+
+
+inline
+bool
+TkIntSetIsEmpty(
+    const TkIntSet *set)
+{
+    assert(set);
+    return set->end == set->buf;
+}
+
+
+inline
+bool
+TkIntSetIsEqual(
+    const TkIntSet *set1,
+    const TkIntSet *set2)
+{
+    assert(set1);
+    assert(set2);
+
+    return set1 == set2 || TkIntSetIsEqual__(set1->buf, set1->end, set2->buf, set2->end);
+}
+
+
+inline
+bool
+TkIntSetContains(
+    const TkIntSet *set1,
+    const TkIntSet *set2)
+{
+    assert(set1);
+    assert(set2);
+
+    return set1 == set2 || TkIntSetContains__(set1->buf, set1->end, set2->buf, set2->end);
+}
+
+
+inline
+bool
+TkIntSetDisjunctive(
+    const TkIntSet *set1,
+    const TkIntSet *set2)
+{
+    assert(set1);
+    assert(set2);
+
+    if (set1 == set2) {
+	return TkIntSetIsEmpty(set1);
+    }
+    return TkIntSetDisjunctive__(set1->buf, set1->end, set2->buf, set2->end);
+}
+
+
+inline
+unsigned
+TkIntSetSize(
+    const TkIntSet *set)
+{
+    assert(set);
+    return set->end - set->buf;
+}
+
+
+inline
+unsigned
+TkIntSetMax(
+    const TkIntSet *set)
+{
+    assert(!TkIntSetIsEmpty(set));
+    return set->end[-1];
+}
+
+
+inline
+unsigned
+TkIntSetRefCount(
+    const TkIntSet *set)
+{
+    assert(set);
+    return set->refCount;
+}
+
+
+inline
+void
+TkIntSetIncrRefCount(TkIntSet *set)
+{
+    assert(set);
+    set->refCount += 1;
+}
+
+
+inline
+unsigned
+TkIntSetDecrRefCount(TkIntSet *set)
+{
+    unsigned refCount;
+
+    assert(set);
+    assert(set->refCount > 0);
+
+    if ((refCount = --set->refCount) == 0) {
+	TkIntSetDestroy(&set);
+    }
+    return refCount;
+}
+
+
+inline
+TkIntSetType
+TkIntSetAccess(
+    const TkIntSet *set,
+    unsigned index)
+{
+    assert(set);
+    assert(index < TkIntSetSize(set));
+    return set->buf[index];
+}
+
+
+inline
+void
+TkIntSetChange(
+    TkIntSet *set,
+    unsigned index,
+    unsigned n)
+{
+    assert(set);
+    assert(index < TkIntSetSize(set));
+    set->buf[index] = n;
+}
+
+
+inline
+bool
+TkIntSetTest(
+    const TkIntSet *set,
+    unsigned n)
+{
+    const TkIntSetType *pos;
+
+    assert(set);
+
+    pos = TkIntSetLowerBound(((TkIntSet *) set)->buf, ((TkIntSet *) set)->end, n);
+    return pos < set->end && *pos == n;
+}
+
+
+inline
+bool
+TkIntSetNone(
+    const TkIntSet *set)
+{
+    assert(set);
+    return set->buf == set->end;
+}
+
+
+inline
+bool
+TkIntSetAny(
+    const TkIntSet *set)
+{
+    assert(set);
+    return set->buf < set->end;
+}
+
+
+inline
+bool
+TkIntSetIntersects(
+    const TkIntSet *set1,
+    const TkIntSet *set2)
+{
+    return !TkIntSetDisjunctive(set1, set2);
+}
+
+
+inline
+unsigned
+TkIntSetFindNext(
+    const TkIntSet *set)
+{
+    assert(set);
+    return set->curr == set->end ? TK_SET_NPOS : *(((TkIntSet *) set)->curr++); /* 'curr' is mutable */
+}
+
+
+inline
+unsigned
+TkIntSetFindFirst(
+    const TkIntSet *set)
+{
+    assert(set);
+    ((TkIntSet *) set)->curr = ((TkIntSet *) set)->buf; /* 'curr' is mutable */
+    return TkIntSetFindNext(set);
+}
+
+
+inline
+TkIntSet *
+TkIntSetAddOrErase(
+    TkIntSet *set,
+    unsigned n,
+    bool add)
+{
+    assert(set);
+    return add ? TkIntSetAdd(set, n) : TkIntSetErase(set, n);
+}
+
+#undef _TK_NEED_IMPLEMENTATION
+#endif /* _TK_NEED_IMPLEMENTATION */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkMisc.c
===================================================================
--- src/tktext/tkMisc.c	(revision 0)
+++ src/tktext/tkMisc.c	(working copy)
@@ -0,0 +1,1312 @@
+/* tkMisc.c
+ *
+ * Provides some replacement functions to support the integration of
+ * the revised text widget in applications/external libraries. Only
+ * Tk_FontObjCmd() has not been re-implemented, this means that resolving
+ * font names in command "inspect" does not work.
+ */
+
+#include "tk.h"
+#include "tkInt.h"
+
+
+typedef struct PixelRep {
+    double value;
+    int units;
+} PixelRep;
+
+
+#if TK_MAJOR_VERSION > 8 \
+	|| (TK_MAJOR_VERSION == 8 \
+	    && (TK_MINOR_VERSION > 6 || (TK_MINOR_VERSION == 6 && TK_RELEASE_SERIAL >= 6)))
+
+void
+TkSendVirtualEvent(
+    Tk_Window target,
+    const char *eventName,
+    Tcl_Obj *detail)
+{
+    union {XEvent general; XVirtualEvent virtual;} event;
+
+    memset(&event, 0, sizeof(event));
+    event.general.xany.type = VirtualEvent;
+    event.general.xany.serial = NextRequest(Tk_Display(target));
+    event.general.xany.send_event = False;
+    event.general.xany.window = Tk_WindowId(target);
+    event.general.xany.display = Tk_Display(target);
+    event.virtual.name = Tk_GetUid(eventName);
+    event.virtual.user_data = detail;
+
+    Tk_QueueWindowEvent(&event.general, TCL_QUEUE_TAIL);
+}
+
+#else
+
+void
+TkSendVirtualEvent(
+    Tk_Window target,
+    const char *eventName)
+{
+    union {XEvent general; XVirtualEvent virtual;} event;
+
+    memset(&event, 0, sizeof(event));
+    event.general.xany.type = VirtualEvent;
+    event.general.xany.serial = NextRequest(Tk_Display(target));
+    event.general.xany.send_event = False;
+    event.general.xany.window = Tk_WindowId(target);
+    event.general.xany.display = Tk_Display(target);
+    event.virtual.name = Tk_GetUid(eventName);
+
+    Tk_QueueWindowEvent(&event.general, TCL_QUEUE_TAIL);
+}
+
+#endif
+
+
+Tcl_Obj*
+TkNewWindowObj(
+	Tk_Window tkwin)
+{
+    return Tcl_NewStringObj(Tk_PathName(tkwin), -1);
+}
+
+
+int
+TkpAlwaysShowSelection(
+    Tk_Window tkwin)
+{
+    return ((TkWindow *) tkwin)->mainPtr->alwaysShowSelection;
+}
+
+
+static int
+SetPixelFromAny(
+    Tcl_Interp *interp,		/* Used for error reporting if not NULL. */
+    Tcl_Obj *objPtr,		/* The object to convert. */
+    PixelRep *pixelPtr)
+{
+    const char *string;
+    char *rest;
+    double d;
+    int i, units;
+
+    string = Tcl_GetString(objPtr);
+
+    d = strtod(string, &rest);
+    if (rest == string) {
+	goto error;
+    }
+    while ((*rest != '\0') && isspace(UCHAR(*rest))) {
+	rest++;
+    }
+
+    switch (*rest) {
+    case '\0':
+	units = -1;
+	break;
+    case 'm':
+	units = 0;
+	break;
+    case 'c':
+	units = 1;
+	break;
+    case 'i':
+	units = 2;
+	break;
+    case 'p':
+	units = 3;
+	break;
+    default:
+	goto error;
+    }
+
+    /*
+     * Free the old internalRep before setting the new one.
+     */
+
+    i = (int) d;
+    if ((units < 0) && (i == d)) {
+	pixelPtr->value = i;
+	pixelPtr->units = -1;
+    } else {
+	pixelPtr->value = d;
+	pixelPtr->units = units;
+    }
+    return TCL_OK;
+
+  error:
+    if (interp != NULL) {
+	Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		"bad screen distance \"%.50s\"", string));
+	Tcl_SetErrorCode(interp, "TK", "VALUE", "PIXELS", NULL);
+    }
+    return TCL_ERROR;
+}
+
+
+static int
+GetPixelsFromObjEx(
+    Tcl_Interp *interp, 	/* Used for error reporting if not NULL. */
+    Tk_Window tkwin,
+    Tcl_Obj *objPtr,		/* The object from which to get pixels. */
+    double *dblPtr)		/* Places to store resulting pixels. */
+{
+    int result;
+    PixelRep pixelRep = { 0.0, -1 };
+    double d;
+    static const double bias[] = {
+	1.0,	10.0,	25.4,	0.35278 /*25.4 / 72.0*/
+    };
+
+    result = SetPixelFromAny(interp, objPtr, &pixelRep);
+    if (result != TCL_OK) {
+	return result;
+    }
+
+    d = pixelRep.value;
+    if (pixelRep.units >= 0) {
+	d *= bias[pixelRep.units] * WidthOfScreen(Tk_Screen(tkwin));
+	d /= WidthMMOfScreen(Tk_Screen(tkwin));
+    }
+    *dblPtr = d;
+    return TCL_OK;
+}
+
+
+int
+Tk_GetDoublePixelsFromObj(
+    Tcl_Interp *interp, 	/* Used for error reporting if not NULL. */
+    Tk_Window tkwin,
+    Tcl_Obj *objPtr,		/* The object from which to get pixels. */
+    double *doublePtr)		/* Place to store resulting pixels. */
+{
+    double d;
+    int result;
+
+    result = GetPixelsFromObjEx(interp, tkwin, objPtr, &d);
+    if (result != TCL_OK) {
+	return result;
+    }
+    *doublePtr = d;
+    return TCL_OK;
+}
+
+
+int
+Tk_FontObjCmd(
+    ClientData clientData,	/* Main window associated with interpreter. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    return TCL_ERROR; /* not implemented */
+}
+
+
+#ifdef __MacOSX__
+
+#define MAC_OSX_TK
+#include "tkMacOSXPrivate.h"
+#include "tkMacOSXFont.h"
+
+
+void
+TkUnderlineCharsInContext(
+    Display *display,		/* Display on which to draw. */
+    Drawable drawable,		/* Window or pixmap in which to draw. */
+    GC gc,			/* Graphics context for actually drawing
+				 * line. */
+    Tk_Font tkfont,		/* Font used in GC; must have been allocated
+				 * by Tk_GetFont(). Used for character
+				 * dimensions, etc. */
+    const char *string,		/* String containing characters to be
+				 * underlined or overstruck. */
+    int numBytes,		/* Number of bytes in string. */
+    int x, int y,		/* Coordinates at which the first character of
+				 * the whole string would be drawn. */
+    int firstByte,		/* Index of first byte of first character. */
+    int lastByte)		/* Index of first byte after the last
+				 * character. */
+{
+    TkFont *fontPtr = (TkFont *) tkfont;
+    int startX, endX;
+
+    TkpMeasureCharsInContext(tkfont, string, numBytes, 0, firstByte, -1, 0,
+	    &startX);
+    TkpMeasureCharsInContext(tkfont, string, numBytes, 0, lastByte, -1, 0,
+	    &endX);
+
+    XFillRectangle(display, drawable, gc, x + startX,
+	    y + fontPtr->underlinePos, (unsigned) (endX - startX),
+	    (unsigned) fontPtr->underlineHeight);
+}
+
+
+int
+TkpMeasureCharsInContext(
+    Tk_Font tkfont,		/* Font in which characters will be drawn. */
+    const char * source,	/* UTF-8 string to be displayed. Need not be
+				 * '\0' terminated. */
+    int numBytes,		/* Maximum number of bytes to consider from
+				 * source string in all. */
+    int rangeStart,		/* Index of first byte to measure. */
+    int rangeLength,		/* Length of range to measure in bytes. */
+    int maxLength,		/* If >= 0, maxLength specifies the longest
+				 * permissible line length; don't consider any
+				 * character that would cross this x-position.
+				 * If < 0, then line length is unbounded and
+				 * the flags argument is ignored. */
+    int flags,			/* Various flag bits OR-ed together:
+				 * TK_PARTIAL_OK means include the last char
+				 * which only partially fits on this line.
+				 * TK_WHOLE_WORDS means stop on a word
+				 * boundary, if possible. TK_AT_LEAST_ONE
+				 * means return at least one character even
+				 * if no characters fit.  If TK_WHOLE_WORDS
+				 * and TK_AT_LEAST_ONE are set and the first
+				 * word doesn't fit, we return at least one
+				 * character or whatever characters fit into
+				 * maxLength.  TK_ISOLATE_END means that the
+				 * last character should not be considered in
+				 * context with the rest of the string (used
+				 * for breaking lines). */
+    int *lengthPtr)		/* Filled with x-location just after the
+				 * terminating character. */
+{
+    const MacFont *fontPtr = (const MacFont *) tkfont;
+    NSString *string;
+    NSAttributedString *attributedString;
+    CTTypesetterRef typesetter;
+    CFIndex start, len;
+    CFRange range = {0, 0};
+    CTLineRef line;
+    CGFloat offset = 0;
+    CFIndex index;
+    double width;
+    int length, fit;
+
+    if (rangeStart < 0 || rangeLength <= 0 ||
+	    rangeStart + rangeLength > numBytes ||
+	    (maxLength == 0 && !(flags & TK_AT_LEAST_ONE))) {
+	*lengthPtr = 0;
+	return 0;
+    }
+#if 0
+    /* Back-compatibility with ATSUI renderer, appears not to be needed */
+    if (rangeStart == 0 && maxLength == 1 && (flags & TK_ISOLATE_END) &&
+	    !(flags & TK_AT_LEAST_ONE)) {
+	length = 0;
+	fit = 0;
+	goto done;
+    }
+#endif
+    if (maxLength > 32767) {
+	maxLength = 32767;
+    }
+    string = [[NSString alloc] initWithBytesNoCopy:(void*)source
+		length:numBytes encoding:NSUTF8StringEncoding freeWhenDone:NO];
+    if (!string) {
+	length = 0;
+	fit = rangeLength;
+	goto done;
+    }
+    attributedString = [[NSAttributedString alloc] initWithString:string
+	    attributes:fontPtr->nsAttributes];
+    typesetter = CTTypesetterCreateWithAttributedString(
+	    (CFAttributedStringRef)attributedString);
+    start = Tcl_NumUtfChars(source, rangeStart);
+    len = Tcl_NumUtfChars(source + rangeStart, rangeLength);
+    if (start > 0) {
+	range.length = start;
+	line = CTTypesetterCreateLine(typesetter, range);
+	offset = CTLineGetTypographicBounds(line, NULL, NULL, NULL);
+	CFRelease(line);
+    }
+    if (maxLength < 0) {
+	index = len;
+	range.length = len;
+	line = CTTypesetterCreateLine(typesetter, range);
+	width = CTLineGetTypographicBounds(line, NULL, NULL, NULL);
+	CFRelease(line);
+    } else {
+	double maxWidth = maxLength + offset;
+	NSCharacterSet *cs;
+
+	index = start;
+	if (flags & TK_WHOLE_WORDS) {
+	    index = CTTypesetterSuggestLineBreak(typesetter, start, maxWidth);
+	    if (index <= start && (flags & TK_AT_LEAST_ONE)) {
+		flags &= ~TK_WHOLE_WORDS;
+	    }
+	}
+	if (index <= start && !(flags & TK_WHOLE_WORDS)) {
+	    index = CTTypesetterSuggestClusterBreak(typesetter, start, maxWidth);
+	}
+	cs = (index < len || (flags & TK_WHOLE_WORDS)) ?
+		whitespaceCharacterSet : lineendingCharacterSet;
+	while (index > start &&
+		[cs characterIsMember:[string characterAtIndex:(index - 1)]]) {
+	    index--;
+	}
+	if (index <= start && (flags & TK_AT_LEAST_ONE)) {
+	    index = start + 1;
+	}
+	if (index > 0) {
+	    range.length = index;
+	    line = CTTypesetterCreateLine(typesetter, range);
+	    width = CTLineGetTypographicBounds(line, NULL, NULL, NULL);
+	    CFRelease(line);
+	} else {
+	    width = 0;
+	}
+	if (width < maxWidth && (flags & TK_PARTIAL_OK) && index < len) {
+	    range.length = ++index;
+	    line = CTTypesetterCreateLine(typesetter, range);
+	    width = CTLineGetTypographicBounds(line, NULL, NULL, NULL);
+	    CFRelease(line);
+	}
+
+        /* The call to CTTypesetterSuggestClusterBreak above will always
+           return at least one character regardless of whether it exceeded
+           it or not.  Clean that up now. */
+	while (width > maxWidth && !(flags & TK_PARTIAL_OK)
+		&& index > start+(flags & TK_AT_LEAST_ONE)) {
+	    range.length = --index;
+	    line = CTTypesetterCreateLine(typesetter, range);
+	    width = CTLineGetTypographicBounds(line, NULL, NULL, NULL);
+	    CFRelease(line);
+	}
+
+    }
+    CFRelease(typesetter);
+    [attributedString release];
+    [string release];
+    length = ceil(width - offset);
+    fit = (Tcl_UtfAtIndex(source, index) - source) - rangeStart;
+done:
+    *lengthPtr = length;
+    return fit;
+}
+
+
+static HIMutableShapeRef
+TkMacOSXHIShapeCreateMutableWithRect(
+    const CGRect *inRect)
+{
+    HIMutableShapeRef result;
+
+    result = HIShapeCreateMutableWithRect(inRect);
+    return result;
+}
+
+
+static void
+TkMacOSXWinCGBounds(
+    TkWindow *winPtr,
+    CGRect *bounds)
+{
+    bounds->origin.x = winPtr->privatePtr->xOff;
+    bounds->origin.y = winPtr->privatePtr->yOff;
+    bounds->size.width = winPtr->changes.width;
+    bounds->size.height = winPtr->changes.height;
+}
+
+
+static OSStatus
+TkMacOSHIShapeDifferenceWithRect(
+    HIMutableShapeRef inShape,
+    const CGRect *inRect)
+{
+    OSStatus result;
+    HIShapeRef rgn = HIShapeCreateWithRect(inRect);
+
+    result = HIShapeDifference(inShape, rgn, inShape);
+    CFRelease(rgn);
+
+    return result;
+}
+
+
+static HIShapeRef
+TkMacOSXHIShapeCreateEmpty(void)
+{
+    HIShapeRef result;
+
+    result = HIShapeCreateEmpty();
+    return result;
+}
+
+
+TkWindow *
+TkpGetOtherWindow(
+    TkWindow *winPtr)		/* Tk's structure for a container or embedded
+				 * window. */
+{
+    Container *containerPtr;
+
+    /*
+     * TkpGetOtherWindow returns NULL if both windows are not in the same
+     * process...
+     */
+
+    if (!(winPtr->flags & TK_BOTH_HALVES)) {
+	return NULL;
+    }
+
+    for (containerPtr = firstContainerPtr; containerPtr != NULL;
+	    containerPtr = containerPtr->nextPtr) {
+	if (containerPtr->embeddedPtr == winPtr) {
+	    return containerPtr->parentPtr;
+	} else if (containerPtr->parentPtr == winPtr) {
+	    return containerPtr->embeddedPtr;
+	}
+    }
+    return NULL;
+}
+
+
+static HIShapeRef
+TkMacOSXGetNativeRegion(
+    TkRegion r)
+{
+    return (HIShapeRef) CFRetain(r);
+}
+
+
+static void
+TkpReleaseRegion(
+    TkRegion r)
+{
+    CFRelease(r);
+}
+
+
+static NSWindow*
+TkMacOSXDrawableWindow(
+    Drawable drawable)
+{
+    MacDrawable *macWin = (MacDrawable *) drawable;
+    NSWindow *result = nil;
+
+    if (!macWin || macWin->flags & TK_IS_PIXMAP) {
+	result = nil;
+    } else if (macWin->toplevel && macWin->toplevel->winPtr &&
+	    macWin->toplevel->winPtr->wmInfoPtr &&
+	    macWin->toplevel->winPtr->wmInfoPtr->window) {
+	result = macWin->toplevel->winPtr->wmInfoPtr->window;
+    } else if (macWin->winPtr && macWin->winPtr->wmInfoPtr &&
+	    macWin->winPtr->wmInfoPtr->window) {
+	result = macWin->winPtr->wmInfoPtr->window;
+    } else if (macWin->toplevel && (macWin->toplevel->flags & TK_EMBEDDED)) {
+	TkWindow *contWinPtr = TkpGetOtherWindow(macWin->toplevel->winPtr);
+	if (contWinPtr) {
+	    result = TkMacOSXDrawableWindow((Drawable) contWinPtr->privatePtr);
+	}
+    }
+    return result;
+}
+
+
+static void
+TkMacOSXUpdateClipRgn(
+    TkWindow *winPtr)
+{
+    MacDrawable *macWin;
+
+    if (winPtr == NULL) {
+	return;
+    }
+    macWin = winPtr->privatePtr;
+    if (macWin && macWin->flags & TK_CLIP_INVALID) {
+	TkWindow *win2Ptr;
+
+	if (Tk_IsMapped(winPtr)) {
+	    int rgnChanged = 0;
+	    CGRect bounds;
+	    HIMutableShapeRef rgn;
+
+	    /*
+	     * Start with a region defined by the window bounds.
+	     */
+
+	    TkMacOSXWinCGBounds(winPtr, &bounds);
+	    rgn = TkMacOSXHIShapeCreateMutableWithRect(&bounds);
+
+	    /*
+	     * Clip away the area of any windows that may obscure this window.
+	     * For a non-toplevel window, first, clip to the parents visible
+	     * clip region. Second, clip away any siblings that are higher in
+	     * the stacking order. For an embedded toplevel, just clip to the
+	     * container's visible clip region. Remember, we only allow one
+	     * contained window in a frame, and don't support any other widgets
+	     * in the frame either. This is not currently enforced, however.
+	     */
+
+	    if (!Tk_IsTopLevel(winPtr)) {
+		TkMacOSXUpdateClipRgn(winPtr->parentPtr);
+		if (winPtr->parentPtr) {
+		    ChkErr(HIShapeIntersect,
+			    winPtr->parentPtr->privatePtr->aboveVisRgn,
+			    rgn, rgn);
+		}
+		win2Ptr = winPtr;
+		while ((win2Ptr = win2Ptr->nextPtr)) {
+		    if (Tk_IsTopLevel(win2Ptr) || !Tk_IsMapped(win2Ptr)) {
+			continue;
+		    }
+		    TkMacOSXWinCGBounds(win2Ptr, &bounds);
+		    ChkErr(TkMacOSHIShapeDifferenceWithRect, rgn, &bounds);
+		}
+	    } else if (Tk_IsEmbedded(winPtr)) {
+		win2Ptr = TkpGetOtherWindow(winPtr);
+		if (win2Ptr) {
+		    TkMacOSXUpdateClipRgn(win2Ptr);
+		    ChkErr(HIShapeIntersect,
+			    win2Ptr->privatePtr->aboveVisRgn, rgn, rgn);
+		} else if (tkMacOSXEmbedHandler != NULL) {
+		    TkRegion r = TkCreateRegion();
+		    HIShapeRef visRgn;
+
+		    tkMacOSXEmbedHandler->getClipProc((Tk_Window) winPtr, r);
+		    visRgn = TkMacOSXGetNativeRegion(r);
+		    ChkErr(HIShapeIntersect, visRgn, rgn, rgn);
+		    CFRelease(visRgn);
+		    TkpReleaseRegion(r);
+		}
+
+		/*
+		 * TODO: Here we should handle out of process embedding.
+		 */
+	    } else if (winPtr->wmInfoPtr->attributes &
+		    kWindowResizableAttribute) {
+		NSWindow *w = TkMacOSXDrawableWindow(winPtr->window);
+
+	    }
+	    macWin->aboveVisRgn = HIShapeCreateCopy(rgn);
+
+	    /*
+	     * The final clip region is the aboveVis region (or visible region)
+	     * minus all the children of this window. If the window is a
+	     * container, we must also subtract the region of the embedded
+	     * window.
+	     */
+
+	    win2Ptr = winPtr->childList;
+	    while (win2Ptr) {
+		if (Tk_IsTopLevel(win2Ptr) || !Tk_IsMapped(win2Ptr)) {
+		    win2Ptr = win2Ptr->nextPtr;
+		    continue;
+		}
+		TkMacOSXWinCGBounds(win2Ptr, &bounds);
+		ChkErr(TkMacOSHIShapeDifferenceWithRect, rgn, &bounds);
+		rgnChanged = 1;
+		win2Ptr = win2Ptr->nextPtr;
+	    }
+
+	    if (Tk_IsContainer(winPtr)) {
+		win2Ptr = TkpGetOtherWindow(winPtr);
+		if (win2Ptr) {
+		    if (Tk_IsMapped(win2Ptr)) {
+			TkMacOSXWinCGBounds(win2Ptr, &bounds);
+			ChkErr(TkMacOSHIShapeDifferenceWithRect, rgn, &bounds);
+			rgnChanged = 1;
+		    }
+		}
+
+		/*
+		 * TODO: Here we should handle out of process embedding.
+		 */
+	    }
+
+	    if (rgnChanged) {
+		HIShapeRef diffRgn = HIShapeCreateDifference(
+			macWin->aboveVisRgn, rgn);
+
+		if (!HIShapeIsEmpty(diffRgn)) {
+		    macWin->visRgn = HIShapeCreateCopy(rgn);
+		}
+		CFRelease(diffRgn);
+	    }
+	    CFRelease(rgn);
+	} else {
+	    /*
+	     * An unmapped window has empty clip regions to prevent any
+	     * (erroneous) drawing into it or its children from becoming
+	     * visible. [Bug 940117]
+	     */
+
+	    if (!Tk_IsTopLevel(winPtr)) {
+		TkMacOSXUpdateClipRgn(winPtr->parentPtr);
+	    } else if (Tk_IsEmbedded(winPtr)) {
+		win2Ptr = TkpGetOtherWindow(winPtr);
+		if (win2Ptr) {
+		    TkMacOSXUpdateClipRgn(win2Ptr);
+		}
+	    }
+	    macWin->aboveVisRgn = TkMacOSXHIShapeCreateEmpty();
+	}
+	if (!macWin->visRgn) {
+	    macWin->visRgn = HIShapeCreateCopy(macWin->aboveVisRgn);
+	}
+	macWin->flags &= ~TK_CLIP_INVALID;
+    }
+}
+
+
+static HIShapeRef
+TkMacOSXGetClipRgn(
+    Drawable drawable)		/* Drawable. */
+{
+    MacDrawable *macDraw = (MacDrawable *) drawable;
+    HIShapeRef clipRgn = NULL;
+
+    if (macDraw->winPtr && macDraw->flags & TK_CLIP_INVALID) {
+	TkMacOSXUpdateClipRgn(macDraw->winPtr);
+    }
+
+    if (macDraw->drawRgn) {
+	clipRgn = HIShapeCreateCopy(macDraw->drawRgn);
+    } else if (macDraw->visRgn) {
+	clipRgn = HIShapeCreateCopy(macDraw->visRgn);
+    }
+
+    return clipRgn;
+}
+
+
+static CGContextRef
+GetCGContextForDrawable(
+    Drawable d)
+{
+    MacDrawable *macDraw = (MacDrawable *) d;
+
+    if (macDraw && (macDraw->flags & TK_IS_PIXMAP) && !macDraw->context) {
+	const size_t bitsPerComponent = 8;
+	size_t bitsPerPixel, bytesPerRow, len;
+	CGColorSpaceRef colorspace = NULL;
+	CGBitmapInfo bitmapInfo =
+#ifdef __LITTLE_ENDIAN__
+	kCGBitmapByteOrder32Host;
+#else
+	kCGBitmapByteOrderDefault;
+#endif
+	char *data;
+	CGRect bounds = CGRectMake(0, 0, macDraw->size.width,
+		macDraw->size.height);
+
+	if (macDraw->flags & TK_IS_BW_PIXMAP) {
+	    bitsPerPixel = 8;
+	    bitmapInfo = kCGImageAlphaOnly;
+	} else {
+	    colorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
+	    bitsPerPixel = 32;
+	    bitmapInfo |= kCGImageAlphaPremultipliedFirst;
+	}
+	bytesPerRow = ((size_t) macDraw->size.width * bitsPerPixel + 127) >> 3
+		& ~15;
+	len = macDraw->size.height * bytesPerRow;
+	data = ckalloc(len);
+	bzero(data, len);
+	macDraw->context = CGBitmapContextCreate(data, macDraw->size.width,
+		macDraw->size.height, bitsPerComponent, bytesPerRow,
+		colorspace, bitmapInfo);
+	if (macDraw->context) {
+	    CGContextClearRect(macDraw->context, bounds);
+	}
+	if (colorspace) {
+	    CFRelease(colorspace);
+	}
+    }
+
+    return (macDraw ? macDraw->context : NULL);
+}
+
+
+static NSView*
+TkMacOSXDrawableView(
+    MacDrawable *macWin)
+{
+    NSView *result = nil;
+
+    if (!macWin) {
+	result = nil;
+    } else if (!macWin->toplevel) {
+	result = macWin->view;
+    } else if (!(macWin->toplevel->flags & TK_EMBEDDED)) {
+	result = macWin->toplevel->view;
+    } else {
+	TkWindow *contWinPtr = TkpGetOtherWindow(macWin->toplevel->winPtr);
+	if (contWinPtr) {
+	    result = TkMacOSXDrawableView(contWinPtr->privatePtr);
+	}
+    }
+    return result;
+}
+
+
+static int
+GetThemeFromPixelCode(
+    unsigned char code,
+    ThemeBrush *brush,
+    ThemeTextColor *textColor,
+    ThemeBackgroundKind *background)
+{
+    if (code >= MIN_PIXELCODE && code <= MAX_PIXELCODE) {
+	*brush = systemColorMap[code - MIN_PIXELCODE].brush;
+	*textColor = systemColorMap[code - MIN_PIXELCODE].textColor;
+	*background = systemColorMap[code - MIN_PIXELCODE].background;
+    } else {
+	*brush = 0;
+	*textColor = 0;
+	*background = 0;
+    }
+    if (!*brush && !*textColor && !*background && code != PIXEL_MAGIC &&
+	    code != TRANSPARENT_PIXEL) {
+	return false;
+    } else {
+	return true;
+    }
+}
+
+
+static OSStatus
+GetThemeColor(
+    unsigned long pixel,
+    ThemeBrush brush,
+    ThemeTextColor textColor,
+    ThemeBackgroundKind background,
+    CGColorRef *c)
+{
+    OSStatus err = noErr;
+
+    if (brush) {
+	err = ChkErr(HIThemeBrushCreateCGColor, brush, c);
+    /*} else if (textColor) {
+	err = ChkErr(GetThemeTextColor, textColor, 32, true, c);*/
+    } else {
+	CGFloat rgba[4] = {0, 0, 0, 1};
+
+	switch ((pixel >> 24) & 0xff) {
+	case PIXEL_MAGIC: {
+	    unsigned short red, green, blue;
+	    red		= (pixel >> 16) & 0xff;
+	    green	= (pixel >>  8) & 0xff;
+	    blue	= (pixel      ) & 0xff;
+	    red		|= red   << 8;
+	    green	|= green << 8;
+	    blue	|= blue  << 8;
+	    rgba[0]	= red	/ 65535.0;
+	    rgba[1]	= green / 65535.0;
+	    rgba[2]	= blue  / 65535.0;
+	    break;
+	    }
+	case TRANSPARENT_PIXEL:
+	    rgba[3]	= 0.0;
+	    break;
+	}
+
+        // this attempts to find something roughly fitting for any display
+//	*c = CGColorCreateGenericRGB(rgba[0], rgba[1], rgba[2], rgba[3]);
+
+        // may be off for non-main display but in most cases better than prev
+	static CGColorSpaceRef deviceRGBSpace = NULL;
+	if (!deviceRGBSpace) {
+	    deviceRGBSpace = CGDisplayCopyColorSpace(CGMainDisplayID());
+	}
+	*c = CGColorCreate(deviceRGBSpace, rgba );
+    }
+    return err;
+}
+
+
+static TkpGCCache*
+TkpGetGCCache(GC gc) {
+    return (gc ? (TkpGCCache*)(((char*) gc) + sizeof(XGCValues) +
+	    MAX_DASH_LIST_SIZE) : NULL);
+}
+
+
+static void
+SetCachedColor(
+    GC gc,
+    unsigned long pixel,
+    CGColorRef cgColor)
+{
+    TkpGCCache *gcCache = TkpGetGCCache(gc);
+
+    if (gcCache && cgColor) {
+	if (gc->foreground == pixel) {
+	    if (gcCache->cachedForegroundColor) {
+		CFRelease(gcCache->cachedForegroundColor);
+	    }
+	    gcCache->cachedForegroundColor = (CGColorRef) CFRetain(cgColor);
+	    gcCache->cachedForeground = pixel;
+	} else if (gc->background == pixel) {
+	    if (gcCache->cachedBackgroundColor) {
+		CFRelease(gcCache->cachedBackgroundColor);
+	    }
+	    gcCache->cachedBackgroundColor = (CGColorRef) CFRetain(cgColor);
+	    gcCache->cachedBackground = pixel;
+	}
+    }
+}
+
+
+static CGColorRef
+CopyCachedColor(
+    GC gc,
+    unsigned long pixel)
+{
+    TkpGCCache *gcCache = TkpGetGCCache(gc);
+    CGColorRef cgColor = NULL;
+
+    if (gcCache) {
+	if (gcCache->cachedForeground == pixel) {
+	    cgColor = gcCache->cachedForegroundColor;
+	} else if (gcCache->cachedBackground == pixel) {
+	    cgColor = gcCache->cachedBackgroundColor;
+	}
+	if (cgColor) {
+	    CFRetain(cgColor);
+	}
+    }
+    return cgColor;
+}
+
+
+static void
+TkMacOSXSetColorInContext(
+    GC gc,
+    unsigned long pixel,
+    CGContextRef context)
+{
+    OSStatus err = -1;
+    CGColorRef cgColor = CopyCachedColor(gc, pixel);
+    ThemeBrush brush;
+    ThemeTextColor textColor;
+    ThemeBackgroundKind background;
+
+    if (!cgColor && GetThemeFromPixelCode((pixel >> 24) & 0xff, &brush,
+	    &textColor, &background)) {
+	if (brush) {
+	    err = ChkErr(HIThemeSetFill, brush, NULL, context,
+		    kHIThemeOrientationNormal);
+	    if (err == noErr) {
+		err = ChkErr(HIThemeSetStroke, brush, NULL, context,
+			kHIThemeOrientationNormal);
+	    }
+	} else if (textColor) {
+	    err = ChkErr(HIThemeSetTextFill, textColor, NULL, context,
+		    kHIThemeOrientationNormal);
+	} else if (background) {
+	    CGRect rect = CGContextGetClipBoundingBox(context);
+	    HIThemeBackgroundDrawInfo info = { 0, kThemeStateActive,
+		    background };
+
+	    err = ChkErr(HIThemeApplyBackground, &rect, &info,
+		    context, kHIThemeOrientationNormal);
+	}
+	if (err == noErr) {
+	    return;
+	}
+	err = ChkErr(GetThemeColor, pixel, brush, textColor, background,
+		&cgColor);
+	if (err == noErr) {
+	    SetCachedColor(gc, pixel, cgColor);
+	}
+    } else if (!cgColor) {
+	printf("Ignored unknown pixel value 0x%lx", pixel);
+    }
+    if (cgColor) {
+	CGContextSetFillColorWithColor(context, cgColor);
+	CGContextSetStrokeColorWithColor(context, cgColor);
+	CGColorRelease(cgColor);
+    }
+}
+
+
+static int
+TkMacOSXSetupDrawingContext(
+    Drawable d,
+    GC gc,
+    int useCG, /* advisory only ! */
+    TkMacOSXDrawingContext *dcPtr)
+{
+    MacDrawable *macDraw = ((MacDrawable*)d);
+    int dontDraw = 0, isWin = 0;
+    TkMacOSXDrawingContext dc = {};
+    CGRect clipBounds;
+
+    dc.clipRgn = TkMacOSXGetClipRgn(d);
+    if (!dontDraw) {
+	ClipToGC(d, gc, &dc.clipRgn);
+	dontDraw = dc.clipRgn ? HIShapeIsEmpty(dc.clipRgn) : 0;
+    }
+    if (dontDraw) {
+	goto end;
+    }
+    if (useCG) {
+	dc.context = GetCGContextForDrawable(d);
+    }
+    if (!dc.context || !(macDraw->flags & TK_IS_PIXMAP)) {
+	isWin = (TkMacOSXDrawableWindow(d) != nil);
+    }
+    if (dc.context) {
+	dc.portBounds = clipBounds = CGContextGetClipBoundingBox(dc.context);
+    } else if (isWin) {
+	NSView *view = TkMacOSXDrawableView(macDraw);
+	if (view) {
+	    if (view != [NSView focusView]) {
+		dc.focusLocked = [view lockFocusIfCanDraw];
+		dontDraw = !dc.focusLocked;
+	    } else {
+		dontDraw = ![view canDraw];
+	    }
+	    if (dontDraw) {
+		goto end;
+	    }
+	    [[view window] disableFlushWindow];
+	    dc.view = view;
+	    dc.context = [[NSGraphicsContext currentContext] graphicsPort];
+	    dc.portBounds = NSRectToCGRect([view bounds]);
+	    if (dc.clipRgn) {
+		clipBounds = CGContextGetClipBoundingBox(dc.context);
+	    }
+	} else {
+	    Tcl_Panic("TkMacOSXSetupDrawingContext(): "
+		    "no NSView to draw into !");
+	}
+    } else {
+	Tcl_Panic("TkMacOSXSetupDrawingContext(): "
+		"no context to draw into !");
+    }
+    if (dc.context) {
+	CGAffineTransform t = { .a = 1, .b = 0, .c = 0, .d = -1, .tx = 0,
+		.ty = dc.portBounds.size.height};
+	dc.portBounds.origin.x += macDraw->xOff;
+	dc.portBounds.origin.y += macDraw->yOff;
+	if (!dc.focusLocked) {
+	    CGContextSaveGState(dc.context);
+	}
+	CGContextSetTextDrawingMode(dc.context, kCGTextFill);
+	CGContextConcatCTM(dc.context, t);
+	if (dc.clipRgn) {
+	    CGRect r;
+	    if (!HIShapeIsRectangular(dc.clipRgn) || !CGRectContainsRect(
+		    *HIShapeGetBounds(dc.clipRgn, &r),
+		    CGRectApplyAffineTransform(clipBounds, t))) {
+		ChkErr(HIShapeReplacePathInCGContext, dc.clipRgn, dc.context);
+		CGContextEOClip(dc.context);
+	    }
+	}
+	if (gc) {
+	    static const CGLineCap cgCap[] = {
+		[CapNotLast] = kCGLineCapButt,
+		[CapButt] = kCGLineCapButt,
+		[CapRound] = kCGLineCapRound,
+		[CapProjecting] = kCGLineCapSquare,
+	    };
+	    static const CGLineJoin cgJoin[] = {
+		[JoinMiter] = kCGLineJoinMiter,
+		[JoinRound] = kCGLineJoinRound,
+		[JoinBevel] = kCGLineJoinBevel,
+	    };
+	    bool shouldAntialias;
+	    double w = gc->line_width;
+
+	    TkMacOSXSetColorInContext(gc, gc->foreground, dc.context);
+	    if (isWin) {
+		CGContextSetPatternPhase(dc.context, CGSizeMake(
+			dc.portBounds.size.width, dc.portBounds.size.height));
+	    }
+	    if(gc->function != GXcopy) {
+		printf("Logical functions other than GXcopy are "
+			"not supported for CG drawing!");
+	    }
+	    /* When should we antialias? */
+	    shouldAntialias = !notAA(gc->line_width);
+	    if (!shouldAntialias) {
+		/* Make non-antialiased CG drawing look more like X11 */
+		w -= (gc->line_width ? NON_AA_CG_OFFSET : 0);
+	    }
+	    CGContextSetShouldAntialias(dc.context, shouldAntialias);
+	    CGContextSetLineWidth(dc.context, w);
+	    if (gc->line_style != LineSolid) {
+		int num = 0;
+		char *p = &(gc->dashes);
+		CGFloat dashOffset = gc->dash_offset;
+		CGFloat lengths[10];
+
+		while (p[num] != '\0' && num < 10) {
+		    lengths[num] = p[num];
+		    num++;
+		}
+		CGContextSetLineDash(dc.context, dashOffset, lengths, num);
+	    }
+	    if ((unsigned)gc->cap_style < sizeof(cgCap)/sizeof(CGLineCap)) {
+		CGContextSetLineCap(dc.context,
+			cgCap[(unsigned)gc->cap_style]);
+	    }
+	    if ((unsigned)gc->join_style < sizeof(cgJoin)/sizeof(CGLineJoin)) {
+		CGContextSetLineJoin(dc.context,
+			cgJoin[(unsigned)gc->join_style]);
+	    }
+	}
+    }
+end:
+    if (dontDraw && dc.clipRgn) {
+	CFRelease(dc.clipRgn);
+	dc.clipRgn = NULL;
+    }
+    *dcPtr = dc;
+    return !dontDraw;
+}
+
+
+static CGColorRef
+TkMacOSXCreateCGColor(
+    GC gc,
+    unsigned long pixel)		/* Pixel value to convert. */
+{
+    CGColorRef cgColor = CopyCachedColor(gc, pixel);
+
+    if (!cgColor && TkSetMacColor(pixel, &cgColor)) {
+	SetCachedColor(gc, pixel, cgColor);
+    }
+    return cgColor;
+}
+
+
+static void
+TkMacOSXRestoreDrawingContext(
+    TkMacOSXDrawingContext *dcPtr)
+{
+    if (dcPtr->context) {
+	CGContextSynchronize(dcPtr->context);
+	[[dcPtr->view window] setViewsNeedDisplay:YES];
+	[[dcPtr->view window] enableFlushWindow];
+	if (dcPtr->focusLocked) {
+	    [dcPtr->view unlockFocus];
+	} else {
+	    CGContextRestoreGState(dcPtr->context);
+	}
+    }
+    if (dcPtr->clipRgn) {
+	CFRelease(dcPtr->clipRgn);
+    }
+}
+
+
+static void
+DrawCharsInContext(
+    Display *display,		/* Display on which to draw. */
+    Drawable drawable,		/* Window or pixmap in which to draw. */
+    GC gc,			/* Graphics context for drawing characters. */
+    Tk_Font tkfont,		/* Font in which characters will be drawn; must
+				 * be the same as font used in GC. */
+    const char * source,	/* UTF-8 string to be displayed. Need not be
+				 * '\0' terminated. All Tk meta-characters
+				 * (tabs, control characters, and newlines)
+				 * should be stripped out of the string that
+				 * is passed to this function. If they are not
+				 * stripped out, they will be displayed as
+				 * regular printing characters. */
+    int numBytes,		/* Number of bytes in string. */
+    int rangeStart,		/* Index of first byte to draw. */
+    int rangeLength,		/* Length of range to draw in bytes. */
+    int x, int y,		/* Coordinates at which to place origin of the
+				 * whole (not just the range) string when
+				 * drawing. */
+    double angle)
+{
+    const MacFont *fontPtr = (const MacFont *) tkfont;
+    NSString *string;
+    NSMutableDictionary *attributes;
+    NSAttributedString *attributedString;
+    CTTypesetterRef typesetter;
+    CFIndex start, len;
+    CTLineRef line;
+    MacDrawable *macWin = (MacDrawable *) drawable;
+    TkMacOSXDrawingContext drawingContext;
+    CGContextRef context;
+    CGColorRef fg;
+    NSFont *nsFont;
+    CGAffineTransform t;
+    int h;
+
+    if (rangeStart < 0 || rangeLength <= 0 ||
+	    rangeStart + rangeLength > numBytes ||
+	    !TkMacOSXSetupDrawingContext(drawable, gc, 1, &drawingContext)) {
+	return;
+    }
+    string = [[NSString alloc] initWithBytesNoCopy:(void*)source
+		length:numBytes encoding:NSUTF8StringEncoding freeWhenDone:NO];
+    if (!string) {
+	return;
+    }
+    context = drawingContext.context;
+    fg = TkMacOSXCreateCGColor(gc, gc->foreground);
+    attributes = [fontPtr->nsAttributes mutableCopy];
+    [attributes setObject:(id)fg forKey:(id)kCTForegroundColorAttributeName];
+    CFRelease(fg);
+    nsFont = [attributes objectForKey:NSFontAttributeName];
+    [nsFont setInContext:[NSGraphicsContext graphicsContextWithGraphicsPort:
+	    context flipped:NO]];
+    CGContextSetTextMatrix(context, CGAffineTransformIdentity);
+    attributedString = [[NSAttributedString alloc] initWithString:string
+	    attributes:attributes];
+    typesetter = CTTypesetterCreateWithAttributedString(
+	    (CFAttributedStringRef)attributedString);
+    x += macWin->xOff;
+    y += macWin->yOff;
+    h = drawingContext.portBounds.size.height;
+    y = h - y;
+    t = CGAffineTransformMake(1.0, 0.0, 0.0, -1.0, 0.0, h);
+    if (angle != 0.0) {
+	t = CGAffineTransformTranslate(CGAffineTransformRotate(
+		CGAffineTransformTranslate(t, x, y), angle*PI/180.0), -x, -y);
+    }
+    CGContextConcatCTM(context, t);
+    CGContextSetTextPosition(context, x, y);
+    start = Tcl_NumUtfChars(source, rangeStart);
+    len = Tcl_NumUtfChars(source, rangeStart + rangeLength);
+    if (start > 0) {
+	CGRect clipRect = CGRectInfinite, startBounds;
+	line = CTTypesetterCreateLine(typesetter, CFRangeMake(0, start));
+	startBounds = CTLineGetImageBounds(line, context);
+	CFRelease(line);
+	clipRect.origin.x = startBounds.origin.x + startBounds.size.width;
+	CGContextClipToRect(context, clipRect);
+    }
+    line = CTTypesetterCreateLine(typesetter, CFRangeMake(0, len));
+    CTLineDraw(line, context);
+    CFRelease(line);
+    CFRelease(typesetter);
+    [attributedString release];
+    [string release];
+    [attributes release];
+    TkMacOSXRestoreDrawingContext(&drawingContext);
+}
+
+
+void
+TkpDrawCharsInContext(
+    Display *display,		/* Display on which to draw. */
+    Drawable drawable,		/* Window or pixmap in which to draw. */
+    GC gc,			/* Graphics context for drawing characters. */
+    Tk_Font tkfont,		/* Font in which characters will be drawn; must
+				 * be the same as font used in GC. */
+    const char * source,	/* UTF-8 string to be displayed. Need not be
+				 * '\0' terminated. All Tk meta-characters
+				 * (tabs, control characters, and newlines)
+				 * should be stripped out of the string that
+				 * is passed to this function. If they are not
+				 * stripped out, they will be displayed as
+				 * regular printing characters. */
+    int numBytes,		/* Number of bytes in string. */
+    int rangeStart,		/* Index of first byte to draw. */
+    int rangeLength,		/* Length of range to draw in bytes. */
+    int x, int y)		/* Coordinates at which to place origin of the
+				 * whole (not just the range) string when
+				 * drawing. */
+{
+    DrawCharsInContext(display, drawable, gc, tkfont, source, numBytes,
+	    rangeStart, rangeLength, x, y, 0.0);
+}
+
+
+void
+XClipBox(
+    Region r,
+    XRectangle* rect_return)
+{
+    CGRect rect;
+
+    HIShapeGetBounds((HIShapeRef) r, &rect);
+    rect_return->x = rect.origin.x;
+    rect_return->y = rect.origin.y;
+    rect_return->width = rect.size.width;
+    rect_return->height = rect.size.height;
+}
+
+
+Region
+XCreateRegion(void)
+{
+    return (Region) HIShapeCreateMutable();
+}
+
+
+void
+XDestroyRegion(
+    Region r)
+{
+    if (r) {
+	CFRelease(r);
+    }
+}
+
+
+static int
+TkMacOSXIsEmptyRegion(
+    TkRegion r)
+{
+    return HIShapeIsEmpty((HIMutableShapeRef) r) ? 1 : 0;
+}
+
+
+int
+XRectInRegion(
+    Region region,
+    int x,
+    int y,
+    unsigned int width,
+    unsigned int height)
+{
+    if (TkMacOSXIsEmptyRegion(region)) {
+	return RectangleOut;
+    }
+    else {
+	const CGRect r = CGRectMake(x, y, width, height);
+	return HIShapeIntersectsRect((HIShapeRef) region, &r) ?
+	    RectanglePart : RectangleOut;
+    }
+}
+
+
+static OSStatus
+TkMacOSHIShapeUnion(
+    HIShapeRef inShape1,
+    HIShapeRef inShape2,
+    HIMutableShapeRef outResult)
+{
+    OSStatus result;
+
+    result = HIShapeUnion(inShape1, inShape2, outResult);
+    return result;
+}
+
+
+void
+XUnionRectWithRegion(
+    XRectangle* rectangle,
+    Region src_region,
+    Region dest_region_return)
+{
+    const CGRect r = CGRectMake(rectangle->x, rectangle->y,
+	    rectangle->width, rectangle->height);
+
+    if (src_region == dest_region_return) {
+	ChkErr(TkMacOSHIShapeUnionWithRect,
+		(HIMutableShapeRef) dest_region_return, &r);
+    } else {
+	HIShapeRef rectRgn = HIShapeCreateWithRect(&r);
+
+	ChkErr(TkMacOSHIShapeUnion, rectRgn, (HIShapeRef) src_region,
+		(HIMutableShapeRef) dest_region_return);
+	CFRelease(rectRgn);
+    }
+}
+
+#endif /* __MacOSX__ */
+// vi:set ts=8 sw=4:
Index: src/tktext/tkQTree.c
===================================================================
--- src/tktext/tkQTree.c	(revision 0)
+++ src/tktext/tkQTree.c	(working copy)
@@ -0,0 +1,1146 @@
+/*
+ * tkQTree.c --
+ *
+ * This module provides an implementation of a Q-Tree (Quartering Tree) for
+ * fast search of rectangles containing a specific point. This provides very
+ * fast mouse hovering lookup, even insertion/deletion/update is fast.
+ *
+ * The search algorithm is working with binary division on two dimensions
+ * (in fact a quartering), so this is (in practice) the fastest possible
+ * search algorithm for testing points in a set of rectangles.
+ *
+ * Complexity of search/insert/delete/update:
+ *
+ *   best case:     O(log n)
+ *   average case:  O(log n)
+ *   worst case:    O(n)
+ *
+ * Complexity of configuring the tree:
+ *
+ *   best case:     O(n*log n)
+ *   average case:  O(n*log n)
+ *   worst case:    O(sqr n)
+ *
+ * The worst case happens if most of the rectangles are overlapping, or even
+ * equal. We could implement the Q-Tree with a worst case of O(log n) for search,
+ * if we omit the spanning items. But then it may happen under certain conditions
+ * that the tree will explode in memory, the spanning items are preventing this.
+ * In practice the search will be super-fast, despite the worst case. It's a bit
+ * similar to the heapsort/quicksort complexity, in theory heapsort is better
+ * (worst case O(n*log n)), but in practice quicksort performs better (although
+ * worst case is O(sqr n)).
+ *
+ * Note that the Q-Tree is far superior compared to the R-Tree, provided that we
+ * know the overall bounding box of all rectangles in advance, and that we are
+ * searching for points (this means we are searching in two-dimensional data).
+ * The worst case of the search inside the R-Tree occurs when all rectangles are
+ * disjoint - and this will mostly be the case when the text widget is using the
+ * Q-Tree for the bounding boxes of the images - and the search inside the R-Tree
+ * needs complex computations, but the Q-Tree doesn't need complex computations,
+ * and is much faster.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkQTree.h"
+#include "tkAlloc.h"
+
+#if !(__STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900))
+# define _TK_NEED_IMPLEMENTATION
+# include "tkQTreePriv.h"
+#endif
+
+#include <tcl.h>
+#include <string.h>
+#include <assert.h>
+
+#if TK_CHECK_ALLOCS
+# define DEBUG_ALLOC(expr) expr
+#else
+# define DEBUG_ALLOC(expr)
+#endif
+
+
+DEBUG_ALLOC(unsigned tkQTreeCountNewTree = 0);
+DEBUG_ALLOC(unsigned tkQTreeCountDestroyTree = 0);
+DEBUG_ALLOC(unsigned tkQTreeCountNewNode = 0);
+DEBUG_ALLOC(unsigned tkQTreeCountDestroyNode = 0);
+DEBUG_ALLOC(unsigned tkQTreeCountNewItem = 0);
+DEBUG_ALLOC(unsigned tkQTreeCountDestroyItem = 0);
+DEBUG_ALLOC(unsigned tkQTreeCountNewElement = 0);
+DEBUG_ALLOC(unsigned tkQTreeCountDestroyElement = 0);
+
+
+/* Based on tests this seems to provide the best performance. */
+enum { MaxNodeItems = 20 };
+
+
+typedef struct Element {
+    struct Element *prev;
+    struct Element *next;
+    TkQTreeUid uid;
+    TkQTreeRect bbox;
+    TkQTreeState state;
+    uint32_t epoch;
+} Element;
+
+typedef struct Item {
+    struct Item *next;
+    Element *elem;
+} Item;
+
+typedef struct Node {
+    Item *spanningItem;
+    int countSpanning;
+
+    Item *partialItem;
+    int countPartial;
+
+    struct Node *ne;
+    struct Node *nw;
+    struct Node *se;
+    struct Node *sw;
+} Node;
+
+struct TkQTree {
+    Node *root;
+    Element *elem;
+    TkQTreeRect bbox;
+    uint32_t epoch;
+};
+
+
+static void InsertElem(const TkQTreeRect *bbox, Node *node, Element *elem);
+
+
+static Element *
+NewElement(
+    TkQTree tree,
+    const TkQTreeRect *rect,
+    const TkQTreeUid uid,
+    TkQTreeState initialState)
+{
+    Element *elem;
+
+    assert(tree);
+    assert(rect);
+
+    DEBUG_ALLOC(tkQTreeCountNewElement++);
+    elem = malloc(sizeof(Element));
+    elem->prev = NULL;
+    if ((elem->next = tree->elem)) {
+	elem->next->prev = elem;
+    }
+    tree->elem = elem;
+    elem->bbox = *rect;
+    elem->uid = uid;
+    elem->state = initialState;
+    elem->epoch = 0;
+    return elem;
+}
+
+
+static Node *
+NewNode(int initialPartialCount)
+{
+    Node *n;
+
+    DEBUG_ALLOC(tkQTreeCountNewNode++);
+    n = memset(malloc(sizeof(Node)), 0, sizeof(Node));
+    n->countPartial = initialPartialCount;
+    return n;
+}
+
+
+static void
+FreeItems(
+    Item *item)
+{
+    while (item) {
+	Item *next = item->next;
+	free(item);
+	item = next;
+	DEBUG_ALLOC(tkQTreeCountDestroyItem++);
+    }
+}
+
+
+static void
+FreeNode(
+    Node *node)
+{
+    if (node) {
+	if (node->countPartial >= 0) {
+	    FreeItems(node->partialItem);
+	} else {
+	    FreeNode(node->ne);
+	    FreeNode(node->nw);
+	    FreeNode(node->se);
+	    FreeNode(node->sw);
+	}
+	FreeItems(node->spanningItem);
+	free(node);
+	DEBUG_ALLOC(tkQTreeCountDestroyNode++);
+    }
+}
+
+
+static void
+FreeElements(
+    Element *elem)
+{
+    while (elem) {
+	Element *next = elem->next;
+	free(elem);
+	elem = next;
+	DEBUG_ALLOC(tkQTreeCountDestroyElement++);
+    }
+}
+
+
+static void
+AddItem(
+    Item **itemPtr,
+    Element *elem)
+{
+    Item *newItem;
+
+    assert(itemPtr);
+    assert(elem);
+
+    DEBUG_ALLOC(tkQTreeCountNewItem++);
+    newItem = malloc(sizeof(Item));
+    newItem->elem = elem;
+    newItem->next = *itemPtr;
+    *itemPtr = newItem;
+}
+
+
+/* Helper for function Split. */
+static Node *
+FillQuarter(
+    const TkQTreeRect *bbox,
+    const Item *partialItem,
+    Element *newElem)
+{
+    Node *node;
+
+    assert(bbox);
+    assert(newElem);
+    assert(!TkQTreeRectIsEmpty(&newElem->bbox));
+
+    if (TkQTreeRectIsEmpty(bbox)) {
+	return NULL;
+    }
+
+    node = NULL;
+
+    for ( ; partialItem; partialItem = partialItem->next) {
+	if (TkQTreeRectIntersects(&partialItem->elem->bbox, bbox)) {
+	    if (!node) { node = NewNode(0); }
+	    if (TkQTreeRectContainsRect(&partialItem->elem->bbox, bbox)) {
+		AddItem(&node->spanningItem, partialItem->elem);
+		node->countSpanning += 1;
+	    } else {
+		AddItem(&node->partialItem, partialItem->elem);
+		node->countPartial += 1;
+	    }
+	}
+    }
+
+    if (TkQTreeRectIntersects(&newElem->bbox, bbox)) {
+	if (!node) { node = NewNode(0); }
+	if (TkQTreeRectContainsRect(&newElem->bbox, bbox)) {
+	    AddItem(&node->spanningItem, newElem);
+	    node->countSpanning += 1;
+	} else {
+	    InsertElem(bbox, node, newElem);
+	}
+    }
+
+    return node;
+}
+
+
+/* Helper for function InsertElem. */
+static void
+Split(
+    const TkQTreeRect *bbox,
+    Node *node,
+    Element *elem)
+{
+    TkQTreeCoord xmin, ymin, xmax, ymax;
+    TkQTreeCoord xh, yh;
+    TkQTreeRect quart;
+
+    assert(node);
+    assert(bbox);
+    assert(elem);
+    assert(node->countPartial == MaxNodeItems);
+    assert(!TkQTreeRectIsEmpty(bbox));
+    assert(!TkQTreeRectIsEmpty(&elem->bbox));
+    assert(!TkQTreeRectContainsRect(&elem->bbox, bbox));
+
+    xmin = bbox->xmin;
+    ymin = bbox->ymin;
+    xmax = bbox->xmax;
+    ymax = bbox->ymax;
+    xh = (xmax - xmin)/2;
+    yh = (ymax - ymin)/2;
+
+    assert(xh > 0 || yh > 0);
+
+    TkQTreeRectSet(&quart, xmin, ymin, xmin + xh, ymin + yh);
+    node->ne = FillQuarter(&quart, node->partialItem, elem);
+
+    TkQTreeRectSet(&quart, xmin + xh, ymin, xmax, ymin + yh);
+    node->nw = FillQuarter(&quart, node->partialItem, elem);
+
+    TkQTreeRectSet(&quart, xmin, ymin + yh, xmin + xh, ymax);
+    node->se = FillQuarter(&quart, node->partialItem, elem);
+
+    TkQTreeRectSet(&quart, xmin + xh, ymin + yh, xmax, ymax);
+    node->sw = FillQuarter(&quart, node->partialItem, elem);
+
+    FreeItems(node->partialItem);
+    node->partialItem = NULL;
+    node->countPartial = -1;
+}
+
+
+static void
+InsertElem(
+    const TkQTreeRect *bbox,
+    Node *node,
+    Element *elem)
+{
+    assert(node);
+    assert(elem);
+    assert(bbox);
+    assert(!TkQTreeRectIsEmpty(bbox));
+    assert(!TkQTreeRectIsEmpty(&elem->bbox));
+    assert(!TkQTreeRectContainsRect(&elem->bbox, bbox));
+
+    if (node->countPartial == MaxNodeItems) {
+	Split(bbox, node, elem);
+    } else {
+	AddItem(&node->partialItem, elem);
+	node->countPartial += 1;
+    }
+}
+
+
+static void
+InsertRect(
+    const TkQTreeRect *bbox,
+    Node *node,
+    Element *elem)
+{
+    assert(node);
+    assert(bbox);
+    assert(elem);
+    assert(!TkQTreeRectIsEmpty(bbox));
+    assert(!TkQTreeRectIsEmpty(&elem->bbox));
+
+    if (TkQTreeRectContainsRect(&elem->bbox, bbox)) {
+	AddItem(&node->spanningItem, elem);
+	node->countSpanning += 1;
+    } else if (node->countPartial >= 0) {
+	InsertElem(bbox, node, elem);
+    } else {
+	TkQTreeRect quart;
+
+	TkQTreeCoord xmin = bbox->xmin;
+	TkQTreeCoord ymin = bbox->ymin;
+	TkQTreeCoord xmax = bbox->xmax;
+	TkQTreeCoord ymax = bbox->ymax;
+	TkQTreeCoord xh = (xmax - xmin)/2;
+	TkQTreeCoord yh = (ymax - ymin)/2;
+
+	TkQTreeRectSet(&quart, xmin, ymin, xmin + xh, ymin + yh);
+	if (!TkQTreeRectIsEmpty(&quart) && TkQTreeRectIntersects(&quart, &elem->bbox)) {
+	    if (!node->ne) { node->ne = NewNode(-1); }
+	    InsertRect(&quart, node->ne, elem);
+	}
+
+	TkQTreeRectSet(&quart, xmin + xh, ymin, xmax, ymin + yh);
+	if (!TkQTreeRectIsEmpty(&quart) && TkQTreeRectIntersects(&quart, &elem->bbox)) {
+	    if (!node->nw) { node->nw = NewNode(-1); }
+	    InsertRect(&quart, node->nw, elem);
+	}
+
+	TkQTreeRectSet(&quart, xmin, ymin + yh, xmin + xh, ymax);
+	if (!TkQTreeRectIsEmpty(&quart) && TkQTreeRectIntersects(&quart, &elem->bbox)) {
+	    if (!node->se) { node->se = NewNode(-1); }
+	    InsertRect(&quart, node->se, elem);
+	}
+
+	TkQTreeRectSet(&quart, xmin + xh, ymin + yh, xmax, ymax);
+	assert(!TkQTreeRectIsEmpty(&quart));
+	if (TkQTreeRectIntersects(&quart, &elem->bbox)) {
+	    if (!node->sw) { node->sw = NewNode(-1); }
+	    InsertRect(&quart, node->sw, elem);
+	}
+    }
+}
+
+
+/* Helper for functions CountPartialItems and CountSpanningItems. */
+static unsigned
+CountItems(
+    const Item *item,
+    uint32_t epoch)
+{
+    unsigned count = 0;
+
+    for ( ; item; item = item->next) {
+	if (item->elem->epoch != epoch) {
+	    item->elem->epoch = epoch;
+	    if (++count == MaxNodeItems + 1) {
+		return count;
+	    }
+	}
+    }
+
+    return count;
+}
+
+
+/* Helper for function DeleteRect. */
+static unsigned
+CountPartialItems(
+    const Node *node,
+    uint32_t epoch)
+{
+    unsigned count;
+
+    if (!node) {
+	count = 0;
+    } else if (node->countPartial == -1) {
+	count = MaxNodeItems + 1;
+    } else {
+	count = CountItems(node->partialItem, epoch);
+    }
+
+    return count;
+}
+
+
+/* Helper for function DeleteRect. */
+static unsigned
+CountSpanningItems(
+    const Node *node,
+    uint32_t epoch)
+{
+    return node ? CountItems(node->spanningItem, epoch) : 0;
+}
+
+
+/* Helper for function TransferItems. */
+static void
+MoveItems(
+    Item **srcPtr,
+    Node *dst,
+    uint32_t epoch)
+{
+    Item *item;
+    Item *prevItem;
+
+    assert(srcPtr);
+    assert(dst);
+
+    item = *srcPtr;
+
+    if (!item) {
+	return;
+    }
+
+    prevItem = NULL;
+
+    while (item) {
+	Item *nextItem = item->next;
+	if (item->elem->epoch != epoch) {
+	    if (prevItem) {
+		prevItem->next = item->next;
+	    } else {
+		*srcPtr = item->next;
+	    }
+	    item->next = dst->partialItem;
+	    dst->partialItem = item;
+	    item->elem->epoch = epoch;
+	} else {
+	    prevItem = item;
+	}
+	item = nextItem;
+    }
+}
+
+
+/* Helper for function DeleteRect. */
+static void
+TransferItems(
+    Node *src,
+    Node *dst,
+    uint32_t epoch)
+{
+    if (!src) {
+	return;
+    }
+
+    assert(dst);
+
+    MoveItems(&src->partialItem, dst, epoch);
+    MoveItems(&src->spanningItem, dst, epoch);
+    FreeNode(src);
+}
+
+
+/* Helper for function DeleteRect. */
+static void
+RemoveItem(
+    Item **itemPtr,
+    int *count,
+    TkQTreeUid uid,
+    Element **elem)
+{
+    Item *item, *prevItem;
+
+    assert(itemPtr);
+    assert(count);
+
+    for (item = *itemPtr, prevItem = NULL; item; prevItem = item, item = item->next) {
+	if (item->elem->uid == uid) {
+	    *elem = item->elem;
+	    if (prevItem) {
+		prevItem->next = item->next;
+	    } else {
+		*itemPtr = item->next;
+	    }
+	    free(item);
+	    *count -= 1;
+	    DEBUG_ALLOC(tkQTreeCountDestroyItem++);
+	    return;
+	}
+    }
+}
+
+
+static Element *
+DeleteRect(
+    TkQTree tree,
+    const TkQTreeRect *bbox,
+    Node *node,
+    const TkQTreeRect *rect,
+    TkQTreeUid uid,
+    uint32_t *epoch)
+{
+    Element *elem, *e;
+
+    assert(tree);
+    assert(rect);
+    assert(!TkQTreeRectIsEmpty(rect));
+    assert(epoch);
+
+    if (!node) {
+	return NULL;
+    }
+
+    elem = NULL;
+
+    RemoveItem(&node->spanningItem, &node->countSpanning, uid, &elem);
+
+    if (node->countPartial >= 0) {
+	RemoveItem(&node->partialItem, &node->countPartial, uid, &elem);
+    } else {
+	TkQTreeRect quart;
+
+	TkQTreeCoord xmin = bbox->xmin;
+	TkQTreeCoord ymin = bbox->ymin;
+	TkQTreeCoord xmax = bbox->xmax;
+	TkQTreeCoord ymax = bbox->ymax;
+	TkQTreeCoord xh = (xmax - xmin)/2;
+	TkQTreeCoord yh = (ymax - ymin)/2;
+
+	if (node->ne) {
+	    TkQTreeRectSet(&quart, xmin, ymin, xmin + xh, ymin + yh);
+	    if (TkQTreeRectIntersects(&quart, rect)) {
+		if ((e = DeleteRect(tree, &quart, node->ne, rect, uid, epoch))) {
+		    elem = e;
+		    if (node->ne->countPartial == 0 && node->ne->countSpanning == 0) {
+			FreeNode(node->ne);
+			node->ne = NULL;
+		    }
+		}
+	    }
+	}
+	if (node->nw) {
+	    TkQTreeRectSet(&quart, xmin + xh, ymin, xmax, ymin + yh);
+	    if (TkQTreeRectIntersects(&quart, rect)) {
+		if ((e = DeleteRect(tree, &quart, node->nw, rect, uid, epoch))) {
+		    elem = e;
+		    if (node->nw->countPartial == 0 && node->nw->countSpanning == 0) {
+			FreeNode(node->nw);
+			node->nw = NULL;
+		    }
+		}
+	    }
+	}
+	if (node->se) {
+	    TkQTreeRectSet(&quart, xmin, ymin + yh, xmin + xh, ymax);
+	    if (TkQTreeRectIntersects(&quart, rect)) {
+		if ((e = DeleteRect(tree, &quart, node->se, rect, uid, epoch))) {
+		    elem = e;
+		    if (node->se->countPartial == 0 && node->se->countSpanning == 0) {
+			FreeNode(node->se);
+			node->se = NULL;
+		    }
+		}
+	    }
+	}
+	if (node->sw) {
+	    TkQTreeRectSet(&quart, xmin + xh, ymin + yh, xmax, ymax);
+	    if (TkQTreeRectIntersects(&quart, rect)) {
+		if ((e = DeleteRect(tree, &quart, node->sw, rect, uid, epoch))) {
+		    elem = e;
+		    if (node->sw->countPartial == 0 && node->sw->countSpanning == 0) {
+			FreeNode(node->sw);
+			node->sw = NULL;
+		    }
+		}
+	    }
+	}
+    }
+
+    if (elem && node->countPartial == -1) {
+	unsigned total = 0;
+
+	*epoch += 1;
+
+	total += CountPartialItems(node->ne, *epoch);
+	total += CountPartialItems(node->nw, *epoch);
+	total += CountPartialItems(node->se, *epoch);
+	total += CountPartialItems(node->sw, *epoch);
+
+	if (total <= MaxNodeItems) {
+	    total += CountSpanningItems(node->ne, *epoch);
+	    total += CountSpanningItems(node->nw, *epoch);
+	    total += CountSpanningItems(node->se, *epoch);
+	    total += CountSpanningItems(node->sw, *epoch);
+
+	    if (total <= MaxNodeItems) {
+		*epoch += 1;
+		TransferItems(node->ne, node, *epoch);
+		TransferItems(node->nw, node, *epoch);
+		TransferItems(node->se, node, *epoch);
+		TransferItems(node->sw, node, *epoch);
+		node->ne = node->nw = node->se = node->sw = NULL;
+		node->countPartial = total;
+	    }
+	}
+    }
+
+    return elem;
+}
+
+
+static Element *
+FindElem(
+    const TkQTreeRect *bbox,
+    const Node *node,
+    const TkQTreeRect *rect,
+    TkQTreeUid uid)
+{
+    const Item *item;
+
+    assert(node);
+    assert(rect);
+    assert(!TkQTreeRectIsEmpty(rect));
+
+    if ((item = node->spanningItem)) {
+	for ( ; item; item = item->next) {
+	    if (item->elem->uid == uid) {
+		return item->elem;
+	    }
+	}
+    }
+    if (node->countPartial >= 0) {
+	for (item = node->partialItem; item; item = item->next) {
+	    if (item->elem->uid == uid) {
+		return item->elem;
+	    }
+	}
+    } else {
+	Element *elem;
+	TkQTreeRect quart;
+
+	TkQTreeCoord xmin = bbox->xmin;
+	TkQTreeCoord ymin = bbox->ymin;
+	TkQTreeCoord xmax = bbox->xmax;
+	TkQTreeCoord ymax = bbox->ymax;
+	TkQTreeCoord xh = (xmax - xmin)/2;
+	TkQTreeCoord yh = (ymax - ymin)/2;
+
+	if (node->ne) {
+	    TkQTreeRectSet(&quart, xmin, ymin, xmin + xh, ymin + yh);
+	    if (TkQTreeRectIntersects(&quart, rect)) {
+		if ((elem = FindElem(&quart, node->ne, rect, uid))) { return elem; }
+	    }
+	}
+	if (node->nw) {
+	    TkQTreeRectSet(&quart, xmin + xh, ymin, xmax, ymin + yh);
+	    if (TkQTreeRectIntersects(&quart, rect)) {
+		if ((elem = FindElem(&quart, node->nw, rect, uid))) { return elem; }
+	    }
+	}
+	if (node->se) {
+	    TkQTreeRectSet(&quart, xmin, ymin + yh, xmin + xh, ymax);
+	    if (TkQTreeRectIntersects(&quart, rect)) {
+		if ((elem = FindElem(&quart, node->se, rect, uid))) { return elem; }
+	    }
+	}
+	if (node->sw) {
+	    TkQTreeRectSet(&quart, xmin + xh, ymin + yh, xmax, ymax);
+	    if (TkQTreeRectIntersects(&quart, rect)) {
+		if ((elem = FindElem(&quart, node->sw, rect, uid))) { return elem; }
+	    }
+	}
+    }
+
+    return NULL;
+}
+
+
+static void
+RemoveElem(
+    TkQTree tree,
+    Element *elem)
+{
+    assert(tree);
+    assert(elem);
+
+    if (elem->prev) {
+	elem->prev->next = elem->next;
+    } else {
+	tree->elem = elem->next;
+    }
+    if (elem->next) {
+	elem->next->prev = elem->prev;
+    }
+    free(elem);
+    DEBUG_ALLOC(tkQTreeCountDestroyElement++);
+}
+
+
+void
+TkQTreeTraverse(
+    TkQTree tree,
+    TkQTreeCallback cbHit,
+    TkQTreeClientData cbArg)
+{
+    Element *elem;
+
+    assert(tree);
+    assert(cbHit);
+
+    for (elem = tree->elem; elem; elem = elem->next) {
+	if (!cbHit(elem->uid, &elem->bbox, &elem->state, cbArg)) {
+	    return;
+	}
+    }
+}
+
+
+bool
+TkQTreeFindState(
+    const TkQTree tree,
+    const TkQTreeRect *rect,
+    TkQTreeUid uid,
+    TkQTreeState *state)
+{
+    const Element *elem;
+
+    assert(tree);
+    assert(rect);
+
+    if (!tree->elem
+	    || TkQTreeRectIsEmpty(rect)
+	    || !(elem = FindElem(&tree->bbox, tree->root, rect, uid))) {
+	return false;
+    }
+    if (state) {
+	*state = elem->state;
+    }
+    return true;
+}
+
+
+bool
+TkQTreeSetState(
+    const TkQTree tree,
+    const TkQTreeRect *rect,
+    TkQTreeUid uid,
+    TkQTreeState state)
+{
+    Element *elem;
+
+    assert(tree);
+    assert(rect);
+
+    if (!tree->elem
+	    || TkQTreeRectIsEmpty(rect)
+	    || !(elem = FindElem(&tree->bbox, tree->root, rect, uid))) {
+	return false;
+    }
+    elem->state = state;
+    return true;
+}
+
+
+unsigned
+TkQTreeSearch(
+    const TkQTree tree,
+    TkQTreeCoord x,
+    TkQTreeCoord y,
+    TkQTreeCallback cbHit,
+    TkQTreeClientData cbArg)
+{
+    const Node *node;
+    unsigned hitCount;
+    TkQTreeRect bbox;
+
+    assert(tree);
+
+    if (!tree->elem) {
+	return 0;
+    }
+
+    if (!TkQTreeRectContainsPoint(&tree->bbox, x, y)) {
+	return 0;
+    }
+
+    node = tree->root;
+    bbox = tree->bbox;
+    hitCount = 0;
+
+    while (node) {
+	const Item *item;
+
+	for (item = node->spanningItem; item; item = item->next) {
+	    Element *elem = item->elem;
+
+	    hitCount += 1;
+	    if (cbHit && !cbHit(elem->uid, &elem->bbox, &elem->state, cbArg)) {
+		return hitCount;
+	    }
+	}
+
+	if (node->countPartial >= 0) {
+	    for (item = node->partialItem; item; item = item->next) {
+		if (TkQTreeRectContainsPoint(&item->elem->bbox, x, y)) {
+		    Element *elem = item->elem;
+
+		    hitCount += 1;
+		    if (cbHit && !cbHit(elem->uid, &elem->bbox, &elem->state, cbArg)) {
+			return hitCount;
+		    }
+		}
+	    }
+	    node = NULL;
+	} else {
+	    TkQTreeCoord xh = (bbox.xmax - bbox.xmin)/2;
+	    TkQTreeCoord yh = (bbox.ymax - bbox.ymin)/2;
+
+	    if (y < yh + bbox.ymin) {
+		if (x < xh + bbox.xmin) {
+		    node = node->ne;
+		    bbox.xmax = bbox.xmin + xh;
+		    bbox.ymax = bbox.ymin + yh;
+		} else {
+		    node = node->nw;
+		    bbox.xmin += xh;
+		    bbox.ymax = bbox.ymin + yh;
+		}
+	    } else {
+		if (x < xh + bbox.xmin) {
+		    node = node->se;
+		    bbox.xmax = bbox.xmin + xh;
+		    bbox.ymin += yh;
+		} else {
+		    node = node->sw;
+		    bbox.xmin += xh;
+		    bbox.ymin += yh;
+		}
+	    }
+	}
+    }
+
+    return hitCount;
+}
+
+
+bool
+TkQTreeInsertRect(
+    TkQTree tree,
+    const TkQTreeRect *rect,
+    TkQTreeUid uid,
+    TkQTreeState initialState)
+{
+    assert(tree);
+    assert(rect);
+
+    if (TkQTreeRectIsEmpty(rect) || !TkQTreeRectIntersects(&tree->bbox, rect)) {
+	return false;
+    }
+
+    InsertRect(&tree->bbox, tree->root, NewElement(tree, rect, uid, initialState));
+    return true;
+}
+
+
+bool
+TkQTreeDeleteRect(
+    TkQTree tree,
+    const TkQTreeRect *rect,
+    TkQTreeUid uid)
+{
+    Element *elem;
+
+    assert(tree);
+    assert(rect);
+
+    if (TkQTreeRectIsEmpty(rect)) {
+	return false;
+    }
+
+    elem = DeleteRect(tree, &tree->bbox, tree->root, rect, uid, &tree->epoch);
+
+    if (!elem) {
+	return false;
+    }
+
+    RemoveElem(tree, elem);
+    return true;
+}
+
+
+bool
+TkQTreeUpdateRect(
+    TkQTree tree,
+    const TkQTreeRect *oldRect,
+    const TkQTreeRect *newRect,
+    TkQTreeUid uid,
+    TkQTreeState newState)
+{
+    Element *elem;
+
+    assert(tree);
+    assert(newRect);
+
+    if (oldRect && TkQTreeRectIsEqual(oldRect, newRect)) {
+	return true;
+    }
+
+    elem = NULL;
+
+    if (oldRect && !TkQTreeRectIsEmpty(oldRect) && TkQTreeRectIntersects(&tree->bbox, oldRect)) {
+	if ((elem = DeleteRect(tree, &tree->bbox, tree->root, oldRect, uid, &tree->epoch))) {
+	    elem->state = newState;
+	    elem->bbox = *newRect;
+	}
+    }
+
+    if (TkQTreeRectIsEmpty(newRect) || !TkQTreeRectIntersects(&tree->bbox, newRect)) {
+	return false;
+    }
+
+    InsertRect(&tree->bbox, tree->root, elem ? elem : NewElement(tree, newRect, uid, newState));
+    return true;
+}
+
+
+void
+TkQTreeDestroy(
+    TkQTree *treePtr)
+{
+    assert(treePtr);
+
+    if (*treePtr) {
+	FreeNode((*treePtr)->root);
+	FreeElements((*treePtr)->elem);
+	free(*treePtr);
+	DEBUG_ALLOC(tkQTreeCountDestroyTree++);
+	*treePtr = NULL;
+    }
+}
+
+
+bool
+TkQTreeConfigure(
+    TkQTree *treePtr,
+    const TkQTreeRect *rect)
+{
+    TkQTree tree;
+    Element *elem;
+
+    assert(treePtr);
+    assert(rect);
+
+    if (TkQTreeRectIsEmpty(rect)) {
+	TkQTreeDestroy(treePtr);
+	return false;
+    }
+
+    if ((tree = *treePtr)) {
+	if (TkQTreeRectIsEqual(&tree->bbox, rect)) {
+	    return true;
+	}
+	FreeNode(tree->root);
+    } else {
+	DEBUG_ALLOC(tkQTreeCountNewTree++);
+	*treePtr = tree = malloc(sizeof(struct TkQTree));
+	tree->elem = NULL;
+	tree->epoch = 0;
+    }
+
+    tree->root = NewNode(0);
+    tree->bbox = *rect;
+
+    for (elem = tree->elem; elem; ) {
+	Element *next = elem->next;
+
+	if (TkQTreeRectIntersects(&elem->bbox, &tree->bbox)) {
+	    InsertRect(&tree->bbox, tree->root, elem);
+	}
+
+	elem = next;
+    }
+
+    return true;
+}
+
+
+const TkQTreeRect *
+TkQTreeGetBoundingBox(
+    const TkQTree tree)
+{
+    assert(tree);
+    return &tree->bbox;
+}
+
+
+#if QTREE_SEARCH_RECTS_CONTAINING
+
+/* *****************************************************************
+ * This is an example how to detect whether a rectangle is contained
+ * in at least one of the rectangles in the tree.
+ *
+ * We assume that TkQTreeInsertRect has been called with intitial
+ * state 0.
+ * *****************************************************************/
+
+typedef struct {
+    TkQTreeCallback cbHit;
+    TkQTreeClientData cbArg;
+    unsigned count;
+    unsigned epoch;
+} MyClientData;
+
+bool HitRectContaining1(
+    TkQTreeUid uid,
+    const TkQTreeRect *rect,
+    TkQTreeState *state,
+    TkQTreeClientData arg)
+{
+    MyClientData *cd = (MyClientData *) arg;
+    *state = arg->epoch;
+    return true;
+}
+
+bool HitRectContaining2(
+    TkQTreeUid uid,
+    const TkQTreeRect *rect,
+    TkQTreeState *state,
+    TkQTreeClientData arg)
+{
+    *state += 1;
+    return true;
+}
+
+bool HitRectContaining3(
+    TkQTreeUid uid,
+    const TkQTreeRect *rect,
+    TkQTreeState *state,
+    TkQTreeClientData arg)
+{
+    MyClientData *cd = (MyClientData *) arg;
+
+    if (++*state == arg->epoch + 3) {
+	if (cd->cbHit) {
+	    cd->cbHit(uid, rect, NULL, cd->cbArg);
+	}
+	cd->count += 1;
+    }
+
+    return true;
+}
+
+unsigned
+TkQTreeSearchRectsContaining(
+    const TkQTree tree,
+    const TkQTreeRect *rect,
+    TkQTreeCallback cbHit,
+    TkQTreeClientData cbArg)
+{
+    static unsigned epoch = 0;
+
+    const Node *node;
+    unsigned hitCount;
+    TkQTreeRect bbox;
+    MyClientData cd;
+
+    assert(tree);
+
+    if (!tree->elem) {
+	return 0;
+    }
+
+    if (!TkQTreeRectContainsRect(&tree->bbox, rect)) {
+	return 0;
+    }
+
+    cd.cbHit = cbHit;
+    cd.cbArg = cbArg;
+    cd.count = 0;
+    cd.epoch = (epoch += 4);
+
+    if (TkQTreeSearch(tree, rect->xmin, rect->ymin, HitRectContaining1, NULL) > 0) {
+	if (TkQTreeSearch(tree, rect->xmax, rect->ymin, HitRectContaining2, NULL) > 0) {
+	    if (TkQTreeSearch(tree, rect->xmin, rect->ymax, HitRectContaining2, NULL) > 0) {
+		TkQTreeSearch(tree, rect->xmax, rect->ymax, HitRectContaining3, (TkQTreeClientData) cd);
+	    }
+	}
+    }
+
+    return cd.count;
+}
+
+#endif /* QTREE_SEARCH_RECTS_CONTAINING */
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+/* Additionally we need stand-alone object code. */
+#define inline extern
+inline bool TkQTreeRectIsEmpty(const TkQTreeRect *rect);
+inline bool TkQTreeRectIsEqual(const TkQTreeRect *rect1, const TkQTreeRect *rect2);
+inline bool TkQTreeRectContainsPoint(const TkQTreeRect *rect, TkQTreeCoord x, TkQTreeCoord y);
+inline bool TkQTreeRectContainsRect(const TkQTreeRect *rect1, const TkQTreeRect *rect2);
+inline bool TkQTreeRectIntersects(const TkQTreeRect *rect1, const TkQTreeRect *rect2);
+inline TkQTreeRect *TkQTreeRectSet(TkQTreeRect *rect,
+    TkQTreeCoord xmin, TkQTreeCoord ymin, TkQTreeCoord xmax, TkQTreeCoord ymax);
+inline TkQTreeRect *TkQTreeRectTranslate(TkQTreeRect *rect, TkQTreeCoord dx, TkQTreeCoord dy);
+#endif /* __STDC_VERSION__ >= 199901L */
+
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkQTree.h
===================================================================
--- src/tktext/tkQTree.h	(revision 0)
+++ src/tktext/tkQTree.h	(working copy)
@@ -0,0 +1,186 @@
+/*
+ * tkQTree.h --
+ *
+ *	Declarations for the Q-Tree implementation.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKQTREE
+#define _TKQTREE
+
+#ifndef _TKINT
+#include "tkInt.h"
+#endif
+
+#include "tkBool.h"
+#include <stdint.h>
+
+#ifdef _MSC_VER
+# if _MSC_VER >= 1900
+#  define inline __inline
+# else
+#  define inline
+# endif
+#elif __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+/* =========================================================================
+ * Definitions for rectangle support.
+ * ========================================================================= */
+
+typedef int32_t TkQTreeCoord;
+
+typedef struct TkQTreeRect {
+    TkQTreeCoord xmin, ymin, xmax, ymax;
+} TkQTreeRect;
+
+/* Return whether rectangle is empty? */
+inline bool TkQTreeRectIsEmpty(const TkQTreeRect *rect);
+
+/* Return whether both rectangles are equal. */
+inline bool TkQTreeRectIsEqual(const TkQTreeRect *rect1, const TkQTreeRect *rect2);
+
+/* Return whether this rectangle contains the specified point. */
+inline bool TkQTreeRectContainsPoint(const TkQTreeRect *rect, TkQTreeCoord x, TkQTreeCoord y);
+
+/* Return whether the first rectangle contains the second one. */
+inline bool TkQTreeRectContainsRect(const TkQTreeRect *rect1, const TkQTreeRect *rect2);
+
+/* Return whether both rectangles are overlapping. */
+inline bool TkQTreeRectIntersects(const TkQTreeRect *rect1, const TkQTreeRect *rect2);
+
+/* Setup a rectangle. */
+inline TkQTreeRect *TkQTreeRectSet(TkQTreeRect *rect,
+    TkQTreeCoord xmin, TkQTreeCoord ymin, TkQTreeCoord xmax, TkQTreeCoord ymax);
+
+/* Translate a rectangle. */
+inline TkQTreeRect *TkQTreeRectTranslate(TkQTreeRect *rect, TkQTreeCoord dx, TkQTreeCoord dy);
+
+/* =========================================================================
+ * Definitions for the Q-Tree (Quartering Tree).
+ * ========================================================================= */
+
+typedef int32_t TkQTreeState;
+typedef uintptr_t TkQTreeUid;
+typedef void *TkQTreeClientData;
+
+struct TkQTree;
+typedef struct TkQTree *TkQTree;
+
+/*
+ * This is defining the callback function for searching and traversing the tree.
+ * Note that argument 'rect' will contain the coordinates according to the current
+ * scroll position. When returning false the search will be terminated, otherwise
+ * the search continues.
+ */
+typedef bool (*TkQTreeCallback)(
+    TkQTreeUid uid, const TkQTreeRect *rect, TkQTreeState *state, TkQTreeClientData arg);
+
+/*
+ * Configure the dimensions of the given Q-Tree. A new tree will be created if
+ * given tree (derefernced treePtr) is NULL. This function returns false if the
+ * specified bounding box is empty, in this case the tree cannot be used.
+ */
+bool TkQTreeConfigure(TkQTree *treePtr, const TkQTreeRect *rect);
+
+/*
+ * Destroy the given tree. Will do nothing if given tree (derefernced treePtr)
+ * is NULL.
+ */
+void TkQTreeDestroy(TkQTree *treePtr);
+
+/*
+ * Return the bounding box of given tree.
+ */
+const TkQTreeRect *TkQTreeGetBoundingBox(const TkQTree tree);
+
+/*
+ * Insert a rectangle into the tree. Each rectangle must be associated with an
+ * unique ID (argument 'uid'). This function returns whether the insertion was
+ * successful. The insertion fails if the given rectangle is empty, or if it
+ * does not overlap with the bounding box of the tree, in these case the
+ * return value will be false.
+ */
+bool TkQTreeInsertRect(TkQTree tree, const TkQTreeRect *rect, TkQTreeUid uid, TkQTreeState initialState);
+
+/*
+ * Update the rectangle which belongs to the given unique ID. The argument
+ * 'oldRect' must exactly match the last provided rectangle (with
+ * TkQTreeInsertRect, or TkQTreeUpdateRect). For convenience it is allowed
+ * to insert a new rectangle (this means new unique ID), in this case
+ * argument 'oldRect' must be NULL. This function returns whether the
+ * insertion/update was successful. The insertion/update fails if the new
+ * rectangle is empty, or if it does not overlap with the bounding box of
+ * the tree, in these cases the return value will be false.
+ */
+bool TkQTreeUpdateRect(TkQTree tree, const TkQTreeRect *oldRect,
+    const TkQTreeRect *newRect, TkQTreeUid uid, TkQTreeState newState);
+
+/*
+ * Delete the specified rectangle from the tree. It is mandatory that the specified
+ * rectangle is exactly matching the last provided rectangle for given uid (with
+ * TkQTreeInsertRect, or TkQTreeUpdateRect). This function returns whether the
+ * deletion was successful.
+ */
+bool TkQTreeDeleteRect(TkQTree tree, const TkQTreeRect *rect, TkQTreeUid uid);
+
+/*
+ * Search for all rectangles containing the given point. For each hit the given
+ * function will be triggered. This function returns the number of hits. It is
+ * allowed to use NULL for argument 'cbHit'.
+ */
+unsigned TkQTreeSearch(const TkQTree tree, TkQTreeCoord x, TkQTreeCoord y,
+    TkQTreeCallback cbHit, TkQTreeClientData cbArg);
+
+/*
+ * Trigger the given callback function for any rectangle in this tree.
+ */
+void TkQTreeTraverse(const TkQTree tree, TkQTreeCallback cbHit, TkQTreeClientData cbArg);
+
+/*
+ * Find the current state of the specified rectangle. This functions returns true
+ * if and only if the specified rectangle has been found. It is allowed to use
+ * NULL for argument 'state', in this case only the existence of the specified
+ * rectangle will be tested.
+ */
+bool TkQTreeFindState(const TkQTree tree, const TkQTreeRect *rect, TkQTreeUid uid, TkQTreeState *state);
+
+/*
+ * Set the current state of the specified rectangle. This functions returns true
+ * if successful, otherwise, if the specified rectangle is not exisiting, false
+ * will be returned.
+ */
+bool TkQTreeSetState(const TkQTree tree, const TkQTreeRect *rect, TkQTreeUid uid, TkQTreeState state);
+
+#if QTREE_SEARCH_RECTS_CONTAINING
+
+/*
+ * Search for all rectangles which are containing the given rectangle. Note that
+ * here the user will receive NULL for parameter 'state' in callback function,
+ * this means that this parameter cannot be used with the use of this function.
+ * This function returns the number of hits. It is allowed to use NULL for
+ * argument 'cbHit'.
+ */
+
+unsigned TkQTreeSearchRectsContaining(const TkQTree tree, const TkQTreeRect *rect,
+    TkQTreeCallback cbHit, TkQTreeClientData cbArg);
+
+#endif /* QTREE_SEARCH_RECTS_CONTAINING */
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+# define _TK_NEED_IMPLEMENTATION
+#include "tkQTreePriv.h"
+# undef _TK_NEED_IMPLEMENTATION
+#else
+# undef inline
+#endif
+
+#endif /* _TKQTREE */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkQTreePriv.h
===================================================================
--- src/tktext/tkQTreePriv.h	(revision 0)
+++ src/tktext/tkQTreePriv.h	(working copy)
@@ -0,0 +1,163 @@
+/*
+ * tkQTreePriv.h --
+ *
+ *	Private implementation for Q-Tree.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKQTREE
+# error "do not include this private header file"
+#endif
+
+
+#ifdef _TK_NEED_IMPLEMENTATION
+
+#include <assert.h>
+
+#if __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+inline
+bool
+TkQTreeRectIsEmpty(
+    const TkQTreeRect *rect)
+{
+    assert(rect);
+
+    /*
+     * Normally this natural statement will be used here:
+     *
+     *     return rect->xmin >= rect->xmax || rect->ymin >= rect->ymax;
+     *
+     * GCC gives the following warning when optimization is enabled:
+     *
+     *     assuming signed overflow does not occur when assuming that (X + c) < X
+     *     is always false [-Wstrict-overflow]
+     *
+     * I guess that GCC is converting (optimizing) this statement into:
+     *
+     *     return rect->xmin - rect->xmax >= 0 || rect->ymin - rect->ymax >= 0;
+     *
+     * So I will use the latter statement to avoid this warning. Unfortunately
+     * this has the drawback that on machines with different architectures
+     * the transformed statement can be a bit slower than the natural statement,
+     * but I will assume that on such architectures GCC will transform it (back)
+     * to the natural one (when optimization is enabled), without giving a warning,
+     * because the natural statement doesn't use arithmetic.
+     *
+     * Note that this problem only happen with signed values.
+     */
+
+    return rect->xmin - rect->xmax >= 0 || rect->ymin - rect->ymax >= 0;
+}
+
+
+inline
+bool
+TkQTreeRectIsEqual(
+    const TkQTreeRect *rect1,
+    const TkQTreeRect *rect2)
+{
+    assert(rect1);
+    assert(rect2);
+
+    return rect1->xmin == rect2->xmin
+    	&& rect1->xmax == rect2->xmax
+	&& rect1->ymin == rect2->ymin
+	&& rect1->ymax == rect2->ymax;
+}
+
+
+inline
+bool
+TkQTreeRectContainsPoint(
+    const TkQTreeRect *rect,
+    TkQTreeCoord x,
+    TkQTreeCoord y)
+{
+    assert(rect);
+
+    return y < rect->ymax && rect->ymin <= y && x < rect->xmax && rect->xmin <= x;
+}
+
+
+inline
+bool
+TkQTreeRectContainsRect(
+    const TkQTreeRect *rect1,
+    const TkQTreeRect *rect2)
+{
+    assert(rect1);
+    assert(rect2);
+
+    return rect1->xmin <= rect2->xmin
+    	&& rect2->xmax <= rect1->xmax
+	&& rect1->ymin <= rect2->ymin
+	&& rect2->ymax <= rect1->ymax;
+}
+
+
+inline
+bool
+TkQTreeRectIntersects(
+    const TkQTreeRect *rect1,
+    const TkQTreeRect *rect2)
+{
+    assert(rect1);
+    assert(rect2);
+
+    return rect1->xmin < rect2->xmax
+	&& rect2->xmin < rect1->xmax
+	&& rect1->ymin < rect2->ymax
+	&& rect2->ymin < rect1->ymax;
+}
+
+
+inline
+TkQTreeRect *
+TkQTreeRectSet(
+    TkQTreeRect *rect,
+    TkQTreeCoord xmin,
+    TkQTreeCoord ymin,
+    TkQTreeCoord xmax,
+    TkQTreeCoord ymax)
+{
+    assert(rect);
+    assert(xmin <= xmax);
+    assert(ymin <= ymax);
+
+    rect->xmin = xmin;
+    rect->ymin = ymin;
+    rect->xmax = xmax;
+    rect->ymax = ymax;
+
+    return rect;
+}
+
+
+inline
+TkQTreeRect *
+TkQTreeRectTranslate(
+    TkQTreeRect *rect,
+    TkQTreeCoord dx,
+    TkQTreeCoord dy)
+{
+    assert(rect);
+
+    rect->xmin += dx;
+    rect->xmax += dx;
+    rect->ymin += dy;
+    rect->ymax += dy;
+
+    return rect;
+}
+
+#undef _TK_NEED_IMPLEMENTATION
+#endif /* _TK_NEED_IMPLEMENTATION */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkRangeList.c
===================================================================
--- src/tktext/tkRangeList.c	(revision 0)
+++ src/tktext/tkRangeList.c	(working copy)
@@ -0,0 +1,690 @@
+/*
+ * tkRangeList.c --
+ *
+ *	This module implements operations on a list of integer ranges.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkRangeList.h"
+#include "tkAlloc.h"
+
+#include <tk.h>
+#include <string.h>
+#include <assert.h>
+
+#if !(__STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900))
+# define _TK_NEED_IMPLEMENTATION
+# include "tkRangeListPriv.h"
+#endif
+
+#ifndef MIN
+# define MIN(a,b) ((a) < (b) ? a : b)
+#endif
+#ifndef MAX
+# define MAX(a,b) ((a) < (b) ? b : a)
+#endif
+
+#if TK_CHECK_ALLOCS
+# define DEBUG_ALLOC(expr) expr
+#else
+# define DEBUG_ALLOC(expr)
+#endif
+
+
+#define MEM_SIZE(size) ((unsigned) (Tk_Offset(TkRangeList, items) + (size)*sizeof(TkRange)))
+
+
+DEBUG_ALLOC(unsigned tkRangeListCountNew = 0);
+DEBUG_ALLOC(unsigned tkRangeListCountDestroy = 0);
+
+
+#if !NDEBUG
+
+static int
+ComputeRangeSize(
+    const TkRangeList *ranges)
+{
+    unsigned i;
+    int count = 0;
+
+    for (i = 0; i < ranges->size; ++i) {
+	count += TkRangeSpan(ranges->items + i);
+    }
+
+    return count;
+}
+
+#endif /* !NDEBUG */
+
+
+static TkRange *
+LowerBound(
+    TkRange *first,
+    TkRange *last,
+    int low)
+{
+    /*
+     * Note that we want to amalgamate adjacent ranges, and this binary
+     * search is designed for this requirement.
+     *
+     * Example for ranges={{2,3}{6,7}}:
+     *
+     *   low < 5       -> {2,3}
+     *   low = 5,6,7,8 -> {6,7}
+     *   low > 8       -> last
+     */
+
+    if (first == last) {
+	return first;
+    }
+
+    low -= 1;
+
+    do {
+	TkRange *mid = first + (last - first)/2;
+
+	if (mid->high < low) {
+	    first = mid + 1;
+	} else {
+	    last = mid;
+	}
+    } while (first != last);
+
+    return first;
+}
+
+
+static TkRange *
+Increase(
+    TkRangeList **rangesPtr)
+{
+    TkRangeList *ranges = *rangesPtr;
+
+    if (ranges->size == ranges->capacity) {
+	ranges->capacity = MAX(1, 2*ranges->capacity);
+	ranges = realloc(ranges, MEM_SIZE(ranges->capacity));
+	*rangesPtr = ranges;
+    }
+
+    return ranges->items + ranges->size++;
+}
+
+
+static TkRange *
+Insert(
+    TkRangeList **rangesPtr,
+    TkRange *entry)
+{
+    TkRangeList *ranges = *rangesPtr;
+    unsigned pos = entry - ranges->items;
+
+    if (ranges->size == ranges->capacity) {
+	TkRangeList *newRanges;
+	TkRange *newEntry;
+
+	ranges->capacity = MAX(1, 2*ranges->capacity);
+	newRanges = malloc(MEM_SIZE(ranges->capacity));
+	newRanges->capacity = ranges->capacity;
+	newRanges->size = ranges->size + 1;
+	newRanges->count = ranges->count;
+	newEntry = newRanges->items + pos;
+	memcpy(newRanges->items, ranges->items, pos*sizeof(TkRange));
+	memcpy(newEntry + 1, entry, (ranges->size - pos)*sizeof(TkRange));
+	free(ranges);
+	*rangesPtr = ranges = newRanges;
+	entry = newEntry;
+    } else {
+	memmove(entry + 1, entry, (ranges->size - pos)*sizeof(TkRange));
+	ranges->size += 1;
+    }
+
+    return entry;
+}
+
+
+static void
+Amalgamate(
+    TkRangeList *ranges,
+    TkRange *curr)
+{
+    const TkRange *last = ranges->items + ranges->size;
+    TkRange *next = curr + 1;
+    int high = curr->high;
+
+    while (next != last && high + 1 >= next->low) {
+	if (high >= next->high) {
+	    ranges->count -= TkRangeSpan(next);
+	} else if (high >= next->low) {
+	    ranges->count -= high - next->low + 1;
+	}
+	next += 1;
+    }
+
+    if (next != curr + 1) {
+	curr->high = MAX((next - 1)->high, high);
+	memmove(curr + 1, next, (last - next)*sizeof(TkRange));
+	ranges->size -= (next - curr) - 1;
+	assert(ComputeRangeSize(ranges) == ranges->count);
+    }
+}
+
+
+TkRangeList *
+TkRangeListCreate(unsigned capacity)
+{
+    TkRangeList *ranges;
+
+    ranges = malloc(MEM_SIZE(capacity));
+    ranges->size = 0;
+    ranges->capacity = capacity;
+    ranges->count = 0;
+    DEBUG_ALLOC(tkRangeListCountNew++);
+    return ranges;
+}
+
+
+TkRangeList *
+TkRangeListCopy(
+    const TkRangeList *ranges)
+{
+    TkRangeList *copy;
+    unsigned memSize;
+
+    assert(ranges);
+
+    copy = malloc(memSize = MEM_SIZE(ranges->size));
+    memcpy(copy, ranges, memSize);
+    DEBUG_ALLOC(tkRangeListCountNew++);
+    return copy;
+}
+
+
+void
+TkRangeListDestroy(
+    TkRangeList **rangesPtr)
+{
+    assert(rangesPtr);
+
+    if (*rangesPtr) {
+	free(*rangesPtr);
+	*rangesPtr = NULL;
+	DEBUG_ALLOC(tkRangeListCountDestroy++);
+    }
+}
+
+
+void
+TkRangeListClear(
+    TkRangeList *ranges)
+{
+    assert(ranges);
+
+    ranges->size = 0;
+    ranges->count = 0;
+}
+
+
+bool
+TkRangeListContainsAny(
+    const TkRangeList *ranges,
+    int low,
+    int high)
+{
+    const TkRange *last;
+    const TkRange *entry;
+
+    assert(ranges);
+
+    last = ranges->items + ranges->size;
+    entry = LowerBound((TkRange *) ranges->items, (TkRange *) last, low);
+
+    if (entry == last) {
+	return false;
+    }
+
+    if (entry->high == low + 1 && ++entry == last) {
+	return false;
+    }
+
+    return high >= entry->low;
+}
+
+
+void
+TkRangeListTruncateAtFront(
+    TkRangeList *ranges,
+    int untilThisValue)
+{
+    TkRange *last;
+    TkRange *curr;
+    TkRange *r;
+
+    assert(ranges);
+
+    last = ranges->items + ranges->size;
+    curr = LowerBound(ranges->items, last, untilThisValue);
+
+    if (curr == last) {
+	return;
+    }
+
+    if (curr->low <= untilThisValue) {
+	if (untilThisValue < curr->high) {
+	    ranges->count -= untilThisValue - curr->low + 1;
+	    curr->low = untilThisValue + 1;
+	} else {
+	    curr += 1;
+	}
+    }
+
+    if (curr != ranges->items) {
+	for (r = ranges->items; r != curr; ++r) {
+	    ranges->count -= TkRangeSpan(r);
+	}
+	memmove(ranges->items, curr, (last - curr)*sizeof(TkRange));
+	ranges->size -= curr - ranges->items;
+    }
+
+    assert(ComputeRangeSize(ranges) == ranges->count);
+}
+
+
+void
+TkRangeListTruncateAtEnd(
+    TkRangeList *ranges,
+    int maxValue)
+{
+    TkRange *last;
+    TkRange *curr;
+
+    assert(ranges);
+
+    last = ranges->items + ranges->size;
+    curr = LowerBound(ranges->items, last, maxValue);
+
+    if (curr == last) {
+	return;
+    }
+
+    if (curr->low <= maxValue) {
+	if (curr->high > maxValue) {
+	    ranges->count -= curr->high - maxValue;
+	    curr->high = maxValue;
+	}
+	curr += 1;
+    }
+
+    ranges->size -= last - curr;
+
+    for ( ; curr != last; ++curr) {
+	ranges->count -= TkRangeSpan(curr);
+    }
+
+    assert(ComputeRangeSize(ranges) == ranges->count);
+}
+
+
+const TkRange *
+TkRangeListFind(
+    const TkRangeList *ranges,
+    int value)
+{
+    const TkRange *last;
+    const TkRange *entry;
+
+    assert(ranges);
+
+    last = ranges->items + ranges->size;
+    entry = LowerBound((TkRange *) ranges->items, (TkRange *) last, value);
+
+    if (entry == last || entry->low > value || value > entry->high) {
+	return NULL;
+    }
+    return entry;
+}
+
+
+const TkRange *
+TkRangeListFindNearest(
+    const TkRangeList *ranges,
+    int value)
+{
+    const TkRange *last;
+    const TkRange *entry;
+
+    assert(ranges);
+
+    last = ranges->items + ranges->size;
+    entry = LowerBound((TkRange *) ranges->items, (TkRange *) last, value);
+
+    if (entry == last) {
+	return NULL;
+    }
+    if (value > entry->high) {
+	if (++entry == last) {
+	    return NULL;
+	}
+    }
+    return entry;
+}
+
+
+TkRangeList *
+TkRangeListAdd(
+    TkRangeList *ranges,
+    int low,
+    int high)
+{
+    TkRange *last;
+    TkRange *curr;
+
+    assert(low <= high);
+
+    last = ranges->items + ranges->size;
+
+    if (ranges->size == 0) {
+	curr = last;
+    } else if (low >= (last - 1)->low) {
+	/* catch a frequent case */
+	curr = (low > (last - 1)->high + 1) ? last : last - 1;
+    } else {
+	curr = LowerBound(ranges->items, last, low);
+    }
+
+    if (curr == last) {
+	/* append new entry */
+	curr = Increase(&ranges);
+	curr->low = low;
+	curr->high = high;
+	ranges->count += high - low + 1;
+    } else if (low + 1 < curr->low) {
+	if (curr->low <= high + 1) {
+	    /* new lower bound of current range */
+	    ranges->count += curr->low - low;
+	    curr->low = low;
+	} else {
+	    /* insert new entry before current */
+	    curr = Insert(&ranges, curr);
+	    curr->low = low;
+	    curr->high = high;
+	    ranges->count += high - low + 1;
+	}
+    } else {
+	if (low + 1 == curr->low) {
+	    /* new lower bound of current range */
+	    ranges->count += 1;
+	    curr->low = low;
+	}
+	if (last - 1 != curr && (last - 1)->high <= high) {
+	    /* catch a frequent case: we don't need the succeeding items */
+	    for (--last; last > curr; --last) {
+		ranges->count -= TkRangeSpan(last);
+	    }
+	    ranges->count += high - curr->high;
+	    ranges->size = (curr + 1) - ranges->items;
+	    curr->high = high;
+	} else if (curr->high < high) {
+	    /* new upper bound of current range */
+	    ranges->count += high - curr->high;
+	    curr->high = high;
+	    /* possibly we have to amalgamate succeeding items */
+	    Amalgamate(ranges, curr);
+	}
+    }
+
+    return ranges;
+}
+
+
+TkRangeList *
+TkRangeListInsert(
+    TkRangeList *ranges,
+    int low,
+    int high)
+{
+    TkRange *curr;
+    TkRange *last;
+    int span = high - low + 1;
+
+    assert(ranges);
+    assert(low <= high);
+
+    last = ranges->items + ranges->size;
+    curr = LowerBound(ranges->items, last, low);
+
+    /* {2,2} : insert {0,0} -> {0,0}{3,3} */
+    /* {2,2} : insert {1,1} -> {1,1}{3,3} */
+    /* {2,2} : insert {2,2} -> {2,3} */
+    /* {2,2} : insert {3,3} -> {2,3} */
+    /* {2,4} : insert {3,3} -> {2,5} */
+    /* {2,4} : insert {4,4} -> {2,5} */
+    /* {2,4} : insert {5,5} -> {2,5} */
+
+    if (curr == last || low > curr->high + 1) {
+	/* append new entry */
+	curr = Increase(&ranges);
+	curr->low = low;
+	curr->high = high;
+    } else {
+	if (low >= curr->low) {
+	    /* new upper bound of current range */
+	    curr->high += span;
+	} else {
+	    /* insert new entry before current */
+	    curr = Insert(&ranges, curr);
+	    curr->low = low;
+	    curr->high = high;
+	}
+	/* adjust all successors */
+	last = ranges->items + ranges->size;
+	for (++curr; curr != last; ++curr) {
+	    curr->low += span;
+	    curr->high += span;
+	}
+    }
+
+    ranges->count += span;
+    assert(ComputeRangeSize(ranges) == ranges->count);
+    return ranges;
+}
+
+
+TkRangeList *
+TkRangeListRemove(
+    TkRangeList *ranges,
+    int low,
+    int high)
+{
+    TkRange *curr;
+    TkRange *last;
+    int span;
+
+    assert(ranges);
+    assert(low <= high);
+
+    if (ranges->size == 0) {
+	return ranges;
+    }
+
+    last = ranges->items + ranges->size;
+    low = MAX(low, ranges->items[0].low);
+    high = MIN(high, (last - 1)->high);
+
+    if (low > high) {
+	return ranges;
+    }
+
+    span = high - low + 1;
+    curr = LowerBound(ranges->items, last, low);
+
+    if (curr != last) {
+	TkRange *next;
+	unsigned size;
+
+	if (high < curr->high) {
+	    if (curr->low < low) {
+		/* Example: cur:{1,4} - arg:{2,3} -> {1,1}{4,4} */
+		int h = curr->high;
+		ranges->count -= span;
+		curr->high = low - 1;
+		low = high + 1;
+		curr = (curr == last) ? Increase(&ranges) : Insert(&ranges, curr + 1);
+		curr->low = low;
+		curr->high = h;
+	    } else if (curr->low <= high) {
+		/* Example: cur:{1,4} - arg:{1,3} -> {4,4} */
+		int low = high + 1;
+		ranges->count -= low - curr->low;
+		curr->low = low;
+	    }
+	} else {
+	    if (curr->low < low && low <= curr->high) {
+		/* Example: cur:{1,7} - arg:{2,5} -> {1,1} */
+		/* Example: cur:{1,3} - arg:{3,6} -> {1,2} */
+		/* Example: cur:{1,1} - arg:{2,5} -> {1,1} */
+		int high = low - 1;
+		ranges->count -= curr->high - high;
+		curr->high = high;
+		curr += 1;
+	    } else if (curr->high < low) {
+		curr += 1;
+	    }
+
+	    for (next = curr; next != last && next->high <= high; ++next) {
+		ranges->count -= TkRangeSpan(next);
+	    }
+
+	    memmove(curr, next, (last - next)*sizeof(TkRange));
+	    ranges->size -= (size = next - curr);
+	    last -= size;
+
+	    if (curr != last) {
+		if (curr->low <= high) {
+		    ranges->count -= high + 1 - curr->low;
+		    curr->low = high + 1;
+		}
+	    }
+	}
+    }
+
+    assert(ComputeRangeSize(ranges) == ranges->count);
+    return ranges;
+}
+
+
+TkRangeList *
+TkRangeListDelete(
+    TkRangeList *ranges,
+    int low,
+    int high)
+{
+    TkRange *curr;
+    TkRange *last;
+    int span;
+    int lower;
+
+    assert(ranges);
+    assert(low <= high);
+
+    if (ranges->size == 0 || low > TkRangeListHigh(ranges)) {
+	return ranges;
+    }
+
+    last = ranges->items + ranges->size;
+    span = high - low + 1;
+    low = MAX(low, TkRangeListLow(ranges));
+    high = MIN(high, TkRangeListHigh(ranges));
+    curr = LowerBound(ranges->items, last, low);
+    lower = high;
+
+    if (curr != last) {
+	TkRange *next;
+	unsigned size;
+
+	if (curr->low < low && low <= curr->high) {
+	    /* Example: cur:{1,7} - arg:{2,5} -> {1,3} */
+	    /* Example: cur:{1,3} - arg:{3,6} -> {1,2} */
+	    /* Example: cur:{1,1} - arg:{2,5} -> {1,1} */
+	    int high = MAX(low - 1, curr->high - span);
+	    ranges->count -= curr->high - high;
+	    curr->high = high;
+	    next = curr + 1;
+	    if (next != last && curr->high + 1 >= next->low - span) {
+		/* Example: curr:{0,3}{8,9}{29,33} - arg:{1,30} -> {0,3} */
+		lower = curr->low;
+	    } else {
+		curr = next;
+	    }
+	} else if (curr->high < low) {
+	    curr += 1;
+	}
+
+	for (next = curr; next != last && next->high <= high; ++next) {
+	    ranges->count -= TkRangeSpan(next);
+	}
+
+	memmove(curr, next, (last - next)*sizeof(TkRange));
+	ranges->size -= (size = next - curr);
+	last -= size;
+
+	if (curr != last) {
+	    if (lower < curr->low) {
+		lower += span;
+		ranges->count -= lower - curr->low;
+		curr->low = lower;
+	    } else if (curr->low <= high) {
+		ranges->count -= high + 1 - curr->low;
+		curr->low = high + 1;
+	    }
+	    for (next = curr; next != last; next += 1) {
+		next->low -= span;
+		next->high -= span;
+	    }
+	}
+    }
+
+    assert(ComputeRangeSize(ranges) == ranges->count);
+    return ranges;
+}
+
+
+#if !NDEBUG
+
+void
+TkRangeListPrint(
+    const TkRangeList *ranges)
+{
+    unsigned i;
+
+    for (i = 0; i < ranges->size; ++i) {
+	printf("{%d,%d} ", ranges->items[i].low, ranges->items[i].high);
+    }
+    printf("(%d)\n", ranges->count);
+}
+
+#endif /* !NDEBUG */
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+/* Additionally we need stand-alone object code. */
+#define inline extern
+inline int TkRangeSpan(const TkRange *range);
+inline bool TkRangeTest(const TkRange *range, int value);
+inline int TkRangeListLow(const TkRangeList *ranges);
+inline int TkRangeListHigh(const TkRangeList *ranges);
+inline unsigned TkRangeListSpan(const TkRangeList *ranges);
+inline unsigned TkRangeListCount(const TkRangeList *ranges);
+inline unsigned TkRangeListSize(const TkRangeList *ranges);
+inline const TkRange *TkRangeListAccess(const TkRangeList *ranges, unsigned index);
+inline const TkRange *TkRangeListFirst(const TkRangeList *ranges);
+inline const TkRange *TkRangeListNext(const TkRangeList *ranges, const TkRange *item);
+inline bool TkRangeListIsEmpty(const TkRangeList *ranges);
+inline bool TkRangeListContains(const TkRangeList *ranges, int value);
+inline bool TkRangeListContainsRange(const TkRangeList *ranges, int low, int high);
+#endif /* __STDC_VERSION__ >= 199901L */
+
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkRangeList.h
===================================================================
--- src/tktext/tkRangeList.h	(revision 0)
+++ src/tktext/tkRangeList.h	(working copy)
@@ -0,0 +1,215 @@
+/*
+ * tkRangeList.h --
+ *
+ *	This module implements operations on a list of integer ranges.
+ *	Note that the current implementation expects short lists of
+ *	ranges, it is quite slow for large list sizes (large number of
+ *	range items).
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKRANGELIST
+#define _TKRANGELIST
+
+#include "tkBool.h"
+
+#if defined(__GNUC__) || defined(__clang__)
+# define __warn_unused__ __attribute__((warn_unused_result))
+#else
+# define __warn_unused__
+#endif
+
+#ifdef _MSC_VER
+# if _MSC_VER >= 1900
+#  define inline __inline
+# else
+#  define inline
+# endif
+#elif __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+typedef struct TkRange {
+    int low;
+    int high;
+} TkRange;
+
+/*
+ * Return the span of given range.
+ */
+inline int TkRangeSpan(const TkRange *range);
+
+/*
+ * Test whether given range contains the specified value.
+ */
+inline bool TkRangeTest(const TkRange *range, int value);
+
+
+typedef struct TkRangeList {
+    unsigned size;
+    unsigned capacity;
+    unsigned count;
+    TkRange items[1];
+} TkRangeList;
+
+/*
+ * Create a range list, and reserve some space for range entries.
+ */
+TkRangeList *TkRangeListCreate(unsigned capacity) __warn_unused__;
+
+/*
+ * Make a copy of given list.
+ */
+TkRangeList *TkRangeListCopy(const TkRangeList *ranges) __warn_unused__;
+
+/*
+ * Destroy the range list, the derefenced pointer can be NULL (in this case the
+ * list is already destroyed).
+ */
+void TkRangeListDestroy(TkRangeList **rangesPtr);
+
+/*
+ * Clear the given list of ranges.
+ */
+void TkRangeListClear(TkRangeList *ranges);
+
+/*
+ * Truncate this list at front until given value (inclusive). This means that after
+ * truncation the lowest value in this list will be larger than 'untilThisValue'.
+ */
+void TkRangeListTruncateAtFront(TkRangeList *ranges, int untilThisValue);
+
+/*
+ * Truncate this list at end with given value (exclusive). This means that after
+ * truncation the highest value in this list will be less or equal to 'maxValue'.
+ */
+void TkRangeListTruncateAtEnd(TkRangeList *ranges, int maxValue);
+
+/*
+ * Return the lower value of the entry with lowest order (ths lowest value inside
+ * the whole list).
+ */
+inline int TkRangeListLow(const TkRangeList *ranges);
+
+/*
+ * Return the upper value of the entry with highest order (ths highest value inside
+ * the whole list).
+ */
+inline int TkRangeListHigh(const TkRangeList *ranges);
+
+/*
+ * Return the span of the whole list (= TkRangeListHigh(ranges) - TkRangeListLow(ranges) + 1).
+ */
+inline unsigned TkRangeListSpan(const TkRangeList *ranges);
+
+/*
+ * Return the number of integers contained in this list.
+ */
+inline unsigned TkRangeListCount(const TkRangeList *ranges);
+
+/*
+ * Return the number of entries (pairs) in this list.
+ */
+inline unsigned TkRangeListSize(const TkRangeList *ranges);
+
+/*
+ * Return a specific entry (pair), the index must not exceed the size of this list.
+ */
+inline const TkRange *TkRangeListAccess(const TkRangeList *ranges, unsigned index);
+
+/*
+ * Find entry (pair) which contains the given value. NULL will be returned if
+ * this value is not contained in this list.
+ */
+const TkRange *TkRangeListFind(const TkRangeList *ranges, int value);
+
+/*
+ * Find entry (pair) which contains the given value. If this value is not contained
+ * in given list then return the item with a low value nearest to specified value.
+ * But it never returns an item with a high value less than given value, so it's
+ * possible that NULL we returned.
+ */
+const TkRange *TkRangeListFindNearest(const TkRangeList *ranges, int value);
+
+/*
+ * Return the first item in given list, can be NULL if list is empty.
+ */
+inline const TkRange *TkRangeListFirst(const TkRangeList *ranges);
+
+/*
+ * Return the next item in given list, can be NULL if at end of list.
+ */
+inline const TkRange *TkRangeListNext(const TkRangeList *ranges, const TkRange *item);
+
+/*
+ * Return whether this list is empty.
+ */
+inline bool TkRangeListIsEmpty(const TkRangeList *ranges);
+
+/*
+ * Return whether the given value is contained in this list.
+ */
+inline bool TkRangeListContains(const TkRangeList *ranges, int value);
+
+/*
+ * Return whether the given range is contained in this list.
+ */
+inline bool TkRangeListContainsRange(const TkRangeList *ranges, int low, int high);
+
+/*
+ * Return whether any value of the given range is contained in this list.
+ */
+bool TkRangeListContainsAny(const TkRangeList *ranges, int low, int high);
+
+/*
+ * Add given range to this list. Adjacent entries (pairs) will be amalgamated
+ * automatically.
+ */
+TkRangeList *TkRangeListAdd(TkRangeList *ranges, int low, int high) __warn_unused__;
+
+/*
+ * Remove given range from list. Adjacent entries (pairs) will be amalgamated
+ * automatically.
+ */
+TkRangeList *TkRangeListRemove(TkRangeList *ranges, int low, int high);
+
+/*
+ * Insert given range to this list. This method has the side effect that all contained
+ * integers with a value higher than the 'high' value will be increased by the span of
+ * the given range (high - low + 1). Adjacent entries (pairs) will be amalgamated
+ * automatically.
+ *
+ * Example: TkRangeListInsert({{5,6} {8,9}}, 1, 5) -> {{1,5} {10,11} {13,14}}
+ */
+TkRangeList *TkRangeListInsert(TkRangeList *ranges, int low, int high) __warn_unused__;
+
+/*
+ * Delete given range from list. This method has the side effect that all contained
+ * integers with a value higher than the 'low' value will be decreased by the span of
+ * the given range (high - low + 1). Adjacent entries (pairs) will be amalgamated
+ * automatically.
+ *
+ * Example: TkRangeListDelete({{5,6} {8,9}}, 1, 5) -> {{1} {3,4}}
+ */
+TkRangeList *TkRangeListDelete(TkRangeList *ranges, int low, int high);
+
+#if !NDEBUG
+void TkRangeListPrint(const TkRangeList *ranges);
+#endif
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+# define _TK_NEED_IMPLEMENTATION
+# include "tkRangeListPriv.h"
+# undef _TK_NEED_IMPLEMENTATION
+#else
+# undef inline
+#endif
+
+#endif /* _TKRANGELIST */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkRangeListPriv.h
===================================================================
--- src/tktext/tkRangeListPriv.h	(revision 0)
+++ src/tktext/tkRangeListPriv.h	(working copy)
@@ -0,0 +1,168 @@
+/*
+ * tkRangeListPriv.h --
+ *
+ *	Private implementation for range list.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKRANGELIST
+# error "do not include this private header file"
+#endif
+
+
+#ifdef _TK_NEED_IMPLEMENTATION
+
+#include <stddef.h>
+#include <assert.h>
+
+#if __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+inline
+int
+TkRangeSpan(
+    const TkRange *range)
+{
+    assert(range);
+    return range->high - range->low + 1;
+}
+
+
+inline
+bool
+TkRangeTest(
+    const TkRange *range,
+    int value)
+{
+    assert(range);
+    return range->low <= value && value <= range->high;
+}
+
+
+inline
+bool
+TkRangeListIsEmpty(
+    const TkRangeList *ranges)
+{
+    assert(ranges);
+    return ranges->size == 0;
+}
+
+
+inline
+int
+TkRangeListLow(
+    const TkRangeList *ranges)
+{
+    assert(ranges);
+    assert(!TkRangeListIsEmpty(ranges));
+    return ranges->items[0].low;
+}
+
+
+inline
+int
+TkRangeListHigh(
+    const TkRangeList *ranges)
+{
+    assert(ranges);
+    assert(!TkRangeListIsEmpty(ranges));
+    return ranges->items[ranges->size - 1].high;
+}
+
+
+inline
+unsigned
+TkRangeListSpan(
+    const TkRangeList *ranges)
+{
+    assert(ranges);
+    return ranges->size ? TkRangeListHigh(ranges) - TkRangeListLow(ranges) + 1 : 0;
+}
+
+
+inline
+unsigned
+TkRangeListSize(
+    const TkRangeList *ranges)
+{
+    assert(ranges);
+    return ranges->size;
+}
+
+
+inline
+unsigned
+TkRangeListCount(
+    const TkRangeList *ranges)
+{
+    assert(ranges);
+    return ranges->count;
+}
+
+
+inline
+const TkRange *
+TkRangeListAccess(
+    const TkRangeList *ranges,
+    unsigned index)
+{
+    assert(ranges);
+    assert(index < TkRangeListSize(ranges));
+    return &ranges->items[index];
+}
+
+
+inline
+bool
+TkRangeListContains(
+    const TkRangeList *ranges,
+    int value)
+{
+    return !!TkRangeListFind(ranges, value);
+}
+
+
+inline
+bool
+TkRangeListContainsRange(
+    const TkRangeList *ranges,
+    int low,
+    int high)
+{
+    const TkRange *range = TkRangeListFind(ranges, low);
+    return range && range->high <= high;
+}
+
+
+inline
+const TkRange *
+TkRangeListFirst(
+    const TkRangeList *ranges)
+{
+    assert(ranges);
+    return ranges->size == 0 ? NULL : ranges->items;
+}
+
+
+inline
+const TkRange *
+TkRangeListNext(
+    const TkRangeList *ranges,
+    const TkRange *item)
+{
+    assert(item);
+    assert(ranges);
+    assert(ranges->items <= item && item < ranges->items + ranges->size);
+    return ++item == ranges->items + ranges->size ? NULL : item;
+}
+
+#undef _TK_NEED_IMPLEMENTATION
+#endif /* _TK_NEED_IMPLEMENTATION */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkText.c
===================================================================
--- src/tktext/tkText.c	(revision 0)
+++ src/tktext/tkText.c	(working copy)
@@ -0,0 +1,11547 @@
+/*
+ * tkText.c --
+ *
+ *	This module provides a big chunk of the implementation of multi-line
+ *	editable text widgets for Tk. Among other things, it provides the Tcl
+ *	command interfaces to text widgets. The B-tree representation of text
+ *	and its actual display are implemented elsewhere.
+ *
+ * Copyright (c) 1992-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1996 Sun Microsystems, Inc.
+ * Copyright (c) 1999 by Scriptics Corporation.
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "default.h"
+#include "tkInt.h"
+#include "tkText.h"
+#include "tkTextUndo.h"
+#include "tkTextTagSet.h"
+#include "tkBitField.h"
+#include <stdlib.h>
+#include <ctype.h>
+#include <assert.h>
+
+#if !(__STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900))
+# define _TK_NEED_IMPLEMENTATION
+# include "tkTextPriv.h"
+#endif
+
+#ifndef MAX
+# define MAX(a,b) ((a) < (b) ? b : a)
+#endif
+#ifndef MIN
+# define MIN(a,b) ((a) < (b) ? a : b)
+#endif
+
+#if NDEBUG
+# define DEBUG(expr)
+#else
+# define DEBUG(expr) expr
+#endif
+
+/*
+ * Support of tk8.5.
+ */
+#ifdef CONST
+# undef CONST
+#endif
+#if TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION == 5
+# define CONST
+#else
+# define CONST const
+#endif
+
+/*
+ * For compatibility with Tk 4.0 through 8.4.x, we allow tabs to be
+ * mis-specified with non-increasing values. These are converted into tabs
+ * which are the equivalent of at least a character width apart.
+ */
+
+#if TK_MAJOR_VERSION < 9
+#define _TK_ALLOW_DECREASING_TABS
+#endif
+
+#include "tkText.h"
+
+/*
+ * Used to avoid having to allocate and deallocate arrays on the fly for
+ * commonly used functions. Must be > 0.
+ */
+
+#define PIXEL_CLIENTS 8
+
+/*
+ * The 'TkTextState' enum in tkText.h is used to define a type for the -state
+ * option of the Text widget. These values are used as indices into the string
+ * table below.
+ */
+
+static const char *CONST stateStrings[] = {
+    "disabled", "normal", "readonly", NULL
+};
+
+/*
+ * The 'TkTextTagging' enum in tkText.h is used to define a type for the -tagging
+ * option of the Text widget. These values are used as indices into the string table below.
+ */
+
+static const char *CONST taggingStrings[] = {
+    "within", "gravity", "none", NULL
+};
+
+/*
+ * The 'TkTextJustify' enum in tkText.h is used to define a type for the -justify option of
+ * the Text widget. These values are used as indices into the string table below.
+ */
+
+static const char *CONST justifyStrings[] = {
+    "left", "right", "full", "center", NULL
+};
+
+/*
+ * The 'TkWrapMode' enum in tkText.h is used to define a type for the -wrap
+ * option of the Text widget. These values are used as indices into the string
+ * table below.
+ */
+
+static const char *CONST wrapStrings[] = {
+    "char", "none", "word", "codepoint", NULL
+};
+
+/*
+ * The 'TkSpacing' enum in tkText.h is used to define a type for the -spacing
+ * option of the Text widget. These values are used as indices into the string
+ * table below.
+ */
+
+static const char *CONST spaceModeStrings[] = {
+    "none", "exact", "trim", NULL
+};
+
+/*
+ * The 'TkTextTabStyle' enum in tkText.h is used to define a type for the
+ * -tabstyle option of the Text widget. These values are used as indices into
+ * the string table below.
+ */
+
+static const char *CONST tabStyleStrings[] = {
+    "tabular", "wordprocessor", NULL
+};
+
+/*
+ * The 'TkTextInsertUnfocussed' enum in tkText.h is used to define a type for
+ * the -insertunfocussed option of the Text widget. These values are used as
+ * indice into the string table below.
+ */
+
+static const char *CONST insertUnfocussedStrings[] = {
+    "hollow", "none", "solid", NULL
+};
+
+/*
+ * The 'TkTextHyphenRule' enum in tkText.h is used to define a type for the
+ * -hyphenrules option of the Text widget. These values are used for applying
+ * hyphen rules to soft hyphens.
+ */
+
+static const char *const hyphenRuleStrings[] = {
+    "ck", "doubledigraph", "doublevowel", "gemination", "repeathyphen", "trema",
+    "tripleconsonant" /* don't appebd a trailing NULL */
+};
+
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+
+/*
+ * The following functions and custom option type are used to define the
+ * "line" option type, and thereby handle the text widget '-startline',
+ * '-endline' configuration options which are of that type.
+ *
+ * We do not need a 'freeProc' because all changes to these two options are
+ * handled through the TK_TEXT_LINE_RANGE flag in the optionSpecs list, and
+ * the internal storage is just a pointer, which therefore doesn't need
+ * freeing.
+ */
+
+static int		SetLineStartEnd(ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin,
+			    Tcl_Obj **value, char *recordPtr, int internalOffset, char *oldInternalPtr,
+			    int flags);
+static Tcl_Obj *	GetLineStartEnd(ClientData clientData, Tk_Window tkwin, char *recordPtr,
+			    int internalOffset);
+static void		RestoreLineStartEnd(ClientData clientData, Tk_Window tkwin, char *internalPtr,
+			    char *oldInternalPtr);
+
+static CONST Tk_ObjCustomOption lineOption = {
+    "line",			/* name */
+    SetLineStartEnd,		/* setProc */
+    GetLineStartEnd,		/* getProc */
+    RestoreLineStartEnd,	/* restoreProc */
+    NULL,			/* freeProc */
+    0
+};
+
+#endif /* SUPPORT_DEPRECATED_STARTLINE_ENDLINE */
+
+/*
+ * The following functions and custom option type are used to define the
+ * "index" option type, and thereby handle the text widget '-startindex',
+ * '-endindex' configuration options which are of that type.
+ */
+
+static int		SetTextStartEnd(ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin,
+			    Tcl_Obj **value, char *recordPtr, int internalOffset, char *oldInternalPtr,
+			    int flags);
+static Tcl_Obj *	GetTextStartEnd(ClientData clientData, Tk_Window tkwin, char *recordPtr,
+			    int internalOffset);
+static void		RestoreTextStartEnd(ClientData clientData, Tk_Window tkwin, char *internalPtr,
+			    char *oldInternalPtr);
+static void		FreeTextStartEnd(ClientData clientData, Tk_Window tkwin, char *internalPtr);
+
+static CONST Tk_ObjCustomOption startEndMarkOption = {
+    "index",			/* name */
+    SetTextStartEnd,		/* setProc */
+    GetTextStartEnd,		/* getProc */
+    RestoreTextStartEnd,	/* restoreProc */
+    FreeTextStartEnd,		/* freeProc */
+    0
+};
+
+/*
+ * Information used to parse text configuration options:
+ */
+
+static const Tk_OptionSpec optionSpecs[] = {
+    {TK_OPTION_BOOLEAN, "-autoseparators", "autoSeparators",
+	"AutoSeparators", DEF_TEXT_AUTO_SEPARATORS, -1, Tk_Offset(TkText, autoSeparators),
+	TK_OPTION_DONT_SET_DEFAULT, 0, 0},
+    {TK_OPTION_BORDER, "-background", "background", "Background",
+	DEF_TEXT_BG_COLOR, -1, Tk_Offset(TkText, border), 0, DEF_TEXT_BG_MONO, TK_TEXT_LINE_REDRAW},
+    {TK_OPTION_SYNONYM, "-bd", NULL, NULL,
+	NULL, 0, -1, 0, "-borderwidth", TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_SYNONYM, "-bg", NULL, NULL,
+	NULL, 0, -1, 0, "-background", TK_TEXT_LINE_REDRAW},
+    {TK_OPTION_BOOLEAN, "-blockcursor", "blockCursor",
+	"BlockCursor", DEF_TEXT_BLOCK_CURSOR, -1, Tk_Offset(TkText, blockCursorType), 0, 0, 0},
+    {TK_OPTION_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
+	DEF_TEXT_BORDER_WIDTH, -1, Tk_Offset(TkText, borderWidth), 0, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_CURSOR, "-cursor", "cursor", "Cursor",
+	DEF_TEXT_CURSOR, -1, Tk_Offset(TkText, cursor), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_CUSTOM, "-endindex", NULL, NULL,
+	 NULL, -1, Tk_Offset(TkText, newEndIndex), 0, &startEndMarkOption, TK_TEXT_INDEX_RANGE},
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+    {TK_OPTION_CUSTOM, "-endline", NULL, NULL,
+	 NULL, -1, Tk_Offset(TkText, endLine), TK_OPTION_NULL_OK, &lineOption, TK_TEXT_LINE_RANGE},
+#endif
+    {TK_OPTION_STRING, "-eolchar", "eolChar", "EolChar",
+	NULL, Tk_Offset(TkText, eolCharPtr), -1, TK_OPTION_NULL_OK, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_COLOR, "-eolcolor", "eolColor", "EolColor",
+	DEF_TEXT_FG, -1, Tk_Offset(TkText, eolColor), TK_OPTION_NULL_OK, 0, TK_TEXT_LINE_REDRAW},
+    {TK_OPTION_BOOLEAN, "-exportselection", "exportSelection",
+	"ExportSelection", DEF_TEXT_EXPORT_SELECTION, -1, Tk_Offset(TkText, exportSelection), 0, 0, 0},
+    {TK_OPTION_SYNONYM, "-fg", "foreground", NULL,
+	NULL, 0, -1, 0, "-foreground", TK_TEXT_LINE_REDRAW},
+    {TK_OPTION_FONT, "-font", "font", "Font",
+	DEF_TEXT_FONT, -1, Tk_Offset(TkText, tkfont), 0, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_COLOR, "-foreground", "foreground", "Foreground",
+	DEF_TEXT_FG, -1, Tk_Offset(TkText, fgColor), 0, 0, TK_TEXT_LINE_REDRAW},
+    {TK_OPTION_PIXELS, "-height", "height", "Height",
+	DEF_TEXT_HEIGHT, -1, Tk_Offset(TkText, height), 0, 0, 0},
+    {TK_OPTION_COLOR, "-highlightbackground", "highlightBackground", "HighlightBackground",
+	DEF_TEXT_HIGHLIGHT_BG, -1, Tk_Offset(TkText, highlightBgColorPtr), 0, 0, 0},
+    {TK_OPTION_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
+	DEF_TEXT_HIGHLIGHT, -1, Tk_Offset(TkText, highlightColorPtr), 0, 0, 0},
+    {TK_OPTION_PIXELS, "-highlightthickness", "highlightThickness", "HighlightThickness",
+	DEF_TEXT_HIGHLIGHT_WIDTH, -1, Tk_Offset(TkText, highlightWidth), 0, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_STRING, "-hyphenrules", NULL, NULL,
+	NULL, Tk_Offset(TkText, hyphenRulesPtr), -1, TK_OPTION_NULL_OK, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_COLOR, "-hyphencolor", "hyphenColor", "HyphenColor",
+	DEF_TEXT_FG, -1, Tk_Offset(TkText, hyphenColor), TK_OPTION_NULL_OK, 0, TK_TEXT_LINE_REDRAW},
+    {TK_OPTION_BOOLEAN, "-hyphens", "hyphens", "Hyphens",
+	"0", -1, Tk_Offset(TkText, hyphens), 0, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_BORDER, "-inactiveselectbackground", "inactiveSelectBackground", "Foreground",
+	DEF_TEXT_INACTIVE_SELECT_COLOR, -1, Tk_Offset(TkText, inactiveSelBorder),
+	TK_OPTION_NULL_OK, DEF_TEXT_SELECT_MONO, 0},
+    {TK_OPTION_BORDER, "-insertbackground", "insertBackground", "Foreground",
+	DEF_TEXT_INSERT_BG, -1, Tk_Offset(TkText, insertBorder), 0, 0, 0},
+    {TK_OPTION_PIXELS, "-insertborderwidth", "insertBorderWidth",
+	"BorderWidth", DEF_TEXT_INSERT_BD_COLOR, -1, Tk_Offset(TkText, insertBorderWidth), 0,
+	(ClientData) DEF_TEXT_INSERT_BD_MONO, 0},
+    {TK_OPTION_COLOR, "-insertforeground", "insertForeground", "InsertForeground",
+	DEF_TEXT_BG_COLOR, -1, Tk_Offset(TkText, insertFgColorPtr), 0, 0, 0},
+    {TK_OPTION_INT, "-insertofftime", "insertOffTime", "OffTime",
+	DEF_TEXT_INSERT_OFF_TIME, -1, Tk_Offset(TkText, insertOffTime), 0, 0, 0},
+    {TK_OPTION_INT, "-insertontime", "insertOnTime", "OnTime",
+	DEF_TEXT_INSERT_ON_TIME, -1, Tk_Offset(TkText, insertOnTime), 0, 0, 0},
+    {TK_OPTION_STRING_TABLE,
+	"-insertunfocussed", "insertUnfocussed", "InsertUnfocussed",
+	DEF_TEXT_INSERT_UNFOCUSSED, -1, Tk_Offset(TkText, insertUnfocussed),
+	0, insertUnfocussedStrings, 0},
+    {TK_OPTION_PIXELS, "-insertwidth", "insertWidth", "InsertWidth",
+	DEF_TEXT_INSERT_WIDTH, -1, Tk_Offset(TkText, insertWidth), 0, 0, 0},
+    {TK_OPTION_STRING_TABLE, "-justify", "justify", "Justify",
+	"left", -1, Tk_Offset(TkText, justify), 0, justifyStrings, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_STRING, "-lang", "lang", "Lang",
+	 NULL, Tk_Offset(TkText, langPtr), -1, TK_OPTION_NULL_OK, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_INT, "-maxundo", "maxUndo", "MaxUndo",
+	DEF_TEXT_MAX_UNDO, -1, Tk_Offset(TkText, maxUndoDepth), TK_OPTION_DONT_SET_DEFAULT, 0, 0},
+    {TK_OPTION_INT, "-maxundosize", "maxUndoSize", "MaxUndoSize",
+	DEF_TEXT_MAX_UNDO, -1, Tk_Offset(TkText, maxUndoSize), TK_OPTION_DONT_SET_DEFAULT, 0, 0},
+    {TK_OPTION_INT, "-maxredo", "maxRedo", "MaxRedo",
+	"-1", -1, Tk_Offset(TkText, maxRedoDepth), TK_OPTION_DONT_SET_DEFAULT, 0, 0},
+    {TK_OPTION_PIXELS, "-padx", "padX", "Pad",
+	DEF_TEXT_PADX, -1, Tk_Offset(TkText, padX), 0, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_PIXELS, "-pady", "padY", "Pad",
+	DEF_TEXT_PADY, -1, Tk_Offset(TkText, padY), 0, 0, 0},
+    {TK_OPTION_RELIEF, "-relief", "relief", "Relief",
+	DEF_TEXT_RELIEF, -1, Tk_Offset(TkText, relief), 0, 0, 0},
+    {TK_OPTION_INT, "-responsiveness", "responsiveness", "Responsiveness",
+	"50", -1, Tk_Offset(TkText, responsiveness), 0, 0, 0},
+    {TK_OPTION_BORDER, "-selectbackground", "selectBackground", "Foreground",
+	DEF_TEXT_SELECT_COLOR, -1, Tk_Offset(TkText, selBorder), 0, DEF_TEXT_SELECT_MONO, 0},
+    {TK_OPTION_PIXELS, "-selectborderwidth", "selectBorderWidth", "BorderWidth",
+	DEF_TEXT_SELECT_BD_COLOR, Tk_Offset(TkText, selBorderWidthPtr),
+	Tk_Offset(TkText, selBorderWidth), TK_OPTION_NULL_OK, DEF_TEXT_SELECT_BD_MONO, 0},
+    {TK_OPTION_COLOR, "-selectforeground", "selectForeground", "Background",
+	DEF_TEXT_SELECT_FG_COLOR, -1, Tk_Offset(TkText, selFgColorPtr),
+	TK_OPTION_NULL_OK, DEF_TEXT_SELECT_FG_MONO, 0},
+    {TK_OPTION_BOOLEAN, "-setgrid", "setGrid", "SetGrid",
+	DEF_TEXT_SET_GRID, -1, Tk_Offset(TkText, setGrid), 0, 0, 0},
+    {TK_OPTION_BOOLEAN, "-showendofline", "showEndOfLine", "ShowEndOfLine",
+	"0", -1, Tk_Offset(TkText, showEndOfLine), 0, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_BOOLEAN, "-showinsertforeground", "showInsertForeground", "ShowInsertForeground",
+	"0", -1, Tk_Offset(TkText, showInsertFgColor), 0, 0, 0},
+    {TK_OPTION_STRING_TABLE, "-spacemode", "spaceMode", "SpaceMode",
+	"none", -1, Tk_Offset(TkText, spaceMode), 0, spaceModeStrings, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_PIXELS, "-spacing1", "spacing1", "Spacing",
+	DEF_TEXT_SPACING1, -1, Tk_Offset(TkText, spacing1), 0, 0 , TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_PIXELS, "-spacing2", "spacing2", "Spacing",
+	DEF_TEXT_SPACING2, -1, Tk_Offset(TkText, spacing2), 0, 0 , TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_PIXELS, "-spacing3", "spacing3", "Spacing",
+	DEF_TEXT_SPACING3, -1, Tk_Offset(TkText, spacing3), 0, 0 , TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_CUSTOM, "-startindex", NULL, NULL,
+	 NULL, -1, Tk_Offset(TkText, newStartIndex), 0, &startEndMarkOption, TK_TEXT_INDEX_RANGE},
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+    {TK_OPTION_CUSTOM, "-startline", NULL, NULL,
+	 NULL, -1, Tk_Offset(TkText, startLine), TK_OPTION_NULL_OK, &lineOption, TK_TEXT_LINE_RANGE},
+#endif
+    {TK_OPTION_STRING_TABLE, "-state", "state", "State",
+	DEF_TEXT_STATE, -1, Tk_Offset(TkText, state), 0, stateStrings, 0},
+    {TK_OPTION_BOOLEAN, "-steadymarks", "steadyMarks", "SteadyMarks",
+	"0", -1, Tk_Offset(TkText, steadyMarks), TK_OPTION_DONT_SET_DEFAULT, 0, 0},
+    {TK_OPTION_INT, "-synctime", "syncTime", "SyncTime", "150", -1, Tk_Offset(TkText, syncTime),
+	0, 0, TK_TEXT_SYNCHRONIZE},
+    {TK_OPTION_STRING, "-tabs", "tabs", "Tabs",
+	DEF_TEXT_TABS, Tk_Offset(TkText, tabOptionPtr), -1, TK_OPTION_NULL_OK, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_STRING_TABLE, "-tabstyle", "tabStyle", "TabStyle",
+	DEF_TEXT_TABSTYLE, -1, Tk_Offset(TkText, tabStyle), 0, tabStyleStrings, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_STRING_TABLE, "-tagging", "tagging", "Tagging",
+	"within", -1, Tk_Offset(TkText, tagging), 0, taggingStrings, 0},
+    {TK_OPTION_STRING, "-takefocus", "takeFocus", "TakeFocus",
+	DEF_TEXT_TAKE_FOCUS, -1, Tk_Offset(TkText, takeFocus), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_BOOLEAN, "-undo", "undo", "Undo",
+	DEF_TEXT_UNDO, -1, Tk_Offset(TkText, undo), TK_OPTION_DONT_SET_DEFAULT, 0 ,0},
+    {TK_OPTION_BOOLEAN, "-useunibreak", "useUniBreak", "UseUniBreak",
+	"0", -1, Tk_Offset(TkText, useUniBreak), 0, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_INT, "-width", "width", "Width",
+	DEF_TEXT_WIDTH, -1, Tk_Offset(TkText, width), 0, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_STRING_TABLE, "-wrap", "wrap", "Wrap",
+	DEF_TEXT_WRAP, -1, Tk_Offset(TkText, wrapMode), 0, wrapStrings, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_STRING, "-xscrollcommand", "xScrollCommand", "ScrollCommand",
+	DEF_TEXT_XSCROLL_COMMAND, -1, Tk_Offset(TkText, xScrollCmd), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-yscrollcommand", "yScrollCommand", "ScrollCommand",
+	DEF_TEXT_YSCROLL_COMMAND, -1, Tk_Offset(TkText, yScrollCmd), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_END, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0}
+};
+
+/*
+ * These three typedefs, the structure and the SearchPerform, SearchCore
+ * functions below are used for line-based searches of the text widget, and,
+ * in particular, to handle multi-line matching even though the text widget is
+ * a single-line based data structure. They are completely abstracted away
+ * from the Text widget internals, however, so could easily be re-used with
+ * any line-based entity to provide multi-line matching.
+ *
+ * We have abstracted this code away from the text widget to try to keep Tk as
+ * modular as possible.
+ */
+
+struct SearchSpec;	/* Forward declaration. */
+
+typedef ClientData	SearchAddLineProc(int lineNum, struct SearchSpec *searchSpecPtr,
+			    Tcl_Obj *theLine, int *lenPtr, int *extraLinesPtr);
+typedef bool		SearchMatchProc(int lineNum, struct SearchSpec *searchSpecPtr,
+			    ClientData clientData, Tcl_Obj *theLine, int matchOffset, int matchLength);
+typedef int		SearchLineIndexProc(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    struct SearchSpec *searchSpecPtr, int *linePosPtr, int *offsetPosPtr);
+
+typedef struct SearchSpec {
+    TkText *textPtr;		/* Information about widget. */
+    bool exact;			/* Whether search is exact or regexp. */
+    bool noCase;		/* Case-insenstivive? */
+    bool noLineStop;		/* If not set, a regexp search will use the TCL_REG_NLSTOP flag. */
+    bool overlap;		/* If set, results from multiple searches (-all) are allowed to
+    				 * overlap each other. */
+    bool strictLimits;		/* If set, matches must be completely inside the from,to range.
+    				 * Otherwise the limits only apply to the start of each match. */
+    bool all;			/* Whether all or the first match should be reported. */
+    bool backwards;		/* Searching forwards or backwards. */
+    bool searchElide;		/* Search in hidden text as well. */
+    bool searchHyphens;		/* Search in soft hyhens as well. */
+    int startLine;		/* First line to examine. */
+    int startOffset;		/* Index in first line to start at. */
+    int stopLine;		/* Last line to examine, or -1 when we search all available text. */
+    int stopOffset;		/* Index to stop at, provided stopLine is not -1. */
+    int numLines;		/* Total lines which are available. */
+    Tcl_Obj *varPtr;		/* If non-NULL, store length(s) of match(es) in this variable. */
+    Tcl_Obj *countPtr;		/* Keeps track of currently found lengths. */
+    Tcl_Obj *resPtr;		/* Keeps track of currently found locations */
+    SearchAddLineProc *addLineProc;
+				/* Function to call when we need to add another line to the search
+				 * string so far */
+    SearchMatchProc *foundMatchProc;
+				/* Function to call when we have found a match. */
+    SearchLineIndexProc *lineIndexProc;
+				/* Function to call when we have found a match. */
+    ClientData clientData;	/* Information about structure being searched, in this case a text
+    				 * widget. */
+} SearchSpec;
+
+/*
+ * The text-widget-independent functions which actually perform the search,
+ * handling both regexp and exact searches.
+ */
+
+static int	SearchCore(Tcl_Interp *interp, SearchSpec *searchSpecPtr, Tcl_Obj *patObj);
+static int	SearchPerform(Tcl_Interp *interp, SearchSpec *searchSpecPtr, Tcl_Obj *patObj,
+		    Tcl_Obj *fromPtr, Tcl_Obj *toPtr);
+
+/*
+ * We need a simple linked list for strings:
+ */
+
+typedef struct TkTextStringList {
+    struct TkTextStringList *nextPtr;
+    Tcl_Obj *strObjPtr;
+} TkTextStringList;
+
+/*
+ * Boolean variable indicating whether or not special debugging code should be executed.
+ */
+
+bool tkTextDebug = false;
+
+typedef const TkTextUndoAtom * (*InspectUndoStackProc)(TkTextUndoStack stack);
+
+/*
+ * Forward declarations for functions defined later in this file:
+ */
+
+static bool		DeleteIndexRange(TkSharedText *sharedTextPtr, TkText *textPtr,
+			    const TkTextIndex *indexPtr1, const TkTextIndex *indexPtr2, int flags,
+			    bool viewUpdate, bool triggerWatchDelete, bool triggerWatchInsert,
+			    bool userFlag, bool final);
+static int		CountIndices(const TkText *textPtr, const TkTextIndex *indexPtr1,
+			    const TkTextIndex *indexPtr2, TkTextCountType type);
+static void		DestroyText(TkText *textPtr);
+static void		ClearText(TkText *textPtr, bool clearTags);
+static void		FireWidgetViewSyncEvent(ClientData clientData);
+static void		FreeEmbeddedWindows(TkText *textPtr);
+static void		InsertChars(TkText *textPtr, TkTextIndex *index1Ptr, TkTextIndex *index2Ptr,
+			    char const *string, unsigned length, bool viewUpdate,
+			    TkTextTagSet *tagInfoPtr, TkTextTag *hyphenTagPtr, bool parseHyphens);
+static void		TextBlinkProc(ClientData clientData);
+static void		TextCmdDeletedProc(ClientData clientData);
+static int		CreateWidget(TkSharedText *sharedTextPtr, Tk_Window tkwin, Tcl_Interp *interp,
+			    const TkText *parent, int objc, Tcl_Obj *const objv[]);
+static void		TextEventProc(ClientData clientData, XEvent *eventPtr);
+static void		ProcessConfigureNotify(TkText *textPtr, bool updateLineGeometry);
+static int		TextFetchSelection(ClientData clientData, int offset, char *buffer,
+			    int maxBytes);
+static int		TextIndexSortProc(const void *first, const void *second);
+static int		TextInsertCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[], const TkTextIndex *indexPtr,
+			    bool viewUpdate, bool triggerWatchDelete, bool triggerWatchInsert,
+			    bool userFlag, bool *destroyed, bool parseHyphens);
+static int		TextReplaceCmd(TkText *textPtr, Tcl_Interp *interp,
+			    const TkTextIndex *indexFromPtr, const TkTextIndex *indexToPtr,
+			    int objc, Tcl_Obj *const objv[], bool viewUpdate, bool triggerWatch,
+			    bool userFlag, bool *destroyed, bool parseHyphens);
+static int		TextSearchCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+static int		TextEditCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+static int		TextWidgetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]);
+static void		TextWorldChangedCallback(ClientData instanceData);
+static void		TextWorldChanged(TkText *textPtr, int mask);
+static void		UpdateLineMetrics(TkText *textPtr, unsigned lineNum, unsigned endLine);
+static int		TextChecksumCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+static int		TextDumpCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+static int		TextInspectCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+static bool		DumpLine(Tcl_Interp *interp, TkText *textPtr,
+			    int what, TkTextLine *linePtr, int start, int end,
+			    int lineno, Tcl_Obj *command, TkTextTag **prevTagPtr);
+static bool		DumpSegment(TkText *textPtr, Tcl_Interp *interp, const char *key,
+			    const char *value, Tcl_Obj *command, const TkTextIndex *index, int what);
+static void		InspectUndoStack(const TkSharedText *sharedTextPtr,
+			    InspectUndoStackProc firstAtomProc, InspectUndoStackProc nextAtomProc,
+			    Tcl_Obj *objPtr);
+static void		InspectRetainedUndoItems(const TkSharedText *sharedTextPtr, Tcl_Obj *objPtr);
+static Tcl_Obj *	TextGetText(TkText *textPtr, const TkTextIndex *index1,
+			    const TkTextIndex *index2, TkTextIndex *lastIndexPtr, Tcl_Obj *resultPtr,
+			    unsigned maxBytes, bool visibleOnly, bool includeHyphens);
+static void		GenerateEvent(TkSharedText *sharedTextPtr, const char *type);
+static void		RunAfterSyncCmd(ClientData clientData);
+static void		UpdateModifiedFlag(TkSharedText *sharedTextPtr, bool flag);
+static Tcl_Obj *	MakeEditInfo(Tcl_Interp *interp, TkText *textPtr, Tcl_Obj *arrayPtr);
+static unsigned		TextSearchIndexInLine(const SearchSpec *searchSpecPtr, TkTextLine *linePtr,
+			    int byteIndex);
+static int		TextPeerCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+static int		TextWatchCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+static bool		TriggerWatchEdit(TkText *textPtr, const char *operation,
+			    const TkTextIndex *indexPtr1, const TkTextIndex *indexPtr2,
+			    const char *info, bool final);
+static void		TriggerUndoStackEvent(TkSharedText *sharedTextPtr);
+static void		PushRetainedUndoTokens(TkSharedText *sharedTextPtr);
+static bool		IsEmpty(const TkSharedText *sharedTextPtr, const TkText *textPtr);
+static bool		IsClean(const TkSharedText *sharedTextPtr, const TkText *textPtr,
+			    bool discardSelection);
+static TkTextUndoPerformProc TextUndoRedoCallback;
+static TkTextUndoFreeProc TextUndoFreeCallback;
+static TkTextUndoStackContentChangedProc TextUndoStackContentChangedCallback;
+
+/*
+ * Some definitions for controlling "dump", "inspect", and "checksum".
+ */
+
+enum {
+    TK_DUMP_TEXT           = SEG_GROUP_CHAR,
+    TK_DUMP_CHARS          = TK_DUMP_TEXT|SEG_GROUP_HYPHEN,
+    TK_DUMP_MARK           = SEG_GROUP_MARK,
+    TK_DUMP_ELIDE          = SEG_GROUP_BRANCH,
+    TK_DUMP_TAG            = SEG_GROUP_TAG,
+    TK_DUMP_WIN            = SEG_GROUP_WINDOW,
+    TK_DUMP_IMG            = SEG_GROUP_IMAGE,
+    TK_DUMP_NODE           = 1 << 20,
+    TK_DUMP_DUMP_ALL       = TK_DUMP_TEXT|TK_DUMP_CHARS|TK_DUMP_MARK|TK_DUMP_TAG|TK_DUMP_WIN|TK_DUMP_IMG,
+
+    TK_DUMP_DISPLAY        = 1 << 21,
+    TK_DUMP_DISPLAY_CHARS  = TK_DUMP_CHARS|TK_DUMP_DISPLAY,
+    TK_DUMP_DISPLAY_TEXT   = TK_DUMP_TEXT|TK_DUMP_DISPLAY,
+    TK_DUMP_CRC_DFLT       = TK_DUMP_TEXT|SEG_GROUP_WINDOW|SEG_GROUP_IMAGE,
+    TK_DUMP_CRC_ALL        = TK_DUMP_TEXT|TK_DUMP_CHARS|TK_DUMP_DISPLAY_TEXT|SEG_GROUP_WINDOW|
+			     SEG_GROUP_IMAGE|TK_DUMP_MARK|TK_DUMP_TAG,
+
+    TK_DUMP_NESTED         = 1 << 22,
+    TK_DUMP_TEXT_CONFIGS   = 1 << 23,
+    TK_DUMP_TAG_CONFIGS    = 1 << 24,
+    TK_DUMP_TAG_BINDINGS   = 1 << 25,
+    TK_DUMP_INSERT_MARK    = 1 << 26,
+    TK_DUMP_DISCARD_SEL    = 1 << 27,
+    TK_DUMP_DONT_RESOLVE   = 1 << 28,
+    TK_DUMP_INSPECT_DFLT   = TK_DUMP_DUMP_ALL|TK_DUMP_TEXT_CONFIGS|TK_DUMP_TAG_CONFIGS,
+    TK_DUMP_INSPECT_ALL    = TK_DUMP_INSPECT_DFLT|TK_DUMP_CHARS|TK_DUMP_TAG_BINDINGS|
+			     TK_DUMP_DISPLAY_TEXT|TK_DUMP_DISCARD_SEL|TK_DUMP_INSERT_MARK|
+			     TK_DUMP_DONT_RESOLVE|TK_DUMP_NESTED|TK_DUMP_ELIDE
+};
+
+/*
+ * Declarations of the three search procs required by the multi-line search routines.
+ */
+
+static SearchMatchProc		TextSearchFoundMatch;
+static SearchAddLineProc	TextSearchAddNextLine;
+static SearchLineIndexProc	TextSearchGetLineIndex;
+
+/*
+ * The structure below defines text class behavior by means of functions that
+ * can be invoked from generic window code.
+ */
+
+static CONST Tk_ClassProcs textClass = {
+    sizeof(Tk_ClassProcs),	/* size */
+    TextWorldChangedCallback,	/* worldChangedProc */
+    NULL,			/* createProc */
+    NULL			/* modalProc */
+};
+
+#if TK_CHECK_ALLOCS
+
+/*
+ * Some stuff for memory checks, and allocation statistic.
+ */
+
+unsigned tkTextCountNewShared = 0;
+unsigned tkTextCountDestroyShared = 0;
+unsigned tkTextCountNewPeer = 0;
+unsigned tkTextCountDestroyPeer = 0;
+unsigned tkTextCountNewPixelInfo = 0;
+unsigned tkTextCountDestroyPixelInfo = 0;
+unsigned tkTextCountNewSegment = 0;
+unsigned tkTextCountDestroySegment = 0;
+unsigned tkTextCountNewTag = 0;
+unsigned tkTextCountDestroyTag = 0;
+unsigned tkTextCountNewUndoToken = 0;
+unsigned tkTextCountDestroyUndoToken = 0;
+unsigned tkTextCountNewNode = 0;
+unsigned tkTextCountDestroyNode = 0;
+unsigned tkTextCountNewLine = 0;
+unsigned tkTextCountDestroyLine = 0;
+unsigned tkTextCountNewSection = 0;
+unsigned tkTextCountDestroySection = 0;
+
+extern unsigned tkIntSetCountDestroy;
+extern unsigned tkIntSetCountNew;
+extern unsigned tkBitCountNew;
+extern unsigned tkBitCountDestroy;
+extern unsigned tkQTreeCountNewTree;
+extern unsigned tkQTreeCountDestroyTree;
+extern unsigned tkQTreeCountNewNode;
+extern unsigned tkQTreeCountDestroyNode;
+extern unsigned tkQTreeCountNewItem;
+extern unsigned tkQTreeCountDestroyItem;
+extern unsigned tkQTreeCountNewElement;
+extern unsigned tkQTreeCountDestroyElement;
+
+typedef struct WatchShared {
+    TkSharedText *sharedTextPtr; 
+    struct WatchShared *nextPtr;
+} WatchShared;
+
+static unsigned widgetNumber = 0;
+static WatchShared *watchShared;
+
+static void
+AllocStatistic()
+{
+    const WatchShared *wShared;
+
+    if (!tkBTreeDebug) {
+	return;
+    }
+
+    for (wShared = watchShared; wShared; wShared = wShared->nextPtr) {
+	const TkText *peer;
+
+	for (peer = wShared->sharedTextPtr->peers; peer; peer = peer->next) {
+	    printf("Unreleased text widget %d\n", peer->widgetNumber);
+	}
+    }
+
+    printf("---------------------------------\n");
+    printf("ALLOCATION:        new    destroy\n");
+    printf("---------------------------------\n");
+    printf("Shared:       %8u - %8u\n", tkTextCountNewShared, tkTextCountDestroyShared);
+    printf("Peer:         %8u - %8u\n", tkTextCountNewPeer, tkTextCountDestroyPeer);
+    printf("Segment:      %8u - %8u\n", tkTextCountNewSegment, tkTextCountDestroySegment);
+    printf("Tag:          %8u - %8u\n", tkTextCountNewTag, tkTextCountDestroyTag);
+    printf("UndoToken:    %8u - %8u\n", tkTextCountNewUndoToken, tkTextCountDestroyUndoToken);
+    printf("Node:         %8u - %8u\n", tkTextCountNewNode, tkTextCountDestroyNode);
+    printf("Line:         %8u - %8u\n", tkTextCountNewLine, tkTextCountDestroyLine);
+    printf("Section:      %8u - %8u\n", tkTextCountNewSection, tkTextCountDestroySection);
+    printf("PixelInfo:    %8u - %8u\n", tkTextCountNewPixelInfo, tkTextCountDestroyPixelInfo);
+    printf("BitField:     %8u - %8u\n", tkBitCountNew, tkBitCountDestroy);
+    printf("IntSet:       %8u - %8u\n", tkIntSetCountNew, tkIntSetCountDestroy);
+    printf("Tree:         %8u - %8u\n", tkQTreeCountNewTree, tkQTreeCountDestroyTree);
+    printf("Tree-Node:    %8u - %8u\n", tkQTreeCountNewNode, tkQTreeCountDestroyNode);
+    printf("Tree-Item:    %8u - %8u\n", tkQTreeCountNewItem, tkQTreeCountDestroyItem);
+    printf("Tree-Element: %8u - %8u\n", tkQTreeCountNewElement, tkQTreeCountDestroyElement);
+    printf("--------------------------------\n");
+
+    if (tkTextCountNewShared != tkTextCountDestroyShared
+	    || tkTextCountNewPeer != tkTextCountDestroyPeer
+	    || tkTextCountNewSegment != tkTextCountDestroySegment
+	    || tkTextCountNewTag != tkTextCountDestroyTag
+	    || tkTextCountNewUndoToken != tkTextCountDestroyUndoToken
+	    || tkTextCountNewNode != tkTextCountDestroyNode
+	    || tkTextCountNewLine != tkTextCountDestroyLine
+	    || tkTextCountNewSection != tkTextCountDestroySection
+	    || tkTextCountNewPixelInfo != tkTextCountDestroyPixelInfo
+	    || tkBitCountNew != tkBitCountDestroy
+	    || tkIntSetCountNew != tkIntSetCountDestroy
+	    || tkQTreeCountNewTree != tkQTreeCountDestroyTree
+	    || tkQTreeCountNewElement != tkQTreeCountDestroyElement
+	    || tkQTreeCountNewNode != tkQTreeCountDestroyNode
+	    || tkQTreeCountNewItem != tkQTreeCountDestroyItem) {
+	printf("*** memory leak detected ***\n");
+	printf("----------------------------\n");
+	/* TkBitCheckAllocs(); */
+    }
+}
+#endif /* TK_CHECK_ALLOCS */
+
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+
+/*
+ * Some helpers.
+ */
+
+static void WarnAboutDeprecatedStartLineOption() {
+    static bool printWarning = true;
+    if (printWarning) {
+	fprintf(stderr, "Option \"-startline\" is deprecated, please use option \"-startindex\"\n");
+	printWarning = false;
+    }
+}
+static void WarnAboutDeprecatedEndLineOption() {
+    static bool printWarning = true;
+    if (printWarning) {
+	fprintf(stderr, "Option \"-endline\" is deprecated, please use option \"-endindex\"\n");
+	printWarning = false;
+    }
+}
+
+#endif /* SUPPORT_DEPRECATED_STARTLINE_ENDLINE */
+
+/*
+ * Wee need a helper for sending virtual events, because in newer Tk version
+ * the footprint of TkSendVirtualEvent has changed. (Note that this source has
+ * backports for 8.5, and older versions of 8.6).
+ */
+
+static void
+SendVirtualEvent(
+    Tk_Window tkwin,
+    char const *eventName,
+    Tcl_Obj *detail)
+{
+#if TK_MAJOR_VERSION > 8 \
+	|| (TK_MAJOR_VERSION == 8 \
+	    && (TK_MINOR_VERSION > 6 || (TK_MINOR_VERSION == 6 && TK_RELEASE_SERIAL >= 6)))
+    /* new footprint since 8.6.6 */
+    TkSendVirtualEvent(tkwin, eventName, detail);
+#else
+# if TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION >= 6
+    if (!detail) {
+	/* new function since 8.6.0, and valid until 8.6.5 */
+	TkSendVirtualEvent(tkwin, eventName);
+	return;
+    }
+# endif
+    {
+	/* backport to 8.5 */
+	union { XEvent general; XVirtualEvent virtual; } event;
+
+	memset(&event, 0, sizeof(event));
+	event.general.xany.type = VirtualEvent;
+	event.general.xany.serial = NextRequest(Tk_Display(tkwin));
+	event.general.xany.send_event = False;
+	event.general.xany.window = Tk_WindowId(tkwin);
+	event.general.xany.display = Tk_Display(tkwin);
+	event.virtual.name = Tk_GetUid(eventName);
+	event.virtual.user_data = detail;
+	Tk_HandleEvent(&event.general);
+    }
+#endif
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * GetByteLength --
+ *
+ *	This function should be defined by Tcl, but it isn't defined,
+ *	so we are doing this.
+ *
+ * Results:
+ *	The length of the string.
+ *
+ * Side effects:
+ *	Calls Tcl_GetString(objPtr) if objPtr->bytes is not yet resolved.
+ *
+ *--------------------------------------------------------------
+ */
+
+static unsigned
+GetByteLength(
+    Tcl_Obj *objPtr)
+{
+    assert(objPtr);
+
+    if (!objPtr->bytes) {
+	Tcl_GetString(objPtr);
+    }
+    return objPtr->length;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * Tk_TextObjCmd --
+ *
+ *	This function is invoked to process the "text" Tcl command. See the
+ *	user documentation for details on what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+int
+Tk_TextObjCmd(
+    ClientData clientData,	/* Main window associated with interpreter. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    Tk_Window tkwin = clientData;
+
+    if (objc < 2) {
+	Tcl_WrongNumArgs(interp, 1, objv, "pathName ?-option value ...?");
+	return TCL_ERROR;
+    }
+
+    if (!tkwin) {
+	tkwin = Tk_MainWindow(interp);
+    }
+    return CreateWidget(NULL, tkwin, interp, NULL, objc, objv);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * PushRetainedUndoTokens --
+ *
+ *	Push the retained undo tokens onto the stack.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Same as TkTextPushUndoToken, additionaly 'undoTagList' and
+ *	'undoMarkList' will be cleared.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+PushRetainedUndoTokens(
+    TkSharedText *sharedTextPtr)
+{
+    unsigned i;
+
+    assert(sharedTextPtr);
+    assert(sharedTextPtr->undoStack);
+
+    for (i = 0; i < sharedTextPtr->undoTagListCount; ++i) {
+	TkTextPushUndoTagTokens(sharedTextPtr, sharedTextPtr->undoTagList[i]);
+    }
+
+    for (i = 0; i < sharedTextPtr->undoMarkListCount; ++i) {
+	TkTextPushUndoMarkTokens(sharedTextPtr, &sharedTextPtr->undoMarkList[i]);
+    }
+
+    sharedTextPtr->undoTagListCount = 0;
+    sharedTextPtr->undoMarkListCount = 0;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextPushUndoToken --
+ *
+ *	This function is pushing the given undo/redo token. Don't use
+ *	TkTextUndoPushItem, because some of the prepared undo tokens
+ *	are retained.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Same as TkTextUndoPushItem, furthermore all retained items
+ *	will be pushed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextPushUndoToken(
+    TkSharedText *sharedTextPtr,
+    void *token,
+    unsigned byteSize)
+{
+    TkTextUndoAction action;
+
+    assert(sharedTextPtr);
+    assert(sharedTextPtr->undoStack);
+    assert(token);
+
+    action = ((TkTextUndoToken *) token)->undoType->action;
+
+    if (action == TK_TEXT_UNDO_INSERT || action == TK_TEXT_UNDO_DELETE) {
+	sharedTextPtr->insertDeleteUndoTokenCount += 1;
+    }
+
+    PushRetainedUndoTokens(sharedTextPtr);
+    TkTextUndoPushItem(sharedTextPtr->undoStack, token, byteSize);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextPushRedoToken --
+ *
+ *	This function is pushing the given redo token. This function
+ *	is useful only for the reconstruction of the undo stack.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Same as TkTextUndoPushRedoItem.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextPushRedoToken(
+    TkSharedText *sharedTextPtr,
+    void *token,
+    unsigned byteSize)
+{
+    assert(sharedTextPtr);
+    assert(sharedTextPtr->undoStack);
+    assert(token);
+
+    TkTextUndoPushRedoItem(sharedTextPtr->undoStack, token, byteSize);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CreateWidget --
+ *
+ *	This function is invoked to process the "text" Tcl command, (when
+ *	called by Tk_TextObjCmd) and the "$text peer create" text widget
+ *	sub-command (called from TextPeerCmd).
+ *
+ *	See the user documentation for details on what it does.
+ *
+ * Results:
+ *	A standard Tcl result, places the name of the widget created into the
+ *	interp's result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+CreateWidget(
+    TkSharedText *sharedTextPtr,/* Shared widget info, or NULL. */
+    Tk_Window tkwin,		/* Main window associated with interpreter. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    const TkText *parent,	/* If non-NULL then take default start, end
+				 * from this parent. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    TkText *textPtr;
+    Tk_OptionTable optionTable;
+    TkTextIndex startIndex;
+    Tk_Window newWin;
+
+    /*
+     * Create the window.
+     */
+
+    if (!(newWin = Tk_CreateWindowFromPath(interp, tkwin, Tcl_GetString(objv[1]), NULL))) {
+	return TCL_ERROR;
+    }
+
+    if (!sharedTextPtr) {
+	sharedTextPtr = memset(malloc(sizeof(TkSharedText)), 0, sizeof(TkSharedText));
+
+	Tcl_InitHashTable(&sharedTextPtr->tagTable, TCL_STRING_KEYS);
+	Tcl_InitHashTable(&sharedTextPtr->markTable, TCL_STRING_KEYS);
+	Tcl_InitHashTable(&sharedTextPtr->windowTable, TCL_STRING_KEYS);
+	Tcl_InitHashTable(&sharedTextPtr->imageTable, TCL_STRING_KEYS);
+	sharedTextPtr->usedTags = TkBitResize(NULL, 256);
+	sharedTextPtr->elisionTags = TkBitResize(NULL, 256);
+	sharedTextPtr->selectionTags = TkBitResize(NULL, 256);
+	sharedTextPtr->dontUndoTags = TkBitResize(NULL, 256);
+	sharedTextPtr->affectDisplayTags = TkBitResize(NULL, 256);
+	sharedTextPtr->notAffectDisplayTags = TkBitResize(NULL, 256);
+	sharedTextPtr->affectDisplayNonSelTags = TkBitResize(NULL, 256);
+	sharedTextPtr->affectGeometryTags = TkBitResize(NULL, 256);
+	sharedTextPtr->affectGeometryNonSelTags = TkBitResize(NULL, 256);
+	sharedTextPtr->affectLineHeightTags = TkBitResize(NULL, 256);
+	sharedTextPtr->tagLookup = malloc(256*sizeof(TkTextTag *));
+	sharedTextPtr->emptyTagInfoPtr = TkTextTagSetResize(NULL, 0);
+	sharedTextPtr->maxRedoDepth = -1;
+	sharedTextPtr->autoSeparators = true;
+	sharedTextPtr->lastEditMode = TK_TEXT_EDIT_OTHER;
+	sharedTextPtr->lastUndoTokenType = -1;
+	sharedTextPtr->startMarker = TkTextMakeStartEndMark(NULL, &tkTextLeftMarkType);
+	sharedTextPtr->endMarker = TkTextMakeStartEndMark(NULL, &tkTextRightMarkType);
+	sharedTextPtr->protectionMark[0] = TkTextMakeMark(NULL, NULL);
+	sharedTextPtr->protectionMark[1] = TkTextMakeMark(NULL, NULL);
+	sharedTextPtr->protectionMark[0]->typePtr = &tkTextProtectionMarkType;
+	sharedTextPtr->protectionMark[1]->typePtr = &tkTextProtectionMarkType;
+
+	DEBUG(memset(sharedTextPtr->tagLookup, 0, 256*sizeof(TkTextTag *)));
+
+	sharedTextPtr->mainPeer = memset(malloc(sizeof(TkText)), 0, sizeof(TkText));
+	sharedTextPtr->mainPeer->startMarker = sharedTextPtr->startMarker;
+	sharedTextPtr->mainPeer->endMarker = sharedTextPtr->endMarker;
+	sharedTextPtr->mainPeer->sharedTextPtr = sharedTextPtr;
+	DEBUG_ALLOC(tkTextCountNewPeer++);
+
+#if TK_CHECK_ALLOCS
+	if (tkTextCountNewShared++ == 0) {
+	    atexit(AllocStatistic);
+	}
+	/*
+	 * Add this shared resource to global list.
+	 */
+	{
+	    WatchShared *wShared = malloc(sizeof(WatchShared));
+	    wShared->sharedTextPtr = sharedTextPtr;
+	    wShared->nextPtr = watchShared;
+	    watchShared = wShared;
+	}
+#endif
+
+	/*
+	 * The construction of the tree requires a valid setup of the shared resource.
+	 */
+
+	sharedTextPtr->tree = TkBTreeCreate(sharedTextPtr, 1);
+    }
+
+    DEBUG_ALLOC(tkTextCountNewPeer++);
+
+    /*
+     * Create the text widget and initialize everything to zero, then set the
+     * necessary initial (non-NULL) values. It is important that the 'set' tag
+     * and 'insert', 'current' mark pointers are all NULL to start.
+     */
+
+    textPtr = memset(malloc(sizeof(TkText)), 0, sizeof(TkText));
+    textPtr->tkwin = newWin;
+    textPtr->display = Tk_Display(newWin);
+    textPtr->interp = interp;
+    textPtr->widgetCmd = Tcl_CreateObjCommand(interp, Tk_PathName(textPtr->tkwin),
+	    TextWidgetObjCmd, textPtr, TextCmdDeletedProc);
+    DEBUG_ALLOC(textPtr->widgetNumber = ++widgetNumber);
+
+    /*
+     * Add the new widget to the shared list.
+     */
+
+    textPtr->sharedTextPtr = sharedTextPtr;
+    sharedTextPtr->refCount += 1;
+    textPtr->next = sharedTextPtr->peers;
+    sharedTextPtr->peers = textPtr;
+
+    /*
+     * Clear the indices, do this after the shared widget is created.
+     */
+
+    TkTextIndexClear(&textPtr->topIndex, textPtr);
+    TkTextIndexClear(&textPtr->selIndex, textPtr);
+
+    /*
+     * This refCount will be held until DestroyText is called. Note also that
+     * the later call to 'TkTextCreateDInfo' will add more refCounts.
+     */
+
+    textPtr->refCount = 1;
+
+    /*
+     * Specify start and end lines in the B-tree. The default is the same as
+     * the parent, but this can be adjusted to display more or less if the
+     * start, end where given as configuration options.
+     */
+
+    if (parent) {
+	(textPtr->startMarker = parent->startMarker)->refCount += 1;
+	(textPtr->endMarker = parent->endMarker)->refCount += 1;
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+	textPtr->startLine = parent->startLine;
+	textPtr->endLine = parent->endLine;
+#endif
+    } else {
+	(textPtr->startMarker = sharedTextPtr->startMarker)->refCount += 1;
+	(textPtr->endMarker = sharedTextPtr->endMarker)->refCount += 1;
+    }
+
+    /*
+     * Register with the B-tree. In some sense it would be best if we could do
+     * this later (after configuration options), so that any changes to
+     * start,end do not require a total recalculation.
+     */
+
+    TkBTreeAddClient(sharedTextPtr->tree, textPtr, textPtr->lineHeight);
+
+    /*
+     * Also the image binding support has to be enabled if required.
+     * This has to be done after TkBTreeAddClient has been called.
+     */
+
+    TkTextImageAddClient(sharedTextPtr, textPtr);
+
+    textPtr->state = TK_TEXT_STATE_NORMAL;
+    textPtr->relief = TK_RELIEF_FLAT;
+    textPtr->cursor = None;
+    textPtr->charWidth = 1;
+    textPtr->spaceWidth = 1;
+    textPtr->lineHeight = -1;
+    textPtr->prevWidth = Tk_Width(newWin);
+    textPtr->prevHeight = Tk_Height(newWin);
+    textPtr->hyphens = -1;
+    textPtr->currNearbyFlag = -1;
+    textPtr->prevSyncState = -1;
+
+    /*
+     * This will add refCounts to textPtr.
+     */
+
+    TkTextCreateDInfo(textPtr);
+    TkTextIndexSetupToStartOfText(&startIndex, textPtr, sharedTextPtr->tree);
+    TkTextSetYView(textPtr, &startIndex, 0);
+    textPtr->exportSelection = true;
+    textPtr->pickEvent.type = LeaveNotify;
+    textPtr->steadyMarks = textPtr->sharedTextPtr->steadyMarks;
+    textPtr->undo = textPtr->sharedTextPtr->undo;
+    textPtr->maxUndoDepth = textPtr->sharedTextPtr->maxUndoDepth;
+    textPtr->maxRedoDepth = textPtr->sharedTextPtr->maxRedoDepth;
+    textPtr->maxUndoSize = textPtr->sharedTextPtr->maxUndoSize;
+    textPtr->autoSeparators = textPtr->sharedTextPtr->autoSeparators;
+
+    /*
+     * Create the "sel" tag and the "current" and "insert" marks.
+     * Note: it is important that textPtr->selTagPtr is NULL before this
+     * initial call.
+     */
+
+    textPtr->selTagPtr = TkTextCreateTag(textPtr, "sel", NULL);
+    textPtr->selTagPtr->reliefString = malloc(sizeof(DEF_TEXT_SELECT_RELIEF));
+    strcpy(textPtr->selTagPtr->reliefString, DEF_TEXT_SELECT_RELIEF);
+    Tk_GetRelief(interp, DEF_TEXT_SELECT_RELIEF, &textPtr->selTagPtr->relief);
+    textPtr->insertMarkPtr = TkTextSetMark(textPtr, "insert", &startIndex);
+    textPtr->currentMarkPtr = TkTextSetMark(textPtr, "current", &startIndex);
+    textPtr->currentMarkIndex = startIndex;
+
+    sharedTextPtr->numPeers += 1;
+
+    /*
+     * Create the option table for this widget class. If it has already been
+     * created, the cached pointer will be returned.
+     */
+
+    optionTable = Tk_CreateOptionTable(interp, optionSpecs);
+
+    Tk_SetClass(textPtr->tkwin, "Text");
+    Tk_SetClassProcs(textPtr->tkwin, &textClass, textPtr);
+    textPtr->optionTable = optionTable;
+
+    Tk_CreateEventHandler(textPtr->tkwin,
+	    ExposureMask|StructureNotifyMask|FocusChangeMask, TextEventProc, textPtr);
+    Tk_CreateEventHandler(textPtr->tkwin, KeyPressMask|KeyReleaseMask
+	    |ButtonPressMask|ButtonReleaseMask|EnterWindowMask
+	    |LeaveWindowMask|PointerMotionMask|VirtualEventMask,
+	    TkTextBindProc, textPtr);
+    Tk_CreateSelHandler(textPtr->tkwin, XA_PRIMARY, XA_STRING, TextFetchSelection, textPtr, XA_STRING);
+
+    if (Tk_InitOptions(interp, (char *) textPtr, optionTable, textPtr->tkwin) != TCL_OK) {
+	Tk_DestroyWindow(textPtr->tkwin);
+	return TCL_ERROR;
+    }
+    if (TkConfigureText(interp, textPtr, objc - 2, objv + 2) != TCL_OK) {
+	Tk_DestroyWindow(textPtr->tkwin);
+	return TCL_ERROR;
+    }
+
+    Tcl_SetObjResult(interp, TkNewWindowObj(textPtr->tkwin));
+    return TCL_OK;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * UpdateLineMetrics --
+ *
+ *	This function updates the pixel height calculations of a range of
+ *	lines in the widget.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Line heights may be recalculated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+UpdateLineMetrics(
+    TkText *textPtr,		/* Information about widget. */
+    unsigned startLine,		/* Start at this line. */
+    unsigned endLine)		/* Go no further than this line. */
+{
+    if (!textPtr->sharedTextPtr->allowUpdateLineMetrics) {
+	ProcessConfigureNotify(textPtr, true);
+    }
+    TkTextUpdateLineMetrics(textPtr, startLine, endLine);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TextWidgetObjCmd --
+ *
+ *	This function is invoked to process the Tcl command that corresponds
+ *	to a text widget. See the user documentation for details on what it
+ *	does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+ErrorNotAllowed(
+    Tcl_Interp *interp,
+    const char *text)
+{
+    Tcl_SetObjResult(interp, Tcl_NewStringObj(text, -1));
+    Tcl_SetErrorCode(interp, "TK", "TEXT", "NOT_ALLOWED", NULL);
+}
+
+static bool
+TestIfTriggerUserMod(
+    TkSharedText *sharedTextPtr,
+    Tcl_Obj *indexObjPtr)
+{
+    return sharedTextPtr->triggerWatchCmd && strcmp(Tcl_GetString(indexObjPtr), "insert") == 0;
+}
+
+static bool
+TestIfPerformingUndoRedo(
+    Tcl_Interp *interp,
+    const TkSharedText *sharedTextPtr,
+    int *result)
+{
+    if (sharedTextPtr->undoStack && TkTextUndoIsPerformingUndoRedo(sharedTextPtr->undoStack)) {
+	/*
+	 * It's possible that this command command will be invoked inside the "watch" callback,
+	 * but this is not allowed when performing undo/redo.
+	 */
+
+	ErrorNotAllowed(interp, "cannot modify inside undo/redo operation");
+	if (result) {
+	    *result = TCL_ERROR;
+	}
+	return true;
+    }
+    return false;
+}
+
+static bool
+TestIfDisabled(
+    Tcl_Interp *interp,
+    const TkText *textPtr,
+    int *result)
+{
+    assert(result);
+
+    if (textPtr->state == TK_TEXT_STATE_DISABLED) {
+#if !SUPPORT_DEPRECATED_MODS_OF_DISABLED_WIDGET
+	ErrorNotAllowed(interp, "attempt to modify disabled widget");
+	*result = TCL_ERROR;
+#endif
+	return true;
+    }
+    return false;
+}
+
+static bool
+TestIfDead(
+    Tcl_Interp *interp,
+    const TkText *textPtr,
+    int *result)
+{
+    assert(result);
+
+    if (TkTextIsDeadPeer(textPtr)) {
+#if !SUPPORT_DEPRECATED_MODS_OF_DISABLED_WIDGET
+	ErrorNotAllowed(interp, "attempt to modify dead widget");
+	*result = TCL_ERROR;
+#endif
+	return true;
+    }
+    return false;
+}
+
+static Tcl_Obj *
+AppendScript(
+    const char *oldScript,
+    const char *script)
+{
+    int lenOfNew = strlen(script);
+    int lenOfOld = strlen(oldScript);
+    int totalLen = lenOfOld + lenOfNew + 1;
+    char *newScript = malloc(totalLen + 1);
+
+    memcpy(newScript, oldScript, lenOfOld);
+    newScript[lenOfOld] = '\n';
+    memcpy(newScript + lenOfOld + 1, script, lenOfNew + 1);
+    return Tcl_NewStringObj(newScript, totalLen);
+}
+
+static int
+TextWidgetObjCmd(
+    ClientData clientData,	/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    TkText *textPtr = clientData;
+    TkSharedText *sharedTextPtr;
+    int result = TCL_OK;
+    int commandIndex = -1;
+    bool oldUndoStackEvent;
+
+    static const char *const optionStrings[] = {
+	"tk_bindvar", "tk_textInsert", "tk_textReplace",
+	"bbox", "brks", "checksum", "cget", "clear", "compare", "configure",
+	"count", "debug", "delete", "dlineinfo", "dump", "edit", "get", "image",
+	"index", "insert", "inspect", "isclean", "isdead", "isempty", "lineno",
+	"load", "mark", "peer", "pendingsync", "replace", "scan", "search",
+	"see", "sync", "tag", "watch", "window", "xview", "yview", NULL
+    };
+    enum options {
+	TEXT_TK_BINDVAR, TEXT_TK_TEXTINSERT, TEXT_TK_TEXTREPLACE,
+	TEXT_BBOX, TEXT_BRKS, TEXT_CHECKSUM, TEXT_CGET, TEXT_CLEAR, TEXT_COMPARE, TEXT_CONFIGURE,
+	TEXT_COUNT, TEXT_DEBUG, TEXT_DELETE, TEXT_DLINEINFO, TEXT_DUMP, TEXT_EDIT, TEXT_GET, TEXT_IMAGE,
+	TEXT_INDEX, TEXT_INSERT, TEXT_INSPECT, TEXT_ISCLEAN, TEXT_ISDEAD, TEXT_ISEMPTY, TEXT_LINENO,
+	TEXT_LOAD, TEXT_MARK, TEXT_PEER, TEXT_PENDINGSYNC, TEXT_REPLACE, TEXT_SCAN, TEXT_SEARCH,
+	TEXT_SEE, TEXT_SYNC, TEXT_TAG, TEXT_WATCH, TEXT_WINDOW, TEXT_XVIEW, TEXT_YVIEW
+    };
+
+    if (objc < 2) {
+	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg ...?");
+	return TCL_ERROR;
+    }
+
+    if (Tcl_GetIndexFromObjStruct(interp, objv[1], optionStrings,
+	    sizeof(char *), "option", 0, &commandIndex) != TCL_OK) {
+	/*
+	 * Hide the first three options, generating the error description with
+	 * the side effects of Tcl_GetIndexFromObjStruct.
+	 */
+
+	(void) Tcl_GetIndexFromObjStruct(interp, objv[1], optionStrings + 3,
+		sizeof(char *), "option", 0, &commandIndex);
+	return TCL_ERROR;
+    }
+
+    textPtr->refCount += 1;
+    sharedTextPtr = textPtr->sharedTextPtr;
+    oldUndoStackEvent = sharedTextPtr->undoStackEvent;
+    sharedTextPtr->undoStackEvent = false;
+
+    /*
+     * Clear saved insert cursor position.
+     */
+
+    TkTextIndexClear(&textPtr->insertIndex, textPtr);
+
+    /*
+     * Check if we need to update the "current" mark segment.
+     */
+
+    if (sharedTextPtr->haveToSetCurrentMark) {
+	TkTextUpdateCurrentMark(sharedTextPtr);
+    }
+
+    switch ((enum options) commandIndex) {
+    case TEXT_TK_BINDVAR: {
+	TkTextStringList *listPtr;
+
+	/*
+	 * Bind a variable to this widget, this variable will be released (Tcl_UnsetVar2)
+	 * when the widget will be destroyed.
+	 *
+	 * I suggest to provide a general support for binding variables to widgets in a
+	 * future Tk version.
+	 */
+
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "varname");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+
+	listPtr = malloc(sizeof(TkTextStringList));
+	Tcl_IncrRefCount(listPtr->strObjPtr = objv[2]);
+	listPtr->nextPtr = textPtr->varBindingList;
+	textPtr->varBindingList = listPtr;
+	break;
+    }
+    case TEXT_BBOX: {
+	int x, y, width, height;
+	TkTextIndex index;
+
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "index");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[2], &index)) {
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (TkTextIndexBbox(textPtr, &index, &x, &y, &width, &height, NULL) == 0) {
+	    Tcl_Obj *listObj = Tcl_NewObj();
+
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(x));
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(y));
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(width));
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(height));
+
+	    Tcl_SetObjResult(interp, listObj);
+	}
+	break;
+    }
+    case TEXT_BRKS: {
+	Tcl_Obj *arrPtr;
+	unsigned length, i;
+	char const *lang = NULL;
+	char buf[1];
+
+	if (objc != 3 && objc != 4) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "index");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (objc == 4) {
+	    if (!TkTextTestLangCode(interp, objv[3])) {
+		result = TCL_ERROR;
+		goto done;
+	    }
+	    if (!TkTextComputeBreakLocations(interp, "", 0, "en", buf)) {
+		ErrorNotAllowed(interp, "external library libunibreak/liblinebreak is not available");
+		result = TCL_ERROR;
+		goto done;
+	    }
+	    lang = Tcl_GetString(objv[3]);
+	}
+	if ((length = GetByteLength(objv[2])) < textPtr->brksBufferSize) {
+	    textPtr->brksBufferSize = MAX(length, textPtr->brksBufferSize + 512);
+	    textPtr->brksBuffer = realloc(textPtr->brksBuffer, textPtr->brksBufferSize);
+	}
+	TkTextComputeBreakLocations(interp, Tcl_GetString(objv[2]), length, lang, textPtr->brksBuffer);
+	arrPtr = Tcl_NewObj();
+
+	for (i = 0; i < length; ++i) {
+	    int value;
+
+	    switch (textPtr->brksBuffer[i]) {
+	    case LINEBREAK_INSIDEACHAR: continue;
+	    case LINEBREAK_MUSTBREAK:   value = 2; break;
+	    case LINEBREAK_ALLOWBREAK:  value = 1; break;
+	    default:                    value = 0; break;
+	    }
+	    Tcl_ListObjAppendElement(interp, arrPtr, Tcl_NewIntObj(value));
+	}
+
+	Tcl_SetObjResult(interp, arrPtr);
+	break;
+    }
+    case TEXT_CHECKSUM:
+	result = TextChecksumCmd(textPtr, interp, objc, objv);
+    	break;
+    case TEXT_CGET:
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "option");
+	    result = TCL_ERROR;
+	    goto done;
+	} else {
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+
+	    Tcl_Obj *objPtr, *optionObj = NULL;
+
+	    if (strcmp(Tcl_GetString(objv[2]), "-start") == 0) {
+		optionObj = Tcl_NewStringObj(textPtr->startLine ? "-startline" : "-startindex", -1);
+	    } else if (strncmp(Tcl_GetString(objv[2]), "-startl", 7) == 0) {
+		optionObj = Tcl_NewStringObj("-startline", -1);
+	    } else if (strcmp(Tcl_GetString(objv[2]), "-end") == 0) {
+		optionObj = Tcl_NewStringObj(textPtr->endLine ? "-endline" : "-endindex", -1);
+	    } else if (strncmp(Tcl_GetString(objv[2]), "-endl", 5) == 0) {
+		optionObj = Tcl_NewStringObj("-endline", -1);
+	    } else {
+		Tcl_IncrRefCount(optionObj = objv[2]);
+	    }
+
+	    Tcl_IncrRefCount(optionObj);
+	    objPtr = Tk_GetOptionValue(interp, (char *) textPtr,
+		    textPtr->optionTable, optionObj, textPtr->tkwin);
+	    Tcl_DecrRefCount(optionObj);
+
+#else /* if !SUPPORT_DEPRECATED_STARTLINE_ENDLINE */
+
+	    objPtr = Tk_GetOptionValue(interp, (char *) textPtr,
+		    textPtr->optionTable, objv[2], textPtr->tkwin);
+
+#endif /* SUPPORT_DEPRECATED_STARTLINE_ENDLINE */
+
+	    if (!objPtr) {
+		result = TCL_ERROR;
+		goto done;
+	    }
+	    Tcl_SetObjResult(interp, objPtr);
+	    result = TCL_OK;
+	}
+	break;
+    case TEXT_CLEAR:
+	if (TestIfPerformingUndoRedo(interp, sharedTextPtr, &result)) {
+	    goto done;
+	}
+	ClearText(textPtr, true);
+	TkTextRelayoutWindow(textPtr, TK_TEXT_LINE_GEOMETRY);
+	TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+	break;
+    case TEXT_COMPARE: {
+	int relation, value;
+	TkTextIndex index1, index2;
+
+	if (objc != 5) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "index1 op index2");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[2], &index1)
+		|| !TkTextGetIndexFromObj(interp, textPtr, objv[4], &index2)) {
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	relation = TkTextIndexCompare(&index1, &index2);
+	value = TkTextTestRelation(interp, relation, Tcl_GetString(objv[3]));
+	if (value == -1) {
+	    result = TCL_ERROR;
+	} else {
+	    Tcl_SetObjResult(interp, Tcl_NewBooleanObj(value));
+	}
+	break;
+    }
+    case TEXT_CONFIGURE:
+	if (objc <= 3) {
+	    Tcl_Obj *objPtr = Tk_GetOptionInfo(interp, (char *) textPtr,
+		    textPtr->optionTable, objc == 3 ? objv[2] : NULL, textPtr->tkwin);
+
+	    if (!objPtr) {
+		result = TCL_ERROR;
+		goto done;
+	    }
+	    Tcl_SetObjResult(interp, objPtr);
+	} else {
+	    result = TkConfigureText(interp, textPtr, objc - 2, objv + 2);
+	}
+	break;
+    case TEXT_COUNT: {
+	TkTextIndex indexFrom, indexTo;
+	Tcl_Obj *objPtr = NULL;
+	bool update = false;
+	int i, found = 0;
+
+	if (objc < 4) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "?-option value ...? index1 index2");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[objc - 2], &indexFrom)
+		|| !TkTextGetIndexFromObj(interp, textPtr, objv[objc - 1], &indexTo)) {
+	    result = TCL_ERROR;
+	    goto done;
+	}
+
+	for (i = 2; i < objc - 2; i++) {
+	    int length;
+	    int value = INT_MIN;
+	    const char *option = Tcl_GetString(objv[i]);
+
+	    length = GetByteLength(objv[i]);
+	    if (length < 2 || option[0] != '-') {
+		goto badOption;
+	    }
+	    switch (option[1]) {
+	    case 'c':
+		if (strncmp("-chars", option, length) == 0) {
+		    value = CountIndices(textPtr, &indexFrom, &indexTo, COUNT_CHARS);
+		}
+		break;
+	    case 'd':
+	    	if (length > 8 && strncmp("-display", option, 8) == 0) {
+		    switch (option[8]) {
+		    case 'c':
+			if (strcmp("chars", option + 8) == 0) {
+			    value = CountIndices(textPtr, &indexFrom, &indexTo, COUNT_DISPLAY_CHARS);
+			}
+			break;
+		    case 'h':
+			if (strcmp("hyphens", option + 8) == 0) {
+			    value = CountIndices(textPtr, &indexFrom, &indexTo, COUNT_DISPLAY_HYPHENS);
+			}
+			break;
+		    case 'i':
+			if (strcmp("indices", option + 8) == 0) {
+			    value = CountIndices(textPtr, &indexFrom, &indexTo, COUNT_DISPLAY_INDICES);
+			}
+			break;
+		    case 'l':
+			if (strcmp("lines", option + 8) == 0) {
+			    int compare = TkTextIndexCompare(&indexFrom, &indexTo);
+
+			    if (compare == 0) {
+				value = 0;
+			    } else {
+				const TkTextIndex *indexPtr1;
+				const TkTextIndex *indexPtr2;
+
+				if (compare < 0) {
+				    indexPtr1 = &indexFrom;
+				    indexPtr2 = &indexTo;
+				} else {
+				    indexPtr1 = &indexTo;
+				    indexPtr2 = &indexFrom;
+				}
+				if (!sharedTextPtr->allowUpdateLineMetrics) {
+				    ProcessConfigureNotify(textPtr, true);
+				}
+				value = TkTextCountDisplayLines(textPtr, indexPtr1, indexPtr2);
+				if (compare > 0) {
+				    value = -value;
+				}
+			    }
+			}
+			break;
+		    case 't':
+			if (strcmp("text", option + 8) == 0) {
+			    value = CountIndices(textPtr, &indexFrom, &indexTo, COUNT_DISPLAY_TEXT);
+			}
+			break;
+		    }
+		}
+		break;
+	    case 'h':
+		if (strncmp("-hyphens", option, length) == 0) {
+		    value = CountIndices(textPtr, &indexFrom, &indexTo, COUNT_HYPHENS);
+		}
+		break;
+	    case 'i':
+		if (strncmp("-indices", option, length) == 0) {
+		    value = CountIndices(textPtr, &indexFrom, &indexTo, COUNT_INDICES);
+		}
+		break;
+	    case 'l':
+	    	if (strncmp("-lines", option, length) == 0) {
+		    TkTextBTree tree = sharedTextPtr->tree;
+		    value = TkBTreeLinesTo(tree, textPtr, TkTextIndexGetLine(&indexTo), NULL)
+			    - TkBTreeLinesTo(tree, textPtr, TkTextIndexGetLine(&indexFrom), NULL);
+		}
+		break;
+	    case 't':
+		if (strncmp("-text", option, length) == 0) {
+		    value = CountIndices(textPtr, &indexFrom, &indexTo, COUNT_TEXT);
+		}
+		break;
+	    case 'u':
+		if (strncmp("-update", option, length) == 0) {
+		    update = true;
+		    continue;
+		}
+		break;
+	    case 'x':
+		if (strncmp("-xpixels", option, length) == 0) {
+		    int x1, x2;
+		    TkTextIndex index;
+
+		    index = indexFrom;
+		    TkTextFindDisplayIndex(textPtr, &index, 0, &x1);
+		    index = indexTo;
+		    TkTextFindDisplayIndex(textPtr, &index, 0, &x2);
+		    value = x2 - x1;
+		}
+		break;
+	    case 'y':
+		if (strncmp("-ypixels", option, length) == 0) {
+		    int from, to;
+
+		    if (update) {
+			from = TkTextIndexGetLineNumber(&indexFrom, textPtr);
+			to = TkTextIndexGetLineNumber(&indexTo, textPtr);
+			UpdateLineMetrics(textPtr, from, to);
+		    }
+		    from = TkTextIndexYPixels(textPtr, &indexFrom);
+		    to = TkTextIndexYPixels(textPtr, &indexTo);
+		    value = to - from;
+		}
+		break;
+	    }
+	    if (value == INT_MIN) {
+		goto badOption;
+	    }
+
+	    found += 1;
+	    if (found == 1) {
+		Tcl_SetObjResult(interp, Tcl_NewIntObj(value));
+	    } else {
+		if (found == 2) {
+		    /*
+		     * Move the first item we put into the result into the
+		     * first element of the list object.
+		     */
+
+		    objPtr = Tcl_NewObj();
+		    Tcl_ListObjAppendElement(NULL, objPtr,
+			    Tcl_GetObjResult(interp));
+		}
+		Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj(value));
+	    }
+	}
+
+	if (found == 0) {
+	    /*
+	     * Use the default '-indices'.
+	     */
+
+	    int value = CountIndices(textPtr, &indexFrom, &indexTo, COUNT_INDICES);
+	    Tcl_SetObjResult(interp, Tcl_NewIntObj(value));
+	} else if (found > 1) {
+	    Tcl_SetObjResult(interp, objPtr);
+	}
+	break;
+
+    badOption:
+	Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		"bad option \"%s\": must be -chars, -displaychars, -displayhyphens, -displayindices, "
+		"-displaylines, -displaytext, -hyphens, -indices, -lines, -text, -update, -xpixels, "
+		"or -ypixels", Tcl_GetString(objv[i])));
+	Tcl_SetErrorCode(interp, "TK", "TEXT", "INDEX_OPTION", NULL);
+	result = TCL_ERROR;
+	goto done;
+    }
+    case TEXT_DEBUG:
+	if (objc > 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "boolean");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (objc == 2) {
+	    Tcl_SetObjResult(interp, Tcl_NewBooleanObj(tkBTreeDebug));
+	} else {
+	    if (Tcl_GetBooleanFromObj(interp, objv[2], (int *) &tkBTreeDebug) != TCL_OK) {
+		result = TCL_ERROR;
+		goto done;
+	    }
+	    tkTextDebug = tkBTreeDebug;
+	}
+	break;
+    case TEXT_DELETE: {
+	int i, flags = 0;
+	bool ok = true;
+
+	for (i = 2; i < objc - 1; i++) {
+	    const char *option = Tcl_GetString(objv[i]);
+	    int length;
+
+	    if (option[0] != '-') {
+		break;
+	    }
+	    length = GetByteLength(objv[i]);
+	    if (strncmp("-marks", option, length) == 0) {
+		flags |= DELETE_MARKS;
+	    } else if (strncmp("-inclusive", option, length) == 0) {
+		flags |= DELETE_INCLUSIVE;
+	    } else {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+			"bad option \"%s\": must be -marks, or -inclusive", Tcl_GetString(objv[i])));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "INDEX_OPTION", NULL);
+		result = TCL_ERROR;
+		goto done;
+	    }
+	}
+
+	objv += i - 2;
+	objc -= i - 2;
+
+	if (objc < 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "?-marks? ?-inclusive? index1 ?index2 ...?");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (TestIfDisabled(interp, textPtr, &result)
+		|| TestIfDead(interp, textPtr, &result)
+		|| TestIfPerformingUndoRedo(interp, sharedTextPtr, &result)) {
+	    goto done;
+	}
+	if (objc < 5) {
+	    /*
+	     * Simple case requires no predetermination of indices.
+	     */
+
+	    TkTextIndex index1, index2, *index2Ptr;
+	    bool triggerUserMod = TestIfTriggerUserMod(sharedTextPtr, objv[2]);
+	    bool triggerWatch = triggerUserMod || textPtr->triggerAlways;
+
+	    if (triggerWatch) {
+		TkTextSaveCursorIndex(textPtr);
+	    }
+
+	    /*
+	     * Parse the starting and stopping indices.
+	     */
+
+	    if (!TkTextGetIndexFromObj(textPtr->interp, textPtr, objv[2], &index1)) {
+		result = TCL_ERROR;
+		goto done;
+	    }
+	    if (objc == 4) {
+		if (!TkTextGetIndexFromObj(textPtr->interp, textPtr, objv[3], index2Ptr = &index2)) {
+		    result = TCL_ERROR;
+		    goto done;
+		}
+	    } else {
+		index2Ptr = NULL;
+	    }
+	    ok = DeleteIndexRange(NULL, textPtr, &index1, index2Ptr, flags, true,
+		    triggerWatch, triggerWatch, triggerUserMod, true);
+	} else {
+	    /*
+	     * Multi-index pair case requires that we prevalidate the
+	     * indices and sort from last to first so that deletes occur
+	     * in the exact (unshifted) text. It also needs to handle
+	     * partial and fully overlapping ranges. We have to do this
+	     * with multiple passes.
+	     */
+
+	    TkTextIndex *indices, *ixStart, *ixEnd, *lastStart;
+	    char *useIdx;
+	    int lastUsed, i;
+
+	    objc -= 2;
+	    objv += 2;
+	    indices = malloc((objc + 1)*sizeof(TkTextIndex));
+
+	    /*
+	     * First pass verifies that all indices are valid.
+	     */
+
+	    for (i = 0; i < objc; i++) {
+		if (!TkTextGetIndexFromObj(interp, textPtr, objv[i], &indices[i])) {
+		    result = TCL_ERROR;
+		    free(indices);
+		    goto done;
+		}
+	    }
+
+	    /*
+	     * Pad out the pairs evenly to make later code easier.
+	     */
+
+	    if (objc & 1) {
+		indices[i] = indices[i - 1];
+		TkTextIndexForwChars(textPtr, &indices[i], 1, &indices[i], COUNT_INDICES);
+		objc += 1;
+	    }
+	    useIdx = malloc(objc);
+	    memset(useIdx, 0, (unsigned) objc);
+
+	    /*
+	     * Do a decreasing order sort so that we delete the end ranges
+	     * first to maintain index consistency.
+	     */
+
+	    qsort(indices, (unsigned) objc/2, 2*sizeof(TkTextIndex), TextIndexSortProc);
+	    lastStart = NULL;
+	    lastUsed = 0; /* otherwise GCC complains */
+
+	    /*
+	     * Second pass will handle bogus ranges (end < start) and
+	     * overlapping ranges.
+	     */
+
+	    for (i = 0; i < objc; i += 2) {
+		ixStart = &indices[i];
+		ixEnd = &indices[i + 1];
+		if (TkTextIndexCompare(ixEnd, ixStart) <= 0) {
+		    continue;
+		}
+		if (lastStart) {
+		    if (TkTextIndexCompare(ixStart, lastStart) == 0) {
+			/*
+			 * Start indices were equal, and the sort placed
+			 * the longest range first, so skip this one.
+			 */
+
+			continue;
+		    } else if (TkTextIndexCompare(lastStart, ixEnd) < 0) {
+			/*
+			 * The next pair has a start range before the end
+			 * point of the last range. Constrain the delete
+			 * range, but use the pointer values.
+			 */
+
+			*ixEnd = *lastStart;
+			if (TkTextIndexCompare(ixEnd, ixStart) <= 0) {
+			    continue;
+			}
+		    }
+		}
+		lastStart = ixStart;
+		useIdx[i] = 1;
+		lastUsed = i;
+	    }
+
+	    /*
+	     * Final pass take the input from the previous and deletes the
+	     * ranges which are flagged to be deleted.
+	     */
+
+	    for (i = 0; i < objc && ok; i += 2) {
+		if (useIdx[i]) {
+		    bool triggerUserMod = TestIfTriggerUserMod(sharedTextPtr, objv[i]);
+		    bool triggerWatch = triggerUserMod || textPtr->triggerAlways;
+
+		    if (triggerWatch) {
+			TkTextSaveCursorIndex(textPtr);
+		    }
+
+		    /*
+		     * We don't need to check the return value because all
+		     * indices are preparsed above.
+		     */
+
+		    ok = DeleteIndexRange(NULL, textPtr, &indices[i], &indices[i + 1],
+			    flags, true, triggerWatch, triggerWatch, triggerUserMod, i == lastUsed);
+		}
+	    }
+	    free(indices);
+	}
+
+	if (!ok) {
+	    return TCL_OK; /* widget has been destroyed */
+	}
+	break;
+    }
+    case TEXT_DLINEINFO: {
+	int x, y, width, height, base;
+	TkTextIndex index;
+
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "index");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[2], &index)) {
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (TkTextGetDLineInfo(textPtr, &index, &x, &y, &width, &height, &base)) {
+	    Tcl_Obj *listObj = Tcl_NewObj();
+
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(x));
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(y));
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(width));
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(height));
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(base));
+
+	    Tcl_SetObjResult(interp, listObj);
+	}
+	break;
+    }
+    case TEXT_DUMP:
+	result = TextDumpCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_EDIT:
+	result = TextEditCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_GET: {
+	Tcl_Obj *objPtr;
+	int i, found;
+	bool includeHyphens;
+	bool visibleOnly;
+	unsigned countOptions;
+	const char *option;
+
+	if (objc < 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "?-option? ?--? index1 ?index2 ...?");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+
+	objPtr = NULL;
+	found = 0;
+	includeHyphens = true;
+	visibleOnly = false;
+	countOptions = 0;
+	i = 2;
+
+	while (objc > i + 1 && (option = Tcl_GetString(objv[i]))[0] == '-') {
+	    bool badOption = false;
+
+	    i += 1;
+
+	    if (option[1] == '-') {
+	    	if (option[2] == '\0') {
+		    break;
+		}
+		badOption = true;
+	    } else if (++countOptions > 1) {
+		i -= 1;
+		break;
+	    } else {
+		switch (option[1]) {
+		case 'c':
+		    if (strcmp("-chars", option) != 0) {
+			badOption = true;
+		    }
+		    break;
+		case 't':
+		    if (strcmp("-text", option) != 0) {
+			badOption = true;
+		    }
+		    includeHyphens = false;
+		    break;
+		case 'd':
+		    if (strcmp("-displaychars", option) == 0) {
+			visibleOnly = true;
+		    } else if (strcmp("-displaytext", option) == 0) {
+			visibleOnly = true;
+			includeHyphens = false;
+		    } else {
+			badOption = true;
+		    }
+		    break;
+		default:
+		    badOption = true;
+		    break;
+		}
+	    }
+
+	    if (badOption) {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf("bad option \"%s\": "
+			"must be -chars, -displaychars, -displaytext, or -text", option));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "INDEX_OPTION", NULL);
+		result = TCL_ERROR;
+		goto done;
+	    }
+	}
+
+	for (; i < objc; i += 2) {
+	    TkTextIndex index1, index2;
+
+	    if (!TkTextGetIndexFromObj(interp, textPtr, objv[i], &index1)) {
+		if (objPtr) {
+		    Tcl_DecrRefCount(objPtr);
+		}
+		result = TCL_ERROR;
+		goto done;
+	    }
+
+	    if (i + 1 == objc) {
+		TkTextIndexForwChars(textPtr, &index1, 1, &index2, COUNT_INDICES);
+	    } else {
+		if (!TkTextGetIndexFromObj(interp, textPtr, objv[i + 1], &index2)) {
+		    if (objPtr) {
+			Tcl_DecrRefCount(objPtr);
+		    }
+		    result = TCL_ERROR;
+		    goto done;
+		}
+		if (TkTextIndexCompare(&index1, &index2) >= 0) {
+		    goto done;
+		}
+	    }
+
+	    /*
+	     * We want to move the text we get from the window into the
+	     * result, but since this could in principle be a megabyte or
+	     * more, we want to do it efficiently!
+	     */
+
+	    Tcl_Obj *get = TextGetText(textPtr, &index1, &index2, NULL, NULL, UINT_MAX,
+		    visibleOnly, includeHyphens);
+
+	    if (++found == 1) {
+		Tcl_SetObjResult(interp, get);
+	    } else {
+		if (found == 2) {
+		    /*
+		     * Move the first item we put into the result into the
+		     * first element of the list object.
+		     */
+
+		    objPtr = Tcl_NewObj();
+		    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_GetObjResult(interp));
+		}
+		Tcl_ListObjAppendElement(NULL, objPtr, get);
+	    }
+	}
+	if (found > 1) {
+	    Tcl_SetObjResult(interp, objPtr);
+	}
+	break;
+    }
+    case TEXT_IMAGE:
+	result = TkTextImageCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_INDEX: {
+	TkTextIndex index;
+
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "index");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[2], &index)) {
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	Tcl_SetObjResult(interp, TkTextNewIndexObj(&index));
+	break;
+    }
+    case TEXT_INSERT:
+    case TEXT_TK_TEXTINSERT: {
+	TkTextIndex index;
+	bool triggerUserMod, triggerWatch;
+	bool destroyed;
+
+	if (objc < 4) {
+	    const char *args = (commandIndex == TEXT_TK_TEXTINSERT) ?
+		"?-hyphentags tags? index chars ?tagList chars tagList ...?" :
+		"index chars ?tagList chars tagList ...?";
+	    Tcl_WrongNumArgs(interp, 2, objv, args);
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[2], &index)) {
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (TestIfDisabled(interp, textPtr, &result)
+		|| TestIfDead(interp, textPtr, &result)
+		|| TestIfPerformingUndoRedo(interp, sharedTextPtr, &result)) {
+	    goto done;
+	}
+
+	triggerUserMod = TestIfTriggerUserMod(sharedTextPtr, objv[2]);
+	triggerWatch = triggerUserMod || textPtr->triggerAlways;
+
+	if (triggerWatch) {
+	    TkTextSaveCursorIndex(textPtr);
+	}
+	result = TextInsertCmd(textPtr, interp, objc - 3, objv + 3, &index, true, triggerWatch,
+		triggerWatch, triggerUserMod, &destroyed, commandIndex == TEXT_TK_TEXTINSERT);
+	if (destroyed) {
+	    return result; /* widget has been destroyed */
+	}
+	break;
+    }
+    case TEXT_INSPECT:
+	result = TextInspectCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_ISCLEAN: {
+	bool discardSelection = false;
+	const TkText *myTextPtr = textPtr;
+	int i;
+
+	for (i = 2; i < objc; ++i) {
+	    char const * opt = Tcl_GetString(objv[i]);
+
+	    if (strcmp(opt, "-overall") == 0) {
+		myTextPtr = NULL;
+	    } else if (strcmp(opt, "-discardselection") == 0) {
+		discardSelection = true;
+	    } else {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf("bad option \"%s\": must be -overall", opt));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "BAD_OPTION", NULL);
+		result = TCL_ERROR;
+		goto done;
+	    }
+	}
+
+	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(IsClean(sharedTextPtr, myTextPtr, discardSelection)));
+	break;
+    }
+    case TEXT_ISDEAD:
+    	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(TkTextIsDeadPeer(textPtr)));
+	break;
+    case TEXT_ISEMPTY: {
+	bool overall = false;
+	int i;
+
+	for (i = 2; i < objc; ++i) {
+	    char const * opt = Tcl_GetString(objv[i]);
+
+	    if (strcmp(opt, "-overall") == 0) {
+		overall = true;
+	    } else {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf("bad option \"%s\": must be -overall", opt));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "BAD_OPTION", NULL);
+		result = TCL_ERROR;
+		goto done;
+	    }
+	}
+
+	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(IsEmpty(sharedTextPtr, overall ? NULL : textPtr)));
+	break;
+    }
+    case TEXT_LINENO: {
+	TkTextIndex index;
+	int lineno;
+
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "index");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[2], &index)) {
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	lineno = TkTextIsDeadPeer(textPtr) ? 0 : TkTextIndexGetLineNumber(&index, textPtr) + 1;
+	Tcl_SetObjResult(interp, Tcl_NewIntObj(lineno));
+	break;
+    }
+    case TEXT_LOAD: {
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "textcontent");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (TestIfPerformingUndoRedo(interp, sharedTextPtr, &result)) {
+	    goto done;
+	}
+	ClearText(textPtr, false);
+	TkTextRelayoutWindow(textPtr, TK_TEXT_LINE_GEOMETRY);
+	if ((result = TkBTreeLoad(textPtr, objv[2])) != TCL_OK) {
+	    ClearText(textPtr, false);
+	}
+	break;
+    }
+    case TEXT_MARK:
+	result = TkTextMarkCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_PEER:
+	result = TextPeerCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_PENDINGSYNC: {
+        if (objc != 2) {
+            Tcl_WrongNumArgs(interp, 2, objv, NULL);
+            result = TCL_ERROR;
+            goto done;
+        }
+	if (!sharedTextPtr->allowUpdateLineMetrics) {
+	    ProcessConfigureNotify(textPtr, true);
+	}
+	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(TkTextPendingSync(textPtr)));
+        break;
+    }
+    case TEXT_REPLACE:
+    case TEXT_TK_TEXTREPLACE: {
+	TkTextIndex indexFrom, indexTo, index;
+	bool triggerUserMod, triggerWatch;
+	bool destroyed;
+
+	if (objc < 5) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "index1 index2 chars ?tagList chars tagList ...?");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[2], &indexFrom)
+		|| !TkTextGetIndexFromObj(interp, textPtr, objv[3], &indexTo)) {
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (TkTextIndexCompare(&indexFrom, &indexTo) > 0) {
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		    "index \"%s\" before \"%s\" in the text",
+		    Tcl_GetString(objv[3]), Tcl_GetString(objv[2])));
+	    Tcl_SetErrorCode(interp, "TK", "TEXT", "INDEX_ORDER", NULL);
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (TestIfDisabled(interp, textPtr, &result) || TestIfDead(interp, textPtr, &result)) {
+	    goto done;
+	}
+
+	destroyed = false;
+	triggerUserMod = TestIfTriggerUserMod(sharedTextPtr, objv[2]);
+	triggerWatch = triggerUserMod || textPtr->triggerAlways;
+
+	/*
+	 * The 'replace' operation is quite complex to do correctly,
+	 * because we want a number of criteria to hold:
+	 *
+	 * 1.  The insertion point shouldn't move, unless it is within the
+	 *	   deleted range. In this case it should end up after the new
+	 *	   text.
+	 *
+	 * 2.  The window should not change the text it shows - should not
+	 *	   scroll vertically - unless the result of the replace is
+	 *	   that the insertion position which used to be on-screen is
+	 *	   now off-screen.
+	 */
+
+	TkTextIndexSave(&textPtr->topIndex);
+	if (triggerWatch) {
+	    TkTextSaveCursorIndex(textPtr);
+	}
+
+	TkTextMarkSegToIndex(textPtr, textPtr->insertMarkPtr, &index);
+	if (TkTextIndexCompare(&indexFrom, &index) < 0
+		&& TkTextIndexCompare(&index, &indexTo) <= 0) {
+	    /*
+	     * The insertion point is inside the range to be replaced, so
+	     * we have to do some calculations to ensure it doesn't move
+	     * unnecessarily.
+	     */
+
+	    int deleteInsertOffset, insertLength, j;
+
+	    insertLength = 0;
+	    for (j = 4; j < objc; j += 2) {
+		insertLength += Tcl_GetCharLength(objv[j]);
+	    }
+
+	    /*
+	     * Calculate 'deleteInsertOffset' as an offset we will apply
+	     * to the insertion point after this operation.
+	     */
+
+	    deleteInsertOffset = CountIndices(textPtr, &indexFrom, &index, COUNT_CHARS);
+	    if (deleteInsertOffset > insertLength) {
+		deleteInsertOffset = insertLength;
+	    }
+
+	    result = TextReplaceCmd(textPtr, interp, &indexFrom, &indexTo, objc, objv, false,
+		    triggerWatch, triggerUserMod, &destroyed, commandIndex == TEXT_TK_TEXTREPLACE);
+	    if (destroyed) { return result; /* widget has been destroyed */ }
+
+	    if (result == TCL_OK) {
+		/*
+		 * Move the insertion position to the correct place.
+		 */
+
+		TkTextIndexForwChars(textPtr, &indexFrom, deleteInsertOffset, &index, COUNT_INDICES);
+		TkBTreeUnlinkSegment(sharedTextPtr, textPtr->insertMarkPtr);
+		TkBTreeLinkSegment(sharedTextPtr, textPtr->insertMarkPtr, &index);
+		textPtr->insertIndex = index;
+	    }
+	} else {
+	    result = TextReplaceCmd(textPtr, interp, &indexFrom, &indexTo, objc, objv, false,
+		    triggerWatch, triggerUserMod, &destroyed, commandIndex == TEXT_TK_TEXTREPLACE);
+	    if (destroyed) { return result; /* widget has been destroyed */ }
+	}
+	if (result == TCL_OK) {
+	    /*
+	     * Now ensure the top-line is in the right place.
+	     */
+
+	    if (!TkTextIndexRebuild(&textPtr->topIndex)) {
+		TkTextSetYView(textPtr, &textPtr->topIndex, TK_TEXT_NOPIXELADJUST);
+	    }
+	}
+	break;
+    }
+    case TEXT_SCAN:
+	result = TkTextScanCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_SEARCH:
+	result = TextSearchCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_SEE:
+	result = TkTextSeeCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_SYNC: {
+	bool wrongNumberOfArgs = false;
+
+	if (objc == 3 || objc == 4) {
+	    const char *option = Tcl_GetString(objv[2]);
+	    if (*option != '-') {
+		wrongNumberOfArgs = true;
+	    } else if (strncmp(option, "-command", objv[2]->length) != 0) {
+		Tcl_AppendResult(interp, "wrong option \"", option,
+			"\": should be \"-command\"", NULL);
+		result = TCL_ERROR;
+		goto done;
+	    }
+	} else if (objc != 2) {
+	    wrongNumberOfArgs = true;
+	}
+	if (wrongNumberOfArgs) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "?-command ?command??");
+	    result = TCL_ERROR;
+	    goto done;
+	}
+	if (!sharedTextPtr->allowUpdateLineMetrics) {
+	    ProcessConfigureNotify(textPtr, true);
+	}
+	if (objc == 3) {
+	    if (textPtr->afterSyncCmd) {
+		Tcl_SetObjResult(interp, textPtr->afterSyncCmd);
+	    }
+	} else if (objc == 4) {
+	    Tcl_Obj *cmd = objv[3];
+	    const char *script = Tcl_GetString(cmd);
+	    bool append = false;
+
+	    if (*script == '+') {
+		script += 1;
+		append = true;
+	    }
+
+	    if (!textPtr->afterSyncCmd) {
+		if (append) {
+		    cmd = Tcl_NewStringObj(script, -1);
+		}
+		Tcl_IncrRefCount(textPtr->afterSyncCmd = cmd);
+	    } else {
+		if (!append && *script == '\0') {
+		    if (textPtr->pendingAfterSync) {
+			Tcl_CancelIdleCall(RunAfterSyncCmd, (ClientData) textPtr);
+			textPtr->pendingAfterSync = false;
+		    }
+		    cmd = NULL;
+		} else {
+		    if (append) {
+			cmd = AppendScript(Tcl_GetString(textPtr->afterSyncCmd), script);
+		    }
+		    Tcl_IncrRefCount(cmd);
+		}
+		Tcl_DecrRefCount(textPtr->afterSyncCmd);
+		textPtr->afterSyncCmd = cmd;
+	    }
+	    if (!textPtr->pendingAfterSync) {
+		textPtr->pendingAfterSync = true;
+		if (!TkTextPendingSync(textPtr)) {
+		    Tcl_DoWhenIdle(RunAfterSyncCmd, (ClientData) textPtr);
+		}
+	    }
+	} else {
+	    textPtr->sendSyncEvent = true;
+
+	    if (!TkTextPendingSync(textPtr)) {
+		/*
+		 * There is nothing to sync, so fire the <<WidgetViewSync>> event,
+		 * because nobody else will do this when no update is pending.
+		 */
+		TkTextGenerateWidgetViewSyncEvent(textPtr, false);
+	    } else {
+		UpdateLineMetrics(textPtr, 0, TkBTreeNumLines(sharedTextPtr->tree, textPtr));
+	    }
+	}
+	break;
+    }
+    case TEXT_TAG:
+	result = TkTextTagCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_WATCH: {
+	Tcl_Obj *cmd = textPtr->watchCmd;
+
+	result = TextWatchCmd(textPtr, interp, objc, objv);
+	if (cmd) {
+	    Tcl_SetObjResult(interp, cmd);
+	    Tcl_DecrRefCount(cmd);
+	}
+    	break;
+    }
+    case TEXT_WINDOW:
+	result = TkTextWindowCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_XVIEW:
+	result = TkTextXviewCmd(textPtr, interp, objc, objv);
+	break;
+    case TEXT_YVIEW:
+	result = TkTextYviewCmd(textPtr, interp, objc, objv);
+	break;
+    }
+
+  done:
+    if (--textPtr->refCount == 0) {
+	bool sharedIsReleased = textPtr->sharedIsReleased;
+
+	free(textPtr);
+	if (sharedIsReleased) {
+	    return result;
+	}
+	textPtr = NULL;
+    } else if (textPtr->watchCmd) {
+	TkTextTriggerWatchCursor(textPtr);
+    }
+    if (sharedTextPtr->undoStackEvent) {
+	TriggerUndoStackEvent(sharedTextPtr);
+    }
+    sharedTextPtr->undoStackEvent = oldUndoStackEvent;
+
+    if (textPtr && textPtr->syncTime == 0) {
+	UpdateLineMetrics(textPtr, 0, TkBTreeNumLines(sharedTextPtr->tree, textPtr));
+	TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+    }
+
+    return result;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * IsEmpty --
+ *
+ *	Test whether this widget is empty. The widget is empty
+ *	if it contains exact two single newline characters.
+ *
+ * Results:
+ *	Returns true if the widget is empty, and false otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+DoesNotContainTextSegments(
+    const TkTextSegment *segPtr1,
+    const TkTextSegment *segPtr2)
+{
+    for ( ; segPtr1 != segPtr2; segPtr1 = segPtr1->nextPtr) {
+	if (segPtr1->size > 0) {
+	    return !segPtr1->nextPtr; /* ignore trailing newline */
+	}
+    }
+
+    return true;
+}
+
+static bool
+IsEmpty(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr)		/* Can be NULL. */
+{
+    TkTextSegment *startMarker;
+    TkTextSegment *endMarker;
+
+    assert(sharedTextPtr);
+
+    if (TkBTreeNumLines(sharedTextPtr->tree, textPtr) > 1) {
+	return false;
+    }
+
+    if (textPtr) {
+	startMarker = textPtr->startMarker;
+	endMarker = textPtr->endMarker;
+    } else {
+	startMarker = sharedTextPtr->startMarker;
+	endMarker = sharedTextPtr->endMarker;
+    }
+
+    return DoesNotContainTextSegments(startMarker, endMarker);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * IsClean --
+ *
+ *	Test whether this widget is clean. The widget is clean
+ *	if it is empty, if no mark is set, and if the solely
+ *	newline of this widget is untagged.
+ *
+ * Results:
+ *	Returns true if the widget is clean, and false otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+ContainsAnySegment(
+    const TkTextSegment *segPtr1,
+    const TkTextSegment *segPtr2)
+{
+    for ( ; segPtr1 != segPtr2; segPtr1 = segPtr1->nextPtr) {
+	if (segPtr1->size > 0 || segPtr1->normalMarkFlag) {
+	    return !!segPtr1->nextPtr; /* ignore trailing newline */
+	}
+    }
+
+    return false;
+}
+
+static bool
+IsClean(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr,		/* Can be NULL. */
+    bool discardSelection)
+{
+    const TkTextTagSet *tagInfoPtr;
+    const TkTextSegment *startMarker;
+    const TkTextSegment *endMarker;
+    const TkTextLine *endLine;
+
+    assert(sharedTextPtr);
+
+    if (TkBTreeNumLines(sharedTextPtr->tree, textPtr) > 1) {
+	return false;
+    }
+
+    if (textPtr) {
+	startMarker = textPtr->startMarker;
+	endMarker = textPtr->endMarker;
+    } else {
+	startMarker = sharedTextPtr->startMarker;
+	endMarker = sharedTextPtr->endMarker;
+    }
+
+    if (ContainsAnySegment(startMarker, endMarker)) {
+	return false;
+    }
+
+    endLine = endMarker->sectionPtr->linePtr;
+
+    if (!textPtr && ContainsAnySegment(endLine->segPtr, NULL)) {
+	/* This widget contains any mark on very last line. */
+	return false;
+    }
+
+    tagInfoPtr = endLine->prevPtr->lastPtr->tagInfoPtr;
+
+    return discardSelection ?
+	    TkTextTagBitContainsSet(sharedTextPtr->selectionTags, tagInfoPtr) :
+	    tagInfoPtr == sharedTextPtr->emptyTagInfoPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextTestRelation --
+ *
+ *	Given a relation (>0 for greater, =0 for equal, and <0 for
+ *	less), this function computes whether the given operator
+ *	satisfies this relation.
+ *
+ * Results:
+ *	Returns 1 if the relation will be satsified, 0 if it will
+ *	not be satisifed, and -1 if the operator is invalid.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+BadComparisonOperator(
+    Tcl_Interp *interp,
+    char const *op)
+{
+    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+	    "bad comparison operator \"%s\": must be <, <=, ==, >=, >, or !=", op));
+    Tcl_SetErrorCode(interp, "TK", "VALUE", "COMPARISON", NULL);
+    return -1;
+}
+
+int
+TkTextTestRelation(
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int relation,		/* Test this relation... */
+    char const *op)		/* ...whether it will be satisifed by this operator. */
+{
+    int value;
+
+    if (op[0] == '<') {
+	value = (relation < 0);
+	if (op[1] == '=' && op[2] == 0) {
+	    value = (relation <= 0);
+	} else if (op[1] != 0) {
+	    return BadComparisonOperator(interp, op);
+	}
+    } else if (op[0] == '>') {
+	value = (relation > 0);
+	if (op[1] == '=' && op[2] == 0) {
+	    value = (relation >= 0);
+	} else if (op[1] != 0) {
+	    return BadComparisonOperator(interp, op);
+	}
+    } else if (op[0] == '=' && op[1] == '=' && op[2] == 0) {
+	value = (relation == 0);
+    } else if (op[0] == '!' && op[1] == '=' && op[2] == 0) {
+	value = (relation != 0);
+    } else {
+	return BadComparisonOperator(interp, op);
+    }
+
+    return value;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TextWatchCmd --
+ *
+ *	This function is invoked to process the "text watch" Tcl command. See
+ *	the user documentation for details on what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+TextWatchCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    TkSharedText *sharedTextPtr;
+
+    if (objc > 4) {
+	/* NOTE: avoid trigraph "??-" in string. */
+	Tcl_WrongNumArgs(interp, 4, objv, "\?\?-always? commandPrefix?");
+	return TCL_ERROR;
+    }
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+
+    if (objc <= 2) {
+	TkText *tPtr;
+
+	if (textPtr->watchCmd) {
+	    textPtr->triggerAlways = false;
+	    textPtr->watchCmd = NULL;
+	}
+	sharedTextPtr->triggerWatchCmd = false;
+	for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next) {
+	    if (tPtr->watchCmd) {
+		sharedTextPtr->triggerWatchCmd = true;
+	    }
+	}
+    } else {
+	const char *script;
+	Tcl_Obj *cmd;
+	int argnum = 2;
+
+	if (objc == 4) {
+	    if (strcmp(Tcl_GetString(objv[2]), "-always") != 0) {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+			"bad option \"%s\": must be -always", Tcl_GetString(objv[2])));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "WATCH_OPTION", NULL);
+		return TCL_ERROR;
+	    }
+	    textPtr->triggerAlways = true;
+	    argnum = 3;
+	}
+
+	cmd = objv[argnum];
+	script = Tcl_GetString(cmd);
+
+	if (*script == '+') {
+	    script += 1;
+	    if (textPtr->watchCmd) {
+		cmd = AppendScript(Tcl_GetString(textPtr->watchCmd), script);
+	    } else {
+		cmd = Tcl_NewStringObj(script, -1);
+	    }
+	} else if (argnum == 2) {
+	    textPtr->triggerAlways = false;
+	}
+
+	textPtr->sharedTextPtr->triggerWatchCmd = true;
+	Tcl_IncrRefCount(textPtr->watchCmd = cmd);
+    }
+
+    return TCL_OK;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TextPeerCmd --
+ *
+ *	This function is invoked to process the "text peer" Tcl command. See
+ *	the user documentation for details on what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+TextPeerCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    Tk_Window tkwin = textPtr->tkwin;
+    int index;
+
+    static const char *const peerOptionStrings[] = { "create", "names", NULL };
+    enum peerOptions { PEER_CREATE, PEER_NAMES };
+
+    if (objc < 3) {
+	Tcl_WrongNumArgs(interp, 2, objv, "option ?arg ...?");
+	return TCL_ERROR;
+    }
+    if (Tcl_GetIndexFromObjStruct(interp, objv[2], peerOptionStrings,
+	    sizeof(char *), "peer option", 0, &index) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    switch ((enum peerOptions) index) {
+    case PEER_CREATE:
+	if (objc < 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "pathName ?-option value ...?");
+	    return TCL_ERROR;
+	}
+	return CreateWidget(textPtr->sharedTextPtr, tkwin, interp, textPtr, objc - 2, objv + 2);
+    case PEER_NAMES: {
+	TkText *tPtr = textPtr->sharedTextPtr->peers;
+	Tcl_Obj *peersObj;
+
+	if (objc > 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	    return TCL_ERROR;
+	}
+	peersObj = Tcl_NewObj();
+	while (tPtr) {
+	    if (tPtr != textPtr) {
+		Tcl_ListObjAppendElement(NULL, peersObj, TkNewWindowObj(tPtr->tkwin));
+	    }
+	    tPtr = tPtr->next;
+	}
+	Tcl_SetObjResult(interp, peersObj);
+    }
+    }
+
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextReplaceCmd --
+ *
+ *	This function is invoked to process part of the "replace" widget
+ *	command for text widgets.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *	If 'viewUpdate' is false, then textPtr->topIndex may no longer be a
+ *	valid index after this function returns. The caller is responsible for
+ *	ensuring a correct index is in place.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+TextReplaceCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    const TkTextIndex *indexFromPtr,
+				/* Index from which to replace. */
+    const TkTextIndex *indexToPtr,
+				/* Index to which to replace. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[],	/* Argument objects. */
+    bool viewUpdate,		/* Update vertical view if set. */
+    bool triggerWatch,		/* Should we trigger the watch command? */
+    bool userFlag,		/* Trigger due to user modification? */
+    bool *destroyed,		/* Store whether the widget has been destroyed. */
+    bool parseHyphens)		/* Should we parse hyphens (tk_textReplace)? */
+{
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    bool *stillExisting = sharedTextPtr->stillExisting;
+    int origAutoSep = sharedTextPtr->autoSeparators;
+    int result = TCL_OK;
+    TkTextIndex indexTmp;
+    bool notDestroyed;
+    bool existing;
+
+    assert(destroyed);
+    assert(!TkTextIsDeadPeer(textPtr));
+
+    if (!stillExisting) {
+	sharedTextPtr->stillExisting = &existing;
+	existing = true;
+    }
+
+    /*
+     * Perform the deletion and insertion, but ensure no undo-separator is
+     * placed between the two operations. Since we are using the helper
+     * functions 'DeleteIndexRange' and 'TextInsertCmd' we have to pretend
+     * that the autoSeparators setting is off, so that we don't get an
+     * undo-separator between the delete and insert.
+     */
+
+    if (sharedTextPtr->undoStack) {
+	sharedTextPtr->autoSeparators = false;
+	if (origAutoSep && sharedTextPtr->lastEditMode != TK_TEXT_EDIT_REPLACE) {
+	    PushRetainedUndoTokens(sharedTextPtr);
+	    TkTextUndoPushSeparator(sharedTextPtr->undoStack, true);
+	    sharedTextPtr->lastUndoTokenType = -1;
+	}
+    }
+
+    /* The line and segment storage may change when deleting. */
+    indexTmp = *indexFromPtr;
+    TkTextIndexSave(&indexTmp);
+
+    notDestroyed = DeleteIndexRange(NULL, textPtr, indexFromPtr, indexToPtr,
+	    0, viewUpdate, triggerWatch, false, userFlag, true);
+
+    if (notDestroyed) {
+	TkTextIndexRebuild(&indexTmp);
+	result = TextInsertCmd(textPtr, interp, objc - 4, objv + 4, &indexTmp,
+		viewUpdate, false, triggerWatch, userFlag, destroyed, parseHyphens);
+	if (*destroyed) {
+	    notDestroyed = false;
+	}
+    } else {
+	*destroyed = true;
+    }
+
+    if (*sharedTextPtr->stillExisting) {
+	if (sharedTextPtr->undoStack) {
+	    sharedTextPtr->lastEditMode = TK_TEXT_EDIT_REPLACE;
+	    sharedTextPtr->autoSeparators = origAutoSep;
+	}
+	if (sharedTextPtr->stillExisting == &existing) {
+	    sharedTextPtr->stillExisting = NULL;
+	}
+    }
+
+    return result;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextIndexSortProc --
+ *
+ *	This function is called by qsort when sorting an array of indices in
+ *	*decreasing* order (last to first).
+ *
+ * Results:
+ *	The return value is less than zero if the first argument should be before
+ *	the second element, 0 if it's equivalent, and greater than zero if it should
+ *	be after the second element.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+TextIndexSortProc(
+    const void *first,		/* Elements to be compared. */
+    const void *second)
+{
+    TkTextIndex *pair1 = (TkTextIndex *) first;
+    TkTextIndex *pair2 = (TkTextIndex *) second;
+    int cmp = TkTextIndexCompare(&pair1[1], &pair2[1]);
+
+    if (cmp == 0) {
+	/*
+	 * If the first indices were equal, we want the second index of the
+	 * pair also to be the greater. Use pointer magic to access the second
+	 * index pair.
+	 */
+
+	cmp = TkTextIndexCompare(&pair1[0], &pair2[0]);
+    }
+
+    return -cmp;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FreeEmbeddedWindows --
+ *
+ *	Free up any embedded windows which belong to this widget.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	All embedded windows of this widget will be freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+FreeEmbeddedWindows(
+    TkText *textPtr)	/* The concerned text widget. */
+{
+    Tcl_HashSearch search;
+    Tcl_HashEntry *hPtr;
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+
+    for (hPtr = Tcl_FirstHashEntry(&sharedTextPtr->windowTable, &search);
+	    hPtr;
+	    hPtr = Tcl_NextHashEntry(&search)) {
+	TkTextSegment *ewPtr = Tcl_GetHashValue(hPtr);
+	TkTextEmbWindowClient *client = ewPtr->body.ew.clients;
+	TkTextEmbWindowClient **prev = &ewPtr->body.ew.clients;
+
+	while (client) {
+	    TkTextEmbWindowClient *next = client->next;
+	    if (client->textPtr == textPtr && client->hPtr == hPtr) {
+		TkTextWinFreeClient(hPtr, client);
+		*prev = next;
+	    } else {
+		prev = &client->next;
+	    }
+	    client = next;
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ClearText --
+ *
+ *	This function is invoked when we reset a text widget to it's intitial
+ *	state, but without resetting options. We will free up many of the
+ *	internal structure.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Almost everything associated with the text content is cleared.
+ *	Note that all the peers of the shared structure will be cleared.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+ClearRetainedUndoTokens(
+    TkSharedText *sharedTextPtr)
+{
+    unsigned i;
+
+    assert(sharedTextPtr);
+
+    for (i = 0; i < sharedTextPtr->undoTagListCount; ++i) {
+	TkTextReleaseUndoTagToken(sharedTextPtr, sharedTextPtr->undoTagList[i]);
+    }
+
+    for (i = 0; i < sharedTextPtr->undoMarkListCount; ++i) {
+	TkTextReleaseUndoMarkTokens(sharedTextPtr, &sharedTextPtr->undoMarkList[i]);
+    }
+
+    sharedTextPtr->undoTagListCount = 0;
+    sharedTextPtr->undoMarkListCount = 0;
+}
+
+static void
+ClearText(
+    TkText *textPtr,		/* Clean up this text widget. */
+    bool clearTags)		/* Also clear all tags? */
+{
+    TkTextSegment *retainedMarks;
+    TkTextIndex startIndex;
+    TkText *tPtr;
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    unsigned oldEpoch = TkBTreeEpoch(sharedTextPtr->tree);
+    bool steadyMarks = textPtr->sharedTextPtr->steadyMarks;
+    bool debug = tkBTreeDebug;
+
+    tkBTreeDebug = false; /* debugging is not wanted here */
+
+    for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next) {
+	/*
+	 * Always clean up the widget-specific tags first. Common tags (i.e. most)
+	 * will only be cleaned up when the shared structure is cleaned up.
+	 *
+	 * We also need to clean up widget-specific marks ('insert', 'current'),
+	 * since otherwise marks will never disappear from the B-tree.
+	 *
+	 * Do not clear the after sync commands, otherwise the widget may hang.
+	 */
+
+	tPtr->refCount += 1;
+	TkBTreeUnlinkSegment(sharedTextPtr, tPtr->insertMarkPtr);
+	TkBTreeUnlinkSegment(sharedTextPtr, tPtr->currentMarkPtr);
+	if (clearTags) {
+	    TkTextFreeAllTags(tPtr);
+	}
+	TkQTreeDestroy(&tPtr->imageBboxTree);
+	FreeEmbeddedWindows(tPtr);
+	TkTextFreeDInfo(tPtr);
+	textPtr->dInfoPtr = NULL;
+	textPtr->dontRepick = false;
+	tPtr->abortSelections = true;
+	tPtr->configureBboxTree = false;
+	tPtr->hoveredImageArrSize = 0;
+	tPtr->currNearbyFlag = -1;
+	tPtr->refCount -= 1;
+	tPtr->startLine = NULL;
+	tPtr->endLine = NULL;
+
+	if (tPtr->startMarker->refCount == 1) {
+	    assert(textPtr->startMarker != textPtr->sharedTextPtr->startMarker);
+	    TkBTreeUnlinkSegment(sharedTextPtr, tPtr->startMarker);
+	    FREE_SEGMENT(tPtr->startMarker);
+	    DEBUG_ALLOC(tkTextCountDestroySegment++);
+	    (tPtr->startMarker = sharedTextPtr->startMarker)->refCount += 1;
+	}
+	if (tPtr->endMarker->refCount == 1) {
+	    assert(textPtr->endMarker != textPtr->sharedTextPtr->endMarker);
+	    TkBTreeUnlinkSegment(sharedTextPtr, tPtr->endMarker);
+	    FREE_SEGMENT(tPtr->endMarker);
+	    DEBUG_ALLOC(tkTextCountDestroySegment++);
+	    (tPtr->endMarker = sharedTextPtr->endMarker)->refCount += 1;
+	}
+    }
+
+    ClearRetainedUndoTokens(sharedTextPtr);
+    TkBTreeUnlinkSegment(sharedTextPtr, sharedTextPtr->startMarker);
+    TkBTreeUnlinkSegment(sharedTextPtr, sharedTextPtr->endMarker);
+    sharedTextPtr->startMarker->nextPtr = sharedTextPtr->startMarker->prevPtr = NULL;
+    sharedTextPtr->endMarker->nextPtr = sharedTextPtr->endMarker->prevPtr = NULL;
+    TkBTreeDestroy(sharedTextPtr->tree);
+    retainedMarks = TkTextFreeMarks(sharedTextPtr, true);
+    Tcl_DeleteHashTable(&sharedTextPtr->imageTable);
+    Tcl_DeleteHashTable(&sharedTextPtr->windowTable);
+
+    if (sharedTextPtr->imageBindingTable) {
+	Tk_DeleteBindingTable(sharedTextPtr->imageBindingTable);
+    }
+
+    if (clearTags) {
+	Tcl_DeleteHashTable(&sharedTextPtr->tagTable);
+	if (sharedTextPtr->tagBindingTable) {
+	    Tk_DeleteBindingTable(sharedTextPtr->tagBindingTable);
+	}
+	sharedTextPtr->numMotionEventBindings = 0;
+	sharedTextPtr->numElisionTags = 0;
+    }
+
+    /*
+     * Rebuild the internal structures.
+     */
+
+    Tcl_InitHashTable(&sharedTextPtr->windowTable, TCL_STRING_KEYS);
+    Tcl_InitHashTable(&sharedTextPtr->imageTable, TCL_STRING_KEYS);
+    TkTextUndoResetStack(sharedTextPtr->undoStack);
+    TkBitClear(sharedTextPtr->elisionTags);
+    TkBitClear(sharedTextPtr->selectionTags);
+    TkBitClear(sharedTextPtr->dontUndoTags);
+    TkBitClear(sharedTextPtr->affectDisplayTags);
+    TkBitClear(sharedTextPtr->notAffectDisplayTags);
+    TkBitClear(sharedTextPtr->affectDisplayNonSelTags);
+    TkBitClear(sharedTextPtr->affectGeometryTags);
+    TkBitClear(sharedTextPtr->affectGeometryNonSelTags);
+    TkBitClear(sharedTextPtr->affectLineHeightTags);
+    sharedTextPtr->imageBindingTable = NULL;
+    sharedTextPtr->isAltered = false;
+    sharedTextPtr->isModified = false;
+    sharedTextPtr->isIrreversible = false;
+    sharedTextPtr->userHasSetModifiedFlag = false;
+    sharedTextPtr->haveToSetCurrentMark = false;
+    sharedTextPtr->undoLevel = 0;
+    sharedTextPtr->imageCount = 0;
+    sharedTextPtr->tree = TkBTreeCreate(sharedTextPtr, oldEpoch + 1);
+    sharedTextPtr->insertDeleteUndoTokenCount = 0;
+
+    if (clearTags) {
+	sharedTextPtr->tagInfoSize = 0;
+	sharedTextPtr->tagBindingTable = NULL;
+	sharedTextPtr->numTags = 0;
+	sharedTextPtr->numEnabledTags = sharedTextPtr->numPeers; /* because the "sel" tag will survive */
+	Tcl_InitHashTable(&sharedTextPtr->tagTable, TCL_STRING_KEYS);
+	TkBitClear(sharedTextPtr->usedTags);
+	DEBUG(memset(sharedTextPtr->tagLookup, 0,
+		TkBitSize(sharedTextPtr->usedTags)*sizeof(TkTextTag *)));
+    }
+
+    for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next) {
+	TkTextCreateDInfo(tPtr);
+	TkBTreeAddClient(sharedTextPtr->tree, tPtr, tPtr->lineHeight);
+	TkTextIndexSetupToStartOfText(&startIndex, tPtr, sharedTextPtr->tree);
+	TkTextSetYView(tPtr, &startIndex, 0);
+	sharedTextPtr->tagLookup[tPtr->selTagPtr->index] = tPtr->selTagPtr;
+	TkBitSet(sharedTextPtr->usedTags, tPtr->selTagPtr->index);
+	tPtr->haveToSetCurrentMark = false;
+	TkBTreeLinkSegment(sharedTextPtr, tPtr->insertMarkPtr, &startIndex);
+	TkBTreeLinkSegment(sharedTextPtr, tPtr->currentMarkPtr, &startIndex);
+	tPtr->currentMarkIndex = startIndex;
+    }
+
+    sharedTextPtr->steadyMarks = false;
+    while (retainedMarks) {
+	TkTextSegment *nextPtr = retainedMarks->nextPtr;
+	TkTextIndexSetupToStartOfText(&startIndex, NULL, sharedTextPtr->tree);
+	TkBTreeLinkSegment(sharedTextPtr, retainedMarks, &startIndex);
+	retainedMarks = nextPtr;
+    }
+    sharedTextPtr->steadyMarks = steadyMarks;
+
+    TkTextResetDInfo(textPtr);
+    sharedTextPtr->lastEditMode = TK_TEXT_EDIT_OTHER;
+    sharedTextPtr->lastUndoTokenType = -1;
+
+    if (debug) {
+	tkBTreeDebug = true;
+	TkBTreeCheck(sharedTextPtr->tree);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DestroyText --
+ *
+ *	This function is invoked when we receive a destroy event to clean up
+ *	the internal structure of a text widget. We will free up most of the
+ *	internal structure and delete the associated Tcl command. If there are
+ *	no outstanding references to the widget, we also free up the textPtr
+ *	itself.
+ *
+ *	The widget has already been flagged as deleted.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Either everything or almost everything associated with the text is
+ *	freed up.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+DestroyText(
+    TkText *textPtr)		/* Info about text widget. */
+{
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    TkTextStringList *listPtr;
+    bool debug = tkBTreeDebug;
+
+    tkBTreeDebug = false; /* debugging is not wanted here */
+
+    /*
+     * Firstly, remove pending idle commands, and free the array.
+     */
+
+    if (textPtr->pendingAfterSync) {
+	Tcl_CancelIdleCall(RunAfterSyncCmd, (ClientData) textPtr);
+	textPtr->pendingAfterSync = false;
+    }
+    if (textPtr->pendingFireEvent) {
+	Tcl_CancelIdleCall(FireWidgetViewSyncEvent, (ClientData) textPtr);
+	textPtr->pendingFireEvent = false;
+    }
+    if (textPtr->afterSyncCmd) {
+	Tcl_DecrRefCount(textPtr->afterSyncCmd);
+    }
+
+    /*
+     * Free up all the stuff that requires special handling. We have already
+     * called let Tk_FreeConfigOptions to handle all the standard
+     * option-related stuff (and so none of that exists when we are called).
+     *
+     * Special note: free up display-related information before deleting the
+     * B-tree, since display-related stuff may refer to stuff in the B-tree.
+     */
+
+    TkTextFreeDInfo(textPtr);
+    textPtr->dInfoPtr = NULL;
+    textPtr->undo = false;
+
+    /*
+     * Always clean up the widget-specific tags first. Common tags (i.e. most)
+     * will only be cleaned up when the shared structure is cleaned up.
+     *
+     * At first clean up the array of bounding boxes for the images.
+     */
+
+    TkQTreeDestroy(&textPtr->imageBboxTree);
+
+    /*
+     * Unset all the variables bound to this widget.
+     */
+
+    listPtr = textPtr->varBindingList;
+    while (listPtr) {
+	TkTextStringList *nextPtr = listPtr->nextPtr;
+
+	Tcl_UnsetVar2(textPtr->interp, Tcl_GetString(listPtr->strObjPtr), NULL, TCL_GLOBAL_ONLY);
+	Tcl_DecrRefCount(listPtr->strObjPtr);
+	free(listPtr);
+	listPtr = nextPtr;
+    }
+
+    /*
+     * Unset the watch command.
+     */
+
+    if (textPtr->watchCmd) {
+	Tcl_DecrRefCount(textPtr->watchCmd);
+    }
+    TextWatchCmd(textPtr, NULL, 0, NULL);
+
+    /*
+     * We also need to clean up widget-specific marks ('insert', 'current'),
+     * since otherwise marks will never disappear from the B-tree.
+     */
+
+    TkTextDeleteTag(textPtr, textPtr->selTagPtr, NULL);
+    TkBTreeUnlinkSegment(sharedTextPtr, textPtr->insertMarkPtr);
+    FREE_SEGMENT(textPtr->insertMarkPtr);
+    DEBUG_ALLOC(tkTextCountDestroySegment++);
+    TkBTreeUnlinkSegment(sharedTextPtr, textPtr->currentMarkPtr);
+    FREE_SEGMENT(textPtr->currentMarkPtr);
+    DEBUG_ALLOC(tkTextCountDestroySegment++);
+    FreeEmbeddedWindows(textPtr);
+
+    /*
+     * Clean up the -start/-end markers, do this after cleanup of other segments (not before).
+     */
+
+    if (textPtr->startMarker->refCount == 1) {
+	assert(textPtr->startMarker != sharedTextPtr->startMarker);
+	TkBTreeUnlinkSegment(sharedTextPtr, textPtr->startMarker);
+	FREE_SEGMENT(textPtr->startMarker);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+    } else {
+	DEBUG(textPtr->startMarker->refCount -= 1);
+    }
+    if (textPtr->endMarker->refCount == 1) {
+	assert(textPtr->endMarker != sharedTextPtr->endMarker);
+	TkBTreeUnlinkSegment(sharedTextPtr, textPtr->endMarker);
+	FREE_SEGMENT(textPtr->endMarker);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+    } else {
+	DEBUG(textPtr->endMarker->refCount -= 1);
+    }
+
+    /*
+     * Now we've cleaned up everything of relevance to us in the B-tree, so we
+     * disassociate ourselves from it.
+     *
+     * When the refCount reaches zero, it's time to clean up the shared
+     * portion of the text widget.
+     */
+
+    sharedTextPtr->refCount -= 1;
+
+    if (sharedTextPtr->refCount > 0) {
+	sharedTextPtr->numPeers -= 1;
+
+	/*
+	 * No need to call 'TkBTreeRemoveClient' first, since this will do
+	 * everything in one go, more quickly.
+	 */
+
+	TkBTreeRemoveClient(sharedTextPtr->tree, textPtr);
+
+	/*
+	 * Remove ourselves from the peer list.
+	 */
+
+	if (sharedTextPtr->peers == textPtr) {
+	    sharedTextPtr->peers = textPtr->next;
+	} else {
+	    TkText *nextPtr = sharedTextPtr->peers;
+	    while (nextPtr) {
+		if (nextPtr->next == textPtr) {
+		    nextPtr->next = textPtr->next;
+		    break;
+		}
+		nextPtr = nextPtr->next;
+	    }
+	}
+    } else {
+	/* Prevent that this resource will be released too early. */
+	textPtr->refCount += 1;
+
+	ClearRetainedUndoTokens(sharedTextPtr);
+	TkTextUndoDestroyStack(&sharedTextPtr->undoStack);
+	free(sharedTextPtr->undoTagList);
+	free(sharedTextPtr->undoMarkList);
+	TkBTreeDestroy(sharedTextPtr->tree);
+	assert(sharedTextPtr->startMarker->refCount == 1);
+	FREE_SEGMENT(sharedTextPtr->startMarker);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+	assert(sharedTextPtr->endMarker->refCount == 1);
+	FREE_SEGMENT(sharedTextPtr->endMarker);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+	FREE_SEGMENT(sharedTextPtr->protectionMark[0]);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+	FREE_SEGMENT(sharedTextPtr->protectionMark[1]);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+	TkTextFreeAllTags(textPtr);
+	Tcl_DeleteHashTable(&sharedTextPtr->tagTable);
+	TkTextFreeMarks(sharedTextPtr, false);
+	TkBitDestroy(&sharedTextPtr->usedTags);
+	TkBitDestroy(&sharedTextPtr->elisionTags);
+	TkBitDestroy(&sharedTextPtr->selectionTags);
+	TkBitDestroy(&sharedTextPtr->dontUndoTags);
+	TkBitDestroy(&sharedTextPtr->affectDisplayTags);
+	TkBitDestroy(&sharedTextPtr->notAffectDisplayTags);
+	TkBitDestroy(&sharedTextPtr->affectDisplayNonSelTags);
+	TkBitDestroy(&sharedTextPtr->affectGeometryTags);
+	TkBitDestroy(&sharedTextPtr->affectGeometryNonSelTags);
+	TkBitDestroy(&sharedTextPtr->affectLineHeightTags);
+	TkTextTagSetDestroy(&sharedTextPtr->emptyTagInfoPtr);
+	Tcl_DeleteHashTable(&sharedTextPtr->windowTable);
+	Tcl_DeleteHashTable(&sharedTextPtr->imageTable);
+	TkTextDeleteBreakInfoTableEntries(&sharedTextPtr->breakInfoTable);
+	Tcl_DeleteHashTable(&sharedTextPtr->breakInfoTable);
+	free(sharedTextPtr->mainPeer);
+	DEBUG_ALLOC(tkTextCountDestroyPeer++);
+
+	if (sharedTextPtr->tagBindingTable) {
+	    Tk_DeleteBindingTable(sharedTextPtr->tagBindingTable);
+	}
+	if (sharedTextPtr->imageBindingTable) {
+	    Tk_DeleteBindingTable(sharedTextPtr->imageBindingTable);
+	}
+	if (sharedTextPtr->stillExisting) {
+	    *sharedTextPtr->stillExisting = false;
+	}
+	free(sharedTextPtr);
+	DEBUG_ALLOC(tkTextCountDestroyShared++);
+
+	textPtr->sharedIsReleased = true;
+	textPtr->refCount -= 1;
+
+#if TK_CHECK_ALLOCS
+	/*
+	 * Remove this shared resource from global list.
+	 */
+	{
+	    WatchShared *thisPtr = watchShared;
+	    WatchShared *prevPtr = NULL;
+
+	    while (thisPtr->sharedTextPtr != sharedTextPtr) {
+		prevPtr = thisPtr;
+		thisPtr = thisPtr->nextPtr;
+		assert(thisPtr);
+	    }
+
+	    if (prevPtr) {
+		prevPtr->nextPtr = thisPtr->nextPtr;
+	    } else {
+		watchShared = thisPtr->nextPtr;
+	    }
+
+	    free(thisPtr);
+	}
+#endif
+    }
+
+    if (textPtr->tabArrayPtr) {
+	free(textPtr->tabArrayPtr);
+    }
+    if (textPtr->insertBlinkHandler) {
+	Tcl_DeleteTimerHandler(textPtr->insertBlinkHandler);
+    }
+
+    textPtr->tkwin = NULL;
+    Tcl_DeleteCommandFromToken(textPtr->interp, textPtr->widgetCmd);
+    if (--textPtr->refCount == 0) {
+	free(textPtr);
+    }
+
+    tkBTreeDebug = debug;
+    DEBUG_ALLOC(tkTextCountDestroyPeer++);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextDecrRefCountAndTestIfDestroyed --
+ *
+ *	This function is decrementing the reference count of the text
+ *	widget and destroys the widget if the reference count has been
+ *	gone to zero.
+ *
+ * Results:
+ *	Returns whether the widget has been destroyed.
+ *
+ * Side effects:
+ *	Memory might be freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextDecrRefCountAndTestIfDestroyed(
+    TkText *textPtr)
+{
+    if (--textPtr->refCount == 0) {
+	assert(textPtr->flags & DESTROYED);
+	free(textPtr);
+	return true;
+    }
+    return !!(textPtr->flags & DESTROYED);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextReleaseIfDestroyed --
+ *
+ *	This function is decrementing the reference count of the text
+ *	widget if it has been destroyed. In this case also the memory
+ *	will be released.
+ *
+ * Results:
+ *	Returns whether the widget was already destroyed.
+ *
+ * Side effects:
+ *	Memory might be freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextReleaseIfDestroyed(
+    TkText *textPtr)
+{
+    if (!(textPtr->flags & DESTROYED)) {
+	return false;
+    }
+    if (--textPtr->refCount == 0) {
+	free(textPtr);
+    }
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextTestLangCode --
+ *
+ *	Test the given language code, whether it satsifies ISO 539-1,
+ *	and set an error message if the code is invalid.
+ *
+ * Results:
+ *	The return value is 'tue' if given language code will be accepted,
+ *	otherwise 'false' will be returned.
+ *
+ * Side effects:
+ *	An error message in the interpreter may be set.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextTestLangCode(
+    Tcl_Interp *interp,
+    Tcl_Obj *langCodePtr)
+{
+    char const *lang = Tcl_GetString(langCodePtr);
+
+    if (UCHAR(lang[0]) >= 0x80
+	    || UCHAR(lang[1]) >= 0x80
+	    || !isalpha(lang[0])
+	    || !isalpha(lang[1])
+	    || !islower(lang[0])
+	    || !islower(lang[1])
+	    || lang[2] != '\0') {
+	Tcl_SetObjResult(interp, Tcl_ObjPrintf("bad lang \"%s\": "
+		"must have the form of an ISO 639-1 language code, or empty", lang));
+	Tcl_SetErrorCode(interp, "TK", "VALUE", "LANG", NULL);
+	return false;
+    }
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkConfigureText --
+ *
+ *	This function is called to process an objv/objc list, plus the Tk
+ *	option database, in order to configure (or reconfigure) a text widget.
+ *
+ * Results:
+ *	The return value is a standard Tcl result. If TCL_ERROR is returned,
+ *	then the interp's result contains an error message.
+ *
+ * Side effects:
+ *	Configuration information, such as text string, colors, font, etc. get
+ *	set for textPtr; old resources get freed, if there were any.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+IsNumberOrEmpty(
+    const char *str)
+{
+    for ( ; *str; ++str) {
+	if (!isdigit(*str)) {
+	    return false;
+	}
+    }
+    return true;
+}
+
+int
+TkConfigureText(
+    Tcl_Interp *interp,		/* Used for error reporting. */
+    TkText *textPtr,		/* Information about widget; may or may not
+				 * already have values for some fields. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    Tk_SavedOptions savedOptions;
+    TkTextIndex start, end, current;
+    unsigned currentEpoch;
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    TkTextBTree tree = sharedTextPtr->tree;
+    bool oldExport = textPtr->exportSelection;
+    bool oldTextDebug = tkTextDebug;
+    bool didHyphenate = textPtr->hyphenate;
+    int oldHyphenRules = textPtr->hyphenRules;
+    int mask = 0;
+    bool copyDownFlags = false;
+
+    tkTextDebug = false; /* debugging is not useful here */
+
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+
+    /*
+     * We want also to support the "-start", and "-end" abbreviations. The thing that
+     * Tcl supports abbreviated options is a real crux.
+     */
+
+    {
+	Tcl_Obj **myObjv;
+	Tcl_Obj *startLineObj = NULL;
+	Tcl_Obj *endLineObj = NULL;
+	Tcl_Obj *startIndexObj = NULL;
+	Tcl_Obj *endIndexObj = NULL;
+	int i, rc;
+
+	myObjv = malloc(objc * sizeof(Tcl_Obj *));
+
+	for (i = 0; i < objc; ++i) {
+	    Tcl_Obj *obj = objv[i];
+
+	    if (!(i & 1)) {
+		if (strcmp(Tcl_GetString(objv[i]), "-start") == 0) {
+		    if (i + 1 < objc && IsNumberOrEmpty(Tcl_GetString(objv[i + 1]))) {
+			if (!startLineObj) {
+			    Tcl_IncrRefCount(startLineObj = Tcl_NewStringObj("-startline", -1));
+			}
+			obj = startLineObj;
+			WarnAboutDeprecatedStartLineOption();
+		    } else {
+			if (!startIndexObj) {
+			    Tcl_IncrRefCount(startIndexObj = Tcl_NewStringObj("-startindex", -1));
+			}
+			obj = startIndexObj;
+		    }
+		} else if (strncmp(Tcl_GetString(objv[i]), "-startl", 7) == 0) {
+		    if (!startLineObj) {
+			Tcl_IncrRefCount(startLineObj = Tcl_NewStringObj("-startline", -1));
+		    }
+		    obj = startLineObj;
+		    WarnAboutDeprecatedStartLineOption();
+		} else if (strncmp(Tcl_GetString(objv[i]), "-starti", 7) == 0) {
+		    if (!startIndexObj) {
+			Tcl_IncrRefCount(startIndexObj = Tcl_NewStringObj("-startindex", -1));
+		    }
+		    obj = startIndexObj;
+		} else if (strcmp(Tcl_GetString(objv[i]), "-end") == 0) {
+		    if (i + 1 < objc && IsNumberOrEmpty(Tcl_GetString(objv[i + 1]))) {
+			if (!endLineObj) {
+			    Tcl_IncrRefCount(endLineObj = Tcl_NewStringObj("-endline", -1));
+			}
+			obj = endLineObj;
+			WarnAboutDeprecatedEndLineOption();
+		    } else {
+			if (!endIndexObj) {
+			    Tcl_IncrRefCount(endIndexObj = Tcl_NewStringObj("-endindex", -1));
+			}
+			obj = endIndexObj;
+		    }
+		} else if (strncmp(Tcl_GetString(objv[i]), "-endl", 5) == 0) {
+		    if (!endLineObj) {
+			Tcl_IncrRefCount(endLineObj = Tcl_NewStringObj("-endline", -1));
+		    }
+		    obj = endLineObj;
+		    WarnAboutDeprecatedEndLineOption();
+		} else if (strncmp(Tcl_GetString(objv[i]), "-endi", 5) == 0) {
+		    if (!endIndexObj) {
+			Tcl_IncrRefCount(endIndexObj = Tcl_NewStringObj("-endindex", -1));
+		    }
+		    obj = endIndexObj;
+		}
+	    }
+	    myObjv[i] = obj;
+	}
+
+	rc = Tk_SetOptions(interp, (char *) textPtr, textPtr->optionTable,
+		objc, myObjv, textPtr->tkwin, &savedOptions, &mask);
+
+	if (rc != TCL_OK) {
+	    if (startLineObj && startIndexObj) {
+		Tcl_SetObjResult(interp, Tcl_NewStringObj(
+		    "cannot use both, -startindex, and deprecated -startline", -1));
+		Tk_RestoreSavedOptions(&savedOptions);
+		rc = TCL_ERROR;
+	    }
+	    if (endLineObj && endIndexObj) {
+		Tcl_SetObjResult(interp, Tcl_NewStringObj(
+		    "cannot use both, -endindex, and deprecated -endline", -1));
+		Tk_RestoreSavedOptions(&savedOptions);
+		rc = TCL_ERROR;
+	    }
+	}
+
+	if (startLineObj)  { Tcl_DecrRefCount(startLineObj); }
+	if (endLineObj)    { Tcl_DecrRefCount(endLineObj); }
+	if (startIndexObj) { Tcl_DecrRefCount(startIndexObj); }
+	if (endIndexObj)   { Tcl_DecrRefCount(endIndexObj); }
+
+	free(myObjv);
+
+	if (rc != TCL_OK) {
+	    tkTextDebug = oldTextDebug;
+	    return rc;
+	}
+    }
+
+    if ((mask & TK_TEXT_LINE_RANGE) == TK_TEXT_LINE_RANGE) {
+	TkTextIndexClear2(&start, NULL, tree);
+	TkTextIndexClear2(&end, NULL, tree);
+	TkTextIndexSetToStartOfLine2(&start, textPtr->startLine ?
+		textPtr->startLine : TkBTreeGetStartLine(textPtr));
+	TkTextIndexSetToStartOfLine2(&end, textPtr->endLine ?
+		textPtr->endLine : TkBTreeGetLastLine(textPtr));
+	if (textPtr->endLine && textPtr->startLine != textPtr->endLine) {
+	    TkTextIndexBackChars(textPtr, &end, 1, &end, COUNT_INDICES);
+	}
+
+	if (TkTextIndexCompare(&start, &end) > 0) {
+	    Tcl_SetObjResult(interp, Tcl_NewStringObj(
+		    "-startline must be less than or equal to -endline", -1));
+	    Tcl_SetErrorCode(interp, "TK", "TEXT", "INDEX_ORDER", NULL);
+	    Tk_RestoreSavedOptions(&savedOptions);
+	    tkTextDebug = oldTextDebug;
+	    return TCL_ERROR;
+	}
+
+	if (textPtr->endLine && textPtr->endLine != sharedTextPtr->endMarker->sectionPtr->linePtr) {
+	    if (textPtr->endMarker->refCount > 1) {
+		textPtr->endMarker->refCount -= 1;
+		textPtr->endMarker = TkTextMakeStartEndMark(textPtr, &tkTextRightMarkType);
+	    } else {
+		TkBTreeUnlinkSegment(sharedTextPtr, textPtr->endMarker);
+	    }
+	    TkBTreeLinkSegment(sharedTextPtr, textPtr->endMarker, &end);
+	} else if (textPtr->endMarker != sharedTextPtr->endMarker) {
+	    if (--textPtr->endMarker->refCount == 0) {
+		TkBTreeUnlinkSegment(sharedTextPtr, textPtr->endMarker);
+		FREE_SEGMENT(textPtr->endMarker);
+		DEBUG_ALLOC(tkTextCountDestroySegment++);
+	    }
+	    (textPtr->endMarker = sharedTextPtr->endMarker)->refCount += 1;
+	}
+	if (textPtr->startLine
+		&& textPtr->startLine != sharedTextPtr->startMarker->sectionPtr->linePtr) {
+	    if (textPtr->startMarker->refCount > 1) {
+		textPtr->startMarker->refCount -= 1;
+		textPtr->startMarker = TkTextMakeStartEndMark(textPtr, &tkTextLeftMarkType);
+	    } else {
+		TkBTreeUnlinkSegment(sharedTextPtr, textPtr->startMarker);
+	    }
+	    TkBTreeLinkSegment(sharedTextPtr, textPtr->startMarker, &start);
+	} else if (textPtr->startMarker != sharedTextPtr->startMarker) {
+	    if (--textPtr->startMarker->refCount == 0) {
+		TkBTreeUnlinkSegment(sharedTextPtr, textPtr->startMarker);
+		FREE_SEGMENT(textPtr->startMarker);
+		DEBUG_ALLOC(tkTextCountDestroySegment++);
+	    }
+	    (textPtr->startMarker = sharedTextPtr->startMarker)->refCount += 1;
+	}
+    }
+
+#else /* if !SUPPORT_DEPRECATED_STARTLINE_ENDLINE */
+
+    if (Tk_SetOptions(interp, (char *) textPtr, textPtr->optionTable,
+	    objc, objv, textPtr->tkwin, &savedOptions, &mask) != TCL_OK) {
+	tkTextDebug = oldTextDebug;
+	return TCL_ERROR;
+    }
+
+#endif /* SUPPORT_DEPRECATED_STARTLINE_ENDLINE */
+
+    if (sharedTextPtr->steadyMarks != textPtr->steadyMarks) {
+	if (!IsClean(sharedTextPtr, NULL, true)) {
+	    ErrorNotAllowed(interp, "setting this option is possible only if the widget is clean");
+	    Tk_RestoreSavedOptions(&savedOptions);
+	    tkTextDebug = oldTextDebug;
+	    return TCL_ERROR;
+	}
+    }
+
+    /*
+     * Copy up shared flags.
+     */
+
+    /* This flag cannot alter if we have peers. */
+    sharedTextPtr->steadyMarks = textPtr->steadyMarks;
+
+    if (sharedTextPtr->autoSeparators != textPtr->autoSeparators) {
+	sharedTextPtr->autoSeparators = textPtr->autoSeparators;
+	copyDownFlags = true;
+    }
+
+    if (textPtr->undo != sharedTextPtr->undo) {
+	if (TestIfPerformingUndoRedo(interp, sharedTextPtr, NULL)) {
+	    Tk_RestoreSavedOptions(&savedOptions);
+	    tkTextDebug = oldTextDebug;
+	    return TCL_ERROR;
+	}
+
+	assert(sharedTextPtr->undo == !!sharedTextPtr->undoStack);
+	sharedTextPtr->undo = textPtr->undo;
+	copyDownFlags = true;
+
+	if (sharedTextPtr->undo) {
+	    sharedTextPtr->undoStack = TkTextUndoCreateStack(
+		    sharedTextPtr->maxUndoDepth,
+		    sharedTextPtr->maxRedoDepth,
+		    sharedTextPtr->maxUndoSize,
+		    TextUndoRedoCallback,
+		    TextUndoFreeCallback,
+		    TextUndoStackContentChangedCallback);
+	    TkTextUndoSetContext(sharedTextPtr->undoStack, sharedTextPtr);
+	    sharedTextPtr->undoLevel = 0;
+	    sharedTextPtr->isIrreversible = false;
+	    sharedTextPtr->isAltered = false;
+	} else {
+	    sharedTextPtr->isIrreversible = TkTextUndoContentIsModified(sharedTextPtr->undoStack);
+	    ClearRetainedUndoTokens(sharedTextPtr);
+	    TkTextUndoDestroyStack(&sharedTextPtr->undoStack);
+	}
+    }
+
+    /* normalize values */
+    textPtr->maxUndoDepth = MAX(textPtr->maxUndoDepth, 0);
+    textPtr->maxRedoDepth = MAX(-1, textPtr->maxRedoDepth);
+    textPtr->maxUndoSize = MAX(textPtr->maxUndoSize, 0);
+
+    if (sharedTextPtr->maxUndoDepth != textPtr->maxUndoDepth
+	    || sharedTextPtr->maxRedoDepth != textPtr->maxRedoDepth
+	    || sharedTextPtr->maxUndoSize != textPtr->maxUndoSize) {
+	if (sharedTextPtr->undoStack) {
+	    TkTextUndoSetMaxStackDepth(sharedTextPtr->undoStack,
+		    textPtr->maxUndoDepth, textPtr->maxRedoDepth);
+	    TkTextUndoSetMaxStackSize(sharedTextPtr->undoStack, textPtr->maxUndoSize, false);
+	}
+	sharedTextPtr->maxUndoDepth = textPtr->maxUndoDepth;
+	sharedTextPtr->maxRedoDepth = textPtr->maxRedoDepth;
+	sharedTextPtr->maxUndoSize = textPtr->maxUndoSize;
+	copyDownFlags = true;
+    }
+
+    if (copyDownFlags) {
+	TkText *tPtr;
+
+	for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next) {
+	    tPtr->autoSeparators = sharedTextPtr->autoSeparators;
+	    tPtr->maxUndoDepth = sharedTextPtr->maxUndoDepth;
+	    tPtr->maxRedoDepth = sharedTextPtr->maxRedoDepth;
+	    tPtr->maxUndoSize = sharedTextPtr->maxUndoSize;
+	    tPtr->undo = sharedTextPtr->undo;
+	}
+    }
+
+    /*
+     * Check soft hyphen support.
+     */
+
+    textPtr->hyphenate = textPtr->hyphens
+	    && textPtr->state != TK_TEXT_STATE_NORMAL
+	    && (textPtr->wrapMode == TEXT_WRAPMODE_WORD || textPtr->wrapMode == TEXT_WRAPMODE_CODEPOINT);
+    if (didHyphenate != textPtr->hyphenate) {
+	mask |= TK_TEXT_LINE_GEOMETRY;
+    }
+
+    /*
+     * Parse hyphen rules.
+     */
+
+    if (textPtr->hyphenRulesPtr) {
+	if (TkTextParseHyphenRules(textPtr, textPtr->hyphenRulesPtr, &textPtr->hyphenRules) != TCL_OK) {
+	    Tk_RestoreSavedOptions(&savedOptions);
+	    tkTextDebug = oldTextDebug;
+	    return TCL_ERROR;
+	}
+    } else {
+	textPtr->hyphenRules = 0;
+    }
+    if (oldHyphenRules != textPtr->hyphenRules && textPtr->hyphenate) {
+	mask |= TK_TEXT_LINE_GEOMETRY;
+    }
+
+    /*
+     * Parse tab stops.
+     */
+
+    if (textPtr->tabArrayPtr) {
+	free(textPtr->tabArrayPtr);
+	textPtr->tabArrayPtr = NULL;
+    }
+    if (textPtr->tabOptionPtr) {
+	textPtr->tabArrayPtr = TkTextGetTabs(interp, textPtr, textPtr->tabOptionPtr);
+	if (!textPtr->tabArrayPtr) {
+	    Tcl_AddErrorInfo(interp, "\n    (while processing -tabs option)");
+	    Tk_RestoreSavedOptions(&savedOptions);
+	    tkTextDebug = oldTextDebug;
+	    return TCL_ERROR;
+	}
+    }
+
+    /*
+     * Check language support.
+     */
+
+    if (textPtr->langPtr) {
+	if (!TkTextTestLangCode(interp, textPtr->langPtr)) {
+	    Tk_RestoreSavedOptions(&savedOptions);
+	    tkTextDebug = oldTextDebug;
+	    return TCL_ERROR;
+	}
+	memcpy(textPtr->lang, Tcl_GetString(textPtr->langPtr), 3);
+    } else {
+	memset(textPtr->lang, 0, 3);
+    }
+
+    /*
+     * A few other options also need special processing, such as parsing the
+     * geometry and setting the background from a 3-D border.
+     */
+
+    Tk_SetBackgroundFromBorder(textPtr->tkwin, textPtr->border);
+
+    /*
+     * Now setup the -startindex/-setindex range. This step cannot be restored,
+     * so this function must not return with an error code after this processing.
+     */
+
+    if (mask & TK_TEXT_INDEX_RANGE) {
+	if (textPtr->newStartIndex) {
+	    if (!TkTextGetIndexFromObj(interp, sharedTextPtr->mainPeer,
+		    textPtr->newStartIndex, &start)) {
+		Tk_RestoreSavedOptions(&savedOptions);
+		tkTextDebug = oldTextDebug;
+		return TCL_ERROR;
+	    }
+	}
+	if (textPtr->newEndIndex) {
+	    if (!TkTextGetIndexFromObj(interp, sharedTextPtr->mainPeer, textPtr->newEndIndex, &end)) {
+		Tk_RestoreSavedOptions(&savedOptions);
+		tkTextDebug = oldTextDebug;
+		return TCL_ERROR;
+	    }
+	}
+	if (TkTextIndexCompare(&start, &end) > 0) {
+	    Tcl_SetObjResult(interp, Tcl_NewStringObj(
+		    "-startindex must be less than or equal to -endindex", -1));
+	    Tcl_SetErrorCode(interp, "TK", "TEXT", "INDEX_ORDER", NULL);
+	    Tk_RestoreSavedOptions(&savedOptions);
+	    tkTextDebug = oldTextDebug;
+	    return TCL_ERROR;
+	}
+
+	start.textPtr = NULL;
+	end.textPtr = NULL;
+
+	if (textPtr->newEndIndex) {
+	    if (TkTextIndexIsEndOfText(&end)) {
+		if (--textPtr->endMarker->refCount == 0) {
+		    assert(textPtr->endMarker != sharedTextPtr->endMarker);
+		    TkBTreeUnlinkSegment(sharedTextPtr, textPtr->endMarker);
+		    FREE_SEGMENT(textPtr->endMarker);
+		    DEBUG_ALLOC(tkTextCountDestroySegment++);
+		}
+		(textPtr->endMarker = sharedTextPtr->endMarker)->refCount += 1;
+	    } else {
+		if (textPtr->endMarker->refCount > 1) {
+		    textPtr->endMarker->refCount -= 1;
+		    textPtr->endMarker = TkTextMakeStartEndMark(textPtr, &tkTextRightMarkType);
+		} else {
+		    assert(textPtr->endMarker != sharedTextPtr->endMarker);
+		    TkBTreeUnlinkSegment(sharedTextPtr, textPtr->endMarker);
+		}
+		TkBTreeLinkSegment(sharedTextPtr, textPtr->endMarker, &end);
+	    }
+	    Tcl_DecrRefCount(textPtr->newEndIndex);
+	    textPtr->newEndIndex = NULL;
+	}
+
+	if (textPtr->newStartIndex) {
+	    if (TkTextIndexIsStartOfText(&start)) {
+		if (--textPtr->startMarker->refCount == 0) {
+		    assert(textPtr->startMarker != sharedTextPtr->startMarker);
+		    TkBTreeUnlinkSegment(sharedTextPtr, textPtr->startMarker);
+		    FREE_SEGMENT(textPtr->startMarker);
+		    DEBUG_ALLOC(tkTextCountDestroySegment++);
+		}
+		(textPtr->startMarker = sharedTextPtr->startMarker)->refCount += 1;
+	    } else {
+		if (textPtr->startMarker->refCount > 1) {
+		    textPtr->startMarker->refCount -= 1;
+		    textPtr->startMarker = TkTextMakeStartEndMark(textPtr, &tkTextLeftMarkType);
+		} else {
+		    TkBTreeUnlinkSegment(sharedTextPtr, textPtr->startMarker);
+		}
+		TkBTreeLinkSegment(sharedTextPtr, textPtr->startMarker, &start);
+	    }
+	    Tcl_DecrRefCount(textPtr->newStartIndex);
+	    textPtr->newStartIndex = NULL;
+	}
+
+	/*
+	 * Line start and/or end have been adjusted. We need to validate the
+	 * first displayed line and arrange for re-layout.
+	 */
+
+	TkBTreeClientRangeChanged(textPtr, textPtr->lineHeight);
+	TkTextMakeByteIndex(tree, NULL, TkTextIndexGetLineNumber(&textPtr->topIndex, NULL), 0, &current);
+
+	if (TkTextIndexCompare(&current, &start) < 0 || TkTextIndexCompare(&end, &current) < 0) {
+	    TkTextSearch search;
+	    TkTextIndex first, last;
+	    bool selChanged = false;
+
+	    TkTextSetYView(textPtr, &start, 0);
+
+	    /*
+	     * We may need to adjust the selection. So we have to check
+	     * whether the "sel" tag was applied to anything outside the
+	     * current start,end.
+	     */
+
+	    TkTextMakeByteIndex(tree, NULL, 0, 0, &first);
+	    TkBTreeStartSearch(&first, &start, textPtr->selTagPtr, &search, SEARCH_NEXT_TAGON);
+	    if (TkBTreeNextTag(&search)) {
+		selChanged = true;
+	    } else {
+		TkTextMakeByteIndex(tree, NULL, TkBTreeNumLines(tree, NULL), 0, &last);
+		TkBTreeStartSearchBack(&end, &last, textPtr->selTagPtr,
+			&search, SEARCH_EITHER_TAGON_TAGOFF);
+		if (TkBTreePrevTag(&search)) {
+		    selChanged = true;
+		}
+	    }
+	    if (selChanged) {
+		/*
+		 * Send an event that the selection has changed, and abort any
+		 * partial-selections in progress.
+		 */
+
+		TkTextSelectionEvent(textPtr);
+		textPtr->abortSelections = true;
+	    }
+	}
+
+	/* Indices are potentially obsolete after changing -start and/or
+	 * -end, therefore increase the epoch.
+	 * Also, clamp the insert and current (unshared) marks to the new
+	 * -start/-end range limits of the widget. All other (shared)
+	 * marks are unchanged.
+         * The return value of TkTextMarkNameToIndex does not need to be
+         * checked: "insert" and "current" marks always exist, and the
+         * purpose of the code below precisely is to move them inside the
+         * -start/-end range.
+	 */
+
+	currentEpoch = TkBTreeIncrEpoch(tree);
+	start.textPtr = textPtr;
+	end.textPtr = textPtr;
+
+	TkTextMarkNameToIndex(textPtr, "current", &current);
+	if (TkTextIndexCompare(&current, &start) < 0) {
+	    textPtr->currentMarkPtr = TkTextSetMark(textPtr, "current", &start);
+	} else if (TkTextIndexCompare(&current, &end) > 0) {
+	    textPtr->currentMarkPtr = TkTextSetMark(textPtr, "current", &end);
+	}
+    } else {
+	currentEpoch = TkBTreeEpoch(tree);
+    }
+
+    /*
+     * Don't allow negative spacings.
+     */
+
+    textPtr->spacing1 = MAX(textPtr->spacing1, 0);
+    textPtr->spacing2 = MAX(textPtr->spacing2, 0);
+    textPtr->spacing3 = MAX(textPtr->spacing3, 0);
+
+    /*
+     * Also the following widths shouldn't be negative.
+     */
+
+    textPtr->highlightWidth = MAX(textPtr->highlightWidth, 0);
+    textPtr->selBorderWidth = MAX(textPtr->selBorderWidth, 0);
+    textPtr->borderWidth = MAX(textPtr->borderWidth, 0);
+    textPtr->insertWidth = MAX(textPtr->insertWidth, 0);
+
+    /*
+     * Don't allow negative sync timeout.
+     */
+
+    textPtr->syncTime = MAX(0, textPtr->syncTime);
+
+    /*
+     * Make sure that configuration options are properly mirrored between the
+     * widget record and the "sel" tags. NOTE: we don't have to free up
+     * information during the mirroring; old information was freed when it was
+     * replaced in the widget record.
+     */
+
+    if (textPtr->selTagPtr->selBorder) {
+	textPtr->selTagPtr->selBorder = textPtr->selBorder;
+    } else {
+	textPtr->selTagPtr->border = textPtr->selBorder;
+    }
+    if (textPtr->selTagPtr->borderWidthPtr != textPtr->selBorderWidthPtr) {
+	textPtr->selTagPtr->borderWidthPtr = textPtr->selBorderWidthPtr;
+	textPtr->selTagPtr->borderWidth = textPtr->selBorderWidth;
+    }
+    if (textPtr->selTagPtr->selFgColor) {
+	textPtr->selTagPtr->selFgColor = textPtr->selFgColorPtr;
+    } else {
+	textPtr->selTagPtr->fgColor = textPtr->selFgColorPtr;
+    }
+    TkTextUpdateTagDisplayFlags(textPtr->selTagPtr);
+    TkTextRedrawTag(NULL, textPtr, NULL, NULL, textPtr->selTagPtr, false);
+
+    /*
+     * Claim the selection if we've suddenly started exporting it and there
+     * are tagged characters.
+     */
+
+    if (textPtr->exportSelection && !oldExport) {
+	TkTextSearch search;
+	TkTextIndex first, last;
+
+	TkTextIndexSetupToStartOfText(&first, textPtr, tree);
+	TkTextIndexSetupToEndOfText(&last, textPtr, tree);
+	TkBTreeStartSearch(&first, &last, textPtr->selTagPtr, &search, SEARCH_NEXT_TAGON);
+	if (TkBTreeNextTag(&search)) {
+	    Tk_OwnSelection(textPtr->tkwin, XA_PRIMARY, TkTextLostSelection, textPtr);
+	    textPtr->flags |= GOT_SELECTION;
+	}
+    }
+
+    /*
+     * Account for state changes that would reenable blinking cursor state.
+     */
+
+    if (textPtr->flags & HAVE_FOCUS) {
+	Tcl_DeleteTimerHandler(textPtr->insertBlinkHandler);
+	textPtr->insertBlinkHandler = NULL;
+	TextBlinkProc(textPtr);
+    }
+
+    /*
+     * Register the desired geometry for the window, and arrange for the
+     * window to be redisplayed.
+     */
+
+    textPtr->width = MAX(textPtr->width, 1);
+    textPtr->height = MAX(textPtr->height, 1);
+
+    Tk_FreeSavedOptions(&savedOptions);
+    TextWorldChanged(textPtr, mask);
+
+    if (textPtr->syncTime == 0 && (mask & TK_TEXT_SYNCHRONIZE)) {
+	UpdateLineMetrics(textPtr, 0, TkBTreeNumLines(sharedTextPtr->tree, textPtr));
+    }
+
+    /*
+     * At least handle the "watch" command, and set the insert cursor.
+     */
+
+    if (mask & TK_TEXT_INDEX_RANGE) {
+	/*
+	 * Setting the "insert" mark must be done at the end, because the "watch" command
+	 * will be triggered. Be sure to use the actual range, mind the epoch.
+	 */
+
+	TkTextMarkNameToIndex(textPtr, "insert", &current);
+
+	if (start.stateEpoch != currentEpoch) {
+	    /*
+	     * The "watch" command did change the content.
+	     */
+	    TkTextIndexSetupToStartOfText(&start, textPtr, tree);
+	    TkTextIndexSetupToEndOfText(&end, textPtr, tree);
+	}
+
+	start.textPtr = textPtr;
+	end.textPtr = textPtr;
+
+	if (TkTextIndexCompare(&current, &start) < 0) {
+	    textPtr->insertMarkPtr = TkTextSetMark(textPtr, "insert", &start);
+	} else if (TkTextIndexCompare(&current, &end) >= 0) {
+	    textPtr->insertMarkPtr = TkTextSetMark(textPtr, "insert", &end);
+	}
+    }
+
+    tkTextDebug = oldTextDebug;
+    TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+
+    return TCL_OK;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextParseHyphenRules --
+ *
+ *	This function is parsing the object containing the hyphen rules.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+int
+TkTextParseHyphenRules(
+    TkText *textPtr,
+    Tcl_Obj *objPtr,
+    int *rulesPtr)
+{
+    int rules = 0;
+    Tcl_Obj **argv;
+    int argc, i, k;
+
+    assert(rulesPtr);
+
+    if (Tcl_ListObjGetElements(textPtr->interp, objPtr, &argc, &argv) != TCL_OK) {
+	return TCL_ERROR;
+    }
+    for (i = 0; i < argc; ++i) {
+	char const *rule = Tcl_GetString(argv[i]);
+	int r = rules;
+
+	for (k = 0; k < sizeof(hyphenRuleStrings)/sizeof(hyphenRuleStrings[0]); ++k) {
+	    if (strcmp(rule, hyphenRuleStrings[k]) == 0) {
+		rules |= (1 << k);
+	    }
+	}
+	if (r == rules) {
+	    Tcl_SetObjResult(textPtr->interp, Tcl_ObjPrintf("unknown hyphen rule \"%s\"", rule));
+	    Tcl_SetErrorCode(textPtr->interp, "TK", "TEXT", "VALUE", NULL);
+	    return TCL_ERROR;
+	}
+    }
+    *rulesPtr = rules;
+    return TCL_OK;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TextWorldChangedCallback --
+ *
+ *	This function is called when the world has changed in some way and the
+ *	widget needs to recompute all its graphics contexts and determine its
+ *	new geometry.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Configures all tags in the Text with a empty objc/objv, for the side
+ *	effect of causing all the items to recompute their geometry and to be
+ *	redisplayed.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+static void
+TextWorldChangedCallback(
+    ClientData instanceData)	/* Information about widget. */
+{
+    TextWorldChanged((TkText *) instanceData, TK_TEXT_LINE_GEOMETRY);
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TextWorldChanged --
+ *
+ *	This function is called when the world has changed in some way and the
+ *	widget needs to recompute all its graphics contexts and determine its
+ *	new geometry.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Configures all tags in the Text with a empty objc/objv, for the side
+ *	effect of causing all the items to recompute their geometry and to be
+ *	redisplayed.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+static void
+TextWorldChanged(
+    TkText *textPtr,		/* Information about widget. */
+    int mask)			/* OR'd collection of bits showing what has changed. */
+{
+    Tk_FontMetrics fm;
+    int border;
+    int oldLineHeight = textPtr->lineHeight;
+
+    Tk_GetFontMetrics(textPtr->tkfont, &fm);
+    textPtr->lineHeight = MAX(1, fm.linespace);
+    textPtr->charWidth = MAX(1, Tk_TextWidth(textPtr->tkfont, "0", 1));
+    textPtr->spaceWidth = MAX(1, Tk_TextWidth(textPtr->tkfont, " ", 1));
+
+    if (oldLineHeight != textPtr->lineHeight) {
+	TkTextFontHeightChanged(textPtr);
+    }
+
+    border = textPtr->borderWidth + textPtr->highlightWidth;
+    Tk_GeometryRequest(textPtr->tkwin,
+	    textPtr->width*textPtr->charWidth + 2*textPtr->padX + 2*border,
+	    textPtr->height*(fm.linespace + textPtr->spacing1 + textPtr->spacing3)
+		    + 2*textPtr->padY + 2*border);
+
+    Tk_SetInternalBorderEx(textPtr->tkwin,
+	    border + textPtr->padX, border + textPtr->padX,
+	    border + textPtr->padY, border + textPtr->padY);
+    if (textPtr->setGrid) {
+	Tk_SetGrid(textPtr->tkwin, textPtr->width, textPtr->height,
+		textPtr->charWidth, textPtr->lineHeight);
+    } else {
+	Tk_UnsetGrid(textPtr->tkwin);
+    }
+
+    TkTextRelayoutWindow(textPtr, mask);
+    TK_BTREE_DEBUG(TkBTreeCheck(textPtr->sharedTextPtr->tree));
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TextEventProc --
+ *
+ *	This function is invoked by the Tk dispatcher on structure changes to
+ *	a text. For texts with 3D borders, this function is also invoked for
+ *	exposures.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	When the window gets deleted, internal structures get cleaned up.
+ *	When it gets exposed, it is redisplayed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+ProcessConfigureNotify(
+    TkText *textPtr,
+    bool updateLineGeometry)
+{
+    int mask = updateLineGeometry ? TK_TEXT_LINE_GEOMETRY : 0;
+
+    /*
+     * Do not allow line height computations before we accept the first
+     * ConfigureNotify event. The problem is the very poor performance
+     * in CalculateDisplayLineHeight() with very small widget width.
+     */
+
+    if (!textPtr->sharedTextPtr->allowUpdateLineMetrics) {
+	textPtr->sharedTextPtr->allowUpdateLineMetrics = true;
+	updateLineGeometry = true;
+	TkTextEventuallyRepick(textPtr);
+    }
+
+    if (textPtr->prevHeight != Tk_Height(textPtr->tkwin)
+	    || textPtr->prevWidth != Tk_Width(textPtr->tkwin)) {
+	mask |= TK_TEXT_LINE_REDRAW_BOTTOM_LINE;
+    }
+    TkTextRelayoutWindow(textPtr, mask);
+    TK_BTREE_DEBUG(TkBTreeCheck(textPtr->sharedTextPtr->tree));
+
+    textPtr->prevWidth = Tk_Width(textPtr->tkwin);
+    textPtr->prevHeight = Tk_Height(textPtr->tkwin);
+
+    if (textPtr->imageBboxTree) {
+	textPtr->configureBboxTree = true;
+    }
+}
+
+static void
+ProcessDestroyNotify(
+    TkText *textPtr)
+{
+    /*
+     * NOTE: we must zero out selBorder, selBorderWidthPtr and
+     * selFgColorPtr: they are duplicates of information in the "sel" tag,
+     * which will be freed up when we delete all tags. Hence we don't want
+     * the automatic config options freeing process to delete them as
+     * well.
+     */
+
+    textPtr->selBorder = NULL;
+    textPtr->selBorderWidthPtr = NULL;
+    textPtr->selBorderWidth = 0;
+    textPtr->selFgColorPtr = NULL;
+    if (textPtr->setGrid) {
+	Tk_UnsetGrid(textPtr->tkwin);
+	textPtr->setGrid = false;
+    }
+    if (!(textPtr->flags & OPTIONS_FREED)) {
+	Tk_FreeConfigOptions((char *) textPtr, textPtr->optionTable, textPtr->tkwin);
+	textPtr->flags |= OPTIONS_FREED;
+    }
+    textPtr->flags |= DESTROYED;
+
+    /*
+     * Call 'DestroyTest' to handle the deletion for us. The actual
+     * textPtr may still exist after this, if there are some outstanding
+     * references. But we have flagged it as DESTROYED just above, so
+     * nothing will try to make use of it very extensively.
+     */
+
+    DestroyText(textPtr);
+}
+
+static void
+ProcessFocusInOut(
+    TkText *textPtr,
+    XEvent *eventPtr)
+{
+    TkTextIndex index, index2;
+
+    if (eventPtr->xfocus.detail == NotifyInferior
+	    || eventPtr->xfocus.detail == NotifyAncestor
+	    || eventPtr->xfocus.detail == NotifyNonlinear) {
+	if (eventPtr->type == FocusIn) {
+	    textPtr->flags |= HAVE_FOCUS | INSERT_ON;
+	} else {
+	    textPtr->flags &= ~(HAVE_FOCUS | INSERT_ON);
+	}
+	if (textPtr->state == TK_TEXT_STATE_NORMAL) {
+	    if (eventPtr->type == FocusOut) {
+		if (textPtr->insertBlinkHandler) {
+		    Tcl_DeleteTimerHandler(textPtr->insertBlinkHandler);
+		    textPtr->insertBlinkHandler = NULL;
+		}
+	    } else if (textPtr->insertOffTime && !textPtr->insertBlinkHandler) {
+		textPtr->insertBlinkHandler =
+			Tcl_CreateTimerHandler(textPtr->insertOnTime, TextBlinkProc, textPtr);
+	    }
+	    TkTextMarkSegToIndex(textPtr, textPtr->insertMarkPtr, &index);
+	    TkTextIndexForwChars(textPtr, &index, 1, &index2, COUNT_INDICES);
+	    TkTextChanged(NULL, textPtr, &index, &index2);
+	}
+	if (textPtr->inactiveSelBorder != textPtr->selBorder) {
+	    TkTextRedrawTag(NULL, textPtr, NULL, NULL, textPtr->selTagPtr, false);
+	}
+	if (textPtr->highlightWidth > 0) {
+	    TkTextRedrawRegion(textPtr, 0, 0, textPtr->highlightWidth, textPtr->highlightWidth);
+	}
+    }
+}
+
+static void
+TextEventProc(
+    ClientData clientData,	/* Information about window. */
+    XEvent *eventPtr)		/* Information about event. */
+{
+    TkText *textPtr = clientData;
+
+    switch (eventPtr->type) {
+    case ConfigureNotify:
+	if (textPtr->prevWidth != Tk_Width(textPtr->tkwin)
+		|| textPtr->prevHeight != Tk_Height(textPtr->tkwin)) {
+	    /*
+	     * We don't need display computations until the widget is mapped
+	     * or as long as the width seems to be unrealistic (not yet expanded
+	     * by the geometry manager), see ProcessConfigureNotify() for more
+	     * information.
+	     */
+
+	    if (Tk_IsMapped(textPtr->tkwin)
+		    || (Tk_Width(textPtr->tkwin) >
+			MAX(1, 2*(textPtr->highlightWidth + textPtr->borderWidth + textPtr->padX)))) {
+		ProcessConfigureNotify(textPtr, textPtr->prevWidth != Tk_Width(textPtr->tkwin));
+	    }
+	}
+	break;
+    case DestroyNotify:
+	ProcessDestroyNotify(textPtr);
+	break;
+    default:
+	if (!textPtr->sharedTextPtr->allowUpdateLineMetrics) {
+	    /*
+	     * I don't know whether this can happen, but we want to be sure,
+	     * probably we have rejected all ConfigureNotify events before
+	     * first Expose arrives.
+	     */
+	    ProcessConfigureNotify(textPtr, true);
+	}
+	switch (eventPtr->type) {
+	case Expose:
+	    TkTextRedrawRegion(textPtr, eventPtr->xexpose.x, eventPtr->xexpose.y,
+		    eventPtr->xexpose.width, eventPtr->xexpose.height);
+	    break;
+	case FocusIn:
+	case FocusOut:
+	    ProcessFocusInOut(textPtr, eventPtr);
+	    break;
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextCmdDeletedProc --
+ *
+ *	This function is invoked when a widget command is deleted. If the
+ *	widget isn't already in the process of being destroyed, this command
+ *	destroys it.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The widget is destroyed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+TextCmdDeletedProc(
+    ClientData clientData)	/* Pointer to widget record for widget. */
+{
+    TkText *textPtr = clientData;
+    Tk_Window tkwin = textPtr->tkwin;
+
+    /*
+     * This function could be invoked either because the window was destroyed
+     * and the command was then deleted (in which this flag is already set) or
+     * because the command was deleted, and then this function destroys the
+     * widget.
+     */
+
+    if (!(textPtr->flags & DESTROYED)) {
+	if (textPtr->setGrid) {
+	    Tk_UnsetGrid(textPtr->tkwin);
+	    textPtr->setGrid = false;
+	}
+	textPtr->flags |= DESTROYED;
+	Tk_DestroyWindow(tkwin);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * InsertChars --
+ *
+ *	This function implements most of the functionality of the "insert"
+ *	widget command.
+ *
+ * Results:
+ *	The length of the inserted string.
+ *
+ * Side effects:
+ *	The characters in "stringPtr" get added to the text just before the
+ *	character indicated by "indexPtr".
+ *
+ *	If 'viewUpdate' is true, we may adjust the window contents'
+ *	y-position, and scrollbar setting.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+InitPosition(
+    TkSharedText *sharedTextPtr,	/* Shared portion of peer widgets. */
+    TkTextPosition *positions)		/* Initialise this position array. */
+{
+    unsigned i;
+
+    for (i = 0; i < sharedTextPtr->numPeers; ++i, ++positions) {
+	positions->lineIndex = -1;
+	positions->byteIndex = 0;
+    }
+}
+
+static void
+FindNewTopPosition(
+    TkSharedText *sharedTextPtr,	/* Shared portion of peer widgets. */
+    TkTextPosition *positions,		/* Fill this position array. */
+    const TkTextIndex *index1Ptr,	/* Start position of this insert/delete. */
+    const TkTextIndex *index2Ptr,	/* End position of this delete, is NULL in case of insert. */
+    unsigned lengthOfInsertion)		/* Length of inserted string, is zero in case of delete. */
+{
+    TkTextBTree tree = sharedTextPtr->tree;
+    TkText *tPtr;
+
+    for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next, ++positions) {
+	int lineIndex = -1;
+	int byteIndex = 0;
+
+	if (index2Ptr == NULL) {
+	    if (TkTextIndexGetLine(index1Ptr) == TkTextIndexGetLine(&tPtr->topIndex)) {
+		lineIndex = TkBTreeLinesTo(tree, NULL, TkTextIndexGetLine(index1Ptr), NULL);
+		byteIndex = TkTextIndexGetByteIndex(&tPtr->topIndex);
+		if (byteIndex > TkTextIndexGetByteIndex(index1Ptr)) {
+		    byteIndex += lengthOfInsertion;
+		}
+	    }
+	} else if (TkTextIndexCompare(index2Ptr, &tPtr->topIndex) >= 0) {
+	    if (TkTextIndexCompare(index1Ptr, &tPtr->topIndex) <= 0) {
+		/*
+		 * Deletion range straddles topIndex: use the beginning of the
+		 * range as the new topIndex.
+		 */
+
+		lineIndex = TkBTreeLinesTo(tree, NULL, TkTextIndexGetLine(index1Ptr), NULL);
+		byteIndex = TkTextIndexGetByteIndex(index1Ptr);
+	    } else if (TkTextIndexGetLine(index1Ptr) == TkTextIndexGetLine(&tPtr->topIndex)) {
+		/*
+		 * Deletion range starts on top line but after topIndex. Use
+		 * the current topIndex as the new one.
+		 */
+
+		lineIndex = TkBTreeLinesTo(tree, NULL, TkTextIndexGetLine(index1Ptr), NULL);
+		byteIndex = TkTextIndexGetByteIndex(&tPtr->topIndex);
+            } else {
+                /*
+                 * Deletion range starts after the top line. This peers's view
+                 * will not need to be reset. Nothing to do.
+                 */
+	    }
+	} else if (TkTextIndexGetLine(index2Ptr) == TkTextIndexGetLine(&tPtr->topIndex)) {
+	    /*
+	     * Deletion range ends on top line but before topIndex. Figure out
+	     * what will be the new character index for the character
+	     * currently pointed to by topIndex.
+	     */
+
+	    lineIndex = TkBTreeLinesTo(tree, NULL, TkTextIndexGetLine(index2Ptr), NULL);
+	    byteIndex = TkTextIndexGetByteIndex(&tPtr->topIndex) - TkTextIndexGetByteIndex(index2Ptr);
+	    if (TkTextIndexGetLine(index1Ptr) == TkTextIndexGetLine(index2Ptr)) {
+		byteIndex += TkTextIndexGetByteIndex(index1Ptr);
+	    }
+        } else {
+            /*
+             * Deletion range ends before the top line. This peers's view
+             * will not need to be reset. Nothing to do.
+             */
+	}
+
+	if (lineIndex != -1) {
+	    if (lineIndex == positions->lineIndex) {
+		positions->byteIndex = MAX(positions->byteIndex, byteIndex);
+	    } else {
+		positions->lineIndex = MAX(positions->lineIndex, lineIndex);
+		positions->byteIndex = byteIndex;
+	    }
+	}
+    }
+}
+
+static void
+SetNewTopPosition(
+    TkSharedText *sharedTextPtr,	/* Shared portion of peer widgets. */
+    TkText *textPtr,			/* Current peer widget, can be NULL. */
+    const TkTextPosition *positions,	/* New top positions. */
+    bool viewUpdate)			/* Update the view of current widget if set. */
+{
+    TkText *tPtr;
+
+    for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next, ++positions) {
+	if (positions->lineIndex != -1) {
+	    TkTextIndex index;
+
+	    if (tPtr == textPtr && !viewUpdate) {
+		continue;
+	    }
+
+	    TkTextMakeByteIndex(sharedTextPtr->tree, NULL, positions->lineIndex, 0, &index);
+	    TkTextIndexForwBytes(tPtr, &index, positions->byteIndex, &index);
+
+	    if (tPtr == textPtr) {
+		/*
+		 * Line cannot be before -startindex of textPtr because this line
+		 * corresponds to an index which is necessarily between "begin"
+		 * and "end" relative to textPtr. Therefore no need to clamp line
+		 * to the -start/-end range.
+		 */
+	    } else {
+		TkTextIndex start;
+
+                /*
+                 * Line may be before -startindex of tPtr and must be clamped to -startindex
+		 * before providing it to TkTextSetYView otherwise lines before -startindex
+                 * would be displayed. There is no need to worry about -endline however,
+                 * because the view will only be reset if the deletion involves the TOP
+		 * line of the screen.
+                 */
+
+		TkTextIndexClear2(&start, tPtr, sharedTextPtr->tree);
+		TkTextIndexSetSegment(&start, tPtr->startMarker);
+		if (TkTextIndexCompare(&index, &start) < 0) {
+		    index = start;
+		}
+	    }
+
+	    TkTextSetYView(tPtr, &index, 0);
+	}
+    }
+}
+
+static void
+ParseHyphens(
+    const char *string,
+    const char *end,
+    char *buffer)
+{
+    /*
+     * Preparing a string for hyphenation support. Note that 0xff is not allowed in
+     * UTF-8 strings, so we can use this value for special purposes.
+     */
+
+    while (string != end) {
+	if (*string == '\\') {
+	    switch (*++string) {
+	    case '\0':
+		*buffer++ = '\\';
+		break;
+	    case '-':
+		*buffer++ = 0xff;
+		*buffer++ = '-';
+		string += 1;
+		break;
+	    case '+':
+	    	*buffer++ = 0xff;
+		*buffer++ = '+';
+		string += 1;
+		break;
+	    case ':':
+		switch (string[1]) {
+		case 'c':
+		    if (strncmp(string, ":ck:", 4) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_CK;
+			string += 4;
+			break;
+		    }
+		    *buffer++ = *string++;
+		    break;
+		case 'd':
+		    if (strncmp(string, ":dd:", 4) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_DOUBLE_DIGRAPH;
+			string += 4;
+			break;
+		    }
+		    if (strncmp(string, ":dv:", 4) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_DOUBLE_VOWEL;
+			string += 4;
+			break;
+		    }
+		    if (strncmp(string, ":doubledigraph:", 15) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_DOUBLE_DIGRAPH;
+			string += 15;
+			break;
+		    }
+		    if (strncmp(string, ":doublevowel:", 13) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_DOUBLE_VOWEL;
+			string += 13;
+			break;
+		    }
+		    *buffer++ = *string++;
+		    break;
+		case 'g':
+		    if (strncmp(string, ":ge:", 4) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_GEMINATION;
+			string += 4;
+			break;
+		    }
+		    if (strncmp(string, ":gemination:", 12) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_GEMINATION;
+			string += 12;
+			break;
+		    }
+		    *buffer++ = *string++;
+		    break;
+		case 'r':
+		    if (strncmp(string, ":rh:", 4) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_REPEAT;
+			string += 4;
+			break;
+		    }
+		    if (strncmp(string, ":repeathyphen:", 14) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_REPEAT;
+			string += 14;
+			break;
+		    }
+		    *buffer++ = *string++;
+		    break;
+		case 't':
+		    if (strncmp(string, ":tr:", 4) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_TREMA;
+			string += 4;
+			break;
+		    }
+		    if (strncmp(string, ":tc:", 4) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_TRIPLE_CONSONANT;
+			string += 4;
+			break;
+		    }
+		    if (strncmp(string, ":trema:", 7) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_TREMA;
+			string += 7;
+			break;
+		    }
+		    if (strncmp(string, ":tripleconsonant:", 17) == 0) {
+			*buffer++ = 0xff;
+			*buffer++ = 1 << TK_TEXT_HYPHEN_TRIPLE_CONSONANT;
+			string += 17;
+			break;
+		    }
+		    *buffer++ = *string++;
+		    break;
+	    default:
+		*buffer++ = *string++;
+		break;
+	    }
+	    }
+	} else {
+	    *buffer++ = *string++;
+	}
+    }
+    *buffer = '\0';
+}
+
+static void
+InsertChars(
+    TkText *textPtr,		/* Overall information about text widget. */
+    TkTextIndex *index1Ptr,	/* Where to insert new characters. May be modified if the index
+    				 * is not valid for insertion (e.g. if at "end"). */
+    TkTextIndex *index2Ptr,	/* Out: Index at the end of the inserted text. */
+    char const *string,		/* Null-terminated string containing new information to add to text. */
+    unsigned length,		/* Length of string content. */
+    bool viewUpdate,		/* Update the view if set. */
+    TkTextTagSet *tagInfoPtr,	/* Add these tags to the inserted text, can be NULL. */
+    TkTextTag *hyphenTagPtr,	/* Associate this tag with soft hyphens, can be NULL. */
+    bool parseHyphens)		/* Should we parse hyphens (tk_textInsert)? */
+{
+    TkSharedText *sharedTextPtr;
+    TkText *tPtr;
+    TkTextPosition *textPosition;
+    TkTextPosition textPosBuf[PIXEL_CLIENTS];
+    TkTextUndoInfo undoInfo;
+    TkTextUndoInfo *undoInfoPtr;
+    TkTextIndex startIndex;
+    const char *text = string;
+    char textBuf[4096];
+
+    assert(textPtr);
+    assert(length > 0);
+    assert(!TkTextIsDeadPeer(textPtr));
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+
+    /*
+     * Don't allow insertions on the last (dummy) line of the text. This is
+     * the only place in this function where the index1Ptr is modified.
+     */
+
+    if (TkTextIndexGetLine(index1Ptr) == TkBTreeGetLastLine(textPtr)) {
+	TkTextIndexBackChars(textPtr, index1Ptr, 1, index1Ptr, COUNT_INDICES);
+    }
+
+    /*
+     * Notify the display module that lines are about to change, then do the
+     * insertion. If the insertion occurs on the top line of the widget
+     * (textPtr->topIndex), then we have to recompute topIndex after the
+     * insertion, since the insertion could invalidate it.
+     */
+
+    if (sharedTextPtr->numPeers > sizeof(textPosition)/sizeof(textPosition[0])) {
+	textPosition = malloc(sizeof(textPosition[0])*sharedTextPtr->numPeers);
+    } else {
+	textPosition = textPosBuf;
+    }
+    InitPosition(sharedTextPtr, textPosition);
+    FindNewTopPosition(sharedTextPtr, textPosition, index1Ptr, NULL, length);
+
+    TkTextChanged(sharedTextPtr, NULL, index1Ptr, index1Ptr);
+    undoInfoPtr = TkTextUndoStackIsFull(sharedTextPtr->undoStack) ? NULL : &undoInfo;
+    startIndex = *index1Ptr;
+    TkTextIndexToByteIndex(&startIndex); /* we need the byte position after insertion */
+
+    if (parseHyphens) {
+	text = (length >= sizeof(textBuf)) ? malloc(length + 1) : textBuf;
+	ParseHyphens(string, string + length, (char *) text);
+    }
+
+    TkBTreeInsertChars(sharedTextPtr->tree, index1Ptr, text, tagInfoPtr, hyphenTagPtr, undoInfoPtr);
+
+    /*
+     * Push the insertion on the undo stack, and update the modified status of the widget.
+     * Try to join with previously pushed undo token, if possible.
+     */
+
+    if (undoInfoPtr) {
+	const TkTextUndoSubAtom *subAtom;
+	bool triggerStackEvent = false;
+
+	assert(undoInfo.byteSize == 0);
+
+	if (sharedTextPtr->autoSeparators && sharedTextPtr->lastEditMode != TK_TEXT_EDIT_INSERT) {
+	    PushRetainedUndoTokens(sharedTextPtr);
+	    TkTextUndoPushSeparator(sharedTextPtr->undoStack, true);
+	    sharedTextPtr->lastUndoTokenType = -1;
+	}
+	if (sharedTextPtr->lastUndoTokenType != TK_TEXT_UNDO_INSERT
+		|| !((subAtom = TkTextUndoGetLastUndoSubAtom(sharedTextPtr->undoStack))
+			&& (triggerStackEvent = TkBTreeJoinUndoInsert(
+				subAtom->item, subAtom->size, undoInfo.token, undoInfo.byteSize)))) {
+	    TkTextPushUndoToken(sharedTextPtr, undoInfo.token, undoInfo.byteSize);
+	} else {
+	    assert(!undoInfo.token->undoType->destroyProc);
+	    free(undoInfo.token);
+	    DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	}
+	if (triggerStackEvent) {
+	    sharedTextPtr->undoStackEvent = true; /* TkBTreeJoinUndoInsert didn't trigger */
+	}
+	assert(undoInfo.token->undoType->rangeProc);
+	sharedTextPtr->prevUndoStartIndex = ((TkTextUndoTokenRange *) undoInfo.token)->startIndex;
+	sharedTextPtr->prevUndoEndIndex = ((TkTextUndoTokenRange *) undoInfo.token)->endIndex;
+	sharedTextPtr->lastUndoTokenType = TK_TEXT_UNDO_INSERT;
+	sharedTextPtr->lastEditMode = TK_TEXT_EDIT_INSERT;
+    }
+
+    *index2Ptr = *index1Ptr;
+    *index1Ptr = startIndex;
+    UpdateModifiedFlag(sharedTextPtr, true);
+    TkTextUpdateAlteredFlag(sharedTextPtr);
+    SetNewTopPosition(sharedTextPtr, textPtr, textPosition, viewUpdate);
+    if (textPosition != textPosBuf) {
+	free(textPosition);
+    }
+
+    /*
+     * Invalidate any selection retrievals in progress.
+     */
+
+    for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next) {
+	tPtr->abortSelections = true;
+    }
+
+    if (parseHyphens && text != textBuf) {
+	free((char *) text);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextUndoRedoCallback --
+ *
+ *	This function is registered with the generic undo/redo code to handle
+ *	'insert' and 'delete' actions on all text widgets. We cannot perform
+ *	those actions on any particular text widget, because that text widget
+ *	might have been deleted by the time we get here.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Will change anything, depending on the undo token.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+TriggerWatchUndoRedo(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *token,
+    bool isRedo,
+    bool isFinal,
+    TkText **peers,
+    int numPeers)
+{
+    TkTextIndex index1, index2;
+    Tcl_Obj *cmdPtr;
+    char arg[100];
+    int i;
+
+    assert(sharedTextPtr->triggerWatchCmd);
+    assert(token->undoType->rangeProc);
+    assert(token->undoType->commandProc);
+
+    sharedTextPtr->triggerWatchCmd = false;
+    token->undoType->rangeProc(sharedTextPtr, token, &index1, &index2);
+    Tcl_IncrRefCount(cmdPtr = token->undoType->commandProc(sharedTextPtr, token));
+    snprintf(arg, sizeof(arg), "{%s} %s", Tcl_GetString(cmdPtr), isFinal ? "yes" : "no");
+    Tcl_DecrRefCount(cmdPtr);
+
+    for (i = 0; i < numPeers; ++i) {
+	TkText *tPtr = peers[i];
+
+	if (!(tPtr->flags & DESTROYED)) {
+	    char idx[2][TK_POS_CHARS];
+	    const char *info = isRedo ? "redo" : "undo";
+
+	    TkTextPrintIndex(tPtr, &index1, idx[0]);
+	    TkTextPrintIndex(tPtr, &index2, idx[1]);
+	    TkTextTriggerWatchCmd(tPtr, info, idx[0], idx[1], arg, false);
+	}
+    }
+
+    sharedTextPtr->triggerWatchCmd = true;
+}
+
+void
+TextUndoRedoCallback(
+    TkTextUndoStack stack,
+    const TkTextUndoAtom *atom)
+{
+    TkSharedText *sharedTextPtr = (TkSharedText *) TkTextUndoGetContext(stack);
+    TkTextUndoInfo undoInfo;
+    TkTextUndoInfo redoInfo;
+    TkTextUndoInfo *redoInfoPtr;
+    TkTextPosition *textPosition = NULL;
+    TkTextPosition textPosBuf[PIXEL_CLIENTS];
+    bool eventuallyRepick = false;
+    TkText *peerArr[20];
+    TkText **peers = peerArr;
+    TkText *tPtr;
+    int i, k, countPeers = 0;
+
+    assert(stack);
+
+    if (sharedTextPtr->triggerWatchCmd) {
+	if (sharedTextPtr->numPeers > sizeof(peerArr) / sizeof(peerArr[0])) {
+	    peers = malloc(sharedTextPtr->numPeers * sizeof(peerArr[0]));
+	}
+	for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next) {
+	    if (tPtr->watchCmd) {
+		TkTextSaveCursorIndex(tPtr);
+		peers[countPeers++] = tPtr;
+		tPtr->refCount += 1;
+	    }
+	}
+    }
+
+    memset(&undoInfo, 0, sizeof(undoInfo));
+    redoInfoPtr = TkTextUndoStackIsFull(stack) ? NULL : &redoInfo;
+
+    for (i = atom->arraySize - 1; i >= 0; --i) {
+	TkTextIndex index1, index2;
+	const TkTextUndoSubAtom *subAtom = atom->array + i;
+	TkTextUndoToken *token = subAtom->item;
+	bool isDelete = token->undoType->action == TK_TEXT_UNDO_INSERT
+		|| token->undoType->action == TK_TEXT_REDO_DELETE;
+	bool isInsert = token->undoType->action == TK_TEXT_UNDO_DELETE
+		|| token->undoType->action == TK_TEXT_REDO_INSERT;
+
+	if (!isInsert) {
+	    token->undoType->rangeProc(sharedTextPtr, token, &index1, &index2);
+	}
+
+	if (isInsert || isDelete) {
+	    const TkTextUndoTokenRange *range = (const TkTextUndoTokenRange *) token;
+
+	    if (isDelete && sharedTextPtr->triggerWatchCmd) {
+		TriggerWatchUndoRedo(sharedTextPtr, token, subAtom->redo, i == 0, peers, countPeers);
+	    }
+	    if (!textPosition) {
+		if (sharedTextPtr->numPeers > sizeof(textPosBuf)/sizeof(textPosBuf[0])) {
+		    textPosition = malloc(sizeof(textPosition[0])*sharedTextPtr->numPeers);
+		} else {
+		    textPosition = textPosBuf;
+		}
+		InitPosition(sharedTextPtr, textPosition);
+	    }
+	    if (isInsert) {
+		TkBTreeUndoIndexToIndex(sharedTextPtr, &range->startIndex, &index1);
+		TkTextChanged(sharedTextPtr, NULL, &index1, &index1);
+		FindNewTopPosition(sharedTextPtr, textPosition, &index1, NULL, subAtom->size);
+	    } else {
+		TkTextChanged(sharedTextPtr, NULL, &index1, &index2);
+		FindNewTopPosition(sharedTextPtr, textPosition, &index1, &index2, 0);
+	    }
+	    for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next) {
+		if (!tPtr->abortSelections) {
+		    if (isInsert) {
+			tPtr->abortSelections = true;
+		    } else {
+			if (range->startIndex.lineIndex < range->endIndex.lineIndex
+				&& TkBTreeTag(sharedTextPtr, NULL, &index1, &index2,
+					tPtr->selTagPtr, false, NULL, TkTextRedrawTag)) {
+			    TkTextSelectionEvent(tPtr);
+			    tPtr->abortSelections = true;
+			}
+		    }
+		}
+	    }
+	}
+
+	/*
+	 * Now perform the undo/redo action.
+	 */
+
+	if (redoInfoPtr) {
+	    memset(redoInfoPtr, 0, sizeof(redoInfo));
+	}
+	undoInfo.token = token;
+	undoInfo.byteSize = atom->size;
+	token->undoType->undoProc(sharedTextPtr, &undoInfo, redoInfoPtr, atom->redo);
+
+	if (token->undoType->action == TK_TEXT_UNDO_TAG) {
+	    eventuallyRepick = true;
+	}
+	if (isInsert) {
+	    token->undoType->rangeProc(sharedTextPtr, token, &index1, &index2);
+	}
+	if (redoInfoPtr) {
+	    if (redoInfo.token == token) {
+		/*
+		 * We are re-using a token, this is possible because the current undo token
+		 * will expire after this action.
+		 */
+		if (!subAtom->redo) {
+		    if (token->undoType->action == TK_TEXT_UNDO_INSERT
+			    || token->undoType->action == TK_TEXT_UNDO_DELETE) {
+			assert(sharedTextPtr->insertDeleteUndoTokenCount > 0);
+			sharedTextPtr->insertDeleteUndoTokenCount -= 1;
+		    }
+		}
+		if (token->undoType->destroyProc) {
+		    /* We need a balanced call of perform/destroy. */
+		    token->undoType->destroyProc(sharedTextPtr, subAtom->item, true);
+		}
+		/*
+		 * Do not free this item.
+		 */
+		((TkTextUndoSubAtom *) subAtom)->item = NULL;
+	    }
+	    TkTextPushUndoToken(sharedTextPtr, redoInfo.token, redoInfo.byteSize);
+	}
+	if (!isDelete && sharedTextPtr->triggerWatchCmd) {
+	    TriggerWatchUndoRedo(sharedTextPtr, token, subAtom->redo, i == 0, peers, countPeers);
+	}
+    }
+
+    if (eventuallyRepick) {
+	for (k = 0; k < countPeers; ++k) {
+	    TkText *tPtr = peers[k];
+
+	    if (!(tPtr->flags & DESTROYED)) {
+		TkTextEventuallyRepick(tPtr);
+	    }
+	}
+    }
+
+    sharedTextPtr->lastEditMode = TK_TEXT_EDIT_OTHER;
+    sharedTextPtr->lastUndoTokenType = -1;
+    UpdateModifiedFlag(sharedTextPtr, false);
+    TkTextUpdateAlteredFlag(sharedTextPtr);
+
+    if (textPosition) {
+	SetNewTopPosition(sharedTextPtr, NULL, textPosition, true);
+	if (textPosition != textPosBuf) {
+	    free(textPosition);
+	}
+    }
+
+    if (sharedTextPtr->triggerWatchCmd) {
+	for (i = 0; i < countPeers; ++i) {
+	    TkText *tPtr = peers[i];
+
+	    if (!(tPtr->flags & DESTROYED)) {
+		TkTextIndexClear(&tPtr->insertIndex, tPtr);
+		TkTextTriggerWatchCursor(tPtr);
+	    }
+	    if (--tPtr->refCount == 0) {
+		free(tPtr);
+	    }
+	}
+    }
+
+    /*
+     * Freeing the peer array has to be done even if sharedTextPtr->triggerWatchCmd
+     * is false, possibly the user has cleared the watch command inside the trigger
+     * callback.
+     */
+
+    if (peers != peerArr) {
+	free(peers);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextUndoStackContentChangedCallback --
+ *
+ *	This function is registered with the generic undo/redo code to handle
+ *	undo/redo stack changes.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+TextUndoStackContentChangedCallback(
+    const TkTextUndoStack stack)
+{
+    ((TkSharedText *) TkTextUndoGetContext(stack))->undoStackEvent = true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TriggerUndoStackEvent --
+ *
+ *	This function is triggering the <<UndoStack>> event for all peers.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	May force the text window (and all peers) into existence.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+TriggerUndoStackEvent(
+    TkSharedText *sharedTextPtr)
+{
+    TkText *textPtr;
+
+    assert(sharedTextPtr->undoStackEvent);
+    sharedTextPtr->undoStackEvent = false;
+
+    for (textPtr = sharedTextPtr->peers; textPtr; textPtr = textPtr->next) {
+	if (!(textPtr->flags & DESTROYED)) {
+	    Tk_MakeWindowExist(textPtr->tkwin);
+	    SendVirtualEvent(textPtr->tkwin, "UndoStack", NULL);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextUndoFreeCallback --
+ *
+ *	This function is registered with the generic undo/redo code to handle
+ *	the freeing operation of undo/redo items.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Some memory will be freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+TextUndoFreeCallback(
+    const TkTextUndoStack stack,
+    const TkTextUndoSubAtom *subAtom)	/* Destroy this token. */
+{
+    TkTextUndoToken *token = (TkTextUndoToken *) subAtom->item;
+
+    /*
+     * Consider that the token is possibly null.
+     */
+
+    if (token) {
+	TkTextUndoAction action = token->undoType->action;
+
+	if (action == TK_TEXT_UNDO_INSERT || action == TK_TEXT_UNDO_DELETE) {
+	    TkSharedText *sharedTextPtr = (TkSharedText *) TkTextUndoGetContext(stack);
+	    assert(sharedTextPtr->insertDeleteUndoTokenCount > 0);
+	    sharedTextPtr->insertDeleteUndoTokenCount -= 1;
+	}
+	if (token->undoType->destroyProc) {
+	    token->undoType->destroyProc(TkTextUndoGetContext(stack), subAtom->item, false);
+	}
+	free(subAtom->item);
+	DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * CountIndices --
+ *
+ *	This function implements most of the functionality of the "count"
+ *	widget command.
+ *
+ *	Note that 'textPtr' is only used if we need to check for elided
+ *	attributes, i.e. if type is COUNT_DISPLAY_INDICES or
+ *	COUNT_DISPLAY_CHARS
+ *
+ * Results:
+ *	Returns the number of characters in the range.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+CountIndices(
+    const TkText *textPtr,	/* Overall information about text widget. */
+    const TkTextIndex *indexPtr1,
+				/* Index describing location of first character to delete. */
+    const TkTextIndex *indexPtr2,
+				/* Index describing location of last character to delete. NULL means
+				 * just delete the one character given by indexPtr1. */
+    TkTextCountType type)	/* The kind of indices to count. */
+{
+    /*
+     * Order the starting and stopping indices.
+     */
+
+    int compare = TkTextIndexCompare(indexPtr1, indexPtr2);
+
+    if (compare == 0) {
+	return 0;
+    }
+    if (compare > 0) {
+	return -TkTextIndexCount(textPtr, indexPtr2, indexPtr1, type);
+    }
+    return TkTextIndexCount(textPtr, indexPtr1, indexPtr2, type);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DeleteIndexRange --
+ *
+ *	This function implements most of the functionality of the "delete"
+ *	widget command.
+ *
+ * Results:
+ *	Returns whether the widget hasn't been destroyed.
+ *
+ * Side effects:
+ *	Characters and other entities (windows, images) get deleted from the
+ *	text.
+ *
+ *	If 'viewUpdate' is true, we may adjust the window contents'
+ *	y-position, and scrollbar setting.
+ *
+ *	If 'viewUpdate' is true, true we can guarantee that textPtr->topIndex
+ *	points to a valid TkTextLine after this function returns. However, if
+ *	'viewUpdate' is false, then there is no such guarantee (since
+ *	topIndex.linePtr can be garbage). The caller is expected to take
+ *	actions to ensure the topIndex is validated before laying out the
+ *	window again.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+DetectUndoTag(
+    const TkTextTag *tagPtr)
+{
+    for ( ; tagPtr; tagPtr = tagPtr->nextPtr) {
+	if (!TkBitTest(tagPtr->sharedTextPtr->dontUndoTags, tagPtr->index)) {
+	    return true;
+	}
+    }
+    return false;
+}
+
+static bool
+HaveMarksInRange(
+    const TkTextIndex *indexPtr1,
+    const TkTextIndex *indexPtr2,
+    int flags)
+{
+    const TkTextSegment *segPtr1;
+    const TkTextSegment *segPtr2;
+
+    assert(TkTextIndexIsEqual(indexPtr1, indexPtr2));
+
+    segPtr2 = TkTextIndexGetSegment(indexPtr2);
+    if (!segPtr2) {
+	return false;
+    }
+    if (flags & DELETE_INCLUSIVE) {
+	segPtr2 = segPtr2->nextPtr;
+	assert(segPtr2);
+    }
+
+    segPtr1 = TkTextIndexGetSegment(indexPtr1);
+    if (!segPtr1 || !TkTextIsStableMark(segPtr1)) {
+	segPtr1 = TkTextIndexGetFirstSegment(indexPtr1, NULL);
+    } else if (!(flags & DELETE_INCLUSIVE)) {
+	segPtr1 = segPtr1->nextPtr;
+	assert(segPtr1);
+    }
+
+    for ( ; segPtr1 && segPtr1->size == 0; segPtr1 = segPtr1->nextPtr) {
+	if (TkTextIsNormalMark(segPtr1)) {
+	    return true;
+	}
+	if (segPtr1 == segPtr2) {
+	    return false;
+	}
+    }
+    return false;
+}
+
+static bool
+DeleteMarksOnLastLine(
+    TkText *textPtr,
+    TkTextSegment *segPtr,
+    TkTextSegment *endPtr,
+    int flags)
+{
+    bool rc;
+
+    assert(endPtr);
+
+    if (flags & DELETE_INCLUSIVE) {
+	endPtr = endPtr->nextPtr;
+	assert(endPtr);
+    }
+
+    if (!segPtr) {
+	segPtr = endPtr->sectionPtr->linePtr->segPtr;
+    } else if (!(flags & DELETE_INCLUSIVE)) {
+	segPtr = segPtr->nextPtr;
+    }
+
+    rc = false;
+    while (segPtr != endPtr) {
+	TkTextSegment *nextPtr = segPtr->nextPtr;
+
+	if (TkTextIsNormalMark(segPtr)) {
+	    TkTextUnsetMark(textPtr, segPtr);
+	    rc = true;
+	}
+
+	segPtr = nextPtr;
+    }
+
+    return rc;
+}
+
+static bool
+DeleteIndexRange(
+    TkSharedText *sharedTextPtr,/* Shared portion of peer widgets. */
+    TkText *textPtr,		/* Overall information about text widget. */
+    const TkTextIndex *indexPtr1,
+				/* Index describing location of first character (or other entity)
+				 * to delete. */
+    const TkTextIndex *indexPtr2,
+				/* Index describing location of last character (or other entity)
+				 * to delete. NULL means just delete the one character given by
+				 * indexPtr1. */
+    int flags,			/* Flags controlling the deletion. */
+    bool viewUpdate,		/* Update vertical view if set. */
+    bool triggerWatchDelete,	/* Should we trigger the watch command for deletion? */
+    bool triggerWatchInsert,	/* Should we trigger the watch command for insertion? */
+    bool userFlag,		/* Trigger user modification? */
+    bool final)			/* This is the final call in a sequence of ranges. */
+{
+    TkTextIndex index1, index2, index3;
+    TkTextPosition *textPosition;
+    TkTextPosition textPosBuf[PIXEL_CLIENTS];
+    TkTextUndoInfo undoInfo;
+    TkTextUndoInfo *undoInfoPtr;
+    bool deleteOnLastLine;
+    bool altered;
+    int cmp;
+
+    if (!sharedTextPtr) {
+	sharedTextPtr = textPtr->sharedTextPtr;
+    }
+
+    if (triggerWatchInsert) {
+	TkTextIndexToByteIndex((TkTextIndex *) indexPtr1); /* mutable due to concept */
+    }
+
+    /*
+     * Prepare the starting and stopping indices.
+     */
+
+    index1 = *indexPtr1;
+
+    if (indexPtr2) {
+	if ((cmp = TkTextIndexCompare(&index1, indexPtr2)) > 0) {
+	    return true; /* there is nothing to delete */
+	}
+	index2 = *indexPtr2;
+    } else if (!TkTextIndexForwChars(textPtr, &index1, 1, &index2, COUNT_INDICES)) {
+	cmp = 0;
+    } else {
+	cmp = -1;
+    }
+
+    if (cmp == 0) {
+	bool isTagged;
+
+	deleteOnLastLine = (flags & DELETE_MARKS) && HaveMarksInRange(&index1, &index2, flags);
+	isTagged = TkTextIndexBackChars(textPtr, &index2, 1, &index3, COUNT_INDICES)
+		&& TkBTreeCharTagged(&index3, NULL);
+
+	if (!deleteOnLastLine && !isTagged) {
+	    return true; /* there is nothing to delete */
+	}
+    } else if (TkTextIndexIsEndOfText(&index1)) {
+	if (!TkTextIndexBackChars(textPtr, &index2, 1, &index3, COUNT_INDICES)
+		|| TkTextIndexIsStartOfText(&index3)
+		|| !TkBTreeCharTagged(&index3, NULL)) {
+	    return true; /* there is nothing to delete */
+	}
+	deleteOnLastLine = (flags & DELETE_MARKS) && HaveMarksInRange(&index1, &index2, flags);
+    } else {
+	deleteOnLastLine = false;
+    }
+
+    /*
+     * Call the "watch" command for deletion. Take into account that the
+     * receiver might change the text content inside the callback, although
+     * he shouldn't do this.
+     */
+
+    if (triggerWatchDelete) {
+	Tcl_Obj *delObj = TextGetText(textPtr, &index1, &index2, NULL, NULL, UINT_MAX, false, true);
+	char const *deleted = Tcl_GetString(delObj);
+	bool unchanged;
+	bool rc;
+
+	TkTextIndexSave(&index1);
+	TkTextIndexSave(&index2);
+	Tcl_IncrRefCount(delObj);
+	rc = TriggerWatchEdit(textPtr, "delete", &index1, &index2, deleted, final);
+	Tcl_DecrRefCount(delObj);
+	unchanged = TkTextIndexRebuild(&index1) && TkTextIndexRebuild(&index2);
+
+	if (!rc) { return false; } /* the receiver has destroyed this widget */
+
+	if (!unchanged && TkTextIndexCompare(&index1, &index2) >= 0) {
+	    /* This can only happen if the receiver of the trigger command did any modification. */
+	    return true;
+	}
+    }
+
+    if (cmp < 0) {
+	TkTextClearSelection(sharedTextPtr, &index1, &index2);
+    }
+
+    altered = (cmp < 0);
+
+    if (deleteOnLastLine) {
+	/*
+	 * Some marks on last line have to be deleted. We are doing this separately,
+	 * because we won't delete the last line.
+	 *
+	 * The alternative is to insert a newly last newline instead, so we can remove
+	 * the last line, but this is more complicated than doing this separate removal
+	 * (consider undo, or the problem with end markers).
+	 */
+
+	if (DeleteMarksOnLastLine(textPtr, TkTextIndexGetSegment(&index1),
+		TkTextIndexGetSegment(&index2), flags)) {
+	    altered = true;
+	}
+    }
+
+    if (TkTextIndexIsEndOfText(&index2)) {
+	TkTextIndexGetByteIndex(&index2);
+	index3 = index2;
+
+	TkTextIndexBackChars(textPtr, &index2, 1, &index3, COUNT_INDICES);
+
+	if (!textPtr->endMarker->sectionPtr->linePtr->nextPtr) {
+	    /*
+	     * We're about to delete the very last (empty) newline, and this must not
+	     * happen. Instead of deleting the newline we will remove all tags from
+	     * this newline character (as if we delete this newline, and afterwards
+	     * a fresh newline will be appended).
+	     */
+
+	    if (DetectUndoTag(TkTextClearTags(sharedTextPtr, textPtr, &index3, &index2, false))) {
+		altered = true;
+	    }
+	    assert(altered);
+	}
+    } else {
+	index3 = index2;
+    }
+
+    if (cmp < 0 && !TkTextIndexIsEqual(&index1, &index3)) {
+	/*
+	 * Tell the display what's about to happen, so it can discard obsolete
+	 * display information, then do the deletion. Also, if the deletion
+	 * involves the top line on the screen, then we have to reset the view
+	 * (the deletion will invalidate textPtr->topIndex). Compute what the new
+	 * first character will be, then do the deletion, then reset the view.
+	 */
+
+	TkTextChanged(sharedTextPtr, NULL, &index1, &index3);
+
+	if (sharedTextPtr->numPeers > sizeof(textPosBuf)/sizeof(textPosBuf[0])) {
+	    textPosition = malloc(sizeof(textPosition[0])*sharedTextPtr->numPeers);
+	} else {
+	    textPosition = textPosBuf;
+	}
+	InitPosition(sharedTextPtr, textPosition);
+	FindNewTopPosition(sharedTextPtr, textPosition, &index1, &index2, 0);
+
+	undoInfoPtr = TkTextUndoStackIsFull(sharedTextPtr->undoStack) ? NULL : &undoInfo;
+	TkBTreeDeleteIndexRange(sharedTextPtr, &index1, &index3, flags, undoInfoPtr);
+
+	/*
+	 * Push the deletion onto the undo stack, and update the modified status of the widget.
+	 * Try to join with previously pushed undo token, if possible.
+	 */
+
+	if (undoInfoPtr) {
+	    const TkTextUndoSubAtom *subAtom;
+
+	    if (sharedTextPtr->autoSeparators && sharedTextPtr->lastEditMode != TK_TEXT_EDIT_DELETE) {
+		PushRetainedUndoTokens(sharedTextPtr);
+		TkTextUndoPushSeparator(sharedTextPtr->undoStack, true);
+		sharedTextPtr->lastUndoTokenType = -1;
+	    }
+
+	    if (TkTextUndoGetMaxSize(sharedTextPtr->undoStack) == 0
+		    || TkTextUndoGetCurrentSize(sharedTextPtr->undoStack) + undoInfo.byteSize
+			    <= TkTextUndoGetMaxSize(sharedTextPtr->undoStack)) {
+		if (sharedTextPtr->lastUndoTokenType != TK_TEXT_UNDO_DELETE
+			|| !((subAtom = TkTextUndoGetLastUndoSubAtom(sharedTextPtr->undoStack))
+				&& TkBTreeJoinUndoDelete(subAtom->item, subAtom->size,
+					undoInfo.token, undoInfo.byteSize))) {
+		    TkTextPushUndoToken(sharedTextPtr, undoInfo.token, undoInfo.byteSize);
+		}
+		sharedTextPtr->lastUndoTokenType = TK_TEXT_UNDO_DELETE;
+		sharedTextPtr->prevUndoStartIndex =
+			((TkTextUndoTokenRange *) undoInfo.token)->startIndex;
+		sharedTextPtr->prevUndoEndIndex = ((TkTextUndoTokenRange *) undoInfo.token)->endIndex;
+		/* stack has changed anyway, but TkBTreeJoinUndoDelete didn't trigger */
+		sharedTextPtr->undoStackEvent = true;
+	    } else {
+		assert(undoInfo.token->undoType->destroyProc);
+		undoInfo.token->undoType->destroyProc(sharedTextPtr, undoInfo.token, false);
+		free(undoInfo.token);
+		DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	    }
+
+	    sharedTextPtr->lastEditMode = TK_TEXT_EDIT_DELETE;
+	}
+
+	UpdateModifiedFlag(sharedTextPtr, true);
+
+	SetNewTopPosition(sharedTextPtr, textPtr, textPosition, viewUpdate);
+	if (textPosition != textPosBuf) {
+	    free(textPosition);
+	}
+    }
+
+    if (altered) {
+	TkTextUpdateAlteredFlag(sharedTextPtr);
+    }
+
+    /*
+     * Lastly, trigger the "watch" command for insertion. This must be the last action,
+     * probably the receiver is calling some widget commands inside the callback.
+     */
+
+    if (triggerWatchInsert) {
+	if (!TriggerWatchEdit(textPtr, "insert", indexPtr1, indexPtr1, NULL, final)) {
+	    return false; /* widget has been destroyed */
+	}
+    }
+
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextFetchSelection --
+ *
+ *	This function is called back by Tk when the selection is requested by
+ *	someone. It returns part or all of the selection in a buffer provided
+ *	by the caller.
+ *
+ * Results:
+ *	The return value is the number of non-NULL bytes stored at buffer.
+ *	Buffer is filled (or partially filled) with a NULL-terminated string
+ *	containing part or all of the selection, as given by offset and
+ *	maxBytes.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+TextFetchSelection(
+    ClientData clientData,	/* Information about text widget. */
+    int offset,			/* Offset within selection of first character to be returned. */
+    char *buffer,		/* Location in which to place selection. */
+    int maxBytes)		/* Maximum number of bytes to place at buffer, not including
+    				 * terminating NULL character. */
+{
+    TkText *textPtr = clientData;
+    TkTextSearch *searchPtr;
+    Tcl_Obj *selTextPtr;
+    int numBytes;
+
+    if (!textPtr->exportSelection) {
+	return -1;
+    }
+
+    /*
+     * Find the beginning of the next range of selected text. Note: if the
+     * selection is being retrieved in multiple pieces (offset != 0) and some
+     * modification has been made to the text that affects the selection then
+     * reject the selection request (make 'em start over again).
+     */
+
+    if (offset == 0) {
+	TkTextIndexSetupToStartOfText(&textPtr->selIndex, textPtr, textPtr->sharedTextPtr->tree);
+	textPtr->abortSelections = false;
+    } else if (textPtr->abortSelections) {
+	return 0;
+    }
+
+    searchPtr = &textPtr->selSearch;
+
+    if (offset == 0 || !TkBTreeCharTagged(&textPtr->selIndex, textPtr->selTagPtr)) {
+	TkTextIndex eof;
+
+	TkTextIndexSetupToEndOfText(&eof, textPtr, textPtr->sharedTextPtr->tree);
+	TkBTreeStartSearch(&textPtr->selIndex, &eof, textPtr->selTagPtr, searchPtr, SEARCH_NEXT_TAGON);
+	if (!TkBTreeNextTag(searchPtr)) {
+	    return offset == 0 ? -1 : 0;
+	}
+	textPtr->selIndex = searchPtr->curIndex;
+
+	/*
+	 * Find the end of the current range of selected text.
+	 */
+
+	if (!TkBTreeNextTag(searchPtr)) {
+	    assert(!"TextFetchSelection couldn't find end of range");
+	}
+    } else {
+	/* we are still inside tagged range */
+    }
+
+    /*
+     * Iterate through the the selected ranges and collect the text content.
+     *
+     * NOTE:
+     * The crux with TextFetchSelection is the old interface of this callback function,
+     * it does not fit with the object design (Tcl_Obj), otherwise it would expect an
+     * object as the result. Thus the actual "natural" implementation is a bit
+     * ineffecient, because we are collecting the data with an object (we are using the
+     * "get" mechanism), and afterwards the content of this object will be copied into
+     * the buffer, and the object will be destroyed. Hopefully some day function
+     * TextFetchSelection will be changed to new object design.
+     */
+
+    Tcl_IncrRefCount(selTextPtr = Tcl_NewObj());
+
+    while (true) {
+	TextGetText(textPtr, &textPtr->selIndex, &searchPtr->curIndex, &textPtr->selIndex,
+		selTextPtr, maxBytes - GetByteLength(selTextPtr), true, false);
+
+	if (GetByteLength(selTextPtr) == maxBytes) {
+	    break;
+	}
+
+	/*
+	 * Find the beginning of the next range of selected text.
+	 */
+
+	if (!TkBTreeNextTag(searchPtr)) {
+	    break;
+	}
+
+	textPtr->selIndex = searchPtr->curIndex;
+
+	/*
+	 * Find the end of the current range of selected text.
+	 */
+
+	if (!TkBTreeNextTag(searchPtr)) {
+	    assert(!"TextFetchSelection couldn't find end of range");
+	}
+    }
+
+    numBytes = GetByteLength(selTextPtr);
+    memcpy(buffer, Tcl_GetString(selTextPtr), numBytes);
+    Tcl_DecrRefCount(selTextPtr);
+    return numBytes;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextSelectionEvent --
+ *
+ *	When anything relevant to the "sel" tag has been changed, call this
+ *	function to generate a <<Selection>> event.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If <<Selection>> bindings are present, they will trigger.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextSelectionEvent(
+    TkText *textPtr)
+{
+    /*
+     * Send an event that the selection changed. This is equivalent to:
+     *     event generate $textWidget <<Selection>>
+     */
+
+    SendVirtualEvent(textPtr->tkwin, "Selection", NULL);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextLostSelection --
+ *
+ *	This function is called back by Tk when the selection is grabbed away
+ *	from a text widget. On Windows and Mac systems, we want to remember
+ *	the selection for the next time the focus enters the window. On Unix,
+ *	just remove the "sel" tag from everything in the widget.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The "sel" tag is cleared from the window.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextLostSelection(
+    ClientData clientData)	/* Information about text widget. */
+{
+    TkText *textPtr = clientData;
+
+    if (TkpAlwaysShowSelection(textPtr->tkwin)) {
+	TkTextIndex start, end;
+
+	if (!textPtr->exportSelection) {
+	    return;
+	}
+
+	/*
+	 * On Windows and Mac systems, we want to remember the selection for
+	 * the next time the focus enters the window. On Unix, just remove the
+	 * "sel" tag from everything in the widget.
+	 */
+
+	TkTextIndexSetupToStartOfText(&start, textPtr, textPtr->sharedTextPtr->tree);
+	TkTextIndexSetupToEndOfText(&end, textPtr, textPtr->sharedTextPtr->tree);
+	TkBTreeTag(textPtr->sharedTextPtr, textPtr, &start, &end, textPtr->selTagPtr,
+		false, NULL, TkTextRedrawTag);
+    }
+
+    /*
+     * Send an event that the selection changed. This is equivalent to:
+     *	   event generate $textWidget <<Selection>>
+     */
+
+    TkTextSelectionEvent(textPtr);
+
+    textPtr->flags &= ~GOT_SELECTION;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextBlinkProc --
+ *
+ *	This function is called as a timer handler to blink the insertion
+ *	cursor off and on.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The cursor gets turned on or off, redisplay gets invoked, and this
+ *	function reschedules itself.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+TextBlinkProc(
+    ClientData clientData)	/* Pointer to record describing text. */
+{
+    TkText *textPtr = clientData;
+    int oldFlags = textPtr->flags;
+
+    if (textPtr->state == TK_TEXT_STATE_DISABLED
+	    || !(textPtr->flags & HAVE_FOCUS)
+	    || textPtr->insertOffTime == 0) {
+	if (!(textPtr->flags & HAVE_FOCUS) && textPtr->insertUnfocussed != TK_TEXT_INSERT_NOFOCUS_NONE) {
+	    /*
+	     * The widget doesn't have the focus yet it is configured to
+	     * display the cursor when it doesn't have the focus. Act now!
+	     */
+
+	    textPtr->flags |= INSERT_ON;
+	} else if (textPtr->insertOffTime == 0) {
+	    /*
+	     * The widget was configured to have zero offtime while the
+	     * insertion point was not displayed. We have to display it once.
+	     */
+
+	    textPtr->flags |= INSERT_ON;
+	}
+    } else {
+	if (textPtr->flags & INSERT_ON) {
+	    textPtr->flags &= ~INSERT_ON;
+	    textPtr->insertBlinkHandler = Tcl_CreateTimerHandler(
+		    textPtr->insertOffTime, TextBlinkProc, textPtr);
+	} else {
+	    textPtr->flags |= INSERT_ON;
+	    textPtr->insertBlinkHandler = Tcl_CreateTimerHandler(
+		    textPtr->insertOnTime, TextBlinkProc, textPtr);
+	}
+    }
+
+    if (oldFlags != textPtr->flags) {
+	TkTextIndex index;
+	int x, y, w, h, charWidth;
+
+	TkTextMarkSegToIndex(textPtr, textPtr->insertMarkPtr, &index);
+
+	if (TkTextIndexBbox(textPtr, &index, &x, &y, &w, &h, &charWidth) == 0) {
+	    if (textPtr->blockCursorType) { /* Block cursor */
+		x -= textPtr->width/2;
+		w = charWidth + textPtr->insertWidth/2;
+	    } else { /* I-beam cursor */
+		x -= textPtr->insertWidth/2;
+		w = textPtr->insertWidth;
+	    }
+	    TkTextRedrawRegion(textPtr, x, y, w, h);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextInsertCmd --
+ *
+ *	This function is invoked to process the "insert" and "replace" widget
+ *	commands for text widgets.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *	If 'viewUpdate' is true, we may adjust the window contents'
+ *	y-position, and scrollbar setting.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+TextInsertCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[],	/* Argument objects. */
+    const TkTextIndex *indexPtr,/* Index at which to insert. */
+    bool viewUpdate,		/* Update the view if set. */
+    bool triggerWatchDelete,	/* Should we trigger the watch command for deletion? */
+    bool triggerWatchInsert,	/* Should we trigger the watch command for insertion? */
+    bool userFlag,		/* Trigger user modification? */
+    bool *destroyed,		/* Store whether the widget has been destroyed. */
+    bool parseHyphens)		/* Should we parse hyphens? (tk_textInsert) */
+{
+    TkTextIndex index1, index2;
+    TkSharedText *sharedTextPtr;
+    TkTextTag *hyphenTagPtr = NULL;
+    int rc = TCL_OK;
+    int j;
+
+    assert(textPtr);
+    assert(destroyed);
+    assert(!TkTextIsDeadPeer(textPtr));
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+    *destroyed = false;
+
+    if (parseHyphens && objc > 1 && *Tcl_GetString(objv[0]) == '-') {
+	int argc;
+	Tcl_Obj **argv;
+
+	if (strcmp(Tcl_GetString(objv[0]), "-hyphentags") != 0) {
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		    "bad option \"%s\": must be -hyphentags", Tcl_GetString(objv[0])));
+	    Tcl_SetErrorCode(interp, "TK", "TEXT", "INDEX_OPTION", NULL);
+	    return TCL_ERROR;
+	}
+	if (Tcl_ListObjGetElements(interp, objv[1], &argc, &argv) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	for (j = 0; j < argc; ++j) {
+	    TkTextTag *tagPtr = TkTextCreateTag(textPtr, Tcl_GetString(argv[j]), NULL);
+	    tagPtr->nextPtr = hyphenTagPtr;
+	    hyphenTagPtr = tagPtr;
+	}
+	objc -= 2;
+	objv += 2;
+    }
+
+    for (j = 0; j < objc && GetByteLength(objv[j]) == 0; j += 2) {
+	/* empty loop body */
+    }
+    index1 = *indexPtr;
+
+    while (j < objc) {
+	Tcl_Obj *stringPtr = objv[j];
+	Tcl_Obj *tagPtr = (j + 1 < objc) ? objv[j + 1] : NULL;
+	char const *string = Tcl_GetString(stringPtr);
+	unsigned length = GetByteLength(stringPtr);
+	int k = j + 2;
+	bool final;
+
+	while (k < objc && GetByteLength(objv[k]) == 0) {
+	    k += 2;
+	}
+	final = objc <= k;
+
+	if (length > 0) {
+	    int numTags = 0;
+	    Tcl_Obj **tagNamePtrs = NULL;
+	    TkTextTagSet *tagInfoPtr = NULL;
+
+	    /*
+	     * Call the "watch" command for deletion. Take into account that the
+	     * receiver might change the text content, although he shouldn't do this.
+	     */
+
+	    if (triggerWatchDelete) {
+		TkTextIndexSave(&index1);
+		if (!TriggerWatchEdit(textPtr, "delete", &index1, &index1, NULL, final)) {
+		    *destroyed = true;
+		    return rc;
+		}
+		TkTextIndexRebuild(&index1);
+	    }
+
+	    if (tagPtr) {
+		unsigned i;
+
+		if (Tcl_ListObjGetElements(interp, tagPtr, &numTags, &tagNamePtrs) != TCL_OK) {
+		    rc = TCL_ERROR;
+		} else if (numTags > 0) {
+		    TkTextTag *tagPtr;
+
+		    tagInfoPtr = TkTextTagSetResize(NULL, sharedTextPtr->tagInfoSize);
+
+		    for (i = 0; i < numTags; ++i) {
+			tagPtr = TkTextCreateTag(textPtr, Tcl_GetString(tagNamePtrs[i]), NULL);
+#if !TK_TEXT_DONT_USE_BITFIELDS
+			if (tagPtr->index >= TkTextTagSetSize(tagInfoPtr)) {
+			    tagInfoPtr = TkTextTagSetResize(NULL, sharedTextPtr->tagInfoSize);
+			}
+#endif
+			tagInfoPtr = TkTextTagSetAdd(tagInfoPtr, tagPtr->index);
+		    }
+		}
+	    }
+
+	    InsertChars(textPtr, &index1, &index2, string, length,
+		    viewUpdate, tagInfoPtr, hyphenTagPtr, parseHyphens);
+	    if (tagInfoPtr) {
+		TkTextTagSetDecrRefCount(tagInfoPtr);
+	    }
+
+	    /*
+	     * Lastly, trigger the "watch" command for insertion. This must be the last action,
+	     * probably the receiver is calling some widget commands inside the callback.
+	     */
+
+	    if (triggerWatchInsert) {
+		if (!TriggerWatchEdit(textPtr, "insert", &index1, &index2, string, final)) {
+		    *destroyed = true;
+		    return rc;
+		}
+	    }
+
+	    if (rc != TCL_OK) {
+		return rc;
+	    }
+	    index1 = index2;
+	}
+
+	j = k;
+    }
+
+    return rc;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextSearchCmd --
+ *
+ *	This function is invoked to process the "search" widget command for
+ *	text widgets. See the user documentation for details on what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+TextSearchCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    int i, argsLeft, code;
+    SearchSpec searchSpec;
+
+    static const char *const switchStrings[] = {
+	"-hidden",
+	"--", "-all", "-backwards", "-count", "-discardhyphens", "-elide",
+	"-exact", "-forwards", "-nocase", "-nolinestop", "-overlap", "-regexp",
+	"-strictlimits", NULL
+    };
+    enum SearchSwitches {
+	SEARCH_HIDDEN,
+	SEARCH_END, SEARCH_ALL, SEARCH_BACK, SEARCH_COUNT, SEARCH_DISCARDHYPHENS, SEARCH_ELIDE,
+	SEARCH_EXACT, SEARCH_FWD, SEARCH_NOCASE, SEARCH_NOLINESTOP, SEARCH_OVERLAP, SEARCH_REGEXP,
+	SEARCH_STRICTLIMITS
+    };
+
+    /*
+     * Set up the search specification, including the last 4 fields which are
+     * text widget specific.
+     */
+
+    searchSpec.textPtr = textPtr;
+    searchSpec.exact = true;
+    searchSpec.noCase = false;
+    searchSpec.all = false;
+    searchSpec.backwards = false;
+    searchSpec.varPtr = NULL;
+    searchSpec.countPtr = NULL;
+    searchSpec.resPtr = NULL;
+    searchSpec.searchElide = false;
+    searchSpec.searchHyphens = true;
+    searchSpec.noLineStop = false;
+    searchSpec.overlap = false;
+    searchSpec.strictLimits = false;
+    searchSpec.numLines = TkBTreeNumLines(textPtr->sharedTextPtr->tree, textPtr);
+    searchSpec.clientData = textPtr;
+    searchSpec.addLineProc = &TextSearchAddNextLine;
+    searchSpec.foundMatchProc = &TextSearchFoundMatch;
+    searchSpec.lineIndexProc = &TextSearchGetLineIndex;
+
+    /*
+     * Parse switches and other arguments.
+     */
+
+    for (i = 2; i < objc; ++i) {
+	int index;
+
+	if (Tcl_GetString(objv[i])[0] != '-') {
+	    break;
+	}
+
+	if (Tcl_GetIndexFromObjStruct(NULL, objv[i], switchStrings,
+		sizeof(char *), "switch", 0, &index) != TCL_OK) {
+	    /*
+	     * Hide the -hidden option, generating the error description with
+	     * the side effects of T_GIFO.
+	     */
+
+	    (void) Tcl_GetIndexFromObjStruct(interp, objv[i], switchStrings + 1,
+		    sizeof(char *), "switch", 0, &index);
+	    return TCL_ERROR;
+	}
+
+	switch ((enum SearchSwitches) index) {
+	case SEARCH_END:
+	    i += 1;
+	    goto endOfSwitchProcessing;
+	case SEARCH_ALL:
+	    searchSpec.all = true;
+	    break;
+	case SEARCH_BACK:
+	    searchSpec.backwards = true;
+	    break;
+	case SEARCH_COUNT:
+	    if (i >= objc - 1) {
+		Tcl_SetObjResult(interp, Tcl_NewStringObj("no value given for \"-count\" option", -1));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "VALUE", NULL);
+		return TCL_ERROR;
+	    }
+	    i += 1;
+
+	    /*
+	     * Assumption objv[i] isn't going to disappear on us during this
+	     * function, which is fair.
+	     */
+
+	    searchSpec.varPtr = objv[i];
+	    break;
+	case SEARCH_DISCARDHYPHENS:
+	    searchSpec.searchHyphens = false;
+	    break;
+	case SEARCH_ELIDE:
+	case SEARCH_HIDDEN:
+	    searchSpec.searchElide = true;
+	    break;
+	case SEARCH_EXACT:
+	    searchSpec.exact = true;
+	    break;
+	case SEARCH_FWD:
+	    searchSpec.backwards = false;
+	    break;
+	case SEARCH_NOCASE:
+	    searchSpec.noCase = true;
+	    break;
+	case SEARCH_NOLINESTOP:
+	    searchSpec.noLineStop = true;
+	    break;
+	case SEARCH_OVERLAP:
+	    searchSpec.overlap = true;
+	    break;
+	case SEARCH_STRICTLIMITS:
+	    searchSpec.strictLimits = true;
+	    break;
+	case SEARCH_REGEXP:
+	    searchSpec.exact = false;
+	    break;
+	default:
+	    assert(!"unexpected switch fallthrough");
+	}
+    }
+  endOfSwitchProcessing:
+
+    argsLeft = objc - (i + 2);
+    if (argsLeft != 0 && argsLeft != 1) {
+	Tcl_WrongNumArgs(interp, 2, objv, "?switches? pattern index ?stopIndex?");
+	return TCL_ERROR;
+    }
+
+    if (searchSpec.noLineStop && searchSpec.exact) {
+	Tcl_SetObjResult(interp, Tcl_NewStringObj(
+		"the \"-nolinestop\" option requires the \"-regexp\" option to be present", -1));
+	Tcl_SetErrorCode(interp, "TK", "TEXT", "SEARCH_USAGE", NULL);
+	return TCL_ERROR;
+    }
+
+    if (searchSpec.overlap && !searchSpec.all) {
+	Tcl_SetObjResult(interp, Tcl_NewStringObj(
+		"the \"-overlap\" option requires the \"-all\" option to be present", -1));
+	Tcl_SetErrorCode(interp, "TK", "TEXT", "SEARCH_USAGE", NULL);
+	return TCL_ERROR;
+    }
+
+    /*
+     * Scan through all of the lines of the text circularly, starting at the
+     * given index. 'objv[i]' is the pattern which may be an exact string or a
+     * regexp pattern depending on the flags set above.
+     */
+
+    code = SearchPerform(interp, &searchSpec, objv[i], objv[i + 1], argsLeft == 1 ? objv[i + 2] : NULL);
+    if (code != TCL_OK) {
+	goto cleanup;
+    }
+
+    /*
+     * Set the '-count' variable, if given.
+     */
+
+    if (searchSpec.varPtr && searchSpec.countPtr) {
+	Tcl_IncrRefCount(searchSpec.countPtr);
+	if (!Tcl_ObjSetVar2(interp, searchSpec.varPtr, NULL, searchSpec.countPtr, TCL_LEAVE_ERR_MSG)) {
+	    code = TCL_ERROR;
+	    goto cleanup;
+	}
+    }
+
+    /*
+     * Set the result.
+     */
+
+    if (searchSpec.resPtr) {
+	Tcl_SetObjResult(interp, searchSpec.resPtr);
+	searchSpec.resPtr = NULL;
+    }
+
+  cleanup:
+    if (searchSpec.countPtr) {
+	Tcl_DecrRefCount(searchSpec.countPtr);
+    }
+    if (searchSpec.resPtr) {
+	Tcl_DecrRefCount(searchSpec.resPtr);
+    }
+    return code;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextSearchGetLineIndex --
+ *
+ *	Extract a row, text offset index position from an objPtr.
+ *
+ *	This means we ignore any embedded windows/images and elidden text
+ *	(unless we are searching that).
+ *
+ * Results:
+ *	Standard Tcl error code (with a message in the interpreter on error
+ *	conditions).
+ *
+ *	The offset placed in offsetPosPtr is a utf-8 char* byte index for
+ *	exact searches, and a Unicode character index for regexp searches.
+ *
+ *	The line number should start at zero (searches which wrap around
+ *	assume the first line is numbered 0).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+TextSearchGetLineIndex(
+    Tcl_Interp *interp,		/* For error messages. */
+    Tcl_Obj *objPtr,		/* Contains a textual index like "1.2" */
+    SearchSpec *searchSpecPtr,	/* Contains other search parameters. */
+    int *linePosPtr,		/* For returning the line number. */
+    int *offsetPosPtr)		/* For returning the text offset in the line. */
+{
+    TkTextIndex index;
+    int line, byteIndex;
+    TkText *textPtr = searchSpecPtr->clientData;
+    TkTextLine *linePtr;
+
+    if (!TkTextGetIndexFromObj(interp, textPtr, objPtr, &index)) {
+	return TCL_ERROR;
+    }
+
+    assert(textPtr);
+    line = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, TkTextIndexGetLine(&index), NULL);
+    if (line >= searchSpecPtr->numLines) {
+	line = searchSpecPtr->numLines - 1;
+	linePtr = TkBTreeFindLine(textPtr->sharedTextPtr->tree, textPtr, line);
+	assert(linePtr); /* this may only fail with dead peers */
+	if (textPtr->endMarker == textPtr->sharedTextPtr->endMarker
+		|| textPtr->endMarker->sectionPtr->linePtr != TkTextIndexGetLine(&index)) {
+	    byteIndex = linePtr->size;
+	} else {
+	    byteIndex = TkTextSegToIndex(textPtr->endMarker);
+	}
+    } else {
+	linePtr = TkTextIndexGetLine(&index);
+	byteIndex = TkTextIndexGetByteIndex(&index);
+    }
+
+    *offsetPosPtr = TextSearchIndexInLine(searchSpecPtr, linePtr, byteIndex);
+    *linePosPtr = line;
+
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextSearchIndexInLine --
+ *
+ *	Find textual index of 'byteIndex' in the searchable characters of
+ *	'linePtr'.
+ *
+ *	This means we ignore any embedded windows/images and elidden text
+ *	(unless we are searching that).
+ *
+ * Results:
+ *	The returned index is a utf-8 char* byte index for exact searches, and
+ *	a Unicode character index for regexp searches.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static unsigned
+CountCharsInSeg(
+    const TkTextSegment *segPtr)
+{
+    assert(segPtr->typePtr == &tkTextCharType);
+    return Tcl_NumUtfChars(segPtr->body.chars, segPtr->size);
+}
+
+static unsigned
+TextSearchIndexInLine(
+    const SearchSpec *searchSpecPtr,
+				/* Search parameters. */
+    TkTextLine *linePtr,	/* The line we're looking at. */
+    int byteIndex)		/* Index into the line. */
+{
+    TkTextSegment *segPtr;
+    int leftToScan;
+    unsigned index = 0;
+    TkText *textPtr = searchSpecPtr->clientData;
+    TkTextLine *startLinePtr = textPtr->startMarker->sectionPtr->linePtr;
+    bool isCharSeg;
+
+    index = 0;
+    segPtr = (startLinePtr == linePtr) ? textPtr->startMarker : linePtr->segPtr;
+
+    /*
+     * TODO: Use new elide structure, but this requires a redesign of the whole
+     * search algorithm.
+     */
+
+    for (leftToScan = byteIndex; leftToScan > 0; segPtr = segPtr->nextPtr) {
+	if ((isCharSeg = segPtr->typePtr == &tkTextCharType)
+		|| (searchSpecPtr->searchHyphens && segPtr->typePtr == &tkTextHyphenType)) {
+	    if (searchSpecPtr->searchElide || !TkTextSegmentIsElided(textPtr, segPtr)) {
+		if (leftToScan < segPtr->size) {
+		    if (searchSpecPtr->exact) {
+			index += leftToScan;
+		    } else {
+			index += isCharSeg ? Tcl_NumUtfChars(segPtr->body.chars, leftToScan) : 1;
+		    }
+		} else if (searchSpecPtr->exact) {
+		    index += isCharSeg ? segPtr->size : 2;
+		} else {
+		    index += isCharSeg ? CountCharsInSeg(segPtr) : 1;
+		}
+	    }
+	}
+	leftToScan -= segPtr->size;
+    }
+
+    return index;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextSearchAddNextLine --
+ *
+ *	Adds a line from the text widget to the object 'theLine'.
+ *
+ * Results:
+ *	A pointer to the TkTextLine corresponding to the given line, or NULL
+ *	if there was no available line.
+ *
+ *	Also 'lenPtr' (if non-NULL) is filled in with the total length of
+ *	'theLine' (not just what we added to it, but the length including what
+ *	was already in there). This is in bytes for an exact search and in
+ *	chars for a regexp search.
+ *
+ *	Also 'extraLinesPtr' (if non-NULL) will have its value incremented by
+ *	1 for each additional logical line we have added because a newline is
+ *	elided (this will only ever happen if we have chosen not to search
+ *	elided text, of course).
+ *
+ * Side effects:
+ *	Memory may be allocated or re-allocated for theLine's string
+ *	representation.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static ClientData
+TextSearchAddNextLine(
+    int lineNum,		/* Line we must add. */
+    SearchSpec *searchSpecPtr,	/* Search parameters. */
+    Tcl_Obj *theLine,		/* Object to append to. */
+    int *lenPtr,		/* For returning the total length. */
+    int *extraLinesPtr)		/* If non-NULL, will have its value
+				 * incremented by the number of additional
+				 * logical lines which are merged into this
+				 * one by newlines being elided. */
+{
+    TkTextLine *linePtr, *thisLinePtr;
+    TkTextSegment *segPtr, *lastPtr;
+    TkText *textPtr = searchSpecPtr->clientData;
+    TkTextLine *startLinePtr = textPtr->startMarker->sectionPtr->linePtr;
+    TkTextLine *endLinePtr = textPtr->endMarker->sectionPtr->linePtr;
+    bool nothingYet = true;
+
+    /*
+     * Extract the text from the line.
+     */
+
+    if (!(linePtr = TkBTreeFindLine(textPtr->sharedTextPtr->tree, textPtr, lineNum))) {
+	return NULL;
+    }
+    thisLinePtr = linePtr;
+
+    while (thisLinePtr) {
+	bool elideWraps = false;
+
+	segPtr = (startLinePtr == thisLinePtr) ? textPtr->startMarker : thisLinePtr->segPtr;
+	lastPtr = (endLinePtr == thisLinePtr) ? textPtr->endMarker : NULL;
+
+	/*
+	 * TODO: Use new elide structure, but this requires a redesign of the whole
+	 * search algorithm.
+	 */
+
+	for ( ; segPtr != lastPtr; segPtr = segPtr->nextPtr) {
+	    if (segPtr->typePtr == &tkTextCharType
+		    || (searchSpecPtr->searchHyphens && segPtr->typePtr == &tkTextHyphenType)) {
+		if (!searchSpecPtr->searchElide && TkTextSegmentIsElided(textPtr, segPtr)) {
+		    /*
+		     * If we reach the end of the logical line, and if we have at
+		     * least one character in the string, then we continue
+		     * wrapping to the next logical line. If there are no
+		     * characters yet, then the entire line of characters is
+		     * elided and there's no need to complicate matters by
+		     * wrapping - we'll look at the next line in due course.
+		     */
+
+		    if (!segPtr->nextPtr && !nothingYet) {
+			elideWraps = true;
+		    }
+		} else if (segPtr->typePtr == &tkTextCharType) {
+		    Tcl_AppendToObj(theLine, segPtr->body.chars, segPtr->size);
+		    nothingYet = false;
+		} else {
+		    Tcl_AppendToObj(theLine, "\xc2\xad", 2); /* U+002D */
+		    nothingYet = false;
+		}
+	    }
+	}
+	if (!elideWraps) {
+	    break;
+	}
+	lineNum += 1;
+	if (lineNum >= searchSpecPtr->numLines) {
+	    break;
+	}
+	thisLinePtr = TkBTreeNextLine(textPtr, thisLinePtr);
+	if (thisLinePtr && extraLinesPtr) {
+	    /*
+	     * Tell our caller we have an extra line merged in.
+	     */
+
+	    *extraLinesPtr = *extraLinesPtr + 1;
+	}
+    }
+
+    /*
+     * If we're ignoring case, convert the line to lower case. There is no
+     * need to do this for regexp searches, since they handle a flag for this
+     * purpose.
+     */
+
+    if (searchSpecPtr->exact && searchSpecPtr->noCase) {
+	Tcl_SetObjLength(theLine, Tcl_UtfToLower(Tcl_GetString(theLine)));
+    }
+
+    if (lenPtr) {
+	*lenPtr = searchSpecPtr->exact ? GetByteLength(theLine) : Tcl_GetCharLength(theLine);
+    }
+    return linePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextSearchFoundMatch --
+ *
+ *	Stores information from a successful search.
+ *
+ * Results:
+ *	'true' if the information was stored, 'false' if the position at
+ *	which the match was found actually falls outside the allowable
+ *	search region (and therefore the search is actually complete).
+ *
+ * Side effects:
+ *	Memory may be allocated in the 'countPtr' and 'resPtr' fields of
+ *	'searchSpecPtr'. Each of those objects will have refCount zero and
+ *	must eventually be freed or stored elsewhere as appropriate.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+TextSearchFoundMatch(
+    int lineNum,		/* Line on which match was found. */
+    SearchSpec *searchSpecPtr,	/* Search parameters. */
+    ClientData clientData,	/* Token returned by the 'addNextLineProc', TextSearchAddNextLine.
+    				 * May be NULL, in which we case we must generate it (from lineNum). */
+    Tcl_Obj *theLine,		/* Text from current line, only accessed for exact searches, and
+    				 * is allowed to be NULL for regexp searches. */
+    int matchOffset,		/* Offset of found item in utf-8 bytes for exact search, Unicode
+    				 * chars for regexp. */
+    int matchLength)		/* Length also in bytes/chars as per search type. */
+{
+    int numChars;
+    int leftToScan;
+    TkTextIndex foundIndex;
+    TkTextSegment *segPtr;
+    TkTextLine *linePtr, *startLinePtr;
+    TkText *textPtr = searchSpecPtr->clientData;
+    int byteIndex;
+
+    if (lineNum == searchSpecPtr->stopLine) {
+	/*
+	 * If the current index is on the wrong side of the stopIndex, then
+	 * the item we just found is actually outside the acceptable range,
+	 * and the search is over.
+	 */
+
+	if (searchSpecPtr->backwards ^ (matchOffset >= searchSpecPtr->stopOffset)) {
+	    return false;
+	}
+    }
+
+    /*
+     * Calculate the character count, which may need augmenting if there are
+     * embedded windows or elidden text.
+     */
+
+    if (searchSpecPtr->exact) {
+	numChars = Tcl_NumUtfChars(Tcl_GetString(theLine) + matchOffset, matchLength);
+    } else {
+	numChars = matchLength;
+    }
+
+    /*
+     * If we're using strict limits checking, ensure that the match with its
+     * full length fits inside the given range.
+     */
+
+    if (searchSpecPtr->strictLimits && lineNum == searchSpecPtr->stopLine) {
+	if (searchSpecPtr->backwards ^ (matchOffset + numChars > searchSpecPtr->stopOffset)) {
+	    return false;
+	}
+    }
+
+    /*
+     * The index information returned by the regular expression parser only
+     * considers textual information: it doesn't account for embedded windows,
+     * elided text (when we are not searching elided text) or any other
+     * non-textual info. Scan through the line's segments again to adjust both
+     * matchChar and matchCount.
+     *
+     * We will walk through the segments of this line until we have either
+     * reached the end of the match or we have reached the end of the line.
+     */
+
+    linePtr = clientData;
+    if (!linePtr) {
+	linePtr = TkBTreeFindLine(textPtr->sharedTextPtr->tree, textPtr, lineNum);
+    }
+    startLinePtr = textPtr->startMarker->sectionPtr->linePtr;
+
+    /*
+     * Find the starting point.
+     */
+
+    leftToScan = matchOffset;
+    while (true) {
+	/*
+	 * Note that we allow leftToScan to be zero because we want to skip
+	 * over any preceding non-textual items.
+	 */
+
+	segPtr = (linePtr == startLinePtr) ? textPtr->startMarker : linePtr->segPtr;
+	byteIndex = TkTextSegToIndex(segPtr);
+
+	/*
+	 * TODO: Use new elide structure, but this requires a redesign of the whole
+	 * search algorithm.
+	 */
+
+	for ( ; leftToScan >= 0 && segPtr; segPtr = segPtr->nextPtr) {
+	    if (segPtr->typePtr == &tkTextCharType) {
+		int size = searchSpecPtr->exact ? segPtr->size : CountCharsInSeg(segPtr);
+
+		if (!searchSpecPtr->searchElide && TkTextSegmentIsElided(textPtr, segPtr)) {
+		    matchOffset += size;
+		} else {
+		    leftToScan -= size;
+		}
+	    } else if (searchSpecPtr->searchHyphens && segPtr->typePtr == &tkTextHyphenType) {
+		int size = searchSpecPtr->exact ? 2 : 1;
+
+		if (!searchSpecPtr->searchElide && TkTextSegmentIsElided(textPtr, segPtr)) {
+		    matchOffset += size;
+		} else {
+		    leftToScan -= size;
+		}
+	    } else {
+		assert(segPtr->size <= 1);
+		matchOffset += segPtr->size;
+	    }
+	    byteIndex += segPtr->size;
+	}
+
+	assert(!segPtr || leftToScan < 0 || TkBTreeNextLine(textPtr, linePtr));
+
+	if (segPtr || leftToScan < 0) {
+	    break;
+	}
+
+	/*
+	 * This will only happen if we are eliding newlines.
+	 *
+	 * We've wrapped to the beginning of the next logical line, which
+	 * has been merged with the previous one whose newline was elided.
+	 */
+
+	linePtr = linePtr->nextPtr;
+	lineNum += 1;
+	matchOffset = 0;
+    }
+
+    /*
+     * Calculate and store the found index in the result.
+     */
+
+    if (searchSpecPtr->exact) {
+	TkTextMakeByteIndex(textPtr->sharedTextPtr->tree, textPtr, lineNum, matchOffset, &foundIndex);
+    } else {
+	TkTextMakeCharIndex(textPtr->sharedTextPtr->tree, textPtr, lineNum, matchOffset, &foundIndex);
+    }
+
+    if (searchSpecPtr->all) {
+	if (!searchSpecPtr->resPtr) {
+	    searchSpecPtr->resPtr = Tcl_NewObj();
+	}
+	Tcl_ListObjAppendElement(NULL, searchSpecPtr->resPtr, TkTextNewIndexObj(&foundIndex));
+    } else {
+	searchSpecPtr->resPtr = TkTextNewIndexObj(&foundIndex);
+    }
+
+    /*
+     * Find the end point. Here 'leftToScan' could be negative already as a
+     * result of the above loop if the segment we reached spanned the start of
+     * the string. When we add matchLength it will become non-negative.
+     */
+
+    /*
+     * TODO: Use new elide structure, but this requires a redesign of the whole
+     * search algorithm.
+     */
+
+    for (leftToScan += matchLength; leftToScan > 0; segPtr = segPtr->nextPtr) {
+	bool isCharSeg;
+
+	if (!segPtr) {
+	    /*
+	     * We are on the next line - this of course should only ever
+	     * happen with searches which have matched across multiple lines.
+	     */
+
+	    assert(TkBTreeNextLine(textPtr, linePtr));
+	    linePtr = linePtr->nextPtr;
+	    segPtr = linePtr->segPtr;
+	    byteIndex = 0;
+	}
+
+	isCharSeg = (segPtr->typePtr == &tkTextCharType);
+
+	if (!isCharSeg && (!searchSpecPtr->searchHyphens || segPtr->typePtr != &tkTextHyphenType)) {
+	    /*
+	     * Anything we didn't count in the search needs adding.
+	     */
+
+	    assert(segPtr->size <= 1);
+	    numChars += segPtr->size;
+	} else if (!searchSpecPtr->searchElide && TkTextSegmentIsElided(textPtr, segPtr)) {
+	    numChars += isCharSeg ? CountCharsInSeg(segPtr) : 1;
+	} else if (searchSpecPtr->exact) {
+	    leftToScan -= isCharSeg ? segPtr->size : 2;
+	} else {
+	    leftToScan -= isCharSeg ? CountCharsInSeg(segPtr) : 1;
+	}
+    }
+
+    /*
+     * Now store the count result, if it is wanted.
+     */
+
+    if (searchSpecPtr->varPtr) {
+	Tcl_Obj *tmpPtr = Tcl_NewIntObj(numChars);
+	if (searchSpecPtr->all) {
+	    if (!searchSpecPtr->countPtr) {
+		searchSpecPtr->countPtr = Tcl_NewObj();
+	    }
+	    Tcl_ListObjAppendElement(NULL, searchSpecPtr->countPtr, tmpPtr);
+	} else {
+	    searchSpecPtr->countPtr = tmpPtr;
+	}
+    }
+
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextGetTabs --
+ *
+ *	Parses a string description of a set of tab stops.
+ *
+ * Results:
+ *	The return value is a pointer to a malloc'ed structure holding parsed
+ *	information about the tab stops. If an error occurred then the return
+ *	value is NULL and an error message is left in the interp's result.
+ *
+ * Side effects:
+ *	Memory is allocated for the structure that is returned. It is up to
+ *	the caller to free this structure when it is no longer needed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextTabArray *
+TkTextGetTabs(
+    Tcl_Interp *interp,		/* Used for error reporting. */
+    TkText *textPtr,		/* Information about the text widget. */
+    Tcl_Obj *stringPtr)		/* Description of the tab stops. See the text
+				 * manual entry for details. */
+{
+    int objc, i, count;
+    Tcl_Obj **objv;
+    TkTextTabArray *tabArrayPtr;
+    TkTextTab *tabPtr;
+    int ch;
+    double prevStop, lastStop;
+    /*
+     * Map these strings to TkTextTabAlign values.
+     */
+    static const char *const tabOptionStrings[] = {
+	"left", "right", "center", "numeric", NULL
+    };
+
+    if (Tcl_ListObjGetElements(interp, stringPtr, &objc, &objv) != TCL_OK) {
+	return NULL;
+    }
+
+    /*
+     * First find out how many entries we need to allocate in the tab array.
+     */
+
+    count = 0;
+    for (i = 0; i < objc; i++) {
+	char c = Tcl_GetString(objv[i])[0];
+
+	if (c != 'l' && c != 'r' && c != 'c' && c != 'n') {
+	    count += 1;
+	}
+    }
+
+    /*
+     * Parse the elements of the list one at a time to fill in the array.
+     */
+
+    tabArrayPtr = malloc(sizeof(TkTextTabArray) + (count - 1)*sizeof(TkTextTab));
+    tabArrayPtr->numTabs = 0;
+    prevStop = 0.0;
+    lastStop = 0.0;
+    for (i = 0, tabPtr = &tabArrayPtr->tabs[0]; i < objc; i++, tabPtr++) {
+	int index;
+
+	/*
+	 * This will round fractional pixels above 0.5 upwards, and otherwise
+	 * downwards, to find the right integer pixel position.
+	 */
+
+	if (Tk_GetPixelsFromObj(interp, textPtr->tkwin, objv[i], &tabPtr->location) != TCL_OK) {
+	    goto error;
+	}
+
+	if (tabPtr->location <= 0) {
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		    "tab stop \"%s\" is not at a positive distance", Tcl_GetString(objv[i])));
+	    Tcl_SetErrorCode(interp, "TK", "VALUE", "TAB_STOP", NULL);
+	    goto error;
+	}
+
+	prevStop = lastStop;
+	if (Tk_GetDoublePixelsFromObj(interp, textPtr->tkwin, objv[i], &lastStop) != TCL_OK) {
+	    goto error;
+	}
+
+	if (i > 0 && tabPtr->location <= (tabPtr - 1)->location) {
+	    /*
+	     * This tab is actually to the left of the previous one, which is
+	     * illegal.
+	     */
+
+#ifdef _TK_ALLOW_DECREASING_TABS
+	    /*
+	     * Force the tab to be a typical character width to the right of
+	     * the previous one, and update the 'lastStop' with the changed
+	     * position.
+	     */
+
+	    tabPtr->location = (tabPtr - 1)->location;
+	    tabPtr->location += (textPtr->charWidth > 0 ? textPtr->charWidth : 8);
+	    lastStop = tabPtr->location;
+#else
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		    "tabs must be monotonically increasing, but \"%s\" is "
+		    "smaller than or equal to the previous tab",
+		    Tcl_GetString(objv[i])));
+	    Tcl_SetErrorCode(interp, "TK", "VALUE", "TAB_STOP", NULL);
+	    goto error;
+#endif /* _TK_ALLOW_DECREASING_TABS */
+	}
+
+	tabArrayPtr->numTabs += 1;
+
+	/*
+	 * See if there is an explicit alignment in the next list element.
+	 * Otherwise just use "left".
+	 */
+
+	tabPtr->alignment = LEFT;
+	if (i + 1 == objc) {
+	    continue;
+	}
+
+	/*
+	 * There may be a more efficient way of getting this.
+	 */
+
+	TkUtfToUniChar(Tcl_GetString(objv[i + 1]), &ch);
+	if (!Tcl_UniCharIsAlpha(ch)) {
+	    continue;
+	}
+	i += 1;
+
+	if (Tcl_GetIndexFromObjStruct(interp, objv[i], tabOptionStrings,
+		sizeof(char *), "tab alignment", 0, &index) != TCL_OK) {
+	    goto error;
+	}
+	tabPtr->alignment = (TkTextTabAlign) index;
+    }
+
+    /*
+     * For when we need to interpolate tab stops, store these two so we know
+     * the tab stop size to very high precision. With the above checks, we can
+     * guarantee that tabIncrement is strictly positive here.
+     */
+
+    tabArrayPtr->lastTab = lastStop;
+    tabArrayPtr->tabIncrement = lastStop - prevStop;
+
+    return tabArrayPtr;
+
+  error:
+    free(tabArrayPtr);
+    return NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextDumpCmd --
+ *
+ *	Return information about the text, tags, marks, and embedded windows
+ *	and images in a text widget. See the man page for the description of
+ *	the text dump operation for all the details.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	Memory is allocated for the result, if needed (standard Tcl result
+ *	side effects).
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+AppendOption(
+    char *result,
+    const char *str,
+    const char *delim)
+{
+    unsigned len = strlen(result);
+
+    if (delim && len > 0 && result[len - 1] != ' ' && result[len - 1] != '?') {
+	strcpy(result + len, delim);
+	len += strlen(delim);
+    }
+    strcpy(result + len, str);
+}
+
+static int
+GetDumpFlags(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[],	/* Argument objects. */
+    unsigned allowed,		/* Which options are allowed? */
+    unsigned dflt,		/* Default options (-all) */
+    unsigned *what,		/* Store flags here. */
+    int *lastArg,		/* Store index of last used argument, can be NULL. */
+    TkTextIndex *index1,	/* Store first index here. */
+    TkTextIndex *index2,	/* Store second index here. */
+    Tcl_Obj **command)		/* Store command here, can be NULL. */
+{
+    static const char *const optStrings[] = {
+	"-all", "-bindings", "-chars", "-command", "-configurations", "-discardselection",
+	"-displaychars", "-displaytext", "-dontresolve", "-elide", "-image",
+	"-insertmark", "-mark", "-nested", "-node", "-setup",
+	"-tag", "-text", "-window", NULL
+    };
+    enum opts {
+	DUMP_ALL, DUMP_TAG_BINDINGS, DUMP_CHARS, DUMP_CMD, DUMP_TAG_CONFIGS, DUMP_DISCARD_SEL,
+	DUMP_DISPLAY_CHARS, DUMP_DISPLAY_TEXT, DUMP_DONT_RESOLVE, DUMP_ELIDE, DUMP_IMG,
+	DUMP_INSERT_MARK, DUMP_MARK, DUMP_NESTED, DUMP_NODE, DUMP_TEXT_CONFIGS,
+	DUMP_TAG, DUMP_TEXT, DUMP_WIN
+    };
+    static const int dumpFlags[] = {
+	0, TK_DUMP_TAG_BINDINGS, TK_DUMP_CHARS, 0, TK_DUMP_TAG_CONFIGS, TK_DUMP_DISCARD_SEL,
+	TK_DUMP_DISPLAY_CHARS, TK_DUMP_DISPLAY_TEXT, TK_DUMP_DONT_RESOLVE, TK_DUMP_ELIDE, TK_DUMP_IMG,
+	TK_DUMP_INSERT_MARK, TK_DUMP_MARK, TK_DUMP_NESTED, TK_DUMP_NODE, TK_DUMP_TEXT_CONFIGS,
+	TK_DUMP_TAG, TK_DUMP_TEXT, TK_DUMP_WIN
+    };
+
+    int arg, i;
+    unsigned flags = 0;
+    const char *myOptStrings[sizeof(optStrings)/sizeof(optStrings[0])];
+    int myOptIndices[sizeof(optStrings)/sizeof(optStrings[0])];
+    int myOptCount;
+
+    assert(what);
+    assert(!index1 == !index2);
+    assert(DUMP_ALL == 0); /* otherwise next loop is wrong */
+
+    /* We know that option -all is allowed in any case. */
+    myOptStrings[0] = optStrings[DUMP_ALL];
+    myOptIndices[0] = DUMP_ALL;
+    myOptCount = 1;
+
+    for (i = 1; i < sizeof(optStrings)/sizeof(optStrings[0]) - 1; ++i) {
+	if (i == DUMP_CMD ? !!command : (allowed & dumpFlags[i]) == dumpFlags[i]) {
+	    myOptStrings[myOptCount] = optStrings[i];
+	    myOptIndices[myOptCount] = i;
+	    myOptCount += 1;
+	}
+    }
+    myOptStrings[myOptCount] = NULL;
+
+    if (lastArg) {
+	*lastArg = 0;
+    }
+    *what = 0;
+
+    for (arg = 2; arg < objc && Tcl_GetString(objv[arg])[0] == '-'; ++arg) {
+	int index;
+
+	if (Tcl_GetString(objv[arg])[1] == '-'
+		&& Tcl_GetString(objv[arg])[2] == '\0'
+		&& (arg < objc - 1 || Tcl_GetString(objv[arg + 1])[0] != '-')) {
+	    continue;
+	}
+
+	if (Tcl_GetIndexFromObjStruct(interp, objv[arg], myOptStrings,
+		sizeof(char *), "option", 0, &index) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+
+	switch ((enum opts) myOptIndices[index]) {
+#define CASE(Flag) case DUMP_##Flag: *what |= TK_DUMP_##Flag; flags |= TK_DUMP_##Flag; break;
+	CASE(CHARS);
+	CASE(TEXT);
+	CASE(DISPLAY_CHARS);
+	CASE(DISPLAY_TEXT);
+	CASE(TAG);
+	CASE(MARK);
+	CASE(ELIDE);
+	CASE(NESTED);
+	CASE(NODE);
+	CASE(DISCARD_SEL);
+	CASE(INSERT_MARK);
+	CASE(TEXT_CONFIGS);
+	CASE(TAG_BINDINGS);
+	CASE(TAG_CONFIGS);
+	CASE(DONT_RESOLVE);
+	CASE(IMG);
+	CASE(WIN);
+#undef CASE
+	case DUMP_ALL:
+	    *what = dflt;
+	    break;
+	case DUMP_CMD:
+	    arg += 1;
+	    if (!command || arg >= objc) {
+		goto wrongArgs;
+	    }
+	    *command = objv[arg];
+	    break;
+	}
+	if (~allowed & flags) {
+	    goto wrongArgs;
+	}
+    }
+    if (!(*what & dflt)) {
+	*what |= dflt;
+    }
+    if (!index1) {
+	if (arg < objc) {
+	    goto wrongArgs;
+	}
+	return TCL_OK;
+    }
+    if (arg >= objc || arg + 2 < objc) {
+	goto wrongArgs;
+    }
+    if (!TkTextGetIndexFromObj(interp, textPtr, objv[arg], index1)) {
+	return TCL_ERROR;
+    }
+    arg += 1;
+    if (lastArg) {
+	*lastArg = arg;
+    }
+    if (objc == arg) {
+	TkTextIndexForwChars(textPtr, index1, 1, index2, COUNT_INDICES);
+    } else if (!TkTextGetIndexFromObj(interp, textPtr, objv[arg], index2)) {
+	return TCL_ERROR;
+    }
+    return TCL_OK;
+
+wrongArgs:
+    {
+	char result[500];
+	unsigned i;
+
+	result[0] = 0;
+	AppendOption(result, "?", NULL);
+
+	for (i = 0; myOptStrings[i]; ++i) {
+	    if (myOptIndices[i] != DUMP_CMD) {
+		AppendOption(result, myOptStrings[i], " ");
+	    }
+	}
+	AppendOption(result, "? ?", NULL);
+	if (command) { AppendOption(result, "-command script", NULL); }
+	AppendOption(result, "?", NULL);
+	if (index1)  { AppendOption(result, " index ?index2?", NULL); }
+
+	Tcl_SetObjResult(interp, Tcl_ObjPrintf("Usage: %s %s %s",
+		Tcl_GetString(objv[0]), Tcl_GetString(objv[1]), result));
+	Tcl_SetErrorCode(interp, "TCL", "WRONGARGS", NULL);
+    }
+    return TCL_ERROR;
+}
+
+static int
+TextDumpCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already parsed this command
+    				 * enough to know that objv[1] is "dump". */
+{
+    TkTextIndex index1, index2;
+    TkTextBTree tree;
+    TkTextTag *tagPtr, *tPtr;
+    int lineno;			/* Current line number. */
+    unsigned what;		/* bitfield to select segment types. */
+    int lastArg;		/* Index of last argument. */
+    TkTextLine *linePtr;
+    TkTextIndex prevByteIndex;
+    Tcl_Obj *command = NULL;	/* Script callback to apply to segments. */
+    TkTextTag *prevTagPtr = NULL;
+    int result;
+
+    assert(textPtr);
+
+    result = GetDumpFlags(textPtr, interp, objc, objv, TK_DUMP_DUMP_ALL|TK_DUMP_NODE, TK_DUMP_DUMP_ALL,
+	    &what, &lastArg, &index1, &index2, &command);
+    if (result != TCL_OK) {
+	return result;
+    }
+    if (TkTextIndexCompare(&index1, &index2) >= 0) {
+	return TCL_OK;
+    }
+    tree = textPtr->sharedTextPtr->tree;
+    textPtr->sharedTextPtr->inspectEpoch += 1;
+    lineno = TkBTreeLinesTo(tree, textPtr, TkTextIndexGetLine(&index1), NULL);
+    prevByteIndex = index1;
+    if (TkTextIndexBackBytes(textPtr, &index1, 1, &prevByteIndex) == 0) {
+	unsigned epoch = textPtr->sharedTextPtr->inspectEpoch + 1;
+	tagPtr = TkBTreeGetTags(&prevByteIndex);
+	for (tPtr = tagPtr; tPtr; tPtr = tPtr->nextPtr) { tPtr->epoch = epoch; }
+    } else {
+	tagPtr = NULL;
+    }
+    if (TkTextIndexGetLine(&index1) == TkTextIndexGetLine(&index2)) {
+	/* we are at the end, so we can ignore the return code of DumpLine */
+	DumpLine(interp, textPtr, what, TkTextIndexGetLine(&index1),
+		TkTextIndexGetByteIndex(&index1), TkTextIndexGetByteIndex(&index2),
+		lineno, command, &prevTagPtr);
+    } else {
+	int lineend = TkBTreeLinesTo(tree, textPtr, TkTextIndexGetLine(&index2), NULL);
+	int endByteIndex = TkTextIndexGetByteIndex(&index2);
+
+	if (!DumpLine(interp, textPtr, what, TkTextIndexGetLine(&index1),
+		TkTextIndexGetByteIndex(&index1), INT_MAX, lineno, command, &prevTagPtr)) {
+	    if (textPtr->flags & DESTROYED) {
+		return TCL_OK;
+	    }
+	    if (!(linePtr = TkBTreeFindLine(textPtr->sharedTextPtr->tree, textPtr, lineno))) {
+		goto textChanged;
+	    }
+	} else {
+	    linePtr = TkTextIndexGetLine(&index1);
+	}
+	while ((linePtr = TkBTreeNextLine(textPtr, linePtr))) {
+	    if (++lineno == lineend) {
+		break;
+	    }
+	    if (!DumpLine(interp, textPtr, what, linePtr, 0, INT_MAX, lineno, command, &prevTagPtr)) {
+		if (textPtr->flags & DESTROYED) {
+		    return TCL_OK;
+		}
+		if (!(linePtr = TkBTreeFindLine(textPtr->sharedTextPtr->tree, textPtr, lineno))) {
+		    goto textChanged;
+		}
+	    }
+	}
+	if (linePtr) {
+	    /* we are at the end, so we can ignore the return code of DumpLine */
+	    DumpLine(interp, textPtr, what, linePtr, 0, endByteIndex, lineno, command, &prevTagPtr);
+	}
+    }
+
+  textChanged:
+
+    /*
+     * Special case to get the leftovers hiding at the end mark.
+     */
+
+    if (!(textPtr->flags & DESTROYED)) {
+	if (lastArg < objc
+		&& strncmp(Tcl_GetString(objv[lastArg]), "end", GetByteLength(objv[lastArg])) == 0) {
+	    /*
+	     * Re-get the end index, in case it has changed.
+	     */
+
+	    if (!TkTextGetIndexFromObj(interp, textPtr, objv[lastArg], &index2)) {
+		return TCL_ERROR;
+	    }
+	    if (!DumpLine(interp, textPtr, what & ~TK_DUMP_TEXT, TkTextIndexGetLine(&index2), 0, 1,
+		    lineno, command, &prevTagPtr)) {
+		prevTagPtr = NULL; /* the tags are no longer valid */
+	    }
+	}
+
+	if (prevTagPtr && TkTextIndexIsEndOfText(&index2)) {
+	    /*
+	     * Finally print "tagoff" information, if at end of text.
+	     */
+
+	    for ( ; prevTagPtr; prevTagPtr = prevTagPtr->succPtr) {
+		if (!DumpSegment(textPtr, interp, "tagoff", prevTagPtr->name, command, &index2, what)) {
+		    break;
+		}
+	    }
+	}
+    }
+
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DumpLine
+ *
+ *	Return information about a given text line from character position
+ *	"start" up to, but not including, "end".
+ *
+ * Results:
+ *	Returns false if the command callback made any changes to the text widget
+ *	which will have invalidated internal structures such as TkTextSegment,
+ *	TkTextIndex, pointers. Our caller can then take action to recompute
+ *	such entities, or he aborts with an error. Returns true otherwise.
+ *
+ * Side effects:
+ *	None, but see DumpSegment which can have arbitrary side-effects
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+DumpLine(
+    Tcl_Interp *interp,
+    TkText *textPtr,
+    int what,			/* Bit flags to select segment types. */
+    TkTextLine *linePtr,	/* The current line. */
+    int startByte, int endByte,	/* Byte range to dump. */
+    int lineno,			/* Line number for indices dump. */
+    Tcl_Obj *command,		/* Script to apply to the segment. */
+    TkTextTag **prevTagPtr)	/* Tag information from previous segment. */
+{
+    TkSharedText *sharedTextPtr;
+    TkTextSegment *sPtr;
+    TkTextSegment *segPtr;
+    TkTextSegment *endPtr;
+    TkTextSegment *newSegPtr;
+    TkTextIndex index;
+    int offset = 0;
+    int currentSize = 0;
+    int bufSize = 0;
+    bool textChanged = false;
+    char *buffer = NULL;
+    bool eol;
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+
+    if (!*prevTagPtr && (startByte > 0 || linePtr != TkBTreeGetStartLine(textPtr))) {
+	/*
+	 * If this is the first line to dump, and we are not at start of line,
+	 * then we need the preceding tag information.
+	 */
+
+	TkTextIndex index;
+	TkTextTag *tagPtr, *tPtr;
+	unsigned epoch = sharedTextPtr->inspectEpoch;
+
+	TkTextIndexClear(&index, textPtr);
+	TkTextIndexSetByteIndex2(&index, linePtr, startByte);
+	TkBTreeMoveBackward(&index, 1);
+	segPtr = TkTextIndexGetContentSegment(&index, NULL);
+	assert(segPtr);
+	tagPtr = TkBTreeGetSegmentTags(textPtr->sharedTextPtr, segPtr, textPtr);
+	for (tPtr = tagPtr; tPtr; tPtr = tPtr->nextPtr) {
+	    tPtr->flag = epoch; /* mark as open */
+	}
+    }
+
+    /*
+     * Must loop through line looking at its segments: character, hyphen, mark, image, window.
+     */
+
+    segPtr = linePtr->segPtr;
+    endPtr = textPtr->endMarker;
+    eol = !segPtr->nextPtr;
+
+    if ((what & TK_DUMP_NODE)
+	    && startByte == 0
+	    && (!linePtr->prevPtr || linePtr->prevPtr->parentPtr != linePtr->parentPtr)) {
+	char buf[20];
+	unsigned depth, number;
+
+	TkTextIndexClear(&index, textPtr);
+	TkTextIndexSetToStartOfLine2(&index, linePtr);
+	number = TkBTreeChildNumber(sharedTextPtr->tree, linePtr, &depth);
+	snprintf(buf, sizeof(buf), "%d:%d", number, depth);
+
+	if (!DumpSegment(textPtr, interp, "node", buf, command, &index, what)) {
+	    goto textChanged;
+	}
+    }
+
+    while (segPtr && offset < endByte) {
+	currentSize = segPtr->size;
+
+	if (offset + MAX(1, currentSize) > startByte) {
+	    if ((what & TK_DUMP_TAG) && segPtr->tagInfoPtr) {
+		TkTextTag *tagPtr = TkBTreeGetSegmentTags(sharedTextPtr, segPtr, textPtr);
+		unsigned epoch = sharedTextPtr->inspectEpoch;
+		unsigned nextEpoch = epoch + 1;
+		TkTextTag *tPtr;
+
+		for (tPtr = tagPtr; tPtr; tPtr = tPtr->nextPtr) {
+		    if (tPtr->flag == epoch) {
+			tPtr->flag = nextEpoch; /* mark as still open */
+		    }
+		}
+
+		if (*prevTagPtr) {
+		    /*
+		     * Print "tagoff" information.
+		     */
+
+		    for (tPtr = *prevTagPtr; tPtr; tPtr = tPtr->succPtr) {
+			if (tPtr->flag == epoch) { /* should be closed? */
+			    TkTextMakeByteIndex(sharedTextPtr->tree, textPtr, lineno, offset, &index);
+			    if (!DumpSegment(textPtr, interp, "tagoff",
+				    tPtr->name, command, &index, what)) {
+				goto textChanged;
+			    }
+			    tPtr->flag = 0; /* mark as closed */
+			}
+		    }
+		}
+
+		/*
+		 * Print "tagon" information.
+		 */
+
+		sharedTextPtr->inspectEpoch = ++epoch;
+
+		for (tPtr = tagPtr; tPtr; tPtr = tPtr->nextPtr) {
+		    if (tPtr->flag != epoch) {
+			TkTextMakeByteIndex(sharedTextPtr->tree, textPtr, lineno, offset, &index);
+			if (!DumpSegment(textPtr, interp, "tagon", tPtr->name, command, &index, what)) {
+			    goto textChanged;
+			}
+			tPtr->flag = epoch; /* mark as open */
+		    }
+		    tPtr->succPtr = tPtr->nextPtr;
+		}
+
+		*prevTagPtr = tagPtr;
+	    }
+
+	    if (what & segPtr->typePtr->group) {
+		assert(segPtr->typePtr->group != SEG_GROUP_BRANCH);
+
+		if (segPtr->typePtr->group == SEG_GROUP_CHAR) {
+		    int last = currentSize;	/* Index of last char in seg. */
+		    int first = 0;		/* Index of first char in seg. */
+
+		    if (offset + currentSize > endByte) {
+			last = endByte - offset;
+		    }
+		    if (startByte > offset) {
+			first = startByte - offset;
+		    }
+		    if (last != currentSize) {
+			/*
+			 * To avoid modifying the string in place we copy over just
+			 * the segment that we want. Since DumpSegment can modify the
+			 * text, we could not confidently revert the modification here.
+			 */
+
+			int length = last - first;
+
+			if (length >= bufSize) {
+			    bufSize = MAX(length + 1, 2*length);
+			    buffer = realloc(buffer, bufSize);
+			}
+
+			memcpy(buffer, segPtr->body.chars + first, length);
+			buffer[length] = '\0';
+
+			TkTextMakeByteIndex(sharedTextPtr->tree, textPtr, lineno,
+				offset + first, &index);
+			if (!DumpSegment(textPtr, interp, "text", buffer, command, &index, what)) {
+			    goto textChanged;
+			}
+		    } else {
+			TkTextMakeByteIndex(sharedTextPtr->tree, textPtr, lineno,
+				offset + first, &index);
+			if (!DumpSegment(textPtr, interp, "text",
+				segPtr->body.chars + first, command, &index, what)) {
+			    goto textChanged;
+			}
+		    }
+		} else if (segPtr == endPtr) {
+		    if (linePtr == TkBTreeGetLastLine(textPtr)) {
+			break; /* finished */
+		    }
+		    /* print final newline in next iteration */
+		    currentSize = linePtr->size - offset - 1;
+		    startByte = offset + currentSize + linePtr->lastPtr->size - 1;
+		    segPtr = linePtr->lastPtr->prevPtr;
+		} else {
+		    char const *value = NULL;
+
+		    switch ((int) segPtr->typePtr->group) {
+		    case SEG_GROUP_MARK:
+			value = TkTextMarkName(sharedTextPtr, textPtr, segPtr);
+			break;
+		    case SEG_GROUP_IMAGE: {
+			TkTextEmbImage *eiPtr = &segPtr->body.ei;
+			value = eiPtr->name ? eiPtr->name : "";
+			break;
+		    }
+		    case SEG_GROUP_WINDOW: {
+			TkTextEmbWindow *ewPtr = &segPtr->body.ew;
+			value = ewPtr->tkwin ? Tk_PathName(ewPtr->tkwin) : "";
+			break;
+		    }
+		    case SEG_GROUP_HYPHEN:
+			value = "";
+			break;
+		    }
+		    if (value) {
+			TkTextMakeByteIndex(sharedTextPtr->tree, textPtr, lineno, offset, &index);
+			if (!DumpSegment(textPtr, interp, segPtr->typePtr->name, value, command,
+				&index, what)) {
+			    goto textChanged;
+			}
+		    }
+		}
+	    }
+	}
+
+	offset += currentSize;
+	segPtr = segPtr->nextPtr;
+	continue;
+
+  textChanged:
+
+	/*
+	 * Our indices, segments, and tag chains are no longer valid. It's a bad
+	 * idea to do changes while the dump is running, it's impossible to
+	 * synchronize in any case, but we will try the best.
+	 */
+
+	*prevTagPtr = NULL;
+	textChanged = true;
+
+	if (eol || (textPtr->flags & DESTROYED)) {
+	    break;
+	}
+
+	offset += currentSize;
+	if (!(linePtr = TkBTreeFindLine(textPtr->sharedTextPtr->tree, textPtr, lineno))) {
+	    break;
+	}
+	TkTextIndexClear(&index, textPtr);
+	TkTextIndexSetByteIndex2(&index, linePtr, MIN(offset, linePtr->size - 1));
+
+	sPtr = newSegPtr = TkTextIndexGetFirstSegment(&index, NULL);
+	while (sPtr && sPtr != segPtr) {
+	    sPtr = sPtr->nextPtr;
+	}
+	if (sPtr != segPtr) {
+	    segPtr = newSegPtr;
+	} else if (offset >= segPtr->size) {
+	    segPtr = segPtr->nextPtr;
+	}
+    }
+
+    free(buffer);
+    return !textChanged;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextChecksumCmd --
+ *
+ *	Return the checksum over the whole content.
+ *	About the format see documentation.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	Memory is allocated for the result, if needed (standard Tcl result
+ *	side effects).
+ *
+ *----------------------------------------------------------------------
+ */
+
+static uint32_t
+ComputeChecksum(
+    uint32_t crc,
+    const char *buf,
+    unsigned len)
+{
+    static const uint32_t crcTable[256] = {
+      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
+      0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
+      0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+      0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
+      0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
+      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+      0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
+      0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
+      0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+      0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
+      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
+      0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+      0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
+      0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
+      0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
+      0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
+      0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+      0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
+      0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
+      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+      0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
+      0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
+      0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+      0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
+      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
+      0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+      0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
+      0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
+      0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
+      0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+    };
+
+    assert(buf);
+
+    /* basic algorithm stolen from zlib/crc32.c (public domain) */
+
+#define DO1(buf) crc = crcTable[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf) DO1(buf); DO1(buf);
+#define DO4(buf) DO2(buf); DO2(buf);
+#define DO8(buf) DO4(buf); DO4(buf);
+
+    crc = crc ^ 0xffffffff;
+
+    if (len == 0) {
+	while (*buf) {
+	    DO1(buf);
+	}
+    } else {
+	while (len >= 8) {
+	    DO8(buf);
+	    len -= 8;
+	}
+	while (len--) {
+	    DO1(buf);
+	}
+    }
+    return crc ^ 0xffffffff;
+}
+
+static int
+TextChecksumCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already parsed this command
+    				 * enough to know that objv[1] is "checksum". */
+{
+    const TkSharedText *sharedTextPtr;
+    const TkTextSegment *segPtr;
+    const TkTextSegment *endPtr;
+    const TkTextLine *linePtr;
+    TkTextTag **tagArrPtr = NULL; /* avoid compiler warning */
+    unsigned what;
+    unsigned crc;
+    int result;
+
+    assert(textPtr);
+
+    result = GetDumpFlags(textPtr, interp, objc, objv, TK_DUMP_CRC_ALL, TK_DUMP_CRC_DFLT,
+	    &what, NULL, NULL, NULL, NULL);
+
+    if (result != TCL_OK) {
+	return result;
+    }
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+    segPtr = sharedTextPtr->startMarker;
+    endPtr = sharedTextPtr->endMarker;
+    linePtr = segPtr->sectionPtr->linePtr;
+    if (endPtr->sectionPtr->linePtr != linePtr) {
+	endPtr = NULL;
+    }
+    crc = 0;
+
+    if ((what & SEG_GROUP_TAG)) {
+	tagArrPtr = malloc(sizeof(tagArrPtr[0])*sharedTextPtr->numTags);
+    }
+
+    /*
+     * Note that 0xff cannot occur in UTF-8 strings, so we can use this value as a separator.
+     */
+
+    while (segPtr != endPtr) {
+	if (segPtr->tagInfoPtr
+		&& (what & SEG_GROUP_TAG)
+		&& segPtr->tagInfoPtr != sharedTextPtr->emptyTagInfoPtr) {
+	    unsigned i = TkTextTagSetFindFirst(segPtr->tagInfoPtr);
+	    unsigned n = 0;
+
+	    for ( ; i != TK_TEXT_TAG_SET_NPOS; i = TkTextTagSetFindNext(segPtr->tagInfoPtr, i)) {
+		assert(sharedTextPtr->tagLookup[i]);
+		tagArrPtr[n++] = sharedTextPtr->tagLookup[i];
+	    }
+
+	    TkTextSortTags(n, tagArrPtr);
+
+	    for (i = 0; i < n; ++i) {
+		crc = ComputeChecksum(crc, "\xff\x00", 2);
+		crc = ComputeChecksum(crc, tagArrPtr[i]->name, 0);
+	    }
+	}
+	switch ((int) segPtr->typePtr->group) {
+	case SEG_GROUP_CHAR:
+	    if (what & SEG_GROUP_CHAR) {
+		crc = ComputeChecksum(crc, "\xff\x01", 0);
+		crc = ComputeChecksum(crc, segPtr->body.chars, segPtr->size);
+	    }
+	    break;
+	case SEG_GROUP_HYPHEN:
+	    if (what & SEG_GROUP_HYPHEN) {
+		crc = ComputeChecksum(crc, "\xff\x02", 0);
+	    }
+	    break;
+	case SEG_GROUP_WINDOW:
+	    if ((what & SEG_GROUP_WINDOW)) {
+		crc = ComputeChecksum(crc, "\xff\x03", 0);
+		crc = ComputeChecksum(crc, Tk_PathName(segPtr->body.ew.tkwin), 0);
+	    }
+	    break;
+	case SEG_GROUP_IMAGE:
+	    if ((what & SEG_GROUP_IMAGE) && segPtr->body.ei.name) {
+		crc = ComputeChecksum(crc, "\xff\x04", 0);
+		crc = ComputeChecksum(crc, segPtr->body.ei.name, 0);
+	    }
+	    break;
+	case SEG_GROUP_MARK:
+	    if ((what & SEG_GROUP_MARK) && TkTextIsNormalMark(segPtr)) {
+		const char *name;
+		const char *signature;
+
+		name = TkTextMarkName(sharedTextPtr, NULL, segPtr);
+		signature = (segPtr->typePtr == &tkTextRightMarkType) ? "\xff\x05" : "\xff\x06";
+		crc = ComputeChecksum(crc, signature, 0);
+		crc = ComputeChecksum(crc, name, 0);
+	    }
+	    break;
+	case SEG_GROUP_BRANCH:
+	    if (segPtr->typePtr == &tkTextBranchType && (what & TK_DUMP_DISPLAY)) {
+		segPtr = segPtr->body.branch.nextPtr;
+	    }
+	    break;
+	}
+	if (!(segPtr = segPtr->nextPtr)) {
+	    linePtr = linePtr->nextPtr;
+	    segPtr = linePtr->segPtr;
+	}
+    }
+
+    if ((what & SEG_GROUP_TAG)) {
+	free(tagArrPtr);
+    }
+    Tcl_SetObjResult(interp, Tcl_NewWideIntObj(crc));
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DumpSegment
+ *
+ *	Either append information about the current segment to the result, or
+ *	make a script callback with that information as arguments.
+ *
+ * Results:
+ *	Returns 'false' if the command callback made any changes to the text widget
+ *	which will have invalidated internal structures such as TkTextSegment,
+ *	TkTextIndex, pointers. Our caller can then take action to recompute
+ *	such entities, or he aborts with an error. Returns 'true' otherwise.
+ *
+ * Side effects:
+ *	Either evals the callback or appends elements to the result string.
+ *	The callback can have arbitrary side-effects.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+DumpSegment(
+    TkText *textPtr,
+    Tcl_Interp *interp,
+    const char *key,		/* Segment type key. */
+    const char *value,		/* Segment value. */
+    Tcl_Obj *command,		/* Script callback. */
+    const TkTextIndex *index,	/* index with line/byte position info. */
+    int what)			/* Look for TK_DUMP_INDEX bit. */
+{
+    char buffer[TK_POS_CHARS];
+    Tcl_Obj *values[3], *tuple;
+
+    TkTextPrintIndex(textPtr, index, buffer);
+    values[0] = Tcl_NewStringObj(key, -1);
+    values[1] = Tcl_NewStringObj(value, -1);
+    values[2] = Tcl_NewStringObj(buffer, -1);
+    tuple = Tcl_NewListObj(3, values);
+    if (!command) {
+	Tcl_ListObjAppendList(NULL, Tcl_GetObjResult(interp), tuple);
+	Tcl_DecrRefCount(tuple);
+	return true;
+    } else {
+	int oldStateEpoch = TkBTreeEpoch(textPtr->sharedTextPtr->tree);
+	Tcl_DString buf;
+	int code;
+
+	Tcl_DStringInit(&buf);
+	Tcl_DStringAppend(&buf, Tcl_GetString(command), -1);
+	Tcl_DStringAppend(&buf, " ", -1);
+	Tcl_DStringAppend(&buf, Tcl_GetString(tuple), -1);
+	code = Tcl_EvalEx(interp, Tcl_DStringValue(&buf), -1, 0);
+	Tcl_DStringFree(&buf);
+	if (code != TCL_OK) {
+	    Tcl_AddErrorInfo(interp, "\n    (segment dumping command executed by text)");
+	    Tcl_BackgroundException(interp, code);
+	}
+	Tcl_DecrRefCount(tuple);
+	return !(textPtr->flags & DESTROYED)
+		&& TkBTreeEpoch(textPtr->sharedTextPtr->tree) == oldStateEpoch;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextInspectOptions --
+ *
+ *	Build information from option table for "inspect".
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory is allocated for the result, if needed (standard Tcl result
+ *	side effects).
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+ObjIsEqual(
+    Tcl_Obj *obj1,
+    Tcl_Obj *obj2)
+{
+    char const *b1, *b2;
+    unsigned i, length;
+
+    assert(obj1);
+    assert(obj2);
+
+    b1 = Tcl_GetString(obj1);
+    b2 = Tcl_GetString(obj2);
+
+    if (strcmp(b1, "#ffffff") == 0) {
+	return strcmp(b2, "#ffffff") == 0 || strcmp(b2, "white") == 0;
+    }
+
+    if (strcmp(b1, "#000000") == 0) {
+	return strcmp(b2, "#000000") == 0 || strcmp(b2, "black") == 0;
+    }
+
+    length = GetByteLength(obj1);
+
+    if (length != GetByteLength(obj2)) {
+	return false;
+    }
+
+    for (i = 0; i < length; ++i) {
+	if (b1[i] != b2[i]) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+/*
+ * NOTE: This function should be moved to tkFont.c. I will not do this,
+ * because I won't touch any file not belonging to text widget implementation.
+ * So the Tk Team has to do this.
+ */
+static Tcl_Obj *
+GetFontAttrs(
+    TkText *textPtr,
+    int argc,
+    Tcl_Obj **args)
+{
+    Tcl_Interp *interp = textPtr->interp;
+    Tcl_Obj *objPtr = NULL;
+
+    if (Tk_FontObjCmd(textPtr->tkwin, interp, argc, args) == TCL_OK) {
+	Tcl_Obj *result = Tcl_GetObjResult(interp);
+	Tcl_Obj *family = NULL;
+	Tcl_Obj *size = NULL;
+	Tcl_Obj *slant = NULL;
+	Tcl_Obj *weight = NULL;
+	Tcl_Obj *underline = NULL;
+	Tcl_Obj *overstrike = NULL;
+	Tcl_Obj **objv;
+	int objc, i;
+
+	if (Tcl_ListObjGetElements(interp, result, &objc, &objv) == TCL_OK) {
+	    for (i = 0; i < objc - 1; ++i) {
+		if (Tcl_GetString(objv[i])[0] == '-') {
+		    switch (Tcl_GetString(objv[i])[1]) {
+		    case 'f': /* -family     */
+		    	family = objv[i + 1];
+			break;
+		    case 'o': /* -overstrike */
+		    	overstrike = objv[i + 1];
+			break;
+		    case 's':
+		    	switch (Tcl_GetString(objv[i])[2]) {
+			case 'i': /* -size   */
+			    size = objv[i + 1];
+			    break;
+			case 'l': /* -slant  */
+			    slant = objv[i + 1];
+			    break;
+			}
+			break;
+		    case 'u': /* -underline  */
+		    	underline = objv[i + 1];
+			break;
+		    case 'w': /* -weight     */
+		    	weight = objv[i + 1];
+			break;
+		    }
+		}
+	    }
+	}
+
+	if (family && size) {
+	    Tcl_DString str;
+	    int boolean;
+
+	    Tcl_DStringInit(&str);
+	    Tcl_DStringAppendElement(&str, Tcl_GetString(family));
+	    Tcl_DStringAppendElement(&str, Tcl_GetString(size));
+	    if (weight && strcmp(Tcl_GetString(weight), "normal") != 0) {
+		Tcl_DStringAppendElement(&str, Tcl_GetString(weight));
+	    }
+	    if (slant && strcmp(Tcl_GetString(slant), "roman") != 0) {
+		Tcl_DStringAppendElement(&str, Tcl_GetString(slant));
+	    }
+	    if (underline && Tcl_GetBooleanFromObj(NULL, underline, &boolean) == TCL_OK && boolean) {
+		Tcl_DStringAppendElement(&str, "underline");
+	    }
+	    if (overstrike && Tcl_GetBooleanFromObj(NULL, overstrike, &boolean) == TCL_OK && boolean) {
+		Tcl_DStringAppendElement(&str, "overstrike");
+	    }
+
+	    objPtr = Tcl_NewStringObj(Tcl_DStringValue(&str), Tcl_DStringLength(&str));
+	    Tcl_DStringFree(&str);
+	}
+
+	Tcl_ResetResult(interp);
+    }
+
+    return objPtr;
+}
+
+void
+TkTextInspectOptions(
+    TkText *textPtr,
+    const void *recordPtr,
+    Tk_OptionTable optionTable,
+    Tcl_DString *result,	/* should be already initialized */
+    bool resolveFontNames,
+    bool discardDefaultValues)
+{
+    Tcl_Obj *objPtr;
+    Tcl_Interp *interp = textPtr->interp;
+
+    Tcl_DStringTrunc(result, 0);
+
+    if ((objPtr = Tk_GetOptionInfo(interp, (char *) recordPtr, optionTable, NULL, textPtr->tkwin))) {
+	Tcl_Obj **objv;
+	Tcl_Obj *font = NULL;   /* shut up compiler */
+	Tcl_Obj *actual = NULL; /* shut up compiler */
+	int objc = 0;
+	int i;
+
+	Tcl_ListObjGetElements(interp, objPtr, &objc, &objv);
+
+	if (resolveFontNames) {
+	    Tcl_IncrRefCount(font = Tcl_NewStringObj("font", -1));
+	    Tcl_IncrRefCount(actual = Tcl_NewStringObj("actual", -1));
+	}
+
+	for (i = 0; i < objc; ++i) {
+	    Tcl_Obj **argv;
+	    int argc = 0;
+
+	    Tcl_ListObjGetElements(interp, objv[i], &argc, &argv);
+
+	    if (argc >= 5) { /* only if this option has a non-default value */
+		Tcl_Obj *val = argv[4];
+
+		if (GetByteLength(val) > 0) {
+		    Tcl_Obj *value = val;
+		    Tcl_Obj *name;
+		    int len;
+
+		    if (discardDefaultValues) {
+			Tcl_Obj *dflt = argv[3];
+
+			if (ObjIsEqual(dflt, val)) {
+			    continue;
+			}
+		    }
+
+		    name = argv[0];
+		    if (Tcl_DStringLength(result) > 0) {
+			Tcl_DStringAppend(result, " ", 1);
+		    }
+		    Tcl_DStringAppend(result, Tcl_GetString(name), GetByteLength(name));
+		    Tcl_DStringAppend(result, " ", 1);
+
+		    if (resolveFontNames
+			    && strcmp(Tcl_GetString(name), "-font") == 0
+			    && (Tcl_ListObjLength(interp, val, &len) != TCL_OK || len == 1)) {
+			const char *s = Tcl_GetString(val);
+			unsigned len = GetByteLength(val);
+
+			/*
+			 * Don't resolve font names like TkFixedFont, TkTextFont, etc.
+			 */
+
+			if (len < 7
+				|| strncmp(s, "Tk", 2) != 0
+				|| strncmp(s + len - 4, "Font", 4) != 0) {
+			    Tcl_Obj *args[3];
+			    Tcl_Obj *result;
+
+			    /*
+			     * Try to resolve the font name to the actual font attributes.
+			     */
+
+			    args[0] = font;
+			    args[1] = actual;
+			    args[2] = val;
+
+			    if ((result = GetFontAttrs(textPtr, 3, args))) {
+				value = result;
+			    }
+			}
+		    }
+
+		    Tcl_DStringAppendElement(result, Tcl_GetString(value));
+
+		    if (value != val) {
+			Tcl_DecrRefCount(value);
+		    }
+		}
+	    }
+	}
+
+	if (resolveFontNames) {
+	    Tcl_DecrRefCount(actual);
+	    Tcl_DecrRefCount(font);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextInspectCmd --
+ *
+ *	Return information about text and the associated tags.
+ *	About the format see documentation.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	Memory is allocated for the result, if needed (standard Tcl result
+ *	side effects).
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+GetBindings(
+    TkText *textPtr,
+    const char *name,
+    Tk_BindingTable bindingTable,
+    Tcl_DString *str)
+{
+    Tcl_Interp *interp = textPtr->interp;
+    Tcl_DString str2;
+    Tcl_Obj **argv;
+    int argc, i;
+
+    Tk_GetAllBindings(interp, bindingTable, (ClientData) name);
+    Tcl_ListObjGetElements(interp, Tcl_GetObjResult(interp), &argc, &argv);
+    Tcl_DStringInit(&str2);
+
+    for (i = 0; i < argc; ++i) {
+	const char *event = Tcl_GetString(argv[i]);
+	const char *binding = Tk_GetBinding(interp, bindingTable, (ClientData) name, event);
+	char *p;
+
+	Tcl_ListObjGetElements(interp, Tcl_GetObjResult(interp), &argc, &argv);
+
+	Tcl_DStringStartSublist(str);
+	Tcl_DStringAppendElement(str, "bind");
+	Tcl_DStringAppendElement(str, name);
+	Tcl_DStringAppendElement(str, event);
+
+	Tcl_DStringTrunc(&str2, 0);
+	p = strchr(binding, '\n');
+	while (p) {
+	    Tcl_DStringAppend(&str2, binding, p - binding);
+	    Tcl_DStringAppend(&str2, "; ", 2);
+	    binding = p + 1;
+	    p = strchr(binding, '\n');
+	}
+	Tcl_DStringAppend(&str2, binding, -1);
+
+	Tcl_DStringAppendElement(str, Tcl_DStringValue(&str2));
+	Tcl_DStringEndSublist(str);
+    }
+
+    Tcl_DStringFree(&str2);
+    Tcl_ResetResult(interp);
+}
+
+static int
+TextInspectCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    TkSharedText *sharedTextPtr;
+    TkTextTag *prevTagPtr;
+    TkTextSegment *nextPtr;
+    TkTextSegment *prevPtr;
+    Tcl_DString buf[2];
+    Tcl_DString *str = &buf[0];
+    Tcl_DString *opts = &buf[1];
+    TkTextTag **tagArray;
+    TkTextTag *tagPtr;
+    TkTextTag *tPtr;
+    unsigned tagArrSize;
+    unsigned epoch;
+    unsigned what;
+    bool closeSubList;
+    int result;
+
+    result = GetDumpFlags(textPtr, interp, objc, objv, TK_DUMP_INSPECT_ALL, TK_DUMP_INSPECT_DFLT,
+	    &what, NULL, NULL, NULL, NULL);
+    if (result != TCL_OK) {
+	return result;
+    }
+
+    Tcl_DStringInit(str);
+    Tcl_DStringInit(opts);
+    sharedTextPtr = textPtr->sharedTextPtr;
+    epoch = sharedTextPtr->inspectEpoch;
+    tagPtr = textPtr->selTagPtr; /* any non-null value */
+    nextPtr = textPtr->startMarker;
+    closeSubList = false;
+    prevTagPtr = NULL;
+    prevPtr = NULL;
+    tagArrSize = 128;
+    tagArray = malloc(tagArrSize * sizeof(tagArray[0]));
+
+    assert(textPtr->selTagPtr->textPtr == textPtr);
+    if (what & TK_DUMP_DISCARD_SEL) {
+	/* this little trick is discarding the "sel" tag */
+	textPtr->selTagPtr->textPtr = (TkText *) textPtr->selTagPtr;
+    }
+
+    if (what & TK_DUMP_TEXT_CONFIGS) {
+	TkTextInspectOptions(textPtr, textPtr, textPtr->optionTable, opts,
+		!(what & TK_DUMP_DONT_RESOLVE), false);
+	Tcl_DStringStartSublist(str);
+	Tcl_DStringAppendElement(str, "setup");
+	Tcl_DStringAppendElement(str, Tk_PathName(textPtr->tkwin));
+	Tcl_DStringAppendElement(str, Tcl_DStringValue(opts));
+	Tcl_DStringEndSublist(str);
+    }
+
+    if (what & TK_DUMP_TAG_CONFIGS) {
+	TkTextTag **tags = textPtr->sharedTextPtr->tagLookup;
+	unsigned n = textPtr->sharedTextPtr->numTags;
+	unsigned i;
+
+	for (i = 0; i < n; ++i) {
+	    TkTextTag *tagPtr = tags[i];
+
+	    if (tagPtr && (!(what & TK_DUMP_DISCARD_SEL) || tagPtr != textPtr->selTagPtr)) {
+		TkTextInspectOptions(textPtr, tagPtr, tagPtr->optionTable, opts,
+			!(what & TK_DUMP_DONT_RESOLVE), true);
+		    Tcl_DStringStartSublist(str);
+		    Tcl_DStringAppendElement(str, "configure");
+		    Tcl_DStringAppendElement(str, tagPtr->name);
+		    if (Tcl_DStringLength(opts) > 2) {
+			Tcl_DStringAppendElement(str, Tcl_DStringValue(opts));
+		    }
+		    Tcl_DStringEndSublist(str);
+	    }
+	}
+    }
+
+    if (what & TK_DUMP_TAG_BINDINGS) {
+	TkTextTag **tags = textPtr->sharedTextPtr->tagLookup;
+	unsigned n = textPtr->sharedTextPtr->numTags;
+	unsigned i;
+
+	for (i = 0; i < n; ++i) {
+	    TkTextTag *tagPtr = tags[i];
+
+	    if (tagPtr && (!(what & TK_DUMP_DISCARD_SEL) || tagPtr != textPtr->selTagPtr)) {
+		GetBindings(textPtr, tagPtr->name, sharedTextPtr->tagBindingTable, str);
+	    }
+	}
+    }
+
+    do {
+	TkTextSegment *segPtr = nextPtr;
+	unsigned group = segPtr->typePtr->group;
+	const char *value = NULL;
+	const char *type = NULL;
+	bool printTags = false;
+
+	nextPtr = segPtr->nextPtr;
+
+	switch (group) {
+	case SEG_GROUP_BRANCH:
+	    if (segPtr->typePtr == &tkTextBranchType && (what & TK_DUMP_DISPLAY)) {
+		segPtr = segPtr->body.branch.nextPtr;
+		nextPtr = segPtr->nextPtr;
+	    }
+	    if (!(what & SEG_GROUP_BRANCH)) {
+		continue;
+	    }
+	    type = "elide";
+	    value = (segPtr->typePtr == &tkTextBranchType) ? "on" : "off";
+	    break;
+	case SEG_GROUP_IMAGE:
+	    if (!(what & SEG_GROUP_IMAGE) || !segPtr->body.ei.name) {
+		continue;
+	    }
+	    type = "image";
+	    TkTextInspectOptions(textPtr, &segPtr->body.ei, segPtr->body.ei.optionTable, opts,
+		    false, false);
+	    value = Tcl_DStringValue(opts);
+	    printTags = !!(what & TK_DUMP_TAG);
+	    break;
+	case SEG_GROUP_WINDOW:
+	    if (!(what & SEG_GROUP_WINDOW) || !segPtr->body.ew.tkwin) {
+		continue;
+	    }
+	    type = "window";
+	    TkTextInspectOptions(textPtr, &segPtr->body.ew, segPtr->body.ew.optionTable, opts,
+		    false, false);
+	    value = Tcl_DStringValue(opts);
+	    printTags = !!(what & TK_DUMP_TAG);
+	    break;
+	case SEG_GROUP_MARK:
+	    if (segPtr == textPtr->endMarker) {
+		if (prevPtr != segPtr
+		    	&& (what & SEG_GROUP_CHAR)
+			&& segPtr->sectionPtr->linePtr != TkBTreeGetLastLine(textPtr)) {
+		    /* print newline before finishing */
+		    type = "break";
+		    printTags = !!(what & TK_DUMP_TAG);
+		    tagPtr = TkBTreeGetSegmentTags(sharedTextPtr,
+			    segPtr->sectionPtr->linePtr->lastPtr, textPtr);
+		    nextPtr = segPtr; /* repeat this mark */
+		} else {
+		    nextPtr = NULL; /* finished */
+		}
+	    } else if (!(what & SEG_GROUP_MARK)) {
+		continue;
+	    } else if (!TkTextIsNormalMark(segPtr)
+		    && (!(what & TK_DUMP_INSERT_MARK) || segPtr != textPtr->insertMarkPtr)) {
+		continue;
+	    } else {
+		type = (segPtr->typePtr == &tkTextLeftMarkType ? "left" : "right");
+		value = TkTextMarkName(sharedTextPtr, textPtr, segPtr);
+	    }
+	    break;
+	case SEG_GROUP_HYPHEN:
+	    if (!(what & SEG_GROUP_HYPHEN)) {
+		continue;
+	    }
+	    printTags = !!(what & TK_DUMP_TAG);
+	    type = "hyphen";
+	    break;
+	case SEG_GROUP_CHAR:
+	    if (what & SEG_GROUP_CHAR) {
+		printTags = !!(what & TK_DUMP_TAG);
+		if (prevPtr == segPtr || *segPtr->body.chars == '\n') {
+		    type = "break";
+		    nextPtr = segPtr->sectionPtr->linePtr->nextPtr->segPtr;
+		    if (prevPtr == segPtr) {
+			tagPtr = prevTagPtr;
+			segPtr->body.chars[segPtr->size - 1] = '\n';
+		    } else if (type && printTags) {
+			tagPtr = TkBTreeGetSegmentTags(sharedTextPtr, segPtr, textPtr);
+		    }
+		} else {
+		    type = "text";
+		    if (segPtr->size > 1 && segPtr->body.chars[segPtr->size - 1] == '\n') {
+			nextPtr = segPtr; /* repeat this char segment */
+			segPtr->body.chars[segPtr->size - 1] = '\0';
+		    }
+		    value = segPtr->body.chars;
+		    if (printTags) {
+			tagPtr = TkBTreeGetSegmentTags(sharedTextPtr, segPtr, textPtr);
+		    }
+		}
+	    } else if (!nextPtr) {
+		nextPtr = segPtr->sectionPtr->linePtr->nextPtr->segPtr;
+	    }
+	    break;
+	default:
+	    continue;
+	}
+
+	if (closeSubList) {
+	    if (what & TK_DUMP_NESTED) {
+		unsigned nextEpoch = epoch + 1;
+		unsigned numTags = 0;
+		unsigned i;
+
+		for (tPtr = tagPtr; tPtr; tPtr = tPtr->nextPtr) {
+		    if (tPtr->flag == epoch) {
+			tPtr->flag = nextEpoch; /* mark as still open */
+		    }
+		}
+
+		for ( ; prevTagPtr; prevTagPtr = prevTagPtr->succPtr) {
+		    if (prevTagPtr->flag == epoch) { /* should be closed? */
+			if (numTags == tagArrSize) {
+			    tagArrSize *= 2;
+			    tagArray = realloc(tagArray, tagArrSize * sizeof(tagArray[0]));
+			}
+			tagArray[numTags++] = prevTagPtr;
+			prevTagPtr->flag = 0; /* mark as closed */
+		    }
+		}
+
+		Tcl_DStringStartSublist(str);
+		TkTextSortTags(numTags, tagArray);
+		for (i = 0; i < numTags; ++i) {
+		    Tcl_DStringAppendElement(str, tagArray[i]->name);
+		}
+		Tcl_DStringEndSublist(str);
+	    }
+
+	    prevTagPtr = NULL;
+	    closeSubList = false;
+	    Tcl_DStringEndSublist(str);
+	}
+
+	if (type) {
+	    Tcl_DStringStartSublist(str);
+	    Tcl_DStringAppendElement(str, type);
+	    if (value) {
+		Tcl_DStringAppendElement(str, value);
+	    }
+	    closeSubList = true;
+
+	    if (printTags) {
+		unsigned numTags = 0;
+		unsigned i;
+
+		prevTagPtr = tagPtr;
+
+		if (what & TK_DUMP_NESTED) {
+		    epoch += 1;
+
+		    for (tPtr = tagPtr; tPtr; tPtr = tPtr->nextPtr) {
+			if (tPtr->flag != epoch) { /* should be opened? */
+			    if (numTags == tagArrSize) {
+				tagArrSize *= 2;
+				tagArray = realloc(tagArray, tagArrSize * sizeof(tagArray[0]));
+			    }
+			    tagArray[numTags++] = tPtr;
+			    tPtr->flag = epoch; /* mark as open */
+			}
+			tPtr->succPtr = tPtr->nextPtr;
+		    }
+		} else {
+		    for (tPtr = tagPtr; tPtr; tPtr = tPtr->nextPtr) {
+			if (numTags == tagArrSize) {
+			    tagArrSize *= 2;
+			    tagArray = realloc(tagArray, tagArrSize * sizeof(tagArray[0]));
+			}
+			tagArray[numTags++] = tPtr;
+		    }
+		}
+
+		Tcl_DStringStartSublist(str);
+		TkTextSortTags(numTags, tagArray);
+		for (i = 0; i < numTags; ++i) {
+		    Tcl_DStringAppendElement(str, tagArray[i]->name);
+		}
+		Tcl_DStringEndSublist(str);
+	    }
+	}
+
+	prevPtr = segPtr;
+    } while (nextPtr);
+
+    Tcl_SetObjResult(interp, Tcl_NewStringObj(Tcl_DStringValue(str), Tcl_DStringLength(str)));
+    Tcl_DStringFree(str);
+    Tcl_DStringFree(opts);
+
+    textPtr->selTagPtr->textPtr = textPtr; /* restore */
+    sharedTextPtr->inspectEpoch = epoch;
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * InspectRetainedUndoItems --
+ *
+ *	Return information about content of retained undo items, these
+ *	items are not yet pushed onto undo stack.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory is allocated for the result.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+InspectRetainedUndoItems(
+    const TkSharedText *sharedTextPtr,
+    Tcl_Obj *objPtr)
+{
+    if (sharedTextPtr->undoTagListCount > 0 || sharedTextPtr->undoMarkListCount > 0) {
+	Tcl_Obj *resultPtr = Tcl_NewObj();
+	int i;
+
+	for (i = 0; i < sharedTextPtr->undoTagListCount; ++i) {
+	    TkTextInspectUndoTagItem(sharedTextPtr, sharedTextPtr->undoTagList[i], resultPtr);
+	}
+
+	for (i = 0; i < sharedTextPtr->undoMarkListCount; ++i) {
+	    TkTextInspectUndoMarkItem(sharedTextPtr, &sharedTextPtr->undoMarkList[i], resultPtr);
+	}
+
+	Tcl_ListObjLength(NULL, resultPtr, &i);
+	if (i == 0) {
+	    Tcl_IncrRefCount(resultPtr);
+	    Tcl_DecrRefCount(resultPtr);
+	} else {
+	    Tcl_ListObjAppendElement(NULL, objPtr, resultPtr);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * InspectUndoStack --
+ *
+ *	Return information about content of undo/redo stack.
+ *
+ * Results:
+ *	A Tcl object.
+ *
+ * Side effects:
+ *	Memory is allocated for the result.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+InspectUndoStack(
+    const TkSharedText *sharedTextPtr,
+    InspectUndoStackProc firstAtomProc,
+    InspectUndoStackProc nextAtomProc,
+    Tcl_Obj *objPtr)
+{
+    TkTextUndoStack undoStack;
+    const TkTextUndoAtom *atom;
+    Tcl_Obj *atomPtr;
+    unsigned i;
+
+    assert(sharedTextPtr->undoStack);
+
+    undoStack = sharedTextPtr->undoStack;
+
+    for (atom = firstAtomProc(undoStack); atom; atom = nextAtomProc(undoStack)) {
+	atomPtr = Tcl_NewObj();
+
+	for (i = 0; i < atom->arraySize; ++i) {
+	    const TkTextUndoToken *token = (const TkTextUndoToken *) atom->array[i].item;
+	    Tcl_Obj *subAtomPtr = token->undoType->inspectProc(sharedTextPtr, token);
+	    Tcl_ListObjAppendElement(NULL, atomPtr, subAtomPtr);
+	}
+
+	Tcl_ListObjAppendElement(NULL, objPtr, atomPtr);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextEditCmd --
+ *
+ *	Handle the subcommands to "$text edit ...". See documentation for
+ *	details.
+ *
+ * Results:
+ *	None
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+GetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *token)
+{
+    assert(token->undoType->commandProc);
+    return token->undoType->commandProc(sharedTextPtr, token);
+}
+
+static int
+TextEditCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+    int index;
+    bool setModified, oldModified;
+    TkSharedText *sharedTextPtr;
+    static const char *const editOptionStrings[] = {
+	"altered",
+#if SUPPORT_DEPRECATED_CANUNDO_REDO
+	"canredo", "canundo",
+#endif /* SUPPORT_DEPRECATED_CANUNDO_REDO */
+	"info", "inspect", "irreversible", "modified", "recover", "redo", "reset",
+	"separator", "undo", NULL
+    };
+    enum editOptions {
+	EDIT_ALTERED,
+#if SUPPORT_DEPRECATED_CANUNDO_REDO
+	EDIT_CANREDO, EDIT_CANUNDO,
+#endif /* SUPPORT_DEPRECATED_CANUNDO_REDO */
+	EDIT_INFO, EDIT_INSPECT, EDIT_IRREVERSIBLE, EDIT_MODIFIED, EDIT_RECOVER, EDIT_REDO, EDIT_RESET,
+	EDIT_SEPARATOR, EDIT_UNDO
+    };
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+
+    if (objc < 3) {
+	Tcl_WrongNumArgs(interp, 2, objv, "option ?arg ...?");
+	return TCL_ERROR;
+    }
+    if (Tcl_GetIndexFromObjStruct(interp, objv[2], editOptionStrings,
+	    sizeof(char *), "edit option", 0, &index) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    switch ((enum editOptions) index) {
+    case EDIT_ALTERED:
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "?boolean?");
+	    return TCL_ERROR;
+	}
+	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(sharedTextPtr->isAltered));
+	return TCL_OK;
+	break;
+#if SUPPORT_DEPRECATED_CANUNDO_REDO
+    case EDIT_CANREDO: {
+	static bool warnDeprecated = true;
+	bool canRedo = false;
+
+	if (warnDeprecated) {
+	    warnDeprecated = false;
+	    fprintf(stderr, "Command \"edit canredo\" is deprecated, please use \"edit info\"\n");
+	}
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	     return TCL_ERROR;
+	}
+	if (textPtr->sharedTextPtr->undoStack) {
+	    canRedo = TkTextUndoGetCurrentRedoStackDepth(textPtr->sharedTextPtr->undoStack) > 0;
+	}
+	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(canRedo));
+	break;
+    }
+    case EDIT_CANUNDO: {
+	static bool warnDeprecated = true;
+	bool canUndo = false;
+
+	if (warnDeprecated) {
+	    warnDeprecated = false;
+	    fprintf(stderr, "Command \"edit canundo\" is deprecated, please use \"edit info\"\n");
+	}
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	     return TCL_ERROR;
+	}
+	if (textPtr->sharedTextPtr->undo) {
+	    canUndo = TkTextUndoGetCurrentUndoStackDepth(textPtr->sharedTextPtr->undoStack) > 0;
+	}
+	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(canUndo));
+	break;
+    }
+#endif /* SUPPORT_DEPRECATED_CANUNDO_REDO */
+    case EDIT_INFO:
+	if (objc != 3 && objc != 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "?array?");
+	    return TCL_ERROR;
+	} else {
+	    Tcl_SetObjResult(textPtr->interp, MakeEditInfo(interp, textPtr, objc == 4 ? objv[3] : NULL));
+	}
+    	break;
+    case EDIT_INSPECT:
+	if (objc != 3 && objc != 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "?stack?");
+	    return TCL_ERROR;
+	} else {
+	    char const *stack = (objc == 4) ? Tcl_GetString(objv[3]) : NULL;
+
+	    if (stack && strcmp(stack, "undo") != 0 && strcmp(stack, "redo") != 0) {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+			"bad stack argument \"%s\": must be \"undo\" or \"redo\"", stack));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "STACK_VALUE", NULL);
+		return TCL_ERROR;
+	    }
+	    if (sharedTextPtr->undoStack) {
+		Tcl_Obj *undoResultPtr = NULL;
+		Tcl_Obj *redoResultPtr = NULL;
+
+		if (!stack || stack[0] == 'u') {
+		    undoResultPtr = Tcl_NewObj();
+		    InspectRetainedUndoItems(sharedTextPtr, undoResultPtr);
+		    InspectUndoStack(sharedTextPtr, TkTextUndoFirstUndoAtom,
+			    TkTextUndoNextUndoAtom, undoResultPtr);
+		}
+		if (!stack || stack[0] == 'r') {
+		    redoResultPtr = Tcl_NewObj();
+		    InspectUndoStack(sharedTextPtr, TkTextUndoFirstRedoAtom,
+			    TkTextUndoNextRedoAtom, redoResultPtr);
+		}
+		if (!stack) {
+		    Tcl_Obj *objPtr = Tcl_NewObj();
+		    Tcl_ListObjAppendElement(NULL, objPtr, undoResultPtr);
+		    Tcl_ListObjAppendElement(NULL, objPtr, redoResultPtr);
+		    Tcl_SetObjResult(interp, objPtr);
+		} else if (stack[0] == 'u') {
+		    Tcl_SetObjResult(interp, undoResultPtr);
+		} else {
+		    Tcl_SetObjResult(interp, redoResultPtr);
+		}
+	    }
+	}
+	break;
+    case EDIT_IRREVERSIBLE:
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "?boolean?");
+	    return TCL_ERROR;
+	}
+	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(sharedTextPtr->isIrreversible));
+	break;
+    case EDIT_MODIFIED:
+	if (objc == 3) {
+	    Tcl_SetObjResult(interp, Tcl_NewBooleanObj(sharedTextPtr->isModified));
+	    return TCL_OK;
+	} else if (objc != 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "?boolean?");
+	    return TCL_ERROR;
+	} else if (Tcl_GetBooleanFromObj(interp, objv[3], (int *) &setModified) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+
+	/*
+	 * Set or reset the modified status, and trigger a <<Modified>> event.
+	 */
+
+	oldModified = sharedTextPtr->isModified;
+	sharedTextPtr->isModified = setModified;
+
+	/*
+	 * Setting the flag to 'false' is clearing the user's decision.
+	 */
+
+	sharedTextPtr->userHasSetModifiedFlag = setModified;
+	if (sharedTextPtr->undoStack) {
+	    sharedTextPtr->undoLevel = TkTextUndoGetCurrentUndoStackDepth(sharedTextPtr->undoStack);
+	}
+
+	/*
+	 * Only issue the <<Modified>> event if the flag actually changed.
+	 * However, degree of modified-ness doesn't matter. [Bug 1799782]
+	 */
+
+	assert(setModified == true || setModified == false);
+
+	if (oldModified != setModified) {
+	    GenerateEvent(textPtr->sharedTextPtr, "Modified");
+	}
+	break;
+    case EDIT_RECOVER:
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	    return TCL_ERROR;
+	}
+	if (sharedTextPtr->undoStack) {
+	    int redoDepth;
+
+	    if (TkTextUndoIsPerformingUndoRedo(sharedTextPtr->undoStack)) {
+		ErrorNotAllowed(interp, "cannot recover inside undo/redo operation");
+		return TCL_ERROR;
+	    }
+
+	    redoDepth = TkTextUndoGetMaxRedoDepth(sharedTextPtr->undoStack);
+	    PushRetainedUndoTokens(sharedTextPtr);
+	    TkTextUndoSetMaxStackDepth(sharedTextPtr->undoStack, textPtr->maxUndoDepth, 0);
+
+	    while (TkTextUndoGetCurrentUndoStackDepth(sharedTextPtr->undoStack) > 0) {
+		TkTextUndoDoUndo(sharedTextPtr->undoStack);
+	    }
+
+	    TkTextUndoSetMaxStackDepth(sharedTextPtr->undoStack, textPtr->maxUndoDepth, redoDepth);
+	}
+    	break;
+    case EDIT_REDO:
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	    return TCL_ERROR;
+	}
+	if (sharedTextPtr->undoStack) {
+	    /*
+	     * It's possible that this command command will be invoked inside the "watch" callback,
+	     * but this is not allowed when performing undo/redo.
+	     */
+
+	    if (TkTextUndoIsPerformingUndoRedo(sharedTextPtr->undoStack)) {
+		ErrorNotAllowed(interp, "cannot redo inside undo/redo operation");
+		return TCL_ERROR;
+	    }
+
+	    if (TkTextUndoGetCurrentRedoStackDepth(sharedTextPtr->undoStack) == 0) {
+		Tcl_SetObjResult(interp, Tcl_NewStringObj("nothing to redo", -1));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "NO_REDO", NULL);
+		return TCL_ERROR;
+	    }
+
+	    PushRetainedUndoTokens(sharedTextPtr);
+	    TkTextUndoDoRedo(sharedTextPtr->undoStack);
+	}
+	break;
+    case EDIT_RESET:
+	if (objc == 3) {
+	    if (sharedTextPtr->undoStack) {
+		/*
+		 * It's possible that this command command will be invoked inside the "watch" callback,
+		 * but this is not allowed when performing undo/redo.
+		 */
+
+		if (TkTextUndoIsPerformingUndoRedo(sharedTextPtr->undoStack)) {
+		    ErrorNotAllowed(interp, "cannot reset stack inside undo/redo operation");
+		    return TCL_ERROR;
+		}
+
+		TkTextUndoClearStack(sharedTextPtr->undoStack);
+		sharedTextPtr->undoLevel = 0;
+		sharedTextPtr->isAltered = false;
+		sharedTextPtr->isIrreversible = false;
+		TkTextUpdateAlteredFlag(sharedTextPtr);
+	    }
+	    return TCL_OK;
+	} else if (objc != 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "?stack?");
+	    return TCL_ERROR;
+	} else {
+	    char const *stack = Tcl_GetString(objv[3]);
+
+	    if (strcmp(stack, "undo") != 0 && strcmp(stack, "redo") != 0) {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+			"bad stack argument \"%s\": must be \"undo\" or \"redo\"", stack));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "STACK_VALUE", NULL);
+		return TCL_ERROR;
+	    }
+	    if (sharedTextPtr->undoStack) {
+		if (TkTextUndoIsPerformingUndoRedo(sharedTextPtr->undoStack)) {
+		    /*
+		     * It's possible that this command command will be invoked inside
+		     * the "watch" callback, but this is not allowed when performing
+		     * undo/redo.
+		     */
+
+		    ErrorNotAllowed(interp, "cannot reset stack inside undo/redo operation");
+		    return TCL_ERROR;
+		}
+		if (stack[0] == 'u') {
+		    TkTextUndoClearUndoStack(sharedTextPtr->undoStack);
+		    sharedTextPtr->undoLevel = 0;
+		    sharedTextPtr->isAltered = false;
+		    sharedTextPtr->isIrreversible = false;
+		    TkTextUpdateAlteredFlag(sharedTextPtr);
+		} else {
+		    TkTextUndoClearRedoStack(sharedTextPtr->undoStack);
+		}
+	    }
+	    return TCL_ERROR;
+	}
+	break;
+    case EDIT_SEPARATOR: {
+	bool immediately = false;
+
+	if (objc == 4) {
+	    if (strcmp(Tcl_GetString(objv[3]), "-immediately")) {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+			"bad option \"%s\": must be -immediately", Tcl_GetString(objv[3])));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "INDEX_OPTION", NULL);
+		return TCL_ERROR;
+	    }
+	    immediately = true;
+	} else if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	    return TCL_ERROR;
+	}
+	if (sharedTextPtr->undoStack) {
+	    if (immediately) {
+		PushRetainedUndoTokens(sharedTextPtr);
+	    }
+	    TkTextUndoPushSeparator(sharedTextPtr->undoStack, immediately);
+	    sharedTextPtr->lastUndoTokenType = -1;
+	}
+	break;
+    }
+    case EDIT_UNDO:
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	    return TCL_ERROR;
+	}
+	if (sharedTextPtr->undoStack) {
+	    /*
+	     * It's possible that this command command will be invoked inside the "watch" callback,
+	     * but this is not allowed when performing undo/redo.
+	     */
+
+	    if (TkTextUndoIsPerformingUndoRedo(sharedTextPtr->undoStack)) {
+		ErrorNotAllowed(interp, "cannot undo inside undo/redo operation");
+		return TCL_ERROR;
+	    }
+
+	    PushRetainedUndoTokens(sharedTextPtr);
+
+	    if (TkTextUndoGetCurrentUndoStackDepth(sharedTextPtr->undoStack) == 0) {
+		Tcl_SetObjResult(interp, Tcl_NewStringObj("nothing to undo", -1));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "NO_UNDO", NULL);
+		return TCL_ERROR;
+	    }
+
+	    TkTextUndoDoUndo(sharedTextPtr->undoStack);
+	}
+	break;
+    }
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * MakeEditInfo --
+ *
+ *	Returns the array containing the "edit info" information.
+ *
+ * Results:
+ *	Tcl_Obj of list type containing the required information.
+ *
+ * Side effects:
+ *	Some memory will be allocated:
+ *
+ *----------------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+MakeEditInfo(
+    Tcl_Interp *interp,		/* Current interpreter. */
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Obj *arrayPtr)		/* Name of array, may be NULL. */
+{
+    enum {
+	INFO_UNDOSTACKSIZE, INFO_REDOSTACKSIZE, INFO_UNDODEPTH, INFO_REDODEPTH,
+	INFO_UNDOBYTESIZE, INFO_REDOBYTESIZE, INFO_UNDOCOMMANDS, INFO_REDOCOMMANDS,
+	INFO_BYTESIZE, INFO_TOTALBYTESIZE, INFO_LINES, INFO_TOTALLINES, INFO_IMAGES,
+	INFO_WINDOWS, INFO_DISPIMAGES, INFO_DISPWINDOWS, INFO_TAGS, INFO_USEDTAGS,
+	INFO_MARKS, INFO_GENERATEDMARKS, INFO_LINESPERNODE,
+	INFO_LAST /* must be last item */
+    };
+
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    TkTextUndoStack st = sharedTextPtr->undoStack;
+    Tcl_Obj *var = arrayPtr ? arrayPtr : Tcl_NewStringObj("", 0);
+    Tcl_Obj *name[INFO_LAST];
+    Tcl_Obj *value[INFO_LAST];
+    int usedTags, i;
+
+    name[INFO_UNDOSTACKSIZE ] = Tcl_NewStringObj("undostacksize", -1);
+    name[INFO_REDOSTACKSIZE ] = Tcl_NewStringObj("redostacksize", -1);
+    name[INFO_UNDODEPTH     ] = Tcl_NewStringObj("undodepth", -1);
+    name[INFO_REDODEPTH     ] = Tcl_NewStringObj("redodepth", -1);
+    name[INFO_UNDOBYTESIZE  ] = Tcl_NewStringObj("undobytesize", -1);
+    name[INFO_REDOBYTESIZE  ] = Tcl_NewStringObj("redobytesize", -1);
+    name[INFO_UNDOCOMMANDS  ] = Tcl_NewStringObj("undocommands", -1);
+    name[INFO_REDOCOMMANDS  ] = Tcl_NewStringObj("redocommands", -1);
+    name[INFO_BYTESIZE      ] = Tcl_NewStringObj("bytesize", -1);
+    name[INFO_TOTALBYTESIZE ] = Tcl_NewStringObj("totalbytesize", -1);
+    name[INFO_LINES         ] = Tcl_NewStringObj("lines", -1);
+    name[INFO_TOTALLINES    ] = Tcl_NewStringObj("totallines", -1);
+    name[INFO_IMAGES        ] = Tcl_NewStringObj("images", -1);
+    name[INFO_WINDOWS       ] = Tcl_NewStringObj("windows", -1);
+    name[INFO_DISPIMAGES    ] = Tcl_NewStringObj("visibleimages", -1);
+    name[INFO_DISPWINDOWS   ] = Tcl_NewStringObj("visiblewindows", -1);
+    name[INFO_TAGS          ] = Tcl_NewStringObj("tags", -1);
+    name[INFO_USEDTAGS      ] = Tcl_NewStringObj("usedtags", -1);
+    name[INFO_MARKS         ] = Tcl_NewStringObj("marks", -1);
+    name[INFO_GENERATEDMARKS] = Tcl_NewStringObj("generatedmarks", -1);
+    name[INFO_LINESPERNODE  ] = Tcl_NewStringObj("linespernode", -1);
+
+    if (st) {
+	const TkTextUndoAtom *atom;
+	Tcl_Obj *listPtr;
+
+	value[INFO_UNDOSTACKSIZE] = Tcl_NewIntObj(TkTextUndoCountUndoItems(st));
+	value[INFO_REDOSTACKSIZE] = Tcl_NewIntObj(TkTextUndoCountRedoItems(st));
+	value[INFO_UNDODEPTH    ] = Tcl_NewIntObj(TkTextUndoGetCurrentUndoStackDepth(st));
+	value[INFO_REDODEPTH    ] = Tcl_NewIntObj(TkTextUndoGetCurrentRedoStackDepth(st));
+	value[INFO_UNDOBYTESIZE ] = Tcl_NewIntObj(TkTextUndoGetCurrentUndoSize(st));
+	value[INFO_REDOBYTESIZE ] = Tcl_NewIntObj(TkTextUndoGetCurrentRedoSize(st));
+	value[INFO_UNDOCOMMANDS ] = Tcl_NewObj();
+	value[INFO_REDOCOMMANDS ] = Tcl_NewObj();
+
+	listPtr = value[TkTextUndoIsPerformingUndo(st) ? INFO_REDOCOMMANDS : INFO_UNDOCOMMANDS];
+
+	for (i = sharedTextPtr->undoTagListCount - 1; i >= 0; --i) {
+	    const TkTextTag *tagPtr = sharedTextPtr->undoTagList[i];
+
+	    if (tagPtr->recentTagAddRemoveToken && !tagPtr->recentTagAddRemoveTokenIsNull) {
+		Tcl_ListObjAppendElement(interp, listPtr,
+			GetCommand(sharedTextPtr, tagPtr->recentTagAddRemoveToken));
+	    }
+	    if (tagPtr->recentChangePriorityToken && tagPtr->savedPriority != tagPtr->priority) {
+		Tcl_ListObjAppendElement(interp, listPtr,
+			GetCommand(sharedTextPtr, tagPtr->recentTagAddRemoveToken));
+	    }
+	}
+
+	for (i = sharedTextPtr->undoMarkListCount - 1; i >= 0; --i) {
+	    const TkTextMarkChange *changePtr = &sharedTextPtr->undoMarkList[i];
+
+	    if (changePtr->setMark) {
+		Tcl_ListObjAppendElement(interp, listPtr,
+			GetCommand(sharedTextPtr, changePtr->setMark));
+	    }
+	    if (changePtr->moveMark) {
+		Tcl_ListObjAppendElement(interp, listPtr,
+			GetCommand(sharedTextPtr, changePtr->moveMark));
+	    }
+	    if (changePtr->toggleGravity) {
+		Tcl_ListObjAppendElement(interp, listPtr,
+			GetCommand(sharedTextPtr, changePtr->toggleGravity));
+	    }
+	}
+
+	atom = TkTextUndoIsPerformingUndo(st) ?
+		TkTextUndoCurrentRedoAtom(st) : TkTextUndoCurrentUndoAtom(st);
+
+	if (atom) {
+	    for (i = atom->arraySize - 1; i >= 0; --i) {
+		const TkTextUndoSubAtom *subAtom = atom->array + i;
+		TkTextUndoToken *token = subAtom->item;
+
+		Tcl_ListObjAppendElement(interp, listPtr, GetCommand(sharedTextPtr, token));
+	    }
+	}
+    } else {
+	value[INFO_UNDOSTACKSIZE] =
+		value[INFO_REDOSTACKSIZE] =
+		value[INFO_UNDODEPTH] =
+		value[INFO_REDODEPTH] =
+		value[INFO_UNDOBYTESIZE] =
+		value[INFO_REDOBYTESIZE] = Tcl_NewIntObj(0);
+	value[INFO_UNDOCOMMANDS] = value[INFO_REDOCOMMANDS] = Tcl_NewObj();
+    }
+
+    usedTags = TkTextTagSetCount(TkBTreeRootTagInfo(sharedTextPtr->tree));
+
+    /* Related to this widget */
+
+    value[INFO_BYTESIZE      ] = Tcl_NewIntObj(TkBTreeSize(sharedTextPtr->tree, textPtr));
+    value[INFO_LINES         ] = Tcl_NewIntObj(TkBTreeNumLines(sharedTextPtr->tree, textPtr));
+    value[INFO_DISPIMAGES    ] = Tcl_NewIntObj(TkTextCountVisibleImages(textPtr));
+    value[INFO_DISPWINDOWS   ] = Tcl_NewIntObj(TkTextCountVisibleWindows(textPtr));
+
+    /* Related to shared resource */
+
+    value[INFO_TOTALBYTESIZE ] = Tcl_NewIntObj(TkBTreeSize(sharedTextPtr->tree, NULL));
+    value[INFO_TOTALLINES    ] = Tcl_NewIntObj(TkBTreeNumLines(sharedTextPtr->tree, NULL));
+    value[INFO_IMAGES        ] = Tcl_NewIntObj(sharedTextPtr->numImages);
+    value[INFO_WINDOWS       ] = Tcl_NewIntObj(sharedTextPtr->numWindows);
+    value[INFO_TAGS          ] = Tcl_NewIntObj(sharedTextPtr->numTags);
+    value[INFO_USEDTAGS      ] = Tcl_NewIntObj(usedTags);
+    value[INFO_MARKS         ] = Tcl_NewIntObj(sharedTextPtr->numMarks);
+    value[INFO_GENERATEDMARKS] = Tcl_NewIntObj(sharedTextPtr->numPrivateMarks);
+    value[INFO_LINESPERNODE  ] = Tcl_NewIntObj(TkBTreeLinesPerNode(sharedTextPtr->tree));
+
+    Tcl_UnsetVar(interp, Tcl_GetString(var), 0);
+    for (i = 0; i < sizeof(name)/sizeof(name[0]); ++i) {
+	Tcl_ObjSetVar2(interp, var, name[i], value[i], 0);
+    }
+
+    return var;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextGetText --
+ *
+ *	Returns the text from indexPtr1 to indexPtr2, placing that text in a
+ *	string object which is returned with a refCount of zero.
+ *
+ *	Since the amount of text may potentially be several megabytes (e.g.
+ *	in text editors built on the text widget), efficiency is very
+ *	important. We may want to investigate the efficiency of the
+ *	Tcl_AppendToObj more carefully (e.g. if we know we are going to be
+ *	appending several thousand lines, we could attempt to pre-allocate a
+ *	larger space).
+ *
+ *	Also the result is built up as a utf-8 string, but, if we knew we
+ *	wanted it as Unicode, we could potentially save a huge conversion by
+ *	building it up as Unicode directly. This could be as simple as
+ *	replacing Tcl_NewObj by Tcl_NewUnicodeObj.
+ *
+ * Results:
+ *	Tcl_Obj of string type containing the specified text. If the
+ *	visibleOnly flag is set to true, then only those characters which are not
+ *	elided will be returned. Otherwise (flag is false) all characters in the
+ *	given range are returned.
+ *
+ * Side effects:
+ *	Memory will be allocated for the new object. Remember to free it if it
+ *	isn't going to be stored appropriately.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+TextGetText(
+    TkText *textPtr,		/* Information about text widget. */
+    const TkTextIndex *indexPtr1,
+				/* Get text from this index... */
+    const TkTextIndex *indexPtr2,
+				/* ...to this index. */
+    TkTextIndex *lastIndexPtr,	/* Position before last character of the result, can be NULL. */
+    Tcl_Obj *resultPtr,		/* Append text to this object, can be NULL. */
+    unsigned maxBytes,		/* Maximal number of bytes. */
+    bool visibleOnly,		/* If true, then only return non-elided characters. */
+    bool includeHyphens)	/* If true, then also include soft hyphens. */
+{
+    TkTextSegment *segPtr, *lastPtr;
+    TkTextIndex index;
+    int offset1, offset2;
+
+    assert(textPtr);
+    assert(TkTextIndexCompare(indexPtr1, indexPtr2) <= 0);
+
+    if (!resultPtr) {
+	resultPtr = Tcl_NewObj();
+    }
+
+    segPtr = TkTextIndexGetContentSegment(indexPtr1, &offset1);
+    if (lastIndexPtr) {
+	*lastIndexPtr = *indexPtr2;
+    }
+
+    if (visibleOnly && TkTextSegmentIsElided(textPtr, segPtr)) {
+	index = *indexPtr1;
+	if (!TkTextSkipElidedRegion(&index) || TkTextIndexCompare(&index, indexPtr2) >= 0) {
+	    return resultPtr; /* end of text reached */
+	}
+	segPtr = TkTextIndexGetContentSegment(&index, &offset1);
+    }
+
+    lastPtr = TkTextIndexGetContentSegment(indexPtr2, &offset2);
+
+    if (segPtr == lastPtr) {
+	if (segPtr->typePtr == &tkTextCharType) {
+	    Tcl_AppendToObj(resultPtr, segPtr->body.chars + offset1, MIN(maxBytes, offset2 - offset1));
+	}
+    } else {
+	TkTextLine *linePtr = segPtr->sectionPtr->linePtr;
+
+	TkTextIndexClear(&index, textPtr);
+
+	if (segPtr->typePtr == &tkTextCharType) {
+	    unsigned nbytes = MIN(maxBytes, segPtr->size - offset1);
+	    Tcl_AppendToObj(resultPtr, segPtr->body.chars + offset1, nbytes);
+	    if ((maxBytes -= nbytes) == 0) {
+		return resultPtr;
+	    }
+	} else if (segPtr->typePtr == &tkTextHyphenType) {
+	    if (includeHyphens) {
+		Tcl_AppendToObj(resultPtr, "\xc2\xad", 2); /* U+002D */
+		if ((maxBytes -= MIN(maxBytes, 2)) == 0) {
+		    return resultPtr;
+		}
+	    }
+	} else if (segPtr->typePtr == &tkTextBranchType) {
+	    if (visibleOnly) {
+		TkTextIndexSetSegment(&index, segPtr = segPtr->body.branch.nextPtr);
+		if (TkTextIndexRestrictToEndRange(&index) >= 0) {
+		    return resultPtr; /* end of text reached */
+		}
+		linePtr = segPtr->sectionPtr->linePtr;
+	    }
+	}
+	if (!(segPtr = segPtr->nextPtr)) {
+	    assert(linePtr->nextPtr);
+	    linePtr = linePtr->nextPtr;
+	    segPtr = linePtr->segPtr;
+	}
+	while (segPtr != lastPtr) {
+	    if (segPtr->typePtr == &tkTextCharType) {
+		unsigned nbytes = MIN(maxBytes, segPtr->size);
+		Tcl_AppendToObj(resultPtr, segPtr->body.chars, nbytes);
+		if ((maxBytes -= nbytes) == 0) {
+		    if (lastIndexPtr) {
+			TkTextIndexSetSegment(lastIndexPtr, segPtr);
+			TkTextIndexAddToByteIndex(lastIndexPtr, nbytes);
+		    }
+		    return resultPtr; /* end of text reached */
+		}
+	    } else if (segPtr->typePtr == &tkTextHyphenType) {
+		if (includeHyphens) {
+		    Tcl_AppendToObj(resultPtr, "\xc2\xad", 2); /* U+002D */
+		    if ((maxBytes -= MIN(maxBytes, 2)) == 0) {
+			return resultPtr;
+		    }
+		}
+	    } else if (segPtr->typePtr == &tkTextBranchType) {
+		if (visibleOnly) {
+		    TkTextIndexSetSegment(&index, segPtr = segPtr->body.branch.nextPtr);
+		    if (TkTextIndexRestrictToEndRange(&index) >= 0) {
+			return resultPtr; /* end of text reached */
+		    }
+		    linePtr = segPtr->sectionPtr->linePtr;
+		}
+	    }
+	    if (!(segPtr = segPtr->nextPtr)) {
+		assert(linePtr->nextPtr);
+		linePtr = linePtr->nextPtr;
+		segPtr = linePtr->segPtr;
+	    }
+	}
+	if (offset2 > 0) {
+	    Tcl_AppendToObj(resultPtr, segPtr->body.chars, MIN(maxBytes, offset2));
+	}
+    }
+
+    return resultPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TriggerWatchEdit --
+ *
+ *	Trigger the watch command for delete/insert operations, see the
+ *	documentation for details on what it does.
+ *
+ * Results:
+ *	Returns 'false' if the referenced widget has been destroyed, otherwise
+ *	'true' will be returned.
+ *
+ * Side effects:
+ *	It might happen that the receiver of the "watch" command is destroying the widget.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+AppendTags(
+    Tcl_DString *buf,
+    TkTextTag *tagPtr)
+{
+    Tcl_DStringStartSublist(buf);
+    for ( ; tagPtr; tagPtr = tagPtr->nextPtr) {
+	Tcl_DStringAppendElement(buf, tagPtr->name);
+    }
+    Tcl_DStringEndSublist(buf);
+}
+
+static bool
+TriggerWatchEdit(
+    TkText *textPtr,			/* Information about text widget. */
+    const char *operation,		/* The triggering operation. */
+    const TkTextIndex *indexPtr1,	/* Start index for deletion / insert. */
+    const TkTextIndex *indexPtr2,	/* End index after insert / before deletion. */
+    const char *string,			/* Deleted/inserted chars. */
+    bool final)				/* Flag indicating whether this is a final part. */
+{
+    TkSharedText *sharedTextPtr;
+    TkText *peerArr[20];
+    TkText **peers = peerArr;
+    TkText *tPtr;
+    unsigned i, n = 0;
+    bool rc = true;
+
+    assert(textPtr->sharedTextPtr->triggerWatchCmd);
+    assert(!indexPtr1 == !indexPtr2);
+    assert(strcmp(operation, "insert") == 0 || strcmp(operation, "delete") == 0);
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+    sharedTextPtr->triggerWatchCmd = false;
+
+    if (sharedTextPtr->numPeers > sizeof(peerArr) / sizeof(peerArr[0])) {
+	peers = malloc(sharedTextPtr->numPeers * sizeof(peerArr[0]));
+    }
+
+    /*
+     * Firstly save all peers, we have to take into account that the list of
+     * peers is changing when executing the "watch" command.
+     */
+
+    peers[n++] = textPtr;
+    for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next) {
+	if (tPtr != textPtr) {
+	    peers[n++] = tPtr;
+	}
+	tPtr->refCount += 1;
+    }
+
+    for (i = 0; i < sharedTextPtr->numPeers; ++i) {
+	TkText *tPtr = peers[i];
+
+	if (!(tPtr->flags & DESTROYED) && tPtr->watchCmd) {
+	    TkTextIndex index[4];
+
+	    if (indexPtr1) {
+		TkTextSegment *startMarker;
+		TkTextSegment *endMarker;
+		int cmp;
+
+		index[0] = *indexPtr1;
+		index[1] = *indexPtr2;
+
+		startMarker = tPtr->startMarker;
+		endMarker = tPtr->endMarker;
+
+		if (startMarker != sharedTextPtr->startMarker) {
+		    TkTextIndex start;
+		    TkTextIndexClear(&start, tPtr);
+		    TkTextIndexSetSegment(&start, startMarker);
+		    if (TkTextIndexCompare(&start, &index[0]) > 0) {
+			index[0] = start;
+		    }
+		}
+		if (endMarker != sharedTextPtr->endMarker) {
+		    TkTextIndex end;
+		    TkTextIndexClear(&end, tPtr);
+		    TkTextIndexSetSegment(&end, endMarker);
+		    if (TkTextIndexCompare(&end, &index[1]) < 0) {
+			index[1] = end;
+		    }
+		}
+
+		if ((cmp = TkTextIndexCompare(&index[0], &index[1])) <= 0) {
+		    TkTextTag *tagPtr;
+		    TkTextIndex myIndex;
+		    Tcl_DString buf;
+		    char idx[2][TK_POS_CHARS];
+		    char const *arg;
+
+		    TkTextPrintIndex(tPtr, &index[0], idx[0]);
+		    TkTextPrintIndex(tPtr, &index[1], idx[1]);
+
+		    Tcl_DStringInit(&buf);
+		    Tcl_DStringAppendElement(&buf, string);
+
+		    tagPtr = NULL;
+		    if (TkTextIndexBackChars(tPtr, &index[0], 1, &myIndex, COUNT_CHARS)) {
+			tagPtr = TkBTreeGetTags(&myIndex);
+		    }
+		    AppendTags(&buf, tagPtr);
+		    AppendTags(&buf, TkBTreeGetTags(&index[1]));
+		    AppendTags(&buf, cmp == 0 ? NULL : TkBTreeGetTags(&index[0]));
+		    if (*operation == 'd') {
+			tagPtr = NULL;
+			if (cmp && TkTextIndexBackChars(tPtr, &index[1], 1, &myIndex, COUNT_CHARS)) {
+			    tagPtr = TkBTreeGetTags(&myIndex);
+			}
+			AppendTags(&buf, tagPtr);
+		    }
+		    Tcl_DStringAppendElement(&buf, final ? "yes" : "no");
+		    arg = Tcl_DStringValue(&buf);
+
+		    if (!TkTextTriggerWatchCmd(tPtr, operation, idx[0], idx[1], arg, true)
+			    && tPtr == textPtr) {
+			rc = false; /* this widget has been destroyed */
+		    }
+
+		    Tcl_DStringFree(&buf);
+		}
+	    } else {
+		if (!TkTextTriggerWatchCmd(textPtr, operation, NULL, NULL, NULL, true)
+			&& tPtr == textPtr) {
+		    rc = false; /* this widget has been destroyed */
+		}
+	    }
+	}
+
+	if (--tPtr->refCount == 0) {
+	    free(tPtr);
+	}
+    }
+
+    if (peers != peerArr) {
+	free(peers);
+    }
+
+    sharedTextPtr->triggerWatchCmd = true;
+    return rc;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextTriggerWatchCmd --
+ *
+ *	Trigger the watch command, see the documentation for details on
+ *	what it does.
+ *
+ * Results:
+ *	Returns 'false' if this peer has been destroyed, otherwise 'true'
+ *	will be returned.
+ *
+ * Side effects:
+ *	It might happen that the receiver of the "watch" command is destroying the widget.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextTriggerWatchCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    const char *operation,	/* The trigger operation. */
+    const char *index1,		/* 1st argument for watch command. */
+    const char *index2,		/* 2nd argument for watch command. */
+    const char *arg,		/* 3rd argument for watch command. */
+    bool userFlag)		/* 4rd argument for watch command. */
+{
+    Tcl_DString cmd;
+
+    assert(textPtr);
+    assert(textPtr->watchCmd);
+    assert(operation);
+
+    Tcl_DStringInit(&cmd);
+    Tcl_DStringAppend(&cmd, Tcl_GetString(textPtr->watchCmd), -1);
+    Tcl_DStringAppendElement(&cmd, Tk_PathName(textPtr->tkwin));
+    Tcl_DStringAppendElement(&cmd, operation);
+    Tcl_DStringAppendElement(&cmd, index1 ? index1 : "");
+    Tcl_DStringAppendElement(&cmd, index2 ? index2 : "");
+    Tcl_DStringAppendElement(&cmd, arg ? arg : "");
+    Tcl_DStringAppendElement(&cmd, userFlag ? "1" : "0");
+
+    textPtr->refCount += 1;
+
+    Tcl_Preserve((ClientData) textPtr->interp);
+    if (Tcl_EvalEx(textPtr->interp, Tcl_DStringValue(&cmd), Tcl_DStringLength(&cmd), 0) != TCL_OK) {
+	Tcl_AddErrorInfo(textPtr->interp, "\n    (triggering the \"watch\" command failed)");
+	Tcl_BackgroundException(textPtr->interp, TCL_ERROR);
+    }
+    Tcl_Release((ClientData) textPtr->interp);
+
+    Tcl_DStringFree(&cmd);
+    return !TkTextDecrRefCountAndTestIfDestroyed(textPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GenerateEvent --
+ *
+ *	Send an event about a new state. This is equivalent to:
+ *	   event generate $textWidget <<TYPE>>
+ *	for all peers of this text widget.
+ *
+ * Results:
+ *	None
+ *
+ * Side effects:
+ *	May force the text window into existence.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+GenerateEvent(
+    TkSharedText *sharedTextPtr,
+    const char *type)
+{
+    TkText *textPtr;
+
+    for (textPtr = sharedTextPtr->peers; textPtr; textPtr = textPtr->next) {
+	Tk_MakeWindowExist(textPtr->tkwin);
+	SendVirtualEvent(textPtr->tkwin, type, NULL);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UpdateModifiedFlag --
+ *
+ *	Updates the modified flag of the text widget.
+ *
+ * Results:
+ *	None
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+UpdateModifiedFlag(
+    TkSharedText *sharedTextPtr,
+    bool flag)
+{
+    bool oldModifiedFlag = sharedTextPtr->isModified;
+
+    if (flag) {
+	sharedTextPtr->isModified = true;
+    } else if (sharedTextPtr->undoStack && !sharedTextPtr->userHasSetModifiedFlag) {
+	if (sharedTextPtr->insertDeleteUndoTokenCount > 0) {
+	    sharedTextPtr->isModified = true;
+	} else {
+	    unsigned undoDepth = TkTextUndoGetCurrentUndoStackDepth(sharedTextPtr->undoStack);
+	    sharedTextPtr->isModified = (undoDepth > 0 && undoDepth == sharedTextPtr->undoLevel);
+	}
+    }
+
+    if (oldModifiedFlag != sharedTextPtr->isModified) {
+	sharedTextPtr->userHasSetModifiedFlag = false;
+	GenerateEvent(sharedTextPtr, "Modified");
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextUpdateAlteredFlag --
+ *
+ *	Updates the "altered" flag of the text widget.
+ *
+ * Results:
+ *	None
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextUpdateAlteredFlag(
+    TkSharedText *sharedTextPtr)/* Information about text widget. */
+{
+    bool oldIsAlteredFlag = sharedTextPtr->isAltered;
+    bool oldIsIrreversibleFlag = sharedTextPtr->isIrreversible;
+
+    if (sharedTextPtr->undoStack) {
+	if (TkTextUndoContentIsIrreversible(sharedTextPtr->undoStack)) {
+	    sharedTextPtr->isIrreversible = true;
+	}
+	if (!sharedTextPtr->isIrreversible) {
+	    sharedTextPtr->isAltered = sharedTextPtr->undoTagListCount > 0
+		    || sharedTextPtr->undoMarkListCount > 0
+		    || TkTextUndoGetCurrentUndoStackDepth(sharedTextPtr->undoStack) > 0;
+	}
+    } else {
+	sharedTextPtr->isIrreversible = true;
+    }
+    if (sharedTextPtr->isIrreversible) {
+	sharedTextPtr->isAltered = true;
+    }
+    if (oldIsAlteredFlag != sharedTextPtr->isAltered) {
+	GenerateEvent(sharedTextPtr, "Altered");
+    }
+    if (oldIsIrreversibleFlag != sharedTextPtr->isIrreversible) {
+	GenerateEvent(sharedTextPtr, "Irreversible");
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextRunAfterSyncCmd --
+ *
+ *	This function executes the command scheduled by
+ *	[.text sync -command $cmd], if any.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Anything may happen, depending on $cmd contents.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextRunAfterSyncCmd(
+    TkText *textPtr)	/* Information about text widget. */
+{
+    int code;
+    bool error = false;
+    Tcl_Obj *afterSyncCmd;
+
+    assert(!TkTextPendingSync(textPtr));
+
+    textPtr->pendingAfterSync = false;
+    afterSyncCmd = textPtr->afterSyncCmd;
+
+    if (!afterSyncCmd) {
+	return;
+    }
+
+    /*
+     * We have to expect nested calls, futhermore the receiver might destroy the widget.
+     */
+
+    textPtr->afterSyncCmd = NULL;
+    textPtr->refCount += 1;
+
+    Tcl_Preserve((ClientData) textPtr->interp);
+    if (!(textPtr->flags & DESTROYED)) {
+	code = Tcl_EvalObjEx(textPtr->interp, afterSyncCmd, TCL_EVAL_GLOBAL);
+	if (code == TCL_ERROR && !error) {
+	    Tcl_AddErrorInfo(textPtr->interp, "\n    (text sync)");
+	    Tcl_BackgroundError(textPtr->interp);
+	    error = true;
+	}
+    }
+    Tcl_DecrRefCount(afterSyncCmd);
+    Tcl_Release((ClientData) textPtr->interp);
+    TkTextReleaseIfDestroyed(textPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * RunAfterSyncCmd --
+ *
+ *	This function is called by the event loop and executes the command
+ *      scheduled by [.text sync -command $cmd].
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Anything may happen, depending on $cmd contents.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+RunAfterSyncCmd(
+    ClientData clientData)	/* Information about text widget. */
+{
+    TkText *textPtr = (TkText *) clientData;
+
+    if (!(textPtr->flags & DESTROYED)) {
+	if (TkTextPendingSync(textPtr)) {
+	    /* Too late here, the widget is not in sync, so we have to wait. */
+	} else {
+	    TkTextRunAfterSyncCmd(textPtr);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextGenerateWidgetViewSyncEvent --
+ *
+ *      Send the <<WidgetViewSync>> event related to the text widget
+ *      line metrics asynchronous update.
+ *      This is equivalent to:
+ *         event generate $textWidget <<WidgetViewSync>> -detail $s
+ *      where $s is the sync status: true (when the widget view is in
+ *      sync with its internal data) or false (when it is not).
+ *
+ *	Note that this has to be done in the idle loop, otherwise vwait
+ *	will not return.
+ *
+ * Results:
+ *      None.
+ *
+ * Side effects:
+ *      If corresponding bindings are present, they will trigger.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+FireWidgetViewSyncEvent(
+    ClientData clientData)	/* Information about text widget. */
+{
+    TkText *textPtr = (TkText *) clientData;
+    Tcl_Interp *interp;
+    bool syncState;
+
+    textPtr->pendingFireEvent = false;
+
+    if (textPtr->flags & DESTROYED) {
+	return;
+    }
+
+    syncState = !TkTextPendingSync(textPtr);
+
+    if (textPtr->sendSyncEvent && syncState) {
+	/*
+	 * The user is waiting for sync state 'true', so we must send it.
+	 */
+
+	textPtr->prevSyncState = false;
+    }
+
+    if (textPtr->prevSyncState == syncState) {
+	/*
+	 * Do not send "WidgetViewSync" with same sync state as before
+	 * (except if we must send it because the user is waiting for it).
+	 */
+
+	return;
+    }
+
+    if ((textPtr->sendSyncEvent || textPtr->pendingAfterSync) && !syncState) {
+	/*
+	 * Do not send "WidgetViewSync" with sync state "false" as long as
+	 * we have a pending sync command.
+	 */
+
+	return;
+    }
+
+    if (syncState) {
+	textPtr->sendSyncEvent = false;
+    }
+    textPtr->prevSyncState = syncState;
+
+    interp = textPtr->interp;
+    Tcl_Preserve((ClientData) interp);
+    SendVirtualEvent(textPtr->tkwin, "WidgetViewSync", Tcl_NewBooleanObj(syncState));
+    Tcl_Release((ClientData) interp);
+}
+
+void
+TkTextGenerateWidgetViewSyncEvent(
+    TkText *textPtr,		/* Information about text widget. */
+    bool sendImmediately)
+{
+    if (!textPtr->pendingFireEvent) {
+	textPtr->pendingFireEvent = true;
+	if (sendImmediately) {
+	    FireWidgetViewSyncEvent((ClientData) textPtr);
+	} else {
+	    Tcl_DoWhenIdle(FireWidgetViewSyncEvent, (ClientData) textPtr);
+	}
+    }
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextPrintIndex --
+ *
+ *	This function generates a string description of an index, suitable for
+ *	reading in again later.
+ *
+ * Results:
+ *	The characters pointed to by string are modified. Returns the number
+ *	of characters in the string.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+/*
+ * NOTE: this function has external linkage (declared in a common header file)
+ * and cannot be inlined.
+ */
+
+int
+TkTextPrintIndex(
+    const TkText *textPtr,
+    const TkTextIndex *indexPtr,/* Pointer to index. */
+    char *string)		/* Place to store the position. Must have at least TK_POS_CHARS
+    				 * characters. */
+{
+    assert(textPtr);
+    return TkTextIndexPrint(textPtr->sharedTextPtr, textPtr, indexPtr, string);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * SearchPerform --
+ *
+ *	Overall control of search process. Is given a pattern, a starting
+ *	index and an ending index, and attempts to perform a search. This
+ *	function is actually completely independent of Tk, and could in the
+ *	future be split off.
+ *
+ * Results:
+ *	Standard Tcl result code. In particular, if fromPtr or toPtr are not
+ *	considered valid by the 'lineIndexProc', an error will be thrown and
+ *	no search performed.
+ *
+ * Side effects:
+ *	See 'SearchCore'.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+SearchPerform(
+    Tcl_Interp *interp,		/* For error messages. */
+    SearchSpec *searchSpecPtr,	/* Search parameters. */
+    Tcl_Obj *patObj,		/* Contains an exact string or a regexp
+				 * pattern. Must have a refCount > 0. */
+    Tcl_Obj *fromPtr,		/* Contains information describing the first index. */
+    Tcl_Obj *toPtr)		/* NULL or information describing the last index. */
+{
+    TkText *textPtr = searchSpecPtr->clientData;
+
+    if (TkTextIsDeadPeer(textPtr)) {
+	return TCL_OK;
+    }
+
+    /*
+     * Find the starting line and starting offset (measured in Unicode chars
+     * for regexp search, utf-8 bytes for exact search).
+     */
+
+    if (searchSpecPtr->lineIndexProc(interp, fromPtr, searchSpecPtr,
+	    &searchSpecPtr->startLine, &searchSpecPtr->startOffset) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    /*
+     * Find the optional end location, similarly.
+     */
+
+    if (toPtr) {
+	TkTextIndex indexTo, indexFrom;
+
+	if (!TkTextGetIndexFromObj(interp, textPtr, toPtr, &indexTo)
+		|| !TkTextGetIndexFromObj(interp, textPtr, fromPtr, &indexFrom)) {
+	    return TCL_ERROR;
+	}
+
+	/*
+	 * Check for any empty search range here. It might be better in the
+	 * future to embed that in SearchCore (whose default behaviour is to
+	 * wrap when given a negative search range).
+	 */
+
+	if (TkTextIndexCompare(&indexFrom, &indexTo) == (searchSpecPtr->backwards ? -1 : 1)) {
+	    return TCL_OK;
+	}
+
+	if (searchSpecPtr->lineIndexProc(interp, toPtr, searchSpecPtr,
+		&searchSpecPtr->stopLine, &searchSpecPtr->stopOffset) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+    } else {
+	searchSpecPtr->stopLine = -1;
+    }
+
+    /*
+     * Scan through all of the lines of the text circularly, starting at the
+     * given index. 'patObj' is the pattern which may be an exact string or a
+     * regexp pattern depending on the flags in searchSpecPtr.
+     */
+
+    return SearchCore(interp, searchSpecPtr, patObj);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * SearchCore --
+ *
+ *	The core of the search function. This function is actually completely
+ *	independent of Tk, and could in the future be split off.
+ *
+ *	The function assumes regexp-based searches operate on Unicode strings,
+ *	and exact searches on utf-8 strings. Therefore the 'foundMatchProc'
+ *	and 'addLineProc' need to be aware of this distinction.
+ *
+ * Results:
+ *	Standard Tcl result code.
+ *
+ * Side effects:
+ *	Only those of the 'searchSpecPtr->foundMatchProc' which is called
+ *	whenever a match is found.
+ *
+ *	Note that the way matching across multiple lines is implemented, we
+ *	start afresh with each line we have available, even though we may
+ *	already have examined the contents of that line (and further ones) if
+ *	we were attempting a multi-line match using the previous line. This
+ *	means there may be ways to speed this up a lot by not throwing away
+ *	all the multi-line information one has accumulated. Profiling should
+ *	be done to see where the bottlenecks lie before attempting this,
+ *	however. We would also need to be very careful such optimisation keep
+ *	within the specified search bounds.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+SearchCore(
+    Tcl_Interp *interp,		/* For error messages. */
+    SearchSpec *searchSpecPtr,	/* Search parameters. */
+    Tcl_Obj *patObj)		/* Contains an exact string or a regexp
+				 * pattern. Must have a refCount > 0. */
+{
+    /*
+     * For exact searches these are utf-8 char* offsets, for regexp searches
+     * they are Unicode char offsets.
+     */
+
+    int firstOffset, lastOffset, matchOffset, matchLength;
+    int passes;
+    int lineNum = searchSpecPtr->startLine;
+    int code = TCL_OK;
+    Tcl_Obj *theLine;
+    int alreadySearchOffset = -1;
+
+    const char *pattern = NULL;	/* For exact searches only. */
+    int firstNewLine = -1; 	/* For exact searches only. */
+    Tcl_RegExp regexp = NULL;	/* For regexp searches only. */
+
+    /*
+     * These items are for backward regexp searches only. They are for two
+     * purposes: to allow us to report backwards matches in the correct order,
+     * even though the implementation uses repeated forward searches; and to
+     * provide for overlap checking between backwards matches on different
+     * text lines.
+     */
+
+#define LOTS_OF_MATCHES 20
+    int matchNum = LOTS_OF_MATCHES;
+    int32_t smArray[2 * LOTS_OF_MATCHES];
+    int32_t *storeMatch = smArray;
+    int32_t *storeLength = smArray + LOTS_OF_MATCHES;
+    int lastBackwardsLineMatch = -1;
+    int lastBackwardsMatchOffset = -1;
+
+    if (searchSpecPtr->exact) {
+	/*
+	 * Convert the pattern to lower-case if we're supposed to ignore case.
+	 */
+
+	if (searchSpecPtr->noCase) {
+	    patObj = Tcl_DuplicateObj(patObj);
+
+	    /*
+	     * This can change the length of the string behind the object's
+	     * back, so ensure it is correctly synchronised.
+	     */
+
+	    Tcl_SetObjLength(patObj, Tcl_UtfToLower(Tcl_GetString(patObj)));
+	}
+    } else {
+	/*
+	 * Compile the regular expression. We want '^$' to match after and
+	 * before \n respectively, so use the TCL_REG_NLANCH flag.
+	 */
+
+	regexp = Tcl_GetRegExpFromObj(interp, patObj,
+		(searchSpecPtr->noCase ? TCL_REG_NOCASE : 0)
+		| (searchSpecPtr->noLineStop ? 0 : TCL_REG_NLSTOP)
+		| TCL_REG_ADVANCED | TCL_REG_CANMATCH | TCL_REG_NLANCH);
+	if (!regexp) {
+	    return TCL_ERROR;
+	}
+    }
+
+    /*
+     * For exact strings, we want to know where the first newline is, and we
+     * will also use this as a flag to test whether it is even possible to
+     * match the pattern on a single line. If not we will have to search
+     * across multiple lines.
+     */
+
+    if (searchSpecPtr->exact) {
+	const char *nl;
+
+	/*
+	 * We only need to set the matchLength once for exact searches, and we
+	 * do it here. It is also used below as the actual pattern length, so
+	 * it has dual purpose.
+	 */
+
+	pattern = Tcl_GetString(patObj);
+	matchLength = GetByteLength(patObj);
+	nl = strchr(pattern, '\n');
+
+	/*
+	 * If there is no newline, or it is the very end of the string, then
+	 * we don't need any special treatment, since single-line matching
+	 * will work fine.
+	 */
+
+	if (nl && nl[1] != '\0') {
+	    firstNewLine = (nl - pattern);
+	}
+    } else {
+	matchLength = 0;	/* Only needed to prevent compiler warnings. */
+    }
+
+    /*
+     * Keep a reference here, so that we can be sure the object doesn't
+     * disappear behind our backs and invalidate its contents which we are
+     * using.
+     */
+
+    Tcl_IncrRefCount(patObj);
+
+    /*
+     * For building up the current line being checked.
+     */
+
+    theLine = Tcl_NewObj();
+    Tcl_IncrRefCount(theLine);
+
+    for (passes = 0; passes < 2; ) {
+	ClientData lineInfo;
+	int linesSearched = 1;
+	int extraLinesSearched = 0;
+
+	if (lineNum >= searchSpecPtr->numLines) {
+	    /*
+	     * Don't search the dummy last line of the text.
+	     */
+
+	    goto nextLine;
+	}
+
+	/*
+	 * Extract the text from the line, storing its length in 'lastOffset'
+	 * (in bytes if exact, chars if regexp), since obviously the length is
+	 * the maximum offset at which it is possible to find something on
+	 * this line, which is what 'lastOffset' represents.
+	 */
+
+	lineInfo = searchSpecPtr->addLineProc(lineNum, searchSpecPtr, theLine,
+		&lastOffset, &linesSearched);
+
+	if (!lineInfo) {
+	    /*
+	     * This should not happen, since 'lineNum' should be valid in the
+	     * call above. However, let's try to be flexible and not cause a
+	     * crash below.
+	     */
+
+	    goto nextLine;
+	}
+
+	if (lineNum == searchSpecPtr->stopLine && searchSpecPtr->backwards) {
+	    firstOffset = searchSpecPtr->stopOffset;
+	} else {
+	    firstOffset = 0;
+	}
+
+	if (alreadySearchOffset != -1) {
+	    if (searchSpecPtr->backwards) {
+		if (alreadySearchOffset < lastOffset) {
+		    lastOffset = alreadySearchOffset;
+		}
+	    } else {
+		if (alreadySearchOffset > firstOffset) {
+		    firstOffset = alreadySearchOffset;
+		}
+	    }
+	    alreadySearchOffset = -1;
+	}
+
+	if (lineNum == searchSpecPtr->startLine) {
+	    /*
+	     * The starting line is tricky: the first time we see it we check
+	     * one part of the line, and the second pass through we check the
+	     * other part of the line.
+	     */
+
+	    passes += 1;
+	    if ((passes == 1) ^ searchSpecPtr->backwards) {
+		/*
+		 * Forward search and first pass, or backward search and
+		 * second pass.
+		 *
+		 * Only use the last part of the line.
+		 */
+
+		if (searchSpecPtr->startOffset > firstOffset) {
+		    firstOffset = searchSpecPtr->startOffset;
+		}
+		if (firstOffset >= lastOffset && (lastOffset != 0 || searchSpecPtr->exact)) {
+		    goto nextLine;
+		}
+	    } else {
+		/*
+		 * Use only the first part of the line.
+		 */
+
+		if (searchSpecPtr->startOffset < lastOffset) {
+		    lastOffset = searchSpecPtr->startOffset;
+		}
+	    }
+	}
+
+	/*
+	 * Check for matches within the current line 'lineNum'. If so, and if
+	 * we're searching backwards or for all matches, repeat the search
+	 * until we find the last match in the line. The 'lastOffset' is one
+	 * beyond the last position in the line at which a match is allowed to
+	 * begin.
+	 */
+
+	matchOffset = -1;
+
+	if (searchSpecPtr->exact) {
+	    int maxExtraLines = 0;
+	    const char *startOfLine = Tcl_GetString(theLine);
+
+	    CLANG_ASSERT(pattern);
+	    do {
+		int ch;
+		const char *p;
+		int lastFullLine = lastOffset;
+
+		if (firstNewLine == -1) {
+		    if (searchSpecPtr->strictLimits && (firstOffset + matchLength > lastOffset)) {
+			/*
+			 * Not enough characters to match.
+			 */
+
+			break;
+		    }
+
+		    /*
+		     * Single line matching. We want to scan forwards or
+		     * backwards as appropriate.
+		     */
+
+		    if (searchSpecPtr->backwards) {
+			/*
+			 * Search back either from the previous match or from
+			 * 'startOfLine + lastOffset - 1' until we find a
+			 * match.
+			 */
+
+			const char c = pattern[0];
+
+			p = startOfLine;
+			if (alreadySearchOffset != -1) {
+			    p += alreadySearchOffset;
+			    alreadySearchOffset = -1;
+			} else {
+			    p += lastOffset - 1;
+			}
+			while (p >= startOfLine + firstOffset) {
+			    if (p[0] == c && strncmp(p, pattern, matchLength) == 0) {
+				goto backwardsMatch;
+			    }
+			    p -= 1;
+			}
+			break;
+		    } else {
+			p = strstr(startOfLine + firstOffset, pattern);
+		    }
+		    if (!p) {
+			/*
+			 * Single line match failed.
+			 */
+
+			break;
+		    }
+		} else if (firstNewLine >= lastOffset - firstOffset) {
+		    /*
+		     * Multi-line match, but not enough characters to match.
+		     */
+
+		    break;
+		} else {
+		    /*
+		     * Multi-line match has only one possible match position,
+		     * because we know where the '\n' is.
+		     */
+
+		    p = startOfLine + lastOffset - firstNewLine - 1;
+		    if (strncmp(p, pattern, firstNewLine + 1) != 0) {
+			/*
+			 * No match.
+			 */
+
+			break;
+		    } else {
+			int extraLines = 1;
+
+			/*
+			 * If we find a match that overlaps more than one
+			 * line, we will use this value to determine the first
+			 * allowed starting offset for the following search
+			 * (to avoid overlapping results).
+			 */
+
+			int lastTotal = lastOffset;
+			int skipFirst = lastOffset - firstNewLine - 1;
+
+			/*
+			 * We may be able to match if given more text. The
+			 * following 'while' block handles multi-line exact
+			 * searches.
+			 */
+
+			while (1) {
+			    lastFullLine = lastTotal;
+
+			    if (lineNum + extraLines >= searchSpecPtr->numLines) {
+				p = NULL;
+				break;
+			    }
+
+			    /*
+			     * Only add the line if we haven't already done so
+			     * already.
+			     */
+
+			    if (extraLines > maxExtraLines) {
+				if (!searchSpecPtr->addLineProc(lineNum + extraLines, searchSpecPtr,
+					theLine, &lastTotal, &extraLines)) {
+				    p = NULL;
+				    if (!searchSpecPtr->backwards) {
+					extraLinesSearched = extraLines;
+				    }
+				    break;
+				}
+				maxExtraLines = extraLines;
+			    }
+
+			    startOfLine = Tcl_GetString(theLine);
+			    p = startOfLine + skipFirst;
+
+			    /*
+			     * Use the fact that 'matchLength = patLength' for
+			     * exact searches.
+			     */
+
+			    if (lastTotal - skipFirst >= matchLength) {
+				/*
+				 * We now have enough text to match, so we
+				 * make a final test and break whatever the
+				 * result.
+				 */
+
+				if (strncmp(p, pattern, matchLength) != 0) {
+				    p = NULL;
+				}
+				break;
+			    } else {
+				/*
+				 * Not enough text yet, but check the prefix.
+				 */
+
+				if (strncmp(p, pattern, lastTotal - skipFirst) != 0) {
+				    p = NULL;
+				    break;
+				}
+
+				/*
+				 * The prefix matches, so keep looking.
+				 */
+			    }
+			    extraLines += 1;
+			}
+			/*
+			 * If we reach here, with p != NULL, we've found a
+			 * multi-line match, else we started a multi-match but
+			 * didn't finish it off, so we go to the next line.
+			 */
+
+			if (!p) {
+			    break;
+			}
+
+			/*
+			 * We've found a multi-line match.
+			 */
+
+			if (extraLines > 0) {
+			    extraLinesSearched = extraLines - 1;
+			}
+		    }
+		}
+
+	    backwardsMatch:
+		if (p - startOfLine >= lastOffset) {
+		    break;
+		}
+
+		/*
+		 * Remember the match.
+		 */
+
+		matchOffset = p - startOfLine;
+
+		if (searchSpecPtr->all &&
+			!searchSpecPtr->foundMatchProc(lineNum, searchSpecPtr,
+			lineInfo, theLine, matchOffset, matchLength)) {
+		    /*
+		     * We reached the end of the search.
+		     */
+
+		    goto searchDone;
+		}
+
+		if (!searchSpecPtr->overlap) {
+		    if (searchSpecPtr->backwards) {
+			alreadySearchOffset = p - startOfLine;
+			if (firstNewLine != -1) {
+			    break;
+			} else {
+			    alreadySearchOffset -= matchLength;
+			}
+		    } else {
+			firstOffset = p - startOfLine + matchLength;
+			if (firstOffset >= lastOffset) {
+			    /*
+			     * Now, we have to be careful not to find
+			     * overlapping matches either on the same or
+			     * following lines. Assume that if we did find
+			     * something, it goes until the last extra line we
+			     * added.
+			     *
+			     * We can break out of the loop, since we know no
+			     * more will be found.
+			     */
+
+			    if (!searchSpecPtr->backwards) {
+				alreadySearchOffset = firstOffset - lastFullLine;
+				break;
+			    }
+			}
+		    }
+		} else {
+		    if (searchSpecPtr->backwards) {
+			alreadySearchOffset = p - startOfLine - 1;
+			if (alreadySearchOffset < 0) {
+			    break;
+			}
+		    } else {
+			firstOffset = p - startOfLine + TkUtfToUniChar(startOfLine + matchOffset, &ch);
+		    }
+		}
+	    } while (searchSpecPtr->all);
+	} else {
+	    int maxExtraLines = 0;
+	    int matches = 0;
+	    int lastNonOverlap = -1;
+
+	    do {
+		Tcl_RegExpInfo info;
+		int match;
+		int lastFullLine = lastOffset;
+
+		match = Tcl_RegExpExecObj(interp, regexp, theLine,
+			firstOffset, 1, firstOffset > 0 ? TCL_REG_NOTBOL : 0);
+		if (match < 0) {
+		    code = TCL_ERROR;
+		    goto searchDone;
+		}
+		Tcl_RegExpGetInfo(regexp, &info);
+
+		/*
+		 * If we don't have a match, or if we do, but it extends to
+		 * the end of the line, we must try to add more lines to get a
+		 * full greedy match.
+		 */
+
+		if (!match
+			|| (info.extendStart == info.matches[0].start
+			    && info.matches[0].end == lastOffset - firstOffset)) {
+		    int extraLines = 0;
+		    int prevFullLine;
+
+		    /*
+		     * If we find a match that overlaps more than one line, we
+		     * will use this value to determine the first allowed
+		     * starting offset for the following search (to avoid
+		     * overlapping results).
+		     */
+
+		    int lastTotal = lastOffset;
+
+		    if (lastBackwardsLineMatch != -1 && lastBackwardsLineMatch == lineNum + 1) {
+			lastNonOverlap = lastTotal;
+		    }
+
+		    if (info.extendStart < 0) {
+			/*
+			 * No multi-line match is possible.
+			 */
+
+			break;
+		    }
+
+		    /*
+		     * We may be able to match if given more text. The
+		     * following 'while' block handles multi-line regexp
+		     * searches.
+		     */
+
+		    while (1) {
+			prevFullLine = lastTotal;
+
+			/*
+			 * Move firstOffset to first possible start.
+			 */
+
+			if (!match) {
+			    firstOffset += info.extendStart;
+			}
+			if (firstOffset >= lastOffset) {
+			    /*
+			     * We're being told that the only possible new
+			     * match is starting after the end of the line.
+			     * But, that is the next line which we will handle
+			     * when we look at that line.
+			     */
+
+			    if (!match && !searchSpecPtr->backwards && firstOffset == 0) {
+				extraLinesSearched = extraLines;
+			    }
+			    break;
+			}
+
+			if (lineNum + extraLines >= searchSpecPtr->numLines) {
+			    break;
+			}
+
+			/*
+			 * Add next line, provided we haven't already done so.
+			 */
+
+			if (extraLines > maxExtraLines) {
+			    if (!searchSpecPtr->addLineProc(lineNum + extraLines, searchSpecPtr,
+				    theLine, &lastTotal, &extraLines)) {
+				/*
+				 * There are no more acceptable lines, so we
+				 * can say we have searched all of these.
+				 */
+
+				if (!match && !searchSpecPtr->backwards) {
+				    extraLinesSearched = extraLines;
+				}
+				break;
+			    }
+
+			    maxExtraLines = extraLines;
+			    if (lastBackwardsLineMatch != -1
+				    && lastBackwardsLineMatch == lineNum + extraLines + 1) {
+				lastNonOverlap = lastTotal;
+			    }
+			}
+
+			match = Tcl_RegExpExecObj(interp, regexp, theLine,
+				firstOffset, 1, firstOffset > 0 ? TCL_REG_NOTBOL : 0);
+			if (match < 0) {
+			    code = TCL_ERROR;
+			    goto searchDone;
+			}
+			Tcl_RegExpGetInfo(regexp, &info);
+
+			/*
+			 * Unfortunately there are bugs in Tcl's regexp
+			 * library, which tells us that info.extendStart is
+			 * zero when it should not be (should be -1), which
+			 * makes our task a bit more complicated here. We
+			 * check if there was a match, and the end of the
+			 * match leaves an entire extra line unmatched, then
+			 * we stop searching. Clearly it still might sometimes
+			 * be possible to add more text and match again, but
+			 * Tcl's regexp library doesn't tell us that.
+			 *
+			 * This means we often add and search one more line
+			 * than might be necessary if Tcl were able to give us
+			 * a correct value of info.extendStart under all
+			 * circumstances.
+			 */
+
+			if ((match  && firstOffset + info.matches[0].end != lastTotal
+				    && firstOffset + info.matches[0].end < prevFullLine)
+				|| info.extendStart < 0) {
+			    break;
+			}
+
+			/*
+			 * If there is a match, but that match starts after
+			 * the end of the first line, then we'll handle that
+			 * next time around, when we're actually looking at
+			 * that line.
+			 */
+
+			if (match && info.matches[0].start >= lastOffset) {
+			    break;
+			}
+			if (match && firstOffset + info.matches[0].end >= prevFullLine) {
+			    if (extraLines > 0) {
+				extraLinesSearched = extraLines - 1;
+			    }
+			    lastFullLine = prevFullLine;
+			}
+
+			/*
+			 * The prefix matches, so keep looking.
+			 */
+
+			extraLines += 1;
+		    }
+
+		    /*
+		     * If we reach here with 'match == 1', we've found a
+		     * multi-line match, which we will record in the code
+		     * which follows directly else we started a multi-line
+		     * match but didn't finish it off, so we go to the next
+		     * line.
+		     */
+
+		    if (!match) {
+			/*
+			 * Here is where we could perform an optimisation,
+			 * since we have already retrieved the contents of the
+			 * next line (perhaps many more), so we shouldn't
+			 * really throw it all away and start again. This
+			 * could be particularly important for complex regexp
+			 * searches.
+			 *
+			 * This 'break' will take us to just before the
+			 * 'nextLine:' below.
+			 */
+
+			break;
+		    }
+
+		    if (lastBackwardsLineMatch != -1) {
+			if (lineNum + linesSearched + extraLinesSearched == lastBackwardsLineMatch) {
+			    /*
+			     * Possible overlap or inclusion.
+			     */
+
+			    int thisOffset = firstOffset + info.matches[0].end - info.matches[0].start;
+
+			    if (lastNonOverlap != -1) {
+				/*
+				 * Possible overlap or enclosure.
+				 */
+
+				if (thisOffset - lastNonOverlap >=
+					lastBackwardsMatchOffset + matchLength) {
+				    /*
+				     * Totally encloses previous match, so
+				     * forget the previous match.
+				     */
+
+				    lastBackwardsLineMatch = -1;
+				} else if (thisOffset - lastNonOverlap > lastBackwardsMatchOffset) {
+				    /*
+				     * Overlap. Previous match is ok, and the
+				     * current match is only ok if we are
+				     * searching with -overlap.
+				     */
+
+				    if (searchSpecPtr->overlap) {
+					goto recordBackwardsMatch;
+				    } else {
+					match = 0;
+					break;
+				    }
+				} else {
+				    /*
+				     * No overlap, although the same line was
+				     * reached.
+				     */
+
+				    goto recordBackwardsMatch;
+				}
+			    } else {
+				/*
+				 * No overlap.
+				 */
+
+				goto recordBackwardsMatch;
+			    }
+			} else if (lineNum + linesSearched + extraLinesSearched
+				< lastBackwardsLineMatch) {
+			    /*
+			     * No overlap.
+			     */
+
+			    goto recordBackwardsMatch;
+			} else {
+			    /*
+			     * Totally enclosed.
+			     */
+
+			    lastBackwardsLineMatch = -1;
+			}
+		    }
+
+		} else {
+		    /*
+		     * Matched in a single line.
+		     */
+
+		    if (lastBackwardsLineMatch != -1) {
+		    recordBackwardsMatch:
+			searchSpecPtr->foundMatchProc(lastBackwardsLineMatch,
+				searchSpecPtr, NULL, NULL, lastBackwardsMatchOffset, matchLength);
+			lastBackwardsLineMatch = -1;
+			if (!searchSpecPtr->all) {
+			    goto searchDone;
+			}
+		    }
+		}
+
+		firstOffset += info.matches[0].start;
+		if (firstOffset >= lastOffset) {
+		    break;
+		}
+
+		/*
+		 * Update our local variables with the match, if we haven't
+		 * yet found anything, or if we're doing '-all' or
+		 * '-backwards' _and_ this match isn't fully enclosed in the
+		 * previous match.
+		 */
+
+		if (matchOffset == -1 ||
+			((searchSpecPtr->all || searchSpecPtr->backwards)
+			    && (firstOffset < matchOffset
+				|| firstOffset + info.matches[0].end - info.matches[0].start
+				    > matchOffset + matchLength))) {
+
+		    matchOffset = firstOffset;
+		    matchLength = info.matches[0].end - info.matches[0].start;
+
+		    if (searchSpecPtr->backwards) {
+			/*
+			 * To get backwards searches in the correct order, we
+			 * must store them away here.
+			 */
+
+			if (matches == matchNum) {
+			    /*
+			     * We've run out of space in our normal store, so
+			     * we must allocate space for these backwards
+			     * matches on the heap.
+			     */
+
+			    int matchNumSize = matchNum * sizeof(int32_t);
+			    int32_t *newArray = malloc(4*matchNumSize);
+			    memcpy(newArray, storeMatch, matchNumSize);
+			    memcpy(newArray + 2*matchNum, storeLength, matchNumSize);
+			    if (storeMatch != smArray) {
+				free((char *) storeMatch);
+			    }
+			    matchNum *= 2;
+			    storeMatch = newArray;
+			    storeLength = newArray + matchNum;
+			}
+			storeMatch[matches] = matchOffset;
+			storeLength[matches] = matchLength;
+			matches += 1;
+		    } else {
+			/*
+			 * Now actually record the match, but only if we are
+			 * doing an '-all' search.
+			 */
+
+			if (searchSpecPtr->all &&
+				!searchSpecPtr->foundMatchProc(lineNum,
+				    searchSpecPtr, lineInfo, theLine, matchOffset, matchLength)) {
+			    /*
+			     * We reached the end of the search.
+			     */
+
+			    goto searchDone;
+			}
+		    }
+
+		    /*
+		     * For forward matches, unless we allow overlaps, we move
+		     * this on by the length of the current match so that we
+		     * explicitly disallow overlapping matches.
+		     */
+
+		    if (matchLength > 0 && !searchSpecPtr->overlap && !searchSpecPtr->backwards) {
+			firstOffset += matchLength;
+			if (firstOffset >= lastOffset) {
+			    /*
+			     * Now, we have to be careful not to find
+			     * overlapping matches either on the same or
+			     * following lines. Assume that if we did find
+			     * something, it goes until the last extra line we
+			     * added.
+			     *
+			     * We can break out of the loop, since we know no
+			     * more will be found.
+			     */
+
+			    alreadySearchOffset = firstOffset - lastFullLine;
+			    break;
+			}
+
+			/*
+			 * We'll add this on again just below.
+			 */
+
+			firstOffset -= 1;
+		    }
+		}
+
+		/*
+		 * Move the starting point on, in case we are doing repeated
+		 * or backwards searches (for the latter, we actually do
+		 * repeated forward searches).
+		 */
+
+		firstOffset += 1;
+	    } while (searchSpecPtr->backwards || searchSpecPtr->all);
+
+	    if (matches > 0) {
+		/*
+		 * Now we have all the matches in our array, but not stored
+		 * with 'foundMatchProc' yet.
+		 */
+
+		matches -= 1;
+		matchOffset = storeMatch[matches];
+		matchLength = storeLength[matches];
+		while (--matches >= 0) {
+		    if (lineNum == searchSpecPtr->stopLine) {
+			/*
+			 * It appears as if a condition like:
+			 *
+			 * if (storeMatch[matches]<searchSpecPtr->stopOffset)
+			 *	break;
+			 *
+			 * might be needed here, but no test case has been
+			 * found which would exercise such a problem.
+			 */
+		    }
+		    if (storeMatch[matches] + storeLength[matches] >= matchOffset + matchLength) {
+			/*
+			 * The new match totally encloses the previous one, so
+			 * we overwrite the previous one.
+			 */
+
+			matchOffset = storeMatch[matches];
+			matchLength = storeLength[matches];
+			continue;
+		    }
+		    if (!searchSpecPtr->overlap) {
+			if (storeMatch[matches] + storeLength[matches] > matchOffset) {
+			    continue;
+			}
+		    }
+		    searchSpecPtr->foundMatchProc(lineNum, searchSpecPtr,
+			    lineInfo, theLine, matchOffset, matchLength);
+		    if (!searchSpecPtr->all) {
+			goto searchDone;
+		    }
+		    matchOffset = storeMatch[matches];
+		    matchLength = storeLength[matches];
+		}
+		if (searchSpecPtr->all && matches > 0) {
+		    /*
+		     * We only need to do this for the '-all' case, because
+		     * just below we will call the foundMatchProc for the
+		     * non-all case.
+		     */
+
+		    searchSpecPtr->foundMatchProc(lineNum, searchSpecPtr,
+			    lineInfo, theLine, matchOffset, matchLength);
+		} else {
+		    lastBackwardsLineMatch = lineNum;
+		    lastBackwardsMatchOffset = matchOffset;
+		}
+	    }
+	}
+
+	/*
+	 * If the 'all' flag is set, we will already have stored all matches,
+	 * so we just proceed to the next line.
+	 *
+	 * If not, and there is a match we need to store that information and
+	 * we are done.
+	 */
+
+	if (lastBackwardsLineMatch == -1 && matchOffset >= 0 && !searchSpecPtr->all) {
+	    searchSpecPtr->foundMatchProc(lineNum, searchSpecPtr, lineInfo,
+		    theLine, matchOffset, matchLength);
+	    goto searchDone;
+	}
+
+	/*
+	 * Go to the next (or previous) line;
+	 */
+
+    nextLine:
+	linesSearched += extraLinesSearched;
+
+	while (linesSearched-- > 0) {
+	    /*
+	     * If we have just completed the 'stopLine', we are done.
+	     */
+
+	    if (lineNum == searchSpecPtr->stopLine) {
+		goto searchDone;
+	    }
+
+	    if (searchSpecPtr->backwards) {
+		lineNum -= 1;
+
+		if (lastBackwardsLineMatch != -1
+			&& (lineNum < 0 || lineNum + 2 < lastBackwardsLineMatch)) {
+		    searchSpecPtr->foundMatchProc(lastBackwardsLineMatch,
+			    searchSpecPtr, NULL, NULL, lastBackwardsMatchOffset, matchLength);
+		    lastBackwardsLineMatch = -1;
+		    if (!searchSpecPtr->all) {
+			goto searchDone;
+		    }
+		}
+
+		if (lineNum < 0) {
+		    lineNum = searchSpecPtr->numLines - 1;
+		}
+		if (!searchSpecPtr->exact) {
+		    /*
+		     * The 'exact' search loops above are designed to give us
+		     * an accurate picture of the number of lines which we can
+		     * skip here. For 'regexp' searches, on the other hand,
+		     * which can match potentially variable lengths, we cannot
+		     * skip multiple lines when searching backwards. Therefore
+		     * we only allow one line to be skipped here.
+		     */
+
+		    break;
+		}
+	    } else {
+		lineNum += 1;
+		if (lineNum >= searchSpecPtr->numLines) {
+		    lineNum = 0;
+		}
+	    }
+	    if (lineNum == searchSpecPtr->startLine && linesSearched > 0) {
+		/*
+		 * We've just searched all the way round and have gone right
+		 * through the start line without finding anything in the last
+		 * attempt.
+		 */
+
+		break;
+	    }
+	}
+
+	Tcl_SetObjLength(theLine, 0);
+    }
+  searchDone:
+
+    if (lastBackwardsLineMatch != -1) {
+	searchSpecPtr->foundMatchProc(lastBackwardsLineMatch, searchSpecPtr,
+		NULL, NULL, lastBackwardsMatchOffset, matchLength);
+    }
+
+    /*
+     * Free up the cached line and pattern.
+     */
+
+    Tcl_DecrRefCount(theLine);
+    Tcl_DecrRefCount(patObj);
+
+    /*
+     * Free up any extra space we allocated.
+     */
+
+    if (storeMatch != smArray) {
+	free((char *) storeMatch);
+    }
+
+    return code;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetTextStartEnd -
+ *
+ *	Converts an internal TkTextSegment ptr into a Tcl string obj containing
+ *	the representation of the index. (Handler for the 'startEndMark' configuration
+ *	option type.)
+ *
+ * Results:
+ *	Tcl_Obj containing the string representation of the index position.
+ *
+ * Side effects:
+ *	Creates a new Tcl_Obj.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+GetTextStartEnd(
+    ClientData clientData,
+    Tk_Window tkwin,
+    char *recordPtr,		/* Pointer to widget record. */
+    int internalOffset)		/* Offset within *recordPtr containing the start object. */
+{
+    TkTextIndex index;
+    char buf[TK_POS_CHARS] = { '\0' };
+    const TkText *textPtr = (const TkText *) recordPtr;
+    const TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    Tcl_Obj **objPtr = (Tcl_Obj **) (recordPtr + internalOffset);
+    const TkTextSegment *sharedMarker;
+    TkTextSegment *marker;
+
+    if (objPtr == &textPtr->newStartIndex) {
+	marker = textPtr->startMarker;
+	sharedMarker = sharedTextPtr->startMarker;
+    } else {
+	marker = textPtr->endMarker;
+	sharedMarker = sharedTextPtr->endMarker;
+    }
+    if (marker != sharedMarker) {
+	TkTextIndexClear2(&index, NULL, sharedTextPtr->tree);
+	TkTextIndexSetSegment(&index, marker);
+	TkTextIndexPrint(sharedTextPtr, NULL, &index, buf);
+    }
+    return Tcl_NewStringObj(buf, -1);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * SetTextStartEnd --
+ *
+ *	Converts a Tcl_Obj representing a widget's (start or end) index into a
+ *	TkTextSegment* value. (Handler for the 'startEndMark' configuration option type.)
+ *
+ * Results:
+ *	Standard Tcl result.
+ *
+ * Side effects:
+ *	May store the TkTextSegment* value into the internal representation
+ *	pointer. May change the pointer to the Tcl_Obj to NULL to indicate
+ *	that the specified string was empty and that is acceptable.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+ObjectIsEmpty(
+    Tcl_Obj *objPtr)		/* Object to test. May be NULL. */
+{
+    return objPtr ? GetByteLength(objPtr) == 0 : true;
+}
+
+static int
+SetTextStartEnd(
+    ClientData clientData,
+    Tcl_Interp *interp,		/* Current interp; may be used for errors. */
+    Tk_Window tkwin,		/* Window for which option is being set. */
+    Tcl_Obj **value,		/* Pointer to the pointer to the value object.
+				 * We use a pointer to the pointer because we
+				 * may need to return a value (NULL). */
+    char *recordPtr,		/* Pointer to storage for the widget record. */
+    int internalOffset,		/* Offset within *recordPtr at which the
+				 * internal value is to be stored. */
+    char *oldInternalPtr,	/* Pointer to storage for the old value. */
+    int flags)			/* Flags for the option, set Tk_SetOptions. */
+{
+    Tcl_Obj **objPtr = (Tcl_Obj **) (recordPtr + internalOffset);
+    Tcl_Obj **oldObjPtr = (Tcl_Obj **) oldInternalPtr;
+    const TkText *textPtr = (const TkText *) recordPtr;
+
+    assert(!*objPtr);
+    *oldObjPtr = NULL;
+
+    if ((flags & TK_OPTION_NULL_OK) && ObjectIsEmpty(*value)) {
+	*value = NULL;
+	*objPtr = Tcl_NewStringObj((objPtr == &textPtr->newStartIndex) ? "begin" : "end", -1);
+    } else {
+	*objPtr = *value;
+    }
+    Tcl_IncrRefCount(*objPtr);
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * RestoreTextStartEnd --
+ *
+ *	Restore an index option value from a saved value. (Handler for the
+ *	'index' configuration option type.)
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Restores the old value.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+RestoreTextStartEnd(
+    ClientData clientData,
+    Tk_Window tkwin,
+    char *internalPtr,		/* Pointer to storage for value. */
+    char *oldInternalPtr)	/* Pointer to old value. */
+{
+    Tcl_Obj **newValue = (Tcl_Obj **) internalPtr;
+    Tcl_Obj **oldValue = (Tcl_Obj **) oldInternalPtr;
+
+    if (*oldValue) {
+	Tcl_IncrRefCount(*oldValue);
+    }
+    *newValue = *oldValue;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FreeTextStartEnd --
+ *
+ *	Free an index option value from a saved value. (Handler for the
+ *	'index' configuration option type.)
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Releases some memory.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+FreeTextStartEnd(
+    ClientData clientData,
+    Tk_Window tkwin,
+    char *internalPtr)
+{
+    Tcl_Obj *objPtr = *(Tcl_Obj **) internalPtr;
+
+    if (objPtr) {
+	Tcl_DecrRefCount(objPtr);
+    }
+}
+
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetLineStartEnd -
+ *
+ *	Converts an internal TkTextLine ptr into a Tcl string obj containing
+ *	the line number. (Handler for the 'line' configuration option type.)
+ *
+ * Results:
+ *	Tcl_Obj containing the string representation of the line value.
+ *
+ * Side effects:
+ *	Creates a new Tcl_Obj.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+GetLineStartEnd(
+    ClientData clientData,
+    Tk_Window tkwin,
+    char *recordPtr,		/* Pointer to widget record. */
+    int internalOffset)		/* Offset within *recordPtr containing the line value. */
+{
+    TkText *textPtr;
+    TkTextLine *linePtr = *(TkTextLine **)(recordPtr + internalOffset);
+
+    if (!linePtr) {
+	return Tcl_NewObj();
+    }
+    textPtr = (TkText *) recordPtr;
+    return Tcl_NewIntObj(1 + TkBTreeLinesTo(textPtr->sharedTextPtr->tree, NULL, linePtr, NULL));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * SetLineStartEnd --
+ *
+ *	Converts a Tcl_Obj representing a widget's (start or end) line into a
+ *	TkTextLine* value. (Handler for the 'line' configuration option type.)
+ *
+ * Results:
+ *	Standard Tcl result.
+ *
+ * Side effects:
+ *	May store the TkTextLine* value into the internal representation
+ *	pointer. May change the pointer to the Tcl_Obj to NULL to indicate
+ *	that the specified string was empty and that is acceptable.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+SetLineStartEnd(
+    ClientData clientData,
+    Tcl_Interp *interp,		/* Current interp; may be used for errors. */
+    Tk_Window tkwin,		/* Window for which option is being set. */
+    Tcl_Obj **value,		/* Pointer to the pointer to the value object.
+				 * We use a pointer to the pointer because we
+				 * may need to return a value (NULL). */
+    char *recordPtr,		/* Pointer to storage for the widget record. */
+    int internalOffset,		/* Offset within *recordPtr at which the
+				 * internal value is to be stored. */
+    char *oldInternalPtr,	/* Pointer to storage for the old value. */
+    int flags)			/* Flags for the option, set Tk_SetOptions. */
+{
+    TkTextLine *linePtr = NULL;
+    char *internalPtr;
+    TkText *textPtr = (TkText *) recordPtr;
+
+    internalPtr = internalOffset >= 0 ? recordPtr + internalOffset : NULL;
+
+    if ((flags & TK_OPTION_NULL_OK) && ObjectIsEmpty(*value)) {
+	*value = NULL;
+    } else {
+	int line;
+
+	if (Tcl_GetIntFromObj(interp, *value, &line) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	linePtr = TkBTreeFindLine(textPtr->sharedTextPtr->tree, NULL, line - 1);
+    }
+
+    if (internalPtr) {
+	*((TkTextLine **) oldInternalPtr) = *((TkTextLine **) internalPtr);
+	*((TkTextLine **) internalPtr) = linePtr;
+    }
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * RestoreLineStartEnd --
+ *
+ *	Restore a line option value from a saved value. (Handler for the
+ *	'line' configuration option type.)
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Restores the old value.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+RestoreLineStartEnd(
+    ClientData clientData,
+    Tk_Window tkwin,
+    char *internalPtr,		/* Pointer to storage for value. */
+    char *oldInternalPtr)	/* Pointer to old value. */
+{
+    *(TkTextLine **) internalPtr = *(TkTextLine **) oldInternalPtr;
+}
+
+#endif /* SUPPORT_DEPRECATED_STARTLINE_ENDLINE */
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkpTesttextCmd --
+ *
+ *	This function implements the "testtext" command. It provides a set of
+ *	functions for testing text widgets and the associated functions in
+ *	tkText*.c.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	Depends on option; see below.
+ *
+ *----------------------------------------------------------------------
+ */
+
+#if TK_MAJOR_VERSION > 8 || (TK_MAJOR_VERSION == 8 && TK_MINOR_VERSION > 5)
+
+int
+TkpTesttextCmd(
+    ClientData clientData,	/* Main window for application. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument strings. */
+{
+    TkText *textPtr;
+    size_t len;
+    int lineIndex, byteIndex, byteOffset;
+    TkTextIndex index;
+    char buf[TK_POS_CHARS];
+    Tcl_CmdInfo info;
+    Tcl_Obj *watchCmd;
+
+    if (objc < 3) {
+	return TCL_ERROR;
+    }
+
+    if (Tcl_GetCommandInfo(interp, Tcl_GetString(objv[1]), &info) == 0) {
+	return TCL_ERROR;
+    }
+    textPtr = info.objClientData;
+    len = strlen(Tcl_GetString(objv[2]));
+    if (strncmp(Tcl_GetString(objv[2]), "byteindex", len) == 0) {
+	if (objc != 5) {
+	    return TCL_ERROR;
+	}
+	lineIndex = atoi(Tcl_GetString(objv[3])) - 1;
+	byteIndex = atoi(Tcl_GetString(objv[4]));
+
+	TkTextMakeByteIndex(textPtr->sharedTextPtr->tree, textPtr, lineIndex, byteIndex, &index);
+    } else if (strncmp(Tcl_GetString(objv[2]), "forwbytes", len) == 0) {
+	if (objc != 5) {
+	    return TCL_ERROR;
+	}
+	if (TkTextGetIndex(interp, textPtr, Tcl_GetString(objv[3]), &index) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	byteOffset = atoi(Tcl_GetString(objv[4]));
+	TkTextIndexForwBytes(textPtr, &index, byteOffset, &index);
+    } else if (strncmp(Tcl_GetString(objv[2]), "backbytes", len) == 0) {
+	if (objc != 5) {
+	    return TCL_ERROR;
+	}
+	if (TkTextGetIndex(interp, textPtr, Tcl_GetString(objv[3]), &index) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	byteOffset = atoi(Tcl_GetString(objv[4]));
+	TkTextIndexBackBytes(textPtr, &index, byteOffset, &index);
+    } else {
+	return TCL_ERROR;
+    }
+
+    /*
+     * Avoid triggering of the "watch" command.
+     */
+
+    watchCmd = textPtr->watchCmd;
+    textPtr->watchCmd = NULL;
+    TkTextSetMark(textPtr, "insert", &index);
+    textPtr->watchCmd = watchCmd;
+
+    TkTextPrintIndex(textPtr, &index, buf);
+    Tcl_SetObjResult(interp, Tcl_ObjPrintf("%s %d", buf, TkTextIndexGetByteIndex(&index)));
+    return TCL_OK;
+}
+
+#else /* backport to Tk 8.5 */
+
+int
+TkpTesttextCmd(
+    ClientData clientData,	/* Main window for application. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int argc,			/* Number of arguments. */
+    const char **argv)		/* Argument strings. */
+{
+    TkText *textPtr;
+    size_t len;
+    int lineIndex, byteIndex, byteOffset;
+    TkTextIndex index;
+    char buf[64];
+    unsigned offs;
+    Tcl_CmdInfo info;
+
+    if (argc < 3) {
+	return TCL_ERROR;
+    }
+
+    if (Tcl_GetCommandInfo(interp, argv[1], &info) == 0) {
+	return TCL_ERROR;
+    }
+    if (info.isNativeObjectProc) {
+	textPtr = (TkText *) info.objClientData;
+    } else {
+	textPtr = (TkText *) info.clientData;
+    }
+    len = strlen(argv[2]);
+    if (strncmp(argv[2], "byteindex", len) == 0) {
+	if (argc != 5) {
+	    return TCL_ERROR;
+	}
+	lineIndex = atoi(argv[3]) - 1;
+	byteIndex = atoi(argv[4]);
+
+	TkTextMakeByteIndex(textPtr->sharedTextPtr->tree, textPtr, lineIndex, byteIndex, &index);
+    } else if (strncmp(argv[2], "forwbytes", len) == 0) {
+	if (argc != 5) {
+	    return TCL_ERROR;
+	}
+	if (TkTextGetIndex(interp, textPtr, argv[3], &index) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	byteOffset = atoi(argv[4]);
+	TkTextIndexForwBytes(textPtr, &index, byteOffset, &index);
+    } else if (strncmp(argv[2], "backbytes", len) == 0) {
+	if (argc != 5) {
+	    return TCL_ERROR;
+	}
+	if (TkTextGetIndex(interp, textPtr, argv[3], &index) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	byteOffset = atoi(argv[4]);
+	TkTextIndexBackBytes(textPtr, &index, byteOffset, &index);
+    } else {
+	return TCL_ERROR;
+    }
+
+    TkTextSetMark(textPtr, "insert", &index);
+    TkTextPrintIndex(textPtr, &index, buf);
+    offs = strlen(buf);
+    snprintf(buf + offs, sizeof(buf) - offs, " %d", TkTextIndexGetByteIndex(&index));
+    Tcl_AppendResult(interp, buf, NULL);
+
+    return TCL_OK;
+}
+
+#endif /* TCL_MAJOR_VERSION > 8 || TCL_MINOR_VERSION > 5 */
+
+#if !NDEBUG
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkpTextInspect --
+ *
+ *	This function is for debugging only, printing the text content
+ *	on stdout.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkpTextInspect(
+    TkText *textPtr)
+{
+    Tcl_Obj *resultPtr;
+    Tcl_Obj *objv[9];
+    Tcl_Obj **argv;
+    int argc, i;
+
+    Tcl_IncrRefCount(resultPtr = Tcl_GetObjResult(textPtr->interp));
+    Tcl_ResetResult(textPtr->interp);
+    Tcl_IncrRefCount(objv[0] = Tcl_NewStringObj(Tk_PathName(textPtr->tkwin), -1));
+    Tcl_IncrRefCount(objv[1] = Tcl_NewStringObj("inspect", -1));
+    Tcl_IncrRefCount(objv[2] = Tcl_NewStringObj("-discardselection", -1));
+    Tcl_IncrRefCount(objv[3] = Tcl_NewStringObj("-elide", -1));
+    Tcl_IncrRefCount(objv[4] = Tcl_NewStringObj("-chars", -1));
+    Tcl_IncrRefCount(objv[5] = Tcl_NewStringObj("-image", -1));
+    Tcl_IncrRefCount(objv[6] = Tcl_NewStringObj("-window", -1));
+    Tcl_IncrRefCount(objv[7] = Tcl_NewStringObj("-mark", -1));
+    Tcl_IncrRefCount(objv[8] = Tcl_NewStringObj("-tag", -1));
+    TextInspectCmd(textPtr, textPtr->interp, sizeof(objv)/sizeof(objv[0]), objv);
+    for (i = 0; i < sizeof(objv)/sizeof(objv[0]); ++i) {
+	Tcl_DecrRefCount(objv[i]);
+    }
+    Tcl_ListObjGetElements(textPtr->interp, Tcl_GetObjResult(textPtr->interp), &argc, &argv);
+    for (i = 0; i < argc; ++i) {
+	printf("%s\n", Tcl_GetString(argv[i]));
+    }
+    Tcl_SetObjResult(textPtr->interp, resultPtr);
+    Tcl_DecrRefCount(resultPtr);
+}
+
+#endif /* !NDEBUG */
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkpTextDump --
+ *
+ *	This function is for debugging only, printing the text content
+ *	on stdout.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+#if !NDEBUG
+
+void
+TkpTextDump(
+    TkText *textPtr)
+{
+    Tcl_Obj *resultPtr;
+    Tcl_Obj *objv[4];
+    Tcl_Obj **argv;
+    int argc, i;
+
+    Tcl_IncrRefCount(resultPtr = Tcl_GetObjResult(textPtr->interp));
+    Tcl_ResetResult(textPtr->interp);
+
+    Tcl_IncrRefCount(objv[0] = Tcl_NewStringObj(Tk_PathName(textPtr->tkwin), -1));
+    Tcl_IncrRefCount(objv[1] = Tcl_NewStringObj("dump", -1));
+    Tcl_IncrRefCount(objv[2] = Tcl_NewStringObj("begin", -1));
+    Tcl_IncrRefCount(objv[3] = Tcl_NewStringObj("end", -1));
+    TextDumpCmd(textPtr, textPtr->interp, sizeof(objv)/sizeof(objv[0]), objv);
+    for (i = 0; i < sizeof(objv)/sizeof(objv[0]); ++i) {
+	Tcl_DecrRefCount(objv[i]);
+    }
+
+    Tcl_ListObjGetElements(textPtr->interp, Tcl_GetObjResult(textPtr->interp), &argc, &argv);
+    for (i = 0; i < argc; i += 3) {
+	char const *type = Tcl_GetString(argv[i]);
+	char const *text = Tcl_GetString(argv[i + 1]);
+	char const *indx = Tcl_GetString(argv[i + 2]);
+
+	printf("%s ", indx);
+	printf("%s ", type);
+
+	if (strcmp(type, "text") == 0) {
+	    int len = strlen(text), i;
+
+	    printf("\"");
+	    for (i = 0; i < len; ++i) {
+		char c = text[i];
+
+		switch (c) {
+		case '\t': printf("\\t"); break;
+		case '\n': printf("\\n"); break;
+		case '\v': printf("\\v"); break;
+		case '\f': printf("\\f"); break;
+		case '\r': printf("\\r"); break;
+
+		default:
+		    if (UCHAR(c) < 0x80 && isprint(c)) {
+			printf("%c", c);
+		    } else {
+			printf("\\x%02u", (unsigned) UCHAR(c));
+		    }
+		    break;
+		}
+	    }
+	    printf("\"\n");
+	} else if (strcmp(type, "mark") == 0) {
+	    Tcl_HashEntry *hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->markTable, text);
+	    const TkTextSegment *markPtr = NULL;
+
+	    if (hPtr) {
+		markPtr = Tcl_GetHashValue(hPtr);
+	    } else {
+		if (strcmp(text, "insert") == 0)  { markPtr = textPtr->insertMarkPtr; }
+		if (strcmp(text, "current") == 0) { markPtr = textPtr->currentMarkPtr; }
+	    }
+	    if (markPtr) {
+		printf("%s (%s)\n", text, markPtr->typePtr == &tkTextLeftMarkType ? "left" : "right");
+	    }
+	} else {
+	    printf("%s\n", text);
+	}
+    }
+
+    Tcl_SetObjResult(textPtr->interp, resultPtr);
+    Tcl_DecrRefCount(resultPtr);
+}
+
+#endif /* !NDEBUG */
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+/* Additionally we need stand-alone object code. */
+#define inline extern
+inline TkSharedText *	TkBTreeGetShared(TkTextBTree tree);
+inline int		TkBTreeGetNumberOfDisplayLines(const TkTextPixelInfo *pixelInfo);
+inline TkTextPixelInfo *TkBTreeLinePixelInfo(const TkText *textPtr, TkTextLine *linePtr);
+inline unsigned		TkBTreeEpoch(TkTextBTree tree);
+inline unsigned		TkBTreeIncrEpoch(TkTextBTree tree);
+inline struct Node	*TkBTreeGetRoot(TkTextBTree tree);
+inline TkTextLine *	TkBTreePrevLogicalLine(const TkSharedText *sharedTextPtr,
+			    const TkText *textPtr, TkTextLine *linePtr);
+inline TkTextTag *	TkBTreeGetTags(const TkTextIndex *indexPtr);
+inline TkTextLine *	TkBTreeGetStartLine(const TkText *textPtr);
+inline TkTextLine *	TkBTreeGetLastLine(const TkText *textPtr);
+inline TkTextLine *	TkBTreeNextLine(const TkText *textPtr, TkTextLine *linePtr);
+inline TkTextLine *	TkBTreePrevLine(const TkText *textPtr, TkTextLine *linePtr);
+inline unsigned		TkBTreeCountLines(const TkTextBTree tree, const TkTextLine *linePtr1,
+			    const TkTextLine *linePtr2);
+inline bool		TkTextIsDeadPeer(const TkText *textPtr);
+inline bool		TkTextIsStartEndMarker(const TkTextSegment *segPtr);
+inline bool		TkTextIsSpecialMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsPrivateMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsSpecialOrPrivateMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsNormalOrSpecialMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsNormalMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsStableMark(const TkTextSegment *segPtr);
+inline void		TkTextIndexSetEpoch(TkTextIndex *indexPtr, unsigned epoch);
+inline void		TkTextIndexUpdateEpoch(TkTextIndex *indexPtr, unsigned epoch);
+inline void		TkTextIndexSetPeer(TkTextIndex *indexPtr, TkText *textPtr);
+inline void		TkTextIndexSetToLastChar2(TkTextIndex *indexPtr, TkTextLine *linePtr);
+inline void		TkTextIndexInvalidate(TkTextIndex *indexPtr);
+inline TkTextLine *	TkTextIndexGetLine(const TkTextIndex *indexPtr);
+inline TkTextSegment *	TkTextIndexGetSegment(const TkTextIndex *indexPtr);
+inline TkSharedText *	TkTextIndexGetShared(const TkTextIndex *indexPtr);
+inline bool		TkTextIndexSameLines(const TkTextIndex *indexPtr1, const TkTextIndex *indexPtr2);
+inline void		TkTextIndexSave(TkTextIndex *indexPtr);
+# if TK_MAJOR_VERSION == 8 && TK_MINOR_VERSION < 7 && TCL_UTF_MAX <= 4
+inline int		TkUtfToUniChar(const char *src, int *chPtr);
+# endif
+#endif /* __STDC_VERSION__ >= 199901L */
+
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 105
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: src/tktext/tkText.h
===================================================================
--- src/tktext/tkText.h	(revision 0)
+++ src/tktext/tkText.h	(working copy)
@@ -0,0 +1,2125 @@
+/*
+ * tkText.h --
+ *
+ *	Declarations shared among the files that implement text widgets.
+ *
+ * Copyright (c) 1992-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1995 Sun Microsystems, Inc.
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKTEXT
+#define _TKTEXT
+
+#ifndef _TK
+# include "tk.h"
+#endif
+
+#ifndef _TKINT
+# include "tkInt.h"
+#endif
+
+#include "tkTextUndo.h"
+#include "tkQTree.h"
+#include "tkBool.h"
+#include "tkAlloc.h"
+#include <stdint.h>
+
+#ifdef MAC_OSX_TK
+/* required for TK_LAYOUT_WITH_BASE_CHUNKS */
+# include "tkMacOSXInt.h"
+#endif
+
+#ifdef _MSC_VER
+# if _MSC_VER >= 1900
+#  define inline __inline
+# else
+#  define inline
+# endif
+#elif __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+#ifdef BUILD_tk
+# undef TCL_STORAGE_CLASS
+# define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+#if TK_CHECK_ALLOCS
+# define DEBUG_ALLOC(expr) expr
+#else
+# define DEBUG_ALLOC(expr)
+#endif
+
+#if TK_MAJOR_VERSION < 9
+
+/* We are still supporting the deprecated -startline/-endline options. */
+# define SUPPORT_DEPRECATED_STARTLINE_ENDLINE 1
+
+/* We are still supporting invalid changes in readonly/disabled widgets. */
+# define SUPPORT_DEPRECATED_MODS_OF_DISABLED_WIDGET 1
+
+/*
+ * The special index identifier "begin" currently has the lowest precedence,
+ * because of portability reasons. But in a future Tk version it should have
+ * the same precedence as the special index identifier "end".
+ */
+# define BEGIN_DOES_NOT_BELONG_TO_BASE 1
+
+/* We are still supporting deprecated tag options. */
+# define SUPPORT_DEPRECATED_TAG_OPTIONS 1
+
+/* We are still supporting the deprecated commands "edit canundo/redo". */
+# define SUPPORT_DEPRECATED_CANUNDO_REDO 1
+
+#endif /* TK_MAJOR_VERSION < 9 */
+
+#if TK_TEXT_DONT_USE_BITFIELDS
+# define TkTextTagSet TkIntSet
+# define STRUCT struct
+#else
+# define STRUCT union
+#endif /* TK_TEXT_DONT_USE_BITFIELDS < 9 */
+
+/*
+ * Forward declarations.
+ */
+
+struct TkTextUndoStack;
+struct TkBitField;
+struct TkTextUndoToken;
+STRUCT TkTextTagSet;
+
+/* We need a backport to version 8.5 */
+#if TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION == 5
+typedef struct TkTextBTree_ *TkTextBTree;
+#endif
+
+/*
+ * The data structure below defines the pixel information for a single line of text.
+ */
+
+typedef struct TkTextDispLineEntry {
+    uint32_t height;		/* Height of display line in pixels. */
+    uint32_t pixels;		/* Accumulated height of display lines. In last entry this attribute
+    				 * will contain the old number of display lines. */
+    uint32_t byteOffset:24;	/* Byte offet relative to logical line. */
+    uint32_t hyphenRule:8;	/* Hyphenation rule applied to last char chunk of this display line. */
+} TkTextDispLineEntry;
+
+typedef struct TkTextDispLineInfo {
+    uint32_t numDispLines;	/* Number of display lines (so far). */
+    TkTextDispLineEntry entry[1];
+				/* Cached information about the display line, this is required for
+				 * long lines to avoid repeated display line height calculations
+				 * when scrolling. If numDispLines <= 1 then this information is
+				 * NULL, in this case attribute height of TkTextPixelInfo is
+				 * identical to the pixel height of the (single) display line. */
+} TkTextDispLineInfo;
+
+typedef struct TkTextPixelInfo {
+    uint32_t height;		/* Number of vertical pixels taken up by this line, whether
+    				 * currently displayed or not. This number is only updated
+				 * asychronously. Note that this number is the sum of
+				 * dispLineInfo, but only when dispLineInfo != NULL. */
+    uint32_t epoch;		/* Last epoch at which the pixel height was recalculated. */
+    TkTextDispLineInfo *dispLineInfo;
+				/* Pixel information for each display line, available only
+     				 * if more than one display line exists, otherwise it is NULL. */
+} TkTextPixelInfo;
+
+/*
+ * Macro that determines how much space to allocate:
+ */
+
+#define TEXT_DISPLINEINFO_SIZE(numDispLines) (Tk_Offset(TkTextDispLineInfo, entry) + \
+	(numDispLines)*sizeof(((TkTextDispLineInfo *) 0)->entry[0]))
+
+/*
+ * The data structure below defines a single logical line of text (from
+ * newline to newline, not necessarily what appears on one display line of the
+ * screen).
+ */
+
+struct TkTextSegment;
+
+typedef struct TkTextLine {
+    struct Node *parentPtr;	/* Pointer to parent node containing line. */
+    struct TkTextLine *nextPtr;	/* Next in linked list of lines with same parent node in B-tree.
+    				 * NULL means end of list. */
+    struct TkTextLine *prevPtr;	/* Previous in linked list of lines. NULL means no predecessor. */
+    struct TkTextSegment *segPtr;
+				/* First in ordered list of segments that make up the line. */
+    struct TkTextSegment *lastPtr;
+				/* Last in ordered list of segments that make up the line. */
+    STRUCT TkTextTagSet *tagonPtr;
+				/* This set contains all tags used in this line. */
+    STRUCT TkTextTagSet *tagoffPtr;
+    				/* This set contains tag t if and only if at least one segment in
+				 * this line does not use tag t, provided that tag t is also included
+				 * in tagonPtr. */
+    TkTextPixelInfo *pixelInfo;	/* Array containing the pixel information for each referring
+    				 * text widget. */
+    int32_t size;		/* Sum of sizes over all segments belonging to this line. */
+    uint32_t numBranches;	/* Counting the number of branches on this line. Only count branches
+    				 * connected with links, do not count branches pointing to a mark. */
+    uint32_t numLinks:30;	/* Counting the number of links on this line. */
+    uint32_t changed:1;		/* Will be set when the content of this logical line has changed. The
+    				 * display stuff will use (and reset) this flag, but only for logical
+				 * lines. The purpose of this flag is the acceleration of the line
+				 * break information. */
+    uint32_t logicalLine:1;	/* Flag whether this is the start of a logical line. */
+} TkTextLine;
+
+/*
+ * -----------------------------------------------------------------------
+ * Index structure containing line and byte index.
+ * -----------------------------------------------------------------------
+ */
+
+typedef struct TkTextPosition {
+    int32_t lineIndex;
+    int32_t byteIndex;
+} TkTextPosition;
+
+/*
+ * -----------------------------------------------------------------------
+ * Structures for undo/redo mechanism.
+ *
+ * Note that TkTextUndoToken is a generic type, used as a base struct for
+ * inheritance. Inheritance in C is portable due to C99 section 6.7.2.1
+ * bullet point 13:
+ *
+ *	Within a structure object, the non-bit-field members and the units 
+ *	in which bit-fields reside have addresses that increase in the order
+ *	in which they are declared. A pointer to a structure object, suitably
+ *	converted, points to its initial member (or if that member is a
+ *	bit-field, then to the unit in which it resides), and vice versa.
+ *	There may be unnamed padding within a structure object, but not at
+ *	beginning.
+ *
+ * This inheritance concept is also used in the portable GTK library.
+ * -----------------------------------------------------------------------
+ */
+
+/* we need some forward declarations */
+struct TkSharedText;
+struct TkTextIndex;
+struct TkTextUndoInfo;
+struct TkTextUndoIndex;
+
+typedef enum {
+    TK_TEXT_UNDO_INSERT,	TK_TEXT_REDO_INSERT,
+    TK_TEXT_UNDO_DELETE,	TK_TEXT_REDO_DELETE,
+    TK_TEXT_UNDO_IMAGE,		TK_TEXT_REDO_IMAGE,
+    TK_TEXT_UNDO_WINDOW,	TK_TEXT_REDO_WINDOW,
+    TK_TEXT_UNDO_TAG,		TK_TEXT_REDO_TAG,
+    TK_TEXT_UNDO_TAG_CLEAR,	TK_TEXT_REDO_TAG_CLEAR,
+    TK_TEXT_UNDO_TAG_PRIORITY,	TK_TEXT_REDO_TAG_PRIORITY,
+    TK_TEXT_UNDO_MARK_SET,	TK_TEXT_REDO_MARK_SET,
+    TK_TEXT_UNDO_MARK_MOVE,	TK_TEXT_REDO_MARK_MOVE,
+    TK_TEXT_UNDO_MARK_GRAVITY,	TK_TEXT_REDO_MARK_GRAVITY
+} TkTextUndoAction;
+
+typedef Tcl_Obj *(*TkTextGetUndoCommandProc)(
+    const struct TkSharedText *sharedTextPtr,
+    const struct TkTextUndoToken *item);
+
+typedef void (*TkTextUndoProc)(
+    struct TkSharedText *sharedTextPtr,
+    struct TkTextUndoInfo *undoInfo,
+    struct TkTextUndoInfo *redoInfo,
+    bool isRedo);
+
+typedef void (*TkTextDestroyUndoItemProc)(
+    struct TkSharedText *sharedTextPtr,
+    struct TkTextUndoToken *item,
+    bool reused);
+
+typedef void (*TkTextGetUndoRangeProc)(
+    const struct TkSharedText *sharedTextPtr,
+    const struct TkTextUndoToken *item,
+    struct TkTextIndex *startIndex,
+    struct TkTextIndex *endIndex);
+
+typedef Tcl_Obj *(*TkTextInspectProc)(
+    const struct TkSharedText *sharedTextPtr,
+    const struct TkTextUndoToken *item);
+
+typedef struct Tk_UndoType {
+    TkTextUndoAction action;
+    TkTextGetUndoCommandProc commandProc;	/* mandatory */
+    TkTextUndoProc undoProc;			/* mandatory */
+    TkTextDestroyUndoItemProc destroyProc;	/* optional */
+    TkTextGetUndoRangeProc rangeProc;		/* mandatory */
+    TkTextInspectProc inspectProc;		/* mandatory */
+} Tk_UndoType;
+
+/*
+ * The struct below either contains a mark segment or a line/byte index pair.
+ * This struct is portable due to C99 7.18.1.4.
+ */
+
+typedef struct TkTextUndoIndex {
+    union {
+	struct TkTextSegment *markPtr;	/* Predecessor/successor segment. */
+	uintptr_t byteIndex;		/* Byte index in this line. */
+    } u;
+    int32_t lineIndex;	/* Line index, if -1 this struct contains a mark segment, otherwise
+    			 * (if >= 0) this struct contains a line/byte index pair. */
+} TkTextUndoIndex;
+
+/*
+ * This is a generic type, any "derived" struct must contain
+ * 'const Tk_UndoType *' as the first member (see note above).
+ */
+typedef struct TkTextUndoToken {
+    const Tk_UndoType *undoType;
+} TkTextUndoToken;
+
+/*
+ * This is a generic type, any "derived" struct must also contain
+ * these members. Especially the tokens for insert/delete must be
+ * derived from this struct.
+ */
+typedef struct TkTextUndoTokenRange {
+    const Tk_UndoType *undoType;
+    TkTextUndoIndex startIndex;
+    TkTextUndoIndex endIndex;
+} TkTextUndoTokenRange;
+
+typedef struct TkTextUndoInfo {
+    TkTextUndoToken *token;	/* The data of this undo/redo item. */
+    uint32_t byteSize;		/* Byte size of this item. */
+} TkTextUndoInfo;
+
+/*
+ * -----------------------------------------------------------------------
+ * Segments: each line is divided into one or more segments, where each
+ * segment is one of several things, such as a group of characters, a hyphen,
+ * a mark, or an embedded widget. Each segment starts with a standard
+ * header followed by a body that varies from type to type.
+ * -----------------------------------------------------------------------
+ */
+
+/*
+ * The data structure below defines the body of a segment that represents
+ * a branch. A branch is adjusting the chain of segments, depending whether
+ * elidden text will be processed or not.
+ */
+
+typedef struct TkTextBranch {
+    struct TkTextSegment *nextPtr; /* The next in list of segments for the alternative branch. */
+} TkTextBranch;
+
+/*
+ * The data structure below defines the body of a segment that represents
+ * a link. A link is the connection point for a segment chain of elidden
+ * text.
+ */
+
+typedef struct TkTextLink {
+    struct TkTextSegment *prevPtr; /* Previous in list of segments for the alternative branch. */
+} TkTextLink;
+
+/*
+ * The data structure below defines line segments that represent marks. There
+ * is one of these for each mark in the text.
+ */
+
+typedef struct TkTextMarkChange {
+    struct TkTextSegment *markPtr;
+    				/* Pointer to mark segment which contains this item. */
+    struct TkTextUndoToken *toggleGravity;
+    				/* Undo token for "mark gravity". */
+    struct TkTextUndoToken *moveMark;
+    				/* Undo token for "mark move". */
+    struct TkTextUndoToken *setMark;
+    				/* Undo token for "mark set". */
+    const struct Tk_SegType *savedMarkType;
+    				/* Type of mark (left or right gravity) before "mark gravity". We
+				 * need this information for optimizing succeeding calls of
+				 * "mark gravity" with same mark. */
+} TkTextMarkChange;
+
+typedef struct TkTextMark {
+    struct TkText *textPtr;	/* Overall information about text widget. */
+    uintptr_t ptr;		/* [Address is even - real type is Tcl_HashEntry *]
+				 *   Pointer to hash table entry for mark (in sharedTextPtr->markTable).
+				 * [Address is odd - real type is const char *]
+				 *   Name of mark, this is used iff the segment is preserved for undo. */
+    TkTextMarkChange *changePtr;/* Pointer to retained undo tokens. */
+} TkTextMark;
+
+/*
+ * A structure of the following type holds information for each window
+ * embedded in a text widget. This information is only used by the file
+ * tkTextWind.c
+ */
+
+typedef struct TkTextEmbWindowClient {
+    struct TkText *textPtr;	/* Information about the overall text widget. */
+    Tk_Window tkwin;		/* Window for this segment. NULL means that the window
+    				 * hasn't been created yet. */
+    Tcl_HashEntry *hPtr;	/* Pointer to hash table entry for mark
+				 * (in sharedTextPtr->windowTable). */
+    unsigned chunkCount;	/* Number of display chunks that refer to this window. */
+    bool displayed;		/* Non-zero means that the window has been displayed on
+    				 * the screen recently. */
+    struct TkTextSegment *parent;
+    struct TkTextEmbWindowClient *next;
+} TkTextEmbWindowClient;
+
+typedef struct TkTextEmbWindow {
+    struct TkSharedText *sharedTextPtr;
+				/* Information about the shared portion of the text widget. */
+    Tk_Window tkwin;		/* Window for this segment. This is just a temporary value,
+    				 * copied from 'clients', to make option table updating easier.
+				 * NULL means that the window hasn't been created yet. */
+    char *create;		/* Script to create window on-demand. NULL means no such script.
+    				 * Malloc-ed. */
+    int align;			/* How to align window in vertical space. See definitions in
+    				 * tkTextWind.c. */
+    int padX, padY;		/* Padding to leave around each side of window, in pixels. */
+    bool stretch;		/* Should window stretch to fill vertical space of line
+    				 * (except for pady)? */
+    Tk_OptionTable optionTable;	/* Token representing the configuration specifications. */
+    TkTextEmbWindowClient *clients;
+				/* Linked list of peer-widget specific information for this
+				 * embedded window. */
+} TkTextEmbWindow;
+
+/*
+ * A structure of the following type holds information for each image embedded
+ * in a text widget. This information is only used by the file tkTextImage.c
+ */
+
+typedef struct TkTextEmbImage {
+    struct TkSharedText *sharedTextPtr;
+				/* Information about the shared portion of the text widget.
+				 * This is used when the image changes or is deleted. */
+    char *imageString;		/* Name of the image for this segment. */
+    char *imageName;		/* Name used by text widget to identify this image.
+    				 * May be unique-ified. */
+    char *name;			/* Name used in the hash table. Used by "image names" to
+    				 * identify this instance of the image. */
+    struct TkTextEmbImage *nextPtr;
+    				/* Will be used in TkTextPickCurrent. */
+    bool hovered;		/* Will be used in TkTextPickCurrent. */
+    bool haveBindings;		/* Flag whether this image has bindings. */
+    uint32_t numClients;	/* Size of bbox array. */
+    TkQTreeRect *bbox;		/* Bounding box of this image, one bbox for every peer. */
+    Tk_Image image;		/* Image for this segment. NULL means that the image hasn't
+    				 * been created yet. */
+    int imgHeight;		/* Height of displayed image. */
+    Tcl_HashEntry *hPtr;	/* Pointer to hash table entry for image
+    				 * (in sharedTextPtr->imageTable).*/
+    int align;			/* How to align image in vertical space. See definitions in
+    				 * tkTextImage.c. */
+    int padX, padY;		/* Padding to leave around each side of image, in pixels. */
+    Tk_OptionTable optionTable;	/* Token representing the configuration specifications. */
+} TkTextEmbImage;
+
+/*
+ * A structure of the following type is for the definition of the hyphenation
+ * segments. Note that this structure is a derivation of a char segment. This
+ * is portable due to C99 section 6.7.2.1 (see above - undo/redo).
+ */
+
+typedef struct TkTextHyphen {
+    char chars[6];		/* Characters that make up character info. Actual length varies. */
+    int8_t textSize;		/* Actual length of text, but not greater than 5. */
+    int8_t rules;		/* Set of rules for this hyphen, will be set by tk_textInsert. */
+} TkTextHyphen;
+
+/*
+ * The data structure below defines line segments.
+ */
+
+typedef struct TkTextSegment {
+    const struct Tk_SegType *typePtr;
+				/* Pointer to record describing segment's type. */
+    struct TkTextSegment *nextPtr;
+				/* Next in list of segments for this line, or NULL for end of list. */
+    struct TkTextSegment *prevPtr;
+				/* Previous in list of segments for this line, or NULL for start
+				 * of list. */
+    struct TkTextSection *sectionPtr;
+    				/* The section where this segment belongs. */
+    STRUCT TkTextTagSet *tagInfoPtr;
+				/* Tag information for this segment, needed for testing whether
+				 * this content is tagged with a specific tag. Used only if size > 0.
+				 * (In case of segments with size == 0 memory will be wasted - these
+				 * segments do not need this attribute - but the alternative would be
+				 * a quite complex structure with some nested structs and unions, and
+				 * this is quite inconvenient. Only marks and branches/links do not
+				 * use this information, so the waste of memory is relatively low.) */
+    int32_t size;		/* Size of this segment (# of bytes of index space it occupies). */
+    uint32_t refCount:26;	/* Reference counter, don't delete until counter is zero, or
+    				 * tree is gone. */
+    uint32_t protectionFlag:1;	/* This (char) segment is protected, join is not allowed. */
+    uint32_t insertMarkFlag:1;	/* This segment is the special "insert" mark? */
+    uint32_t currentMarkFlag:1;	/* This segment is the special "current" mark? */
+    uint32_t privateMarkFlag:1;	/* This mark segment is private (generated)? */
+    uint32_t normalMarkFlag:1;	/* This mark segment is neither protected, nor special, nor private,
+    				 * nor start or end marker. */
+    uint32_t startEndMarkFlag:1;/* This segment is a start marker or an end marker? */
+
+    union {
+	char chars[1];		/* Characters that make up character info. Actual length varies
+				 * to hold as many characters as needed. */
+	TkTextHyphen hyphen;	/* Information about hyphen. */
+	TkTextEmbWindow ew;	/* Information about embedded window. */
+	TkTextEmbImage ei;	/* Information about embedded image. */
+	TkTextMark mark;	/* Information about mark. */
+	TkTextBranch branch;	/* Information about branch. */
+	TkTextLink link;	/* Information about link. */
+    } body;
+} TkTextSegment;
+
+/*
+ * Macro that determines how much space to allocate for a specific segment:
+ */
+
+#define SEG_SIZE(bodyType) ((unsigned) (Tk_Offset(TkTextSegment, body) + sizeof(bodyType)))
+
+/*
+ * The data structure below defines sections of text segments. Each section
+ * contains 40 line segments in average. In this way fast search for segments
+ * is possible.
+ */
+typedef struct TkTextSection {
+    struct TkTextLine *linePtr;	/* The line where this section belongs. */
+    struct TkTextSection *nextPtr;
+    				/* Next in list of sections, or NULL if last. */
+    struct TkTextSection *prevPtr;
+    				/* Previous in list of sections, or NULL if first. */
+    struct TkTextSegment *segPtr;
+    				/* First segment belonging to this section. */
+    int32_t size:24;		/* Sum of size over all segments belonging to this section. */
+    uint32_t length:8;		/* Number of segments belonging to this section. */
+} TkTextSection;
+
+/*
+ * Data structures of the type defined below are used during the execution of
+ * Tcl commands to keep track of various interesting places in a text. An
+ * index is only valid up until the next modification to the character
+ * structure of the b-tree so they can't be retained across Tcl commands.
+ * However, mods to marks or tags don't invalidate indices.
+ */
+
+typedef struct TkTextIndex {
+    TkTextBTree tree;		/* Tree containing desired position. */
+    struct TkText *textPtr;	/* The associated text widget (required). */
+    uint32_t stateEpoch;	/* The epoch of the segment pointer. */
+
+    /*
+     * The following attribtes should not be accessed directly, use the TkTextIndex*
+     * functions if you want to set or get attributes.
+     */
+
+    struct {
+	TkTextLine *linePtr;	/* Pointer to line containing position of interest. */
+	TkTextSegment *segPtr;	/* Pointer to segment containing position
+				 * of interest (NULL means not yet computed). */
+	bool isCharSegment;	/* Whether 'segPtr' is a char segment (if not NULL). */
+	int32_t byteIndex;	/* Index within line of desired character (0 means first one,
+				 * -1 means not yet computed). */
+	int32_t lineNo;		/* The line number of the line pointer. */
+	int32_t lineNoRel;	/* The line number of the line pointer in associated text widget. */
+    } priv;
+
+    bool discardConsistencyCheck;
+				/* This flag is for debugging only: in certain situations consistency
+				 * checks should not be done (for example when inserting or deleting
+				 * text). */
+} TkTextIndex;
+
+/*
+ * Types for procedure pointers stored in TkTextDispChunk strutures:
+ */
+
+typedef struct TkTextDispChunk TkTextDispChunk;
+
+typedef void 	Tk_ChunkDisplayProc(struct TkText *textPtr, TkTextDispChunk *chunkPtr,
+		    int x, int y, int height, int baseline, Display *display, Drawable dst,
+		    int screenY);
+typedef void	Tk_ChunkUndisplayProc(struct TkText *textPtr, TkTextDispChunk *chunkPtr);
+typedef int	Tk_ChunkMeasureProc(TkTextDispChunk *chunkPtr, int x);
+typedef void	Tk_ChunkBboxProc(struct TkText *textPtr, TkTextDispChunk *chunkPtr,
+		    int index, int y, int lineHeight, int baseline, int *xPtr, int *yPtr,
+		    int *widthPtr, int *heightPtr);
+
+/*
+ * The structure below represents a chunk of stuff that is displayed together
+ * on the screen. This structure is allocated and freed by generic display
+ * code but most of its fields are filled in by segment-type-specific code.
+ */
+
+typedef enum {
+    TEXT_DISP_CHAR   = 1 << 0, /* Character layout */
+    TEXT_DISP_HYPHEN = 1 << 1, /* Hyphen layout */
+    TEXT_DISP_ELIDED = 1 << 2, /* Elided content layout */
+    TEXT_DISP_WINDOW = 1 << 3, /* Embedded window layout */
+    TEXT_DISP_IMAGE  = 1 << 4, /* Embedded image layout */
+    TEXT_DISP_CURSOR = 1 << 5, /* Insert cursor layout */
+} TkTextDispType;
+
+/* This constant can be used for a test whether the chunk has any content. */
+#define TEXT_DISP_CONTENT (TEXT_DISP_CHAR|TEXT_DISP_HYPHEN|TEXT_DISP_WINDOW|TEXT_DISP_IMAGE)
+/* This constant can be used for a test whether the chunk contains text. */
+#define TEXT_DISP_TEXT    (TEXT_DISP_CHAR|TEXT_DISP_HYPHEN)
+
+typedef struct TkTextDispChunkProcs {
+    TkTextDispType type;	/* Layout type. */
+    Tk_ChunkDisplayProc *displayProc;
+				/* Procedure to invoke to draw this chunk on the display
+				 * or an off-screen pixmap. */
+    Tk_ChunkUndisplayProc *undisplayProc;
+				/* Procedure to invoke when segment ceases to be displayed
+				 * on screen anymore. */
+    Tk_ChunkMeasureProc *measureProc;
+				/* Procedure to find character under a given x-location. */
+    Tk_ChunkBboxProc *bboxProc;	/* Procedure to find bounding box of character in chunk. */
+} TkTextDispChunkProcs;
+
+struct TkTextDispChunkSection;
+
+struct TkTextDispChunk {
+    /*
+     * The fields below are set by the type-independent code before calling
+     * the segment-type-specific layoutProc. They should not be modified by
+     * segment-type-specific code.
+     */
+
+    struct TkTextDispChunk *nextPtr;
+				/* Next chunk in the display line or NULL for the end of the list. */
+    struct TkTextDispChunk *prevPtr;
+				/* Previous chunk in the display line or NULL for the start of the
+				 * list. */
+    struct TkTextDispChunk *prevCharChunkPtr;
+				/* Previous char chunk in the display line, or NULL. */
+    struct TkTextDispChunkSection *sectionPtr;
+    				/* The section of this chunk. The section structure allows fast search
+				 * for x positions, and character positions. */
+    struct TextStyle *stylePtr;	/* Display information, known only to tkTextDisp.c. */
+
+    /*
+     * The fields below are set by the layoutProc that creates the chunk.
+     */
+
+    const TkTextDispChunkProcs *layoutProcs;
+    const char *brks;		/* Line break information of this chunk for TEXT_WRAPMODE_CODEPOINT. */
+    ClientData clientData;	/* Additional information for use of displayProc and undisplayProc. */
+
+    /*
+     * The fields below are set by the type-independent code before calling
+     * the segment-type-specific layoutProc. They should not be modified by
+     * segment-type-specific code.
+     */
+
+    int32_t x;			/* X position of chunk, in pixels. This position is measured
+    				 * from the left edge of the logical line, not from the left
+				 * edge of the window (i.e. it doesn't change under horizontal
+				 * scrolling). */
+
+    /*
+     * The fields below are set by the layoutProc that creates the chunk.
+     */
+
+    uint32_t byteOffset;	/* Byte offset relative to display line start. */
+    uint32_t numBytes;		/* Number of bytes that will be used in the chunk. */
+    uint32_t numSpaces;		/* Number of expandable spaces. */
+    uint32_t segByteOffset;	/* Starting offset in corresponding char segment. */
+    int32_t minAscent;		/* Minimum space above the baseline needed by this chunk. */
+    int32_t minDescent;		/* Minimum space below the baseline needed by this chunk. */
+    int32_t minHeight;		/* Minimum total line height needed by this chunk. */
+    int32_t width;		/* Width of this chunk, in pixels. Initially set by
+    				 * chunk-specific code, but may be increased to include tab
+				 * or extra space at end of line. */
+    int32_t additionalWidth;	/* Additional width when expanding spaces for full justification. */
+    int32_t hyphenRules;	/* Allowed hyphenation rules for this (hyphen) chunk. */
+    int32_t breakIndex:29;	/* Index within chunk of last acceptable position for a line
+    				 * (break just before this byte index). <= 0 means don't break
+				 * during or immediately after this chunk. */
+    uint32_t wrappedAtSpace:1;	/* This flag will be set when the a chunk has been wrapped while
+    				 * gobbling a trailing space. */
+    uint32_t endsWithSyllable:1;/* This flag will be set when the corresponding sgement for
+    				 * this chunk will be followed by a hyphen segment. */
+    uint32_t skipFirstChar:1;	/* This flag will be set if the first byte has to be skipped due
+    				 * to a spelling change. */
+
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+
+    /*
+     * Support of context drawing (Mac):
+     */
+
+    Tcl_DString baseChars;	/* Actual characters for the stretch of text, only defined in
+    				 * base chunk. */
+    int32_t baseWidth;		/* Width in pixels of the whole string, if known, else 0. */
+    int32_t xAdjustment;	/* Adjustment of x-coord for next chunk. */
+    struct TkTextDispChunk *baseChunkPtr;
+    				/* Points to base chunk. */
+
+#endif /* TK_LAYOUT_WITH_BASE_CHUNKS */
+};
+
+/*
+ * One data structure of the following type is used for each tag in a text
+ * widget. These structures are kept in sharedTextPtr->tagTable and referred
+ * to in other structures.
+ */
+
+typedef enum {
+    TEXT_WRAPMODE_CHAR,
+    TEXT_WRAPMODE_NONE,
+    TEXT_WRAPMODE_WORD,
+    TEXT_WRAPMODE_CODEPOINT,
+    TEXT_WRAPMODE_NULL
+} TkWrapMode;
+
+/*
+ * The spacing mode of the text widget:
+ */
+
+typedef enum {
+    TEXT_SPACEMODE_NONE,
+    TEXT_SPACEMODE_EXACT,
+    TEXT_SPACEMODE_TRIM,
+    TEXT_SPACEMODE_NULL,
+} TkTextSpaceMode;
+
+/*
+ * The justification modes:
+ */
+
+typedef enum {
+    TK_TEXT_JUSTIFY_LEFT,	/* The text is aligned along the left margin. This is the default. */
+    TK_TEXT_JUSTIFY_RIGHT,	/* The text is aligned along the right margin. */
+    TK_TEXT_JUSTIFY_FULL,	/* The text is aligned along the left margin, and word-spacing is
+    				 * adjusted so that the text flush with both margins. */
+    TK_TEXT_JUSTIFY_CENTER	/* The text is aligned to neither the left nor the right margin,
+    				 * there is an even gap on each side of each line. */
+} TkTextJustify;
+
+/*
+ * If the soft hyphen is the right neighbor of character "c", and the right neighbor is character
+ * "k", then the ck hyphenation rule will be applied.
+ */
+#define TK_TEXT_HYPHEN_CK		1 /* de */
+/*
+ * Hungarian has an unusual hyphenation case which involves reinsertion of a root-letter, as in the
+ * following example: "vissza" becomes "visz-sza". These special cases, occurring when the characters
+ * are in the middle of a word are: "ccs" becomes "cs-cs", "ggy" becomes "gy-gy", "lly" becomes "ly-ly",
+ * "nny" becomes "ny-ny", "tty" becomes "ty-ty", "zzs" becomes "zs-zs", "ssz" becomes "sz-sz".
+ */
+#define TK_TEXT_HYPHEN_DOUBLE_DIGRAPH	2 /* hu */
+/*
+ * If the soft hyphen is the right neighbor of any vowel, and the right neighbor is the same vowel,
+ * then the doublevowel hyphenation rule will be applied.
+ */
+#define TK_TEXT_HYPHEN_DOUBLE_VOWEL	3 /* nl */
+/*
+ * In Catalan, a geminated consonant can be splitted: the word "parallel" hyphenates
+ * into "paral-lel".
+ */
+#define TK_TEXT_HYPHEN_GEMINATION	4 /* ca */
+/*
+ * In Polish the hyphen will be repeated after line break, this means for example that "kong-fu"
+ * becomes "kong- -fu".
+ */
+#define TK_TEXT_HYPHEN_REPEAT		5 /* pl */
+/*
+ * If the soft hyphen is the right neighbor of any vocal, and the right neighbor of any vocal with
+ * trema (umlaut), then the trema hyphenation rule will be applied.
+ */
+#define TK_TEXT_HYPHEN_TREMA		6 /* nl */
+/*
+ * If the soft hyphen is the right neighbor of any consonant, and the right neighbor is the same
+ * consonant, and the right consonant is followed by a vowel, then the tripleconsonant hyphenation
+ * rule will be applied when not hyphenating.
+ */
+#define TK_TEXT_HYPHEN_TRIPLE_CONSONANT	7 /* de, nb, nn, no, sv */
+/*
+ * Mask of all defined hyphen rules.
+ */
+#define TK_TEXT_HYPHEN_MASK		((1 << (TK_TEXT_HYPHEN_TRIPLE_CONSONANT + 1)) - 1)
+
+typedef struct TkTextTag {
+    const char *name;		/* Name of this tag. This field is actually a pointer to the key
+    				 * from the entry in 'sharedTextPtr->tagTable', so it needn't be
+				 * freed explicitly. For "sel" tags this is just a static string,
+				 * so again need not be freed. */
+    const struct TkSharedText *sharedTextPtr;
+				/* Shared section of all peers. */
+    struct TkText *textPtr;
+				/* If non-NULL, then this tag only applies to the given text widget
+				 * (when there are peer widgets). */
+    struct Node *rootPtr;	/* Pointer into the B-Tree at the lowest node that completely
+    				 * dominates the ranges of text occupied by the tag. At this node
+				 * there is no information about the tag. One or more children of
+				 * the node do contain information about the tag. */
+    int32_t priority;		/* Priority of this tag within widget. 0 means lowest priority.
+    				 * Exactly one tag has each integer value between 0 and numTags-1. */
+    uint32_t index;		/* Unique index for fast tag lookup. It is guaranteed that the index
+    				 * number is less or equal than 'TkBitSize(sharedTextPtr->usedTags)'.*/
+    unsigned refCount;		/* Number of objects referring to us. */
+    bool isDisabled;		/* This tag is disabled? */
+
+    /*
+     * Information for tag collection [TkBTreeGetTags, TextInspectCmd, TkTextPickCurrent].
+     */
+
+    struct TkTextTag *nextPtr;	/* Will be set by TkBTreeGetTags, TkBTreeClearTags, and TextInsertCmd. */
+    struct TkTextTag *succPtr;	/* Only TextInspectCmd will use this attribute. */
+    uint32_t flag;		/* Only for temporary usage (currently only TextInspectCmd and
+    				 * TkTextPickCurrent will use this attribute). */
+    uint32_t epoch;		/* Only TkBTreeGetTags, TkBTreeGetSegmentTags, TkBTreeClearTags,
+    				 * and TkTextPickCurrent will use this attribute. */
+
+    /*
+     * Information for undo/redo.
+     */
+
+    TkTextUndoToken *recentTagAddRemoveToken;
+    				/* Holds the undo information of last tag add/remove operation. */
+    TkTextUndoToken *recentChangePriorityToken;
+    				/* Holds the undo information of last tag lower/raise operation. */
+    bool recentTagAddRemoveTokenIsNull;
+    				/* 'recentTagAddRemoveToken' is null, this means the pointer still
+				 * is valid, but should not be saved onto undo stack. */
+    int32_t savedPriority; 	/* Contains the priority before recentChangePriorityToken will be set. */
+    int32_t undoTagListIndex;	/* Index to entry in 'undoTagList', is -1 if not in 'undoTagList'. */
+
+    /*
+     * Information for displaying text with this tag. The information belows
+     * acts as an override on information specified by lower-priority tags.
+     * If no value is specified, then the next-lower-priority tag on the text
+     * determins the value. The text widget itself provides defaults if no tag
+     * specifies an override.
+     */
+
+    Tk_3DBorder border;		/* Used for drawing background. NULL means no value specified here. */
+    int borderWidth;		/* Width of 3-D border for background. */
+    Tcl_Obj *borderWidthPtr;	/* Width of 3-D border for background. */
+    char *reliefString;		/* -relief option string (malloc-ed). NULL means option not specified. */
+    int relief;			/* 3-D relief for background. */
+    Pixmap bgStipple;		/* Stipple bitmap for background. None means no value specified here. */
+    char *indentBgString;	/* Background will be indented accordingly to the -lmargin1, and
+    				 * -lmargin2 options. */
+    bool indentBg;		/* Background will be indented accordingly to the -lmargin1, and
+    				 * -lmargin2 options. */
+    XColor *fgColor;		/* Foreground color for text. NULL means no value specified here. */
+    Tk_Font tkfont;		/* Font for displaying text. NULL means no value specified here. */
+    Pixmap fgStipple;		/* Stipple bitmap for text and other foreground stuff. None means
+    				 * no value specified here.*/
+    char *justifyString;	/* -justify option string (malloc-ed). NULL means option not
+    				 * specified. */
+    TkTextJustify justify;	/* How to justify text: TK_TEXT_JUSTIFY_LEFT, TK_TEXT_JUSTIFY_RIGHT,
+    				 * TK_TEXT_JUSTIFY_CENTER, or TK_TEXT_JUSTIFY_FULL. Only valid if
+				 * justifyString is non-NULL. */
+    char *lMargin1String;	/* -lmargin1 option string (malloc-ed). NULL means option not
+				 * specified. */
+    int lMargin1;		/* Left margin for first display line of each text line, in pixels.
+    				 * Only valid if lMargin1String is non-NULL. */
+    char *lMargin2String;	/* -lmargin2 option string (malloc-ed). NULL means option not
+    				 * specified. */
+    int lMargin2;		/* Left margin for second and later display lines of each text line,
+    				 * in pixels. Only valid if lMargin2String is non-NULL. */
+    Tk_3DBorder lMarginColor;	/* Used for drawing background in left margins. This is used for both
+    				 * lmargin1 and lmargin2. NULL means no value specified here. */
+    char *offsetString;		/* -offset option string (malloc-ed). NULL means option not specified. */
+    int offset;			/* Vertical offset of text's baseline from baseline of line. Used
+    				 * for superscripts and subscripts. Only valid if offsetString is
+				 * non-NULL. */
+    char *overstrikeString;	/* -overstrike option string (malloc-ed). NULL means option not
+    				 * specified. */
+    bool overstrike;		/* True means draw horizontal line through middle of text. Only
+    				 * valid if overstrikeString is non-NULL. */
+    XColor *overstrikeColor;    /* Color for the overstrike. NULL means same color as foreground. */
+    char *rMarginString;	/* -rmargin option string (malloc-ed). NULL means option not
+    				 * specified. */
+    int rMargin;		/* Right margin for text, in pixels. Only valid if rMarginString
+    				 * is non-NULL. */
+    Tk_3DBorder rMarginColor;	/* Used for drawing background in right margin. NULL means no value
+    				 * specified here. */
+    Tk_3DBorder selBorder;	/* Used for drawing background for selected text.
+				 * NULL means no value specified here. */
+    XColor *selFgColor;		/* Foreground color for selected text. NULL means no value specified
+    				 * here. */
+    char *spacing1String;	/* -spacing1 option string (malloc-ed). NULL means option not
+    				 * specified. */
+    int spacing1;		/* Extra spacing above first display line for text line. Only valid
+    				 * if spacing1String is non-NULL. */
+    char *spacing2String;	/* -spacing2 option string (malloc-ed). NULL means option not
+    				 * specified. */
+    int spacing2;		/* Extra spacing between display lines for the same text line. Only
+    				 * valid if spacing2String is non-NULL. */
+    char *spacing3String;	/* -spacing2 option string (malloc-ed). NULL means option not
+    				 * specified. */
+    int spacing3;		/* Extra spacing below last display line for text line. Only valid
+    				 * if spacing3String is non-NULL. */
+    Tcl_Obj *tabStringPtr;	/* -tabs option string. NULL means option not specified. */
+    struct TkTextTabArray *tabArrayPtr;
+				/* Info about tabs for tag (malloc-ed) or NULL. Corresponds to
+				 * tabString. */
+    int tabStyle;		/* One of TABULAR or WORDPROCESSOR or NONE (if not specified). */
+    char *underlineString;	/* -underline option string (malloc-ed). NULL means option not
+    				 * specified. */
+    bool underline;		/* True means draw underline underneath text. Only valid if
+    				 * underlineString is non-NULL. */
+    XColor *underlineColor;     /* Color for the underline. NULL means same color as foreground. */
+    XColor *eolColor;		/* Color for the end of line symbol. NULL means same color as
+    				 * foreground. */
+    XColor *hyphenColor;	/* Color for the soft hyphen character. NULL means same color as
+    				 * foreground. */
+    TkWrapMode wrapMode;	/* How to handle wrap-around for this tag. Must be TEXT_WRAPMODE_CHAR,
+				 * TEXT_WRAPMODE_NONE, TEXT_WRAPMODE_WORD, TEXT_WRAPMODE_CODEPOINT, or
+				 * TEXT_WRAPMODE_NULL to use wrapmode for whole widget. */
+    TkTextSpaceMode spaceMode;	/* How to handle displaying spaces. Must be TEXT_SPACEMODE_NULL,
+    				 * TEXT_SPACEMODE_NONE, TEXT_SPACEMODE_EXACT, or TEXT_SPACEMODE_TRIM. */
+    Tcl_Obj *hyphenRulesPtr;	/* The hyphen rules string. */
+    int hyphenRules;		/* The hyphen rules, only useful for soft hyphen segments. */
+    Tcl_Obj *langPtr;		/* -lang option string. NULL means option not specified. */
+    char lang[3];		/* The specified language for the text content, only enabled if not
+    				 * NUL. */
+    char *elideString;		/* -elide option string (malloc-ed). NULL means option not specified. */
+    bool elide;			/* True means that data under this tag should not be displayed. */
+    bool undo;			/* True means that any change of tagging with this tag will be pushed
+    				 * on the undo stack (if undo stack is enabled), otherwise this tag
+				 * will not regarded in the undo/redo process. */
+
+    /*
+     * Derived values, and the container for all the options.
+     */
+
+    bool affectsDisplay;	/* True means that this tag affects the way information is
+    				 * displayed on the screen (so need to redisplay if tag changes). */
+    bool affectsDisplayGeometry;/* True means that this tag affects the size with which
+    				 * information is displayed on the screen (so need to recalculate
+				 * line dimensions if tag changes). */
+    Tk_OptionTable optionTable;	/* Token representing the configuration specifications. */
+    } TkTextTag;
+
+/*
+ * Some definitions for tag search, used by TkBTreeStartSearch, TkBTreeStartSearchBack:
+ */
+
+typedef enum {
+    SEARCH_NEXT_TAGON,		/* Search for next range, this will skip the current range. */
+    SEARCH_EITHER_TAGON_TAGOFF,	/* Search for next tagon/tagoff change. */
+} TkTextSearchMode;
+
+/*
+ * The data structure below is used for searching a B-tree for transitions on
+ * a single tag (or for all tag transitions). No code outside of tkTextBTree.c
+ * should ever modify any of the fields in these structures, but it's OK to
+ * use them for read-only information.
+ */
+
+typedef struct TkTextSearch {
+    TkTextIndex curIndex;	/* Position of last tag transition returned by TkBTreeNextTag,
+    				 * or index of start of segment containing starting position
+				 * for search if TkBTreeNextTag hasn't been called yet, or
+				 * same as stopIndex if search is over. */
+    TkTextSegment *segPtr;	/* Actual tag segment returned by last call to TkBTreeNextTag,
+    				 * or NULL if TkBTreeNextTag hasn't returned anything yet. */
+    TkTextSegment *resultPtr;	/* Actual result of last search. */
+    TkTextSegment *lastPtr;	/* Stop search before just before considering this segment. */
+    TkTextLine *lastLinePtr;	/* The last line of the search range. */
+    const TkTextTag *tagPtr;	/* Tag to search for. */
+    struct TkText *textPtr;	/* Where we are searching. */
+    TkTextSearchMode mode;	/* Search mode. */
+    bool tagon;			/* We have to search for toggle on? */
+    bool endOfText;		/* Search is ending at end of text? */
+    int linesLeft;		/* Lines left to search (including curIndex and stopIndex).
+    				 * When this becomes <= 0 the search is over. */
+    int linesToEndOfText;	/* Add this to linesLeft when searching to end of text. */
+} TkTextSearch;
+
+/*
+ * The following data structure describes a single tab stop. It must be kept
+ * in sync with the 'tabOptionStrings' array in the function 'TkTextGetTabs'
+ */
+
+typedef enum { LEFT, RIGHT, CENTER, NUMERIC } TkTextTabAlign;
+
+/*
+ * The following are the supported styles of tabbing, used for the -tabstyle
+ * option of the text widget. The last element is only used for tag options.
+ */
+
+typedef enum {
+    TK_TEXT_TABSTYLE_TABULAR,
+    TK_TEXT_TABSTYLE_WORDPROCESSOR,
+    TK_TEXT_TABSTYLE_NONE
+} TkTextTabStyle;
+
+typedef struct TkTextTab {
+    int location;		/* Offset in pixels of this tab stop from the left margin
+    				 * (lmargin2) of the text. */
+    TkTextTabAlign alignment;	/* Where the tab stop appears relative to the text. */
+} TkTextTab;
+
+typedef struct TkTextTabArray {
+    int numTabs;		/* Number of tab stops. */
+    double lastTab;		/* The accurate fractional pixel position of the last tab. */
+    double tabIncrement;	/* The accurate fractional pixel increment between interpolated
+    				 * tabs we have to create when we exceed numTabs. */
+    TkTextTab tabs[1];		/* Array of tabs. The actual size will be numTabs. THIS FIELD
+    				 * MUST BE THE LAST IN THE STRUCTURE. */
+} TkTextTabArray;
+
+/*
+ * Enumeration defining the edit modes of the widget.
+ */
+
+typedef enum {
+    TK_TEXT_EDIT_INSERT,	/* insert mode */
+    TK_TEXT_EDIT_DELETE,	/* delete mode */
+    TK_TEXT_EDIT_REPLACE,	/* replace mode */
+    TK_TEXT_EDIT_OTHER		/* none of the above */
+} TkTextEditMode;
+
+/*
+ * The following enum is used to define a type for the -state option of the Text widget.
+ */
+
+typedef enum {
+    TK_TEXT_STATE_DISABLED,	/* Don't receive any text. */
+    TK_TEXT_STATE_NORMAL,	/* Allows all operations. */
+    TK_TEXT_STATE_READONLY	/* Do not allow user operations. */
+} TkTextState;
+
+/*
+ * A data structure of the following type is shared between each text widget that are peers.
+ */
+
+struct TkRangeList;
+struct TkText;
+
+typedef struct TkSharedText {
+    unsigned refCount;		/* Reference count this shared object. */
+    TkTextBTree tree;		/* B-tree representation of text and tags for widget. */
+    Tcl_HashTable tagTable;	/* Hash table that maps from tag names to pointers to TkTextTag
+    				 * structures. The "sel" tag does not feature in this table, since
+				 * there's one of those for each text peer. */
+    unsigned numEnabledTags;	/* Number of tags currently enabled; needed to keep track of
+    				 * priorities. */
+    unsigned numTags;		/* Number of tags currently defined for widget. */
+    unsigned numMarks;		/* Number of marks, not including private or special marks. */
+    unsigned numPrivateMarks;	/* Number of private marks. */
+    unsigned numImages;		/* Number of embedded images; for information only. */
+    unsigned numWindows;	/* Number of embedded windows; for information only. */
+    unsigned tagInfoSize;	/* The required index size for tag info sets. */
+    struct TkBitField *usedTags;
+				/* Bit set of used tag indices. */
+    struct TkBitField *elisionTags;
+				/* Bit set of tags with elide information. */
+    struct TkBitField *selectionTags;
+				/* Bit set of all selection tags. */
+    struct TkBitField *dontUndoTags;
+				/* Bit set of all tags with -undo=no. */
+    struct TkBitField *affectDisplayTags;
+				/* Bit set of tags which are affecting the display. */
+    struct TkBitField *notAffectDisplayTags;
+				/* Bit set of tags which are *not* affecting the display. */
+    struct TkBitField *affectDisplayNonSelTags;
+				/* Bit set of tags which are affecting the display, but exclusive
+				 * the special selection tags. */
+    struct TkBitField *affectGeometryTags;
+				/* Bit set of tags which are affecting the display geometry. */
+    struct TkBitField *affectGeometryNonSelTags;
+				/* Bit set of tags which are affecting the display geometry, but
+				 * exclusive the special selection tags. */
+    struct TkBitField *affectLineHeightTags;
+				/* Bit set of tags which are affecting the line heigth. */
+    TkTextTag **tagLookup;	/* Lookup vector for tags. */
+    Tcl_HashTable markTable;	/* Hash table that maps from mark names to pointers to mark
+    				 * segments. The special "insert" and "current" marks are not
+				 * stored in this table, but directly accessed as fields of
+				 * textPtr. */
+    Tcl_HashTable windowTable;	/* Hash table that maps from window names to pointers to window
+    				 * segments. If a window segment doesn't yet have an associated
+				 * window, there is no entry for it here. */
+    Tcl_HashTable imageTable;	/* Hash table that maps from image names to pointers to image
+    				 * segments. If an image segment doesn't yet have an associated
+				 * image, there is no entry for it here. */
+    Tk_BindingTable tagBindingTable;
+				/* Table of all tag bindings currently defined for this widget.
+				 * NULL means that no bindings exist, so the table hasn't been
+				 * created. Each "object" used for this table is the name of a
+				 * tag. */
+    Tk_BindingTable imageBindingTable;
+				/* Table of all image bindings currently defined for this widget.
+				 * NULL means that no bindings exist, so the table hasn't been
+				 * created. Each "object" used for this table is the name of an
+				 * image. */
+    TkTextSegment *startMarker;	/* The start marker, the content of this widget starts after this
+    				 * merker. */
+    TkTextSegment *endMarker;	/* If the end marker is at byte index zero, then the next newline
+				 * does not belong to this widget, otherwise the next newline
+				 * also belongs to this widget. */
+    STRUCT TkTextTagSet *emptyTagInfoPtr;
+    				/* Empty tag information. */
+    unsigned numMotionEventBindings;
+				/* Number of tags with bindings to motion events. */
+    unsigned numElisionTags;	/* Number of tags with elideString. */
+    bool allowUpdateLineMetrics;
+				/* We don't allow line height computations before first Configure
+				 * event has been accepted. */
+
+    /*
+     * Miscellanous information.
+     */
+
+    bool steadyMarks;		/* This option causes that any mark now simultaneous behaves like
+    				 * an invisible character, this means that the relative order of
+				 * marks will not change. */
+    unsigned imageCount;	/* Used for creating unique image names. */
+    unsigned countEmbWindows;	/* Used for counting embedded windows. */
+    bool triggerWatchCmd;	/* Whether we should trigger the watch command for any peer. */
+    bool haveToSetCurrentMark;	/* Flag whether a position change of the "current" mark has
+    				 * been postponed in any peer. */
+
+    /*
+     * Miscellaneous mutual data.
+     */
+
+    unsigned inspectEpoch;	/* Only used in TextInspectCmd. */
+    unsigned pickEpoch;		/* Only used in TkTextPickCurrent. */
+    TkTextSegment *protectionMark[2];
+    				/* Protection markers for segments .*/
+    struct TkText *mainPeer;	/* Needed for unrelated index lookup. */
+
+    /*
+     * Information for displaying.
+     */
+
+    Tcl_HashTable breakInfoTable;
+    				/* Hash table that maps from logical line pointers to BreakInfos for
+				 * this widget. Note that this table is used in display stuff, but
+				 * for technical reasons we have to keep this table in shared
+				 * resource, because it's a shared table. */
+    bool breakInfoTableIsInitialized;
+    				/* Flag whether breakInfoTable is initialized. */
+
+    /*
+     * Information related to the undo/redo functionality.
+     */
+
+    struct TkTextUndoStack *undoStack;
+				/* The undo/redo stack. */
+    int maxUndoDepth;		/* The maximum depth of the undo stack expressed as the
+    				 * maximum number of compound statements. */
+    int maxRedoDepth;		/* The maximum depth of the redo stack expressed as the
+    				 * maximum number of compound statements. */
+    int maxUndoSize;		/* The maximum number of bytes kept on the undo stack. */
+    bool undo;			/* Non-zero means the undo/redo behaviour is enabled. */
+    bool autoSeparators;	/* Non-zero means the separators will be inserted automatically. */
+    bool isModified;		/* Flag indicating the computed 'modified' state of the text widget. */
+    bool isAltered;		/* Flag indicating the computed 'altered' state of the text widget. */
+    bool isIrreversible;	/* Flag indicating the computed 'irreversible' flag. Value
+    				 * 'true' can never change to 'false', except the widget will
+				 * be cleared, or the user is clearing. */
+    bool userHasSetModifiedFlag;/* Flag indicating if the user has set the 'modified' flag.
+    				 * Value 'true' is superseding the computed value, but value
+				 * 'false' is only clearing to the initial state of this flag. */
+    bool undoStackEvent;	/* Flag indicating whether <<UndoStack>> is already triggered. */
+    unsigned undoLevel;		/* The undo level which corresponds to the unmodified state. */
+    TkTextEditMode lastEditMode;/* Keeps track of what the last edit mode was. */
+    int lastUndoTokenType;	/* Type of newest undo token on stack. */
+    TkTextTag **undoTagList;	/* Array of tags, prepared for undo stack. */
+    TkTextMarkChange *undoMarkList;
+    				/* Array of mark changes, prepared for undo stack. */
+    uint32_t undoTagListCount;	/* Number of entries in array 'undoTagList'. */
+    uint32_t undoTagListSize;	/* Size of array 'undoTagList'. */
+    				/* Array of undo entries for mark operations. */
+    uint32_t undoMarkListCount;	/* Number of entries in array 'undoMarkList'. */
+    uint32_t undoMarkListSize;	/* Size of array 'undoMarkList'. */
+    uint32_t insertDeleteUndoTokenCount;
+    				/* Count number of tokens on undo stack for insert/delete actions. */
+    TkTextUndoIndex prevUndoStartIndex;
+    				/* Start index (left position) of previous undo operation; only for
+				 * 'insert' and 'delete'. */
+    TkTextUndoIndex prevUndoEndIndex;
+    				/* End index (right position) of previous undo operation; only for
+				 * 'insert' and 'delete'. */
+
+    /*
+     * Keep track of all the peers.
+     */
+
+    struct TkText *peers;
+    unsigned numPeers;
+
+    /*
+     * Hook for watching the existence of this struct. Do never use dynamic memory,
+     * only stack pointers shall be hooked.
+     */
+
+    bool *stillExisting;
+} TkSharedText;
+
+/*
+ * The following enum is used to define a type for the -insertunfocussed
+ * option of the Text widget.
+ */
+
+typedef enum {
+    TK_TEXT_INSERT_NOFOCUS_HOLLOW,
+    TK_TEXT_INSERT_NOFOCUS_NONE,
+    TK_TEXT_INSERT_NOFOCUS_SOLID
+} TkTextInsertUnfocussed;
+
+/*
+ * The tagging modes:
+ */
+
+typedef enum {
+    TK_TEXT_TAGGING_WITHIN,	/* The new text will receive any tags that are present on both
+				 * the character before and the character after the insertion point.
+				 * This is the default. */
+    TK_TEXT_TAGGING_GRAVITY,	/* The new text will receive any tags that are present at one side
+    				 * of the insertion point: if insert cursor has gravity right then
+				 * receive the tags of the character after the insertion point,
+				 * otherwise it will receive the tags of the character before the
+				 * insertion point (supports Arabian, and the like). */
+    TK_TEXT_TAGGING_NONE	/* The new text will not receive any tags from adjacent characters. */
+} TkTextTagging;
+
+/*
+ * A data structure of the following type is kept for each text widget that
+ * currently exists for this process:
+ */
+
+struct TkTextStringList;
+
+typedef struct TkText {
+    /*
+     * Information related to and accessed by widget peers and the TkSharedText handling routines.
+     */
+
+    TkSharedText *sharedTextPtr;/* Shared section of all peers. */
+    struct TkText *next;	/* Next in list of linked peers. */
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+    TkTextLine *startLine;	/* First B-tree line to show, or NULL to start at the beginning.
+    				 * Note that this feature is deprecated and should be removed some day.
+				 */
+    TkTextLine *endLine;	/* Last B-tree line to show, or NULL for up to the end.
+    				 * Note that this feature is deprecated and should be removed some day.
+				 */
+#endif
+    TkTextSegment *startMarker;	/* First B-Tree segment (mark) belonging to this widget. */
+    TkTextSegment *endMarker;	/* Last B-Tree segment (mark) belonging to this widget */
+    Tcl_Obj *newStartIndex;	/* New position for start marker. */
+    Tcl_Obj *newEndIndex;	/* New position for end marker. */
+    int pixelReference;		/* Counter into the current tree reference index corresponding
+    				 * to this widget. */
+    bool abortSelections;	/* Set to true whenever the text is modified in a way that interferes
+    				 * with selection retrieval: used to abort incremental selection
+				 * retrievals. */
+    bool pendingAfterSync;	/* RunAfterSyncCmd is in event queue. */
+    bool pendingFireEvent;	/* FireWidgetViewSyncEvent is in event queue. */
+    bool sendSyncEvent;		/* Send <<WidgetViewSync>> event as soon as the line metric is
+    				 * up-to-date, even if we have no sync state change. */
+    bool prevSyncState;		/* Previous sync state of the line-height calculation. */
+    bool dontRepick;		/* Set to 'true' during scroll operation, but only when -responsiveness
+    				 * is greater than zero. */
+
+    /*
+     * Standard Tk widget information and text-widget specific items.
+     */
+
+    Tk_Window tkwin;		/* Window that embodies the text. NULL means that the window has been
+    				 * destroyed but the data structures haven't yet been cleaned up.*/
+    Display *display;		/* Display for widget. Needed, among other things, to allow resources
+    				 * to be freed even after tkwin has gone away. */
+    Tcl_Interp *interp;		/* Interpreter associated with widget. Used to delete widget command. */
+    Tcl_Command widgetCmd;	/* Token for text's widget command. */
+    TkTextState state;		/* Either TK_TEXT_STATE_NORMAL, TK_TEXT_STATE_READONLY, or
+    				 * TK_TEXT_STATE_DISABLED. A text widget is also read-only when
+				 * disabled. */
+
+    /*
+     * Default information for displaying (may be overridden by tags applied
+     * to ranges of characters).
+     */
+
+    Tk_3DBorder border;		/* Structure used to draw 3-D border and default background. */
+    int borderWidth;		/* Width of 3-D border to draw around entire widget. */
+    int padX, padY;		/* Padding between text and window border. */
+    int relief;			/* 3-d effect for border around entire widget: TK_RELIEF_RAISED etc. */
+    int highlightWidth;		/* Width in pixels of highlight to draw around widget when it
+    				 * has the focus. <= 0 means don't draw a highlight. */
+    XColor *highlightBgColorPtr;/* Color for drawing traversal highlight area when highlight is off. */
+    XColor *highlightColorPtr;	/* Color for drawing traversal highlight. */
+    Tk_Cursor cursor;		/* Current cursor for window, or None. */
+    XColor *fgColor;		/* Default foreground color for text. */
+    XColor *eolColor;		/* Foreground color for end of line symbol, can be NULL. */
+    Tcl_Obj *eolCharPtr;	/* Use this character for displaying end of line. Can be NULL or empty,
+    				 * in this case the default char U+00B6 (pilcrow) will be used. */
+    XColor *hyphenColor;	/* Foreground color for soft hyphens, can be NULL. */
+    Tk_Font tkfont;		/* Default font for displaying text. */
+    int charWidth;		/* Width of average character in default font. */
+    int spaceWidth;		/* Width of space character in default font. */
+    int lineHeight;		/* Height of line in default font, including line spacing. */
+    int spacing1;		/* Default extra spacing above first display line for each text line. */
+    int spacing2;		/* Default extra spacing between display lines for the same text line. */
+    int spacing3;		/* Default extra spacing below last display line for each text line. */
+    Tcl_Obj *tabOptionPtr; 	/* Value of -tabs option string. */
+    TkTextTabArray *tabArrayPtr;
+				/* Information about tab stops (malloc'ed). NULL means perform
+				 * default tabbing behavior. */
+    int tabStyle;		/* One of TABULAR or WORDPROCESSOR. */
+    TkTextJustify justify;	/* How to justify text: TK_TEXT_JUSTIFY_LEFT, TK_TEXT_JUSTIFY_RIGHT,
+    				 * TK_TEXT_JUSTIFY_CENTER, or TK_TEXT_JUSTIFY_FULL. */
+    Tcl_Obj *hyphenRulesPtr;	/* The hyphen rules string. */
+    int hyphenRules;		/* The hyphen rules, only useful for soft hyphen segments. */
+    Tcl_Obj *langPtr;		/* -lang option string. NULL means option not specified. */
+    char lang[3];		/* The specified language for the text content, only enabled if not
+    				 * NUL. */
+
+    /*
+     * Additional information used for displaying:
+     */
+
+    TkWrapMode wrapMode;	/* How to handle wrap-around. Must be TEXT_WRAPMODE_CHAR,
+    				 * TEXT_WRAPMODE_WORD, TEXT_WRAPMODE_CODEPOINT, or TEXT_WRAPMODE_NONE. */
+    TkTextSpaceMode spaceMode;	/* How to handle displaying spaces. Must be TEXT_SPACEMODE_NONE,
+    				 * TEXT_SPACEMODE_EXACT, or TEXT_SPACEMODE_TRIM. */
+    bool hyphens;		/* Indicating the hypenation support. */
+    bool hyphenate;		/* Indicating whether the soft hyphens will be used for line breaks
+    				 * (if not in state TK_TEXT_STATE_NORMAL). */
+    bool useUniBreak;		/* Use library libunibreak for line break computation, otherwise the
+    				 * internal algorithm will be used. */
+    int width, height;		/* Desired dimensions for window, measured in characters. */
+    bool setGrid;		/* Non-zero means pass gridding information to window manager. */
+    int prevWidth, prevHeight;	/* Last known dimensions of window; used to detect changes in size. */
+    TkTextIndex topIndex;	/* Identifies first character in top display line of window. */
+    struct TextDInfo *dInfoPtr;	/* Information maintained by tkTextDisp.c. */
+    bool showEndOfLine;		/* Flag whether the end of line symbol will be shown at end of
+    				 * each logical line. */
+    bool syncTime;		/* Synchronization timeout, used for line metric calculation, default is
+    				 * 200. */
+
+    /*
+     * Information related to selection.
+     */
+
+    TkTextTag *selTagPtr;	/* Pointer to "sel" tag. Used to tell when a new selection
+    				 * has been made. */
+    Tk_3DBorder selBorder;	/* Border and background for selected characters. This is
+    				 * a copy of information in *selTagPtr, so it shouldn't be
+				 * explicitly freed. */
+    Tk_3DBorder inactiveSelBorder;
+				/* Border and background for selected characters when they
+				 * don't have the focus. */
+    int selBorderWidth;		/* Width of border around selection. */
+    Tcl_Obj *selBorderWidthPtr;	/* Width of border around selection. */
+    XColor *selFgColorPtr;	/* Foreground color for selected text. This is a copy of
+    				 * information in *selTagPtr, so it shouldn't be explicitly freed. */
+    bool exportSelection;	/* Non-zero means tie "sel" tag to X selection. */
+    TkTextSearch selSearch;	/* Used during multi-pass selection retrievals. */
+    TkTextIndex selIndex;	/* Used during multi-pass selection retrievals. This index
+    				 * identifies the next character to be returned from the
+				 * selection. */
+
+    /*
+     * Information related to insertion cursor:
+     */
+
+    TkTextSegment *insertMarkPtr;
+				/* Points to segment for "insert" mark. */
+    Tk_3DBorder insertBorder;	/* Used to draw vertical bar for insertion cursor. */
+    XColor *insertFgColorPtr;	/* Foreground color for text behind a block cursor.
+    				 * NULL means no value specified here. */
+    bool showInsertFgColor;	/* Flag whether insertFgColorPtr is relevant. */
+    int insertWidth;		/* Total width of insert cursor. */
+    int insertBorderWidth;	/* Width of 3-D border around insert cursor */
+    TkTextInsertUnfocussed insertUnfocussed;
+				/* How to display the insert cursor when the
+				 * text widget does not have the focus. */
+    int insertOnTime;		/* Number of milliseconds cursor should spend
+				 * in "on" state for each blink. */
+    int insertOffTime;		/* Number of milliseconds cursor should spend
+				 * in "off" state for each blink. */
+    Tcl_TimerToken insertBlinkHandler;
+				/* Timer handler used to blink cursor on and off. */
+    TkTextTagging tagging;	/* Tagging mode, used when inserting chars; the mode how to extend
+				 * tagged ranges of characters. */
+
+    /*
+     * Information used for the watch of changes:
+     */
+
+    Tcl_Obj *watchCmd;		/* The command prefix for the "watch" command. */
+    bool triggerAlways;		/* Whether we should trigger for any modification. */
+    TkTextIndex insertIndex;	/* Saved position of insertion cursor. */
+
+    /*
+     * Information related to the language support functionality.
+     */
+
+    char *brksBuffer;		/* Buffer for line break information, will be filled by
+    				 * TkTextComputeBreakLocations (for TEXT_WRAPMODE_CODEPOINT). */
+    unsigned brksBufferSize;	/* Size of line break buffer. */
+
+    /*
+     * Information used for event bindings associated with tags:
+     */
+
+    TkTextSegment *currentMarkPtr;
+				/* Pointer to segment for "current" mark, or NULL if none. */
+    TkTextIndex currentMarkIndex;
+    				/* The index of the "current" mark, needed for postponing the
+				 * insertion of the "current" mark segment.
+				 */
+    bool haveToSetCurrentMark;	/* Flag whether a position change of the "current" mark has
+    				 * been postponed. */
+    XEvent pickEvent;		/* The event from which the current character was chosen.
+    				 * Must be saved so that we can repick after modifications
+				 * to the text. */
+    unsigned numCurTags;	/* Number of tags associated with character at current mark. */
+    TkTextTag **curTagArrayPtr;
+    				/* Pointer to array of tags for current mark, or NULL if none. */
+    bool currNearbyFlag;	/* The 'nearby' flag of last pick event. */
+
+    /*
+     * Information used for event bindings associated with images:
+     */
+
+    bool configureBboxTree;	/* Flag whether we have to resize the image bounding box tree. */
+    TkQTree imageBboxTree;	/* Lookup of points in a set of rectangles, for fast mouse
+    				 * hovering lookup. */
+    TkTextEmbImage **hoveredImageArr;
+    				/* This is the array of currently hovered image. */
+    unsigned hoveredImageArrSize;
+    				/* Number of entries in 'hoveredImageArrSize'. */
+    unsigned hoveredImageArrCapacity;
+    				/* Capacity of 'hoveredImageArr'. */
+
+    /*
+     * Miscellaneous additional information:
+     */
+
+    char *takeFocus;		/* Value of -takeFocus option; not used in the C code, but
+    				 * used by keyboard traversal scripts. Malloc'ed, but may be NULL. */
+    char *xScrollCmd;		/* Prefix of command to issue to update horizontal scrollbar
+    				 * when view changes. */
+    char *yScrollCmd;		/* Prefix of command to issue to update vertical scrollbar when
+    				 * view changes. */
+    unsigned flags;		/* Miscellaneous flags; see below for definitions. */
+    Tk_OptionTable optionTable;	/* Token representing the configuration specifications. */
+    unsigned refCount;		/* Number of objects referring to us. */
+    bool blockCursorType;	/* false = standard insertion cursor, true = block cursor. */
+    bool accelerateTagSearch;	/* Update B-Tree tag information for search? */
+    int responsiveness;		/* The delay in ms before repick the mouse position (behavior when
+				 * scrolling the widget). */
+    unsigned uniqueIdCounter;	/* Used for the generation of unique mark names. */
+    struct TkTextStringList *varBindingList;
+    				/* Linked list of variables which should be unset when the widget
+				 * will be destroyed. */
+    bool sharedIsReleased;	/* Boolean value whether shared resource have been released. */
+
+    /*
+     * Copies of information from the shared section relating to the editor control mode:
+     */
+
+    bool steadyMarks;		/* false = behavior of original implementation,
+    				 * true  = new editor control mode. */
+
+    /*
+     * Copies of information from the shared section relating to the undo/redo functonality:
+     */
+
+    bool undo;			/* Non-zero means the undo/redo behaviour is enabled. */
+    int maxUndoDepth;		/* The maximum depth of the undo stack expressed as the
+    				 * maximum number of compound statements. */
+    int maxRedoDepth;		/* The maximum depth of the redo stack expressed as the
+    				 * maximum number of compound statements. */
+    int maxUndoSize;		/* The maximum number of bytes kept on the undo stack. */
+    bool autoSeparators;	/* Non-zero means the separators will be inserted automatically. */
+
+    /*
+     * Support of sync command:
+     */
+
+    Tcl_Obj *afterSyncCmd;	/* Commands to be executed when lines are up to date */
+
+#if TK_CHECK_ALLOCS
+    unsigned widgetNumber;
+#endif
+} TkText;
+
+/*
+ * Flag values for TkText records:
+ *
+ * GOT_SELECTION:		Non-zero means we've already claimed the selection.
+ * INSERT_ON:			Non-zero means insertion cursor should be displayed on screen.
+ * HAVE_FOCUS:			Non-zero means this window has the input focus.
+ * BUTTON_DOWN:			1 means that a mouse button is currently down;
+ *				this is used to implement grabs for the duration of button presses.
+ * UPDATE_SCROLLBARS:		Non-zero means scrollbar(s) should be updated
+ *				during next redisplay operation.
+ * NEED_REPICK			This appears unused and should probably be ignored.
+ * OPTIONS_FREED		The widget's options have been freed.
+ * DESTROYED			The widget is going away.
+ */
+
+#define GOT_SELECTION		(1 << 0)
+#define INSERT_ON		(1 << 1)
+#define HAVE_FOCUS		(1 << 2)
+#define BUTTON_DOWN		(1 << 3)
+#define UPDATE_SCROLLBARS	(1 << 4)
+#define NEED_REPICK		(1 << 5)
+#define OPTIONS_FREED		(1 << 6)
+#define DESTROYED		(1 << 7)
+
+/*
+ * The categories of segment types:
+ */
+
+typedef enum {
+    SEG_GROUP_CHAR    = 1 << 0,	/* tkTextCharType */
+    SEG_GROUP_MARK    = 1 << 1,	/* tkTextLeftMarkType, tkTextRightMarkType */
+    SEG_GROUP_HYPHEN  = 1 << 2,	/* tkTextHyphenType */
+    SEG_GROUP_BRANCH  = 1 << 3,	/* tkTextBranchType, tkTextLinkType */
+    SEG_GROUP_IMAGE   = 1 << 4,	/* tkTextEmbImageType */
+    SEG_GROUP_WINDOW  = 1 << 5,	/* tkTextEmbWindowType */
+    SEG_GROUP_PROTECT = 1 << 6,	/* tkTextProtectionMarkType */
+    SEG_GROUP_TAG     = 1 << 7,	/* this is only needed for convenience */
+} TkSegGroupType;
+
+/*
+ * Records of the following type define segment types in terms of a collection
+ * of procedures that may be called to manipulate segments of that type.
+ */
+
+typedef bool Tk_SegDeleteProc(TkTextBTree tree, struct TkTextSegment *segPtr, int flags);
+typedef void Tk_SegReuseProc(struct TkTextSegment *segPtr);
+typedef int Tk_SegLayoutProc(const struct TkTextIndex *indexPtr, TkTextSegment *segPtr,
+		    int offset, int maxX, int maxChars, bool noCharsYet, TkWrapMode wrapMode,
+		    TkTextSpaceMode spaceMode, struct TkTextDispChunk *chunkPtr);
+typedef void Tk_SegCheckProc(const struct TkSharedText *sharedTextPtr, const TkTextSegment *segPtr);
+typedef Tcl_Obj *Tk_SegInspectProc(const TkSharedText *textPtr, const TkTextSegment *segPtr);
+
+typedef struct Tk_SegType {
+    const char *name;		/* Name of this kind of segment. */
+    TkSegGroupType group;	/* Group information. */
+    int gravity;		/* The gravity of this segment, one of GRAVITY_LEFT, GRAVITY_NEUTRAL,
+    				 * GRAVITY_RIGHT. */
+    Tk_SegDeleteProc *deleteProc;
+				/* Procedure to call to delete segment. */
+    Tk_SegReuseProc *restoreProc;
+    				/* Restore a preserved segment. This will be done when performing
+    				 * an undo. */
+    Tk_SegLayoutProc *layoutProc;
+				/* Returns size information when figuring out what to display
+				 * in window. */
+    Tk_SegCheckProc *checkProc;	/* Called during consistency checks to check internal consistency
+    				 * of segment. */
+    Tk_SegInspectProc *inspectProc;
+     				/* Called when creating the information for "inspect". */
+} Tk_SegType;
+
+/*
+ * These items are the gravity values:
+ */
+
+enum { GRAVITY_LEFT, GRAVITY_NEUTRAL, GRAVITY_RIGHT };
+
+/*
+ * The following type and items describe different flags for text widget items
+ * to count. They are used in both tkText.c and tkTextIndex.c, in
+ * 'CountIndices', 'TkTextIndexBackChars', 'TkTextIndexForwChars', and
+ * 'TkTextIndexCount'.
+ */
+
+typedef enum {
+    COUNT_HYPHENS		= 1 << 1,
+    COUNT_TEXT			= 1 << 2,
+    COUNT_CHARS			= COUNT_HYPHENS | COUNT_TEXT,
+    COUNT_INDICES		= 1 << 3,
+    COUNT_DISPLAY		= 1 << 4,
+    COUNT_DISPLAY_CHARS		= COUNT_CHARS | COUNT_DISPLAY,
+    COUNT_DISPLAY_HYPHENS	= COUNT_HYPHENS | COUNT_DISPLAY,
+    COUNT_DISPLAY_TEXT		= COUNT_TEXT | COUNT_DISPLAY,
+    COUNT_DISPLAY_INDICES	= COUNT_INDICES | COUNT_DISPLAY
+} TkTextCountType;
+
+/*
+ * Some definitions for line break support, must coincide with the defintions
+ * in /usr/include/linebreak.h:
+ */
+
+#define LINEBREAK_MUSTBREAK	0 /* Break is mandatory */
+#define LINEBREAK_ALLOWBREAK	1 /* Break is allowed */
+#define LINEBREAK_NOBREAK	2 /* No break is possible */
+#define LINEBREAK_INSIDEACHAR	3 /* Inside UTF-8 sequence */
+
+/*
+ * Flags for the delete function (Tk_SegDeleteProc):
+ *
+ * TREE_GONE		The entire tree is being deleted, so everything must get cleaned up.
+ * DELETE_BRANCHES	The branches and links will be deleted.
+ * DELETE_MARKS		The marks will be deleted.
+ * DELETE_INCLUSIVE	The deletion of the marks includes also the marks given as arguments
+ *			for the range.
+ * DELETE_CLEANUP	We have to delete anyway, due to a cleanup.
+ * DELETE_PRESERVE	We have to preserve this segment.
+ */
+
+#define TREE_GONE		(1 << 0)
+#define DELETE_BRANCHES		(1 << 1)
+#define DELETE_MARKS		(1 << 2)
+#define DELETE_INCLUSIVE	(1 << 3)
+#define DELETE_CLEANUP		(1 << 4)
+#define DELETE_PRESERVE		(1 << 5)
+
+/*
+ * The following definition specifies the maximum number of characters needed
+ * in a string to hold a position specifier.
+ */
+
+#define TK_POS_CHARS		30
+
+/*
+ * Mask used for those options which may impact the text content
+ * of individual lines displayed in the widget.
+ */
+
+#define TK_TEXT_LINE_REDRAW		(1 << 0)
+#define TK_TEXT_LINE_REDRAW_BOTTOM_LINE	(1 << 1)
+
+/*
+ * Mask used for those options which may impact the pixel height calculations
+ * of individual lines displayed in the widget.
+ */
+
+#define TK_TEXT_LINE_GEOMETRY		(1 << 2)
+
+/*
+ * Mask used for those options which should invoke the line metric update
+ * immediately.
+ */
+
+#define TK_TEXT_SYNCHRONIZE		(1 << 3)
+
+/*
+ * Mask used for those options which may impact the start and end lines/index
+ * used in the widget.
+ */
+
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+# define TK_TEXT_LINE_RANGE		(1 << 4)
+# define TK_TEXT_INDEX_RANGE		((1 << 5)|TK_TEXT_LINE_RANGE)
+#else
+# define TK_TEXT_INDEX_RANGE		(1 << 4)
+#endif /* SUPPORT_DEPRECATED_STARTLINE_ENDLINE */
+
+#if SUPPORT_DEPRECATED_TAG_OPTIONS
+# define TK_TEXT_DEPRECATED_OVERSTRIKE_FG	(1 << 6)
+# define TK_TEXT_DEPRECATED_UNDERLINE_FG	(1 << 7)
+#endif /* SUPPORT_DEPRECATED_TAG_OPTIONS */
+
+/*
+ * Used as 'action' values in calls to TkTextInvalidateLineMetrics
+ */
+
+typedef enum {
+    TK_TEXT_INVALIDATE_ONLY,
+    TK_TEXT_INVALIDATE_INSERT,
+    TK_TEXT_INVALIDATE_DELETE,
+    TK_TEXT_INVALIDATE_ELIDE
+} TkTextInvalidateAction;
+
+/*
+ * Used as special 'pickPlace' values in calls to TkTextSetYView. Zero or
+ * positive values indicate a number of pixels.
+ */
+
+#define TK_TEXT_PICKPLACE	-1
+#define TK_TEXT_NOPIXELADJUST	-2
+
+/*
+ * Declarations for variables shared among the text-related files:
+ */
+
+MODULE_SCOPE bool tkBTreeDebug;
+MODULE_SCOPE bool tkTextDebug;
+MODULE_SCOPE const Tk_SegType tkTextCharType;
+MODULE_SCOPE const Tk_SegType tkTextBranchType;
+MODULE_SCOPE const Tk_SegType tkTextLinkType;
+MODULE_SCOPE const Tk_SegType tkTextLeftMarkType;
+MODULE_SCOPE const Tk_SegType tkTextRightMarkType;
+MODULE_SCOPE const Tk_SegType tkTextHyphenType;
+MODULE_SCOPE const Tk_SegType tkTextEmbImageType;
+MODULE_SCOPE const Tk_SegType tkTextEmbWindowType;
+MODULE_SCOPE const Tk_SegType tkTextProtectionMarkType;
+
+/*
+ * Convenience constants for a better readability of TkTextFindDisplayLineStartEnd call:
+ */
+
+enum { DISP_LINE_START = false, DISP_LINE_END = true };
+
+/*
+ * Helper for guarded deallocation.
+ */
+
+#define FREE_SEGMENT(ptr) { \
+    assert(ptr->typePtr); \
+    assert(!(ptr->typePtr = NULL)); \
+    free(ptr); }
+
+/*
+ * We need a callback function for tag changes. The return value informs whether
+ * this operation is undoable.
+ */
+
+typedef bool TkTextTagChangedProc(
+    const TkSharedText *sharedTextPtr,
+    TkText *textPtr,
+    const TkTextIndex *indexPtr1,
+    const TkTextIndex *indexPtr2,
+    const TkTextTag *tagPtr,
+    bool affectsDisplayGeometry);
+
+/*
+ * Declarations for procedures that are used by the text-related files but
+ * shouldn't be used anywhere else in Tk (or by Tk clients):
+ */
+
+inline TkSharedText *	TkBTreeGetShared(TkTextBTree tree);
+inline int		TkBTreeGetNumberOfDisplayLines(const TkTextPixelInfo *pixelInfo);
+MODULE_SCOPE void	TkBTreeAdjustPixelHeight(const TkText *textPtr,
+			TkTextLine *linePtr, int newPixelHeight, unsigned mergedLogicalLines,
+			    unsigned oldNumDispLines);
+MODULE_SCOPE void	TkBTreeUpdatePixelHeights(const TkText *textPtr, TkTextLine *linePtr,
+			    int numLines, unsigned epoch);
+MODULE_SCOPE void	TkBTreeResetDisplayLineCounts(TkText *textPtr, TkTextLine *linePtr,
+			    unsigned numLines);
+MODULE_SCOPE bool	TkBTreeHaveElidedSegments(const TkSharedText *sharedTextPtr);
+inline TkTextPixelInfo * TkBTreeLinePixelInfo(const TkText *textPtr, TkTextLine *linePtr);
+MODULE_SCOPE bool	TkBTreeCharTagged(const TkTextIndex *indexPtr, const TkTextTag *tagPtr);
+MODULE_SCOPE void	TkBTreeCheck(TkTextBTree tree);
+MODULE_SCOPE TkTextBTree TkBTreeCreate(TkSharedText *sharedTextPtr, unsigned epoch);
+MODULE_SCOPE void	TkBTreeAddClient(TkTextBTree tree, TkText *textPtr, int defaultHeight);
+MODULE_SCOPE void	TkBTreeClientRangeChanged(TkText *textPtr, unsigned defaultHeight);
+MODULE_SCOPE void	TkBTreeRemoveClient(TkTextBTree tree, TkText *textPtr);
+MODULE_SCOPE void	TkBTreeDestroy(TkTextBTree tree);
+MODULE_SCOPE int	TkBTreeLoad(TkText *textPtr, Tcl_Obj *content);
+MODULE_SCOPE void	TkBTreeDeleteIndexRange(TkSharedText *sharedTextPtr,
+			    TkTextIndex *index1Ptr, TkTextIndex *index2Ptr,
+			    int flags, TkTextUndoInfo *undoInfo);
+inline unsigned		TkBTreeEpoch(TkTextBTree tree);
+inline unsigned		TkBTreeIncrEpoch(TkTextBTree tree);
+inline struct Node	* TkBTreeGetRoot(TkTextBTree tree);
+MODULE_SCOPE TkTextLine * TkBTreeFindLine(TkTextBTree tree, const TkText *textPtr, int line);
+MODULE_SCOPE TkTextLine * TkBTreeFindPixelLine(TkTextBTree tree,
+			    const TkText *textPtr, int pixels, int32_t *pixelOffset);
+MODULE_SCOPE TkTextLine * TkBTreeGetLogicalLine(const TkSharedText *sharedTextPtr,
+			    const TkText *textPtr, TkTextLine *linePtr);
+MODULE_SCOPE TkTextLine * TkBTreeNextLogicalLine(const TkSharedText *sharedTextPtr,
+			    const TkText *textPtr, TkTextLine *linePtr);
+inline TkTextLine *	TkBTreePrevLogicalLine(const TkSharedText *sharedTextPtr,
+			    const TkText *textPtr, TkTextLine *linePtr);
+MODULE_SCOPE TkTextLine * TkBTreeNextDisplayLine(TkText *textPtr, TkTextLine *linePtr,
+			    int *displayLineNo, unsigned offset);
+MODULE_SCOPE TkTextLine * TkBTreePrevDisplayLine(TkText *textPtr, TkTextLine *linePtr,
+			    int *displayLineNo, unsigned offset);
+MODULE_SCOPE TkTextSegment * TkBTreeFindStartOfElidedRange(const TkSharedText *sharedTextPtr,
+			    const TkText *textPtr, const TkTextSegment *segPtr);
+MODULE_SCOPE TkTextSegment * TkBTreeFindEndOfElidedRange(const TkSharedText *sharedTextPtr,
+			    const TkText *textPtr, const TkTextSegment *segPtr);
+inline TkTextTag *	TkBTreeGetTags(const TkTextIndex *indexPtr);
+MODULE_SCOPE TkTextTag * TkBTreeGetSegmentTags(const TkSharedText *sharedTextPtr,
+			    const TkTextSegment *segPtr, const TkText *textPtr);
+MODULE_SCOPE const char * TkBTreeGetLang(const TkText *textPtr, const TkTextSegment *segPtr);
+MODULE_SCOPE void	TkBTreeInsertChars(TkTextBTree tree, TkTextIndex *indexPtr, const char *string,
+			    STRUCT TkTextTagSet *tagInfoPtr, TkTextTag *hyphenTagPtr,
+			    TkTextUndoInfo *undoInfo);
+MODULE_SCOPE TkTextSegment *TkBTreeMakeCharSegment(const char *string, unsigned length,
+			    STRUCT TkTextTagSet *tagInfoPtr);
+MODULE_SCOPE void	TkBTreeMakeUndoIndex(const TkSharedText *sharedTextPtr,
+			    TkTextSegment *segPtr, TkTextUndoIndex *indexPtr);
+MODULE_SCOPE void	TkBTreeUndoIndexToIndex(const TkSharedText *sharedTextPtr,
+			    const TkTextUndoIndex *srcPtr, TkTextIndex *dstPtr);
+MODULE_SCOPE Tcl_Obj *	TkBTreeUndoTagInspect(const TkSharedText *sharedTextPtr,
+			    const TkTextUndoToken *item);
+MODULE_SCOPE bool	TkBTreeJoinUndoInsert(TkTextUndoToken *token1, unsigned byteSize1,
+			    TkTextUndoToken *token2, unsigned byteSize2);
+MODULE_SCOPE bool	TkBTreeJoinUndoDelete(TkTextUndoToken *token1, unsigned byteSize1,
+			    TkTextUndoToken *token2, unsigned byteSize2);
+MODULE_SCOPE void	TkBTreeReInsertSegment(const TkSharedText *sharedTextPtr,
+			    const TkTextUndoIndex *indexPtr, TkTextSegment *segPtr);
+MODULE_SCOPE unsigned	TkBTreeLinesTo(TkTextBTree tree, const TkText *textPtr,
+			    const TkTextLine *linePtr, int *deviation);
+MODULE_SCOPE unsigned	TkBTreePixelsTo(const TkText *textPtr, const TkTextLine *linePtr);
+MODULE_SCOPE void	TkBTreeLinkSegment(const TkSharedText *sharedTextPtr,
+			    TkTextSegment *segPtr, TkTextIndex *indexPtr);
+inline TkTextLine *	TkBTreeGetStartLine(const TkText *textPtr);
+inline TkTextLine *	TkBTreeGetLastLine(const TkText *textPtr);
+inline TkTextLine *	TkBTreeNextLine(const TkText *textPtr, TkTextLine *linePtr);
+inline TkTextLine *	TkBTreePrevLine(const TkText *textPtr, TkTextLine *linePtr);
+MODULE_SCOPE bool	TkBTreeMoveForward(TkTextIndex *indexPtr, unsigned byteCount);
+MODULE_SCOPE bool	TkBTreeMoveBackward(TkTextIndex *indexPtr, unsigned byteCount);
+MODULE_SCOPE bool	TkBTreeNextTag(TkTextSearch *searchPtr);
+MODULE_SCOPE bool	TkBTreePrevTag(TkTextSearch *searchPtr);
+MODULE_SCOPE TkTextSegment * TkBTreeFindNextTagged(const TkTextIndex *indexPtr1,
+			    const TkTextIndex *indexPtr2, const struct TkBitField *discardTags);
+MODULE_SCOPE TkTextSegment * TkBTreeFindPrevTagged(const TkTextIndex *indexPtr1,
+			    const TkTextIndex *indexPtr2, bool discardSelection);
+MODULE_SCOPE TkTextSegment * TkBTreeFindNextUntagged(const TkTextIndex *indexPtr1,
+			    const TkTextIndex *indexPtr2, const struct TkBitField *discardTags);
+MODULE_SCOPE unsigned	TkBTreeNumPixels(const TkText *textPtr);
+MODULE_SCOPE unsigned	TkBTreeSize(const TkTextBTree tree, const TkText *textPtr);
+MODULE_SCOPE unsigned	TkBTreeCountSize(const TkTextBTree tree, const TkText *textPtr,
+			    const TkTextLine *linePtr1, const TkTextLine *linePtr2);
+inline unsigned		TkBTreeCountLines(const TkTextBTree tree, const TkTextLine *linePtr1,
+			    const TkTextLine *linePtr2);
+MODULE_SCOPE void	TkBTreeStartSearch(const TkTextIndex *index1Ptr,
+			    const TkTextIndex *index2Ptr, const TkTextTag *tagPtr,
+			    TkTextSearch *searchPtr, TkTextSearchMode mode);
+MODULE_SCOPE void	TkBTreeStartSearchBack(const TkTextIndex *index1Ptr,
+			    const TkTextIndex *index2Ptr, const TkTextTag *tagPtr,
+			    TkTextSearch *searchPtr, TkTextSearchMode mode);
+MODULE_SCOPE void	TkBTreeLiftSearch(TkTextSearch *searchPtr);
+MODULE_SCOPE bool	TkBTreeTag(TkSharedText *sharedTextPtr, TkText *textPtr,
+			    const TkTextIndex *index1Ptr, const TkTextIndex *index2Ptr,
+			    TkTextTag *tagPtr, bool add, TkTextUndoInfo *undoInfo,
+			    TkTextTagChangedProc changedProc);
+MODULE_SCOPE TkTextTag * TkBTreeClearTags(TkSharedText *sharedTextPtr, TkText *textPtr,
+			    const TkTextIndex *index1Ptr, const TkTextIndex *index2Ptr,
+			    TkTextUndoInfo *undoInfo, bool discardSelection,
+			    TkTextTagChangedProc changedProc);
+MODULE_SCOPE void	TkBTreeUpdateElideInfo(TkText *textPtr, TkTextTag *tagPtr);
+MODULE_SCOPE void	TkBTreeUnlinkSegment(const TkSharedText *sharedTextPtr, TkTextSegment *segPtr);
+MODULE_SCOPE void	TkBTreeFreeSegment(TkTextSegment *segPtr);
+MODULE_SCOPE unsigned	TkBTreeChildNumber(const TkTextBTree tree, const TkTextLine *linePtr,
+			    unsigned *depth);
+MODULE_SCOPE unsigned	TkBTreeLinesPerNode(const TkTextBTree tree);
+MODULE_SCOPE const STRUCT TkTextTagSet * TkBTreeRootTagInfo(const TkTextBTree tree);
+MODULE_SCOPE void	TkTextBindProc(ClientData clientData, XEvent *eventPtr);
+MODULE_SCOPE void	TkTextSelectionEvent(TkText *textPtr);
+MODULE_SCOPE void	TkTextAllocStatistic();
+MODULE_SCOPE int	TkConfigureText(Tcl_Interp *interp, TkText *textPtr, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE bool	TkTextTriggerWatchCmd(TkText *textPtr, const char *operation,
+			    const char *index1, const char *index2, const char *arg, bool userFlag);
+MODULE_SCOPE void	TkTextUpdateAlteredFlag(TkSharedText *sharedTextPtr);
+MODULE_SCOPE int	TkTextIndexBbox(TkText *textPtr,
+			    const TkTextIndex *indexPtr, int *xPtr, int *yPtr,
+			    int *widthPtr, int *heightPtr, int *charWidthPtr);
+MODULE_SCOPE int	TkTextCharLayoutProc(const TkTextIndex *indexPtr, TkTextSegment *segPtr,
+			    int byteOffset, int maxX, int maxBytes, bool noCharsYet,
+			    TkWrapMode wrapMode, TkTextSpaceMode spaceMode, TkTextDispChunk *chunkPtr);
+MODULE_SCOPE void	TkTextCreateDInfo(TkText *textPtr);
+MODULE_SCOPE bool	TkTextGetDLineInfo(TkText *textPtr, const TkTextIndex *indexPtr, int *xPtr,
+			    int *yPtr, int *widthPtr, int *heightPtr, int *basePtr);
+MODULE_SCOPE int	TkTextBindEvent(Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
+			     TkSharedText *sharedTextPtr, Tk_BindingTable *bindingTablePtr,
+			     const char *name);
+MODULE_SCOPE TkTextTag * TkTextClearTags(TkSharedText *sharedTextPtr, TkText *textPtr,
+			    const TkTextIndex *indexPtr1, const TkTextIndex *indexPtr2,
+			    bool discardSelection);
+MODULE_SCOPE void	TkTextClearSelection(TkSharedText *sharedTextPtr,
+			    const TkTextIndex *indexPtr1, const TkTextIndex *indexPtr2);
+MODULE_SCOPE void	TkTextUpdateTagDisplayFlags(TkTextTag *tagPtr);
+MODULE_SCOPE TkTextTag * TkTextCreateTag(TkText *textPtr, const char *tagName, bool *newTag);
+MODULE_SCOPE TkTextTag * TkTextFindTag(const TkText *textPtr, const char *tagName);
+MODULE_SCOPE int	TkConfigureTag(Tcl_Interp *interp, TkText *textPtr, const char *tagName,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TkTextEnableTag(TkSharedText *sharedTextPtr, TkTextTag *tagPtr);
+MODULE_SCOPE void	TkTextSortTags(unsigned numTags, TkTextTag **tagArrayPtr);
+MODULE_SCOPE void	TkTextFreeDInfo(TkText *textPtr);
+MODULE_SCOPE void	TkTextResetDInfo(TkText *textPtr);
+MODULE_SCOPE void	TkTextDeleteBreakInfoTableEntries(Tcl_HashTable *breakInfoTable);
+MODULE_SCOPE void	TkTextPushTagPriorityUndo(TkSharedText *sharedTextPtr, TkTextTag *tagPtr,
+			    unsigned priority);
+MODULE_SCOPE void	TkTextPushTagPriorityRedo(TkSharedText *sharedTextPtr, TkTextTag *tagPtr,
+			    unsigned priority);
+MODULE_SCOPE void	TkTextInspectUndoTagItem(const TkSharedText *sharedTextPtr,
+			    const TkTextTag *tagPtr, Tcl_Obj* objPtr);
+MODULE_SCOPE void	TkTextTagAddRetainedUndo(TkSharedText *sharedTextPtr, TkTextTag *tagPtr);
+MODULE_SCOPE void	TkTextPushUndoTagTokens(TkSharedText *sharedTextPtr, TkTextTag *tagPtr);
+MODULE_SCOPE void	TkTextReleaseUndoTagToken(TkSharedText *sharedTextPtr, TkTextTag *tagPtr);
+MODULE_SCOPE void	TkTextPushUndoMarkTokens(TkSharedText *sharedTextPtr,
+			    TkTextMarkChange *changePtr);
+MODULE_SCOPE void	TkTextReleaseUndoMarkTokens(TkSharedText *sharedTextPtr,
+			    TkTextMarkChange *changePtr);
+MODULE_SCOPE void	TkTextInspectUndoMarkItem(const TkSharedText *sharedTextPtr,
+			    const TkTextMarkChange *changePtr, Tcl_Obj* objPtr);
+MODULE_SCOPE bool	TkTextTagChangedUndoRedo(const TkSharedText *sharedTextPtr, TkText *textPtr,
+			    const TkTextIndex *index1Ptr, const TkTextIndex *index2Ptr,
+			    const TkTextTag *tagPtr, bool affectsDisplayGeometry);
+MODULE_SCOPE bool	TkTextDeleteTag(TkText *textPtr, TkTextTag *tagPtr, Tcl_HashEntry *hPtr);
+MODULE_SCOPE void	TkTextReleaseTag(TkSharedText *sharedTextPtr, TkTextTag *tagPtr,
+			    Tcl_HashEntry *hPtr);
+MODULE_SCOPE void	TkTextFontHeightChanged(TkText *textPtr);
+MODULE_SCOPE int	TkTextTestRelation(Tcl_Interp *interp, int relation, const char *op);
+MODULE_SCOPE bool	TkTextReleaseIfDestroyed(TkText *textPtr);
+MODULE_SCOPE bool	TkTextDecrRefCountAndTestIfDestroyed(TkText *textPtr);
+MODULE_SCOPE void	TkTextFreeAllTags(TkText *textPtr);
+MODULE_SCOPE bool	TkTextGetIndexFromObj(Tcl_Interp *interp, TkText *textPtr, Tcl_Obj *objPtr,
+			    TkTextIndex *indexPtr);
+MODULE_SCOPE TkTextTabArray * TkTextGetTabs(Tcl_Interp *interp, TkText *textPtr, Tcl_Obj *stringPtr);
+MODULE_SCOPE void	TkTextInspectOptions(TkText *textPtr, const void *recordPtr,
+			    Tk_OptionTable optionTable, Tcl_DString *result, bool resolveFontNames,
+			    bool discardDefaultValues);
+MODULE_SCOPE void	TkTextFindDisplayLineStartEnd(TkText *textPtr, TkTextIndex *indexPtr, bool end);
+MODULE_SCOPE unsigned	TkTextCountDisplayLines(TkText *textPtr, const TkTextIndex *indexFrom,
+			    const TkTextIndex *indexTo);
+MODULE_SCOPE void	TkTextFindDisplayIndex(TkText *textPtr, TkTextIndex *indexPtr,
+			    int displayLineOffset, int *xOffset);
+MODULE_SCOPE bool	TkTextIndexBackChars(const TkText *textPtr, const TkTextIndex *srcPtr,
+			    int count, TkTextIndex *dstPtr, TkTextCountType type);
+MODULE_SCOPE Tcl_UniChar TkTextIndexGetChar(const TkTextIndex *indexPtr);
+MODULE_SCOPE unsigned	TkTextIndexCountBytes(const TkTextIndex *index1Ptr,
+			    const TkTextIndex *index2Ptr);
+MODULE_SCOPE unsigned	TkTextIndexCount(const TkText *textPtr,
+			    const TkTextIndex *index1Ptr, const TkTextIndex *index2Ptr,
+			    TkTextCountType type);
+MODULE_SCOPE bool	TkTextIndexForwChars(const TkText *textPtr, const TkTextIndex *srcPtr,
+			    int count, TkTextIndex *dstPtr, TkTextCountType type);
+MODULE_SCOPE void	TkTextIndexOfX(TkText *textPtr, int x, TkTextIndex *indexPtr);
+MODULE_SCOPE int	TkTextIndexYPixels(TkText *textPtr, const TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextComputeBreakLocations(Tcl_Interp *interp, const char *text, unsigned len,
+			    const char *lang, char *brks);
+MODULE_SCOPE bool	TkTextTestLangCode(Tcl_Interp *interp, Tcl_Obj *langCodePtr);
+MODULE_SCOPE int	TkTextParseHyphenRules(TkText *textPtr, Tcl_Obj *objPtr, int *rulesPtr);
+MODULE_SCOPE void	TkTextLostSelection(ClientData clientData);
+MODULE_SCOPE void	TkTextConfigureUndoStack(TkSharedText *sharedTextPtr, int maxUndoDepth,
+			    int maxByteSize);
+MODULE_SCOPE void	TkTextConfigureRedoStack(TkSharedText *sharedTextPtr, int maxRedoDepth);
+MODULE_SCOPE void	TkTextPushUndoToken(TkSharedText *sharedTextPtr, void *token,
+			    unsigned byteSize);
+MODULE_SCOPE void	TkTextPushRedoToken(TkSharedText *sharedTextPtr, void *token,
+			    unsigned byteSize);
+MODULE_SCOPE void	TkTextUndoAddMoveSegmentItem(TkSharedText *sharedTextPtr,
+			    TkTextSegment *oldPos, TkTextSegment *newPos);
+MODULE_SCOPE TkTextIndex * TkTextMakeCharIndex(TkTextBTree tree, TkText *textPtr,
+			    int lineIndex, int charIndex, TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextSegmentIsElided(const TkText *textPtr, const TkTextSegment *segPtr);
+MODULE_SCOPE void	TkTextDispAllocStatistic();
+MODULE_SCOPE bool	TkTextLineIsElided(const TkSharedText *sharedTextPtr, const TkTextLine *linePtr,
+			    const TkText *textPtr);
+MODULE_SCOPE bool	TkTextIsElided(const TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextTestTag(const TkTextIndex *indexPtr, const TkTextTag *tagPtr);
+inline bool		TkTextIsDeadPeer(const TkText *textPtr);
+MODULE_SCOPE void	TkTextGenerateWidgetViewSyncEvent(TkText *textPtr, bool sendImmediately);
+MODULE_SCOPE void	TkTextRunAfterSyncCmd(TkText *textPtr);
+MODULE_SCOPE void	TkTextInvalidateLineMetrics(TkSharedText *sharedTextPtr, TkText *textPtr,
+			    TkTextLine *linePtr, unsigned lineCount, TkTextInvalidateAction action);
+MODULE_SCOPE void	TkTextUpdateLineMetrics(TkText *textPtr, unsigned lineNum, unsigned endLine);
+MODULE_SCOPE int	TkTextUpdateOneLine(TkText *textPtr, TkTextLine *linePtr, TkTextIndex *indexPtr,
+			    unsigned maxDispLines);
+MODULE_SCOPE int	TkTextMarkCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE TkTextSegment * TkTextFindMark(const TkText *textPtr, const char *name);
+MODULE_SCOPE TkTextSegment * TkTextFreeMarks(TkSharedText *sharedTextPtr, bool retainPrivateMarks);
+MODULE_SCOPE bool	TkTextMarkNameToIndex(TkText *textPtr, const char *name, TkTextIndex *indexPtr);
+MODULE_SCOPE void	TkTextMarkSegToIndex(TkText *textPtr,
+			    TkTextSegment *markPtr, TkTextIndex *indexPtr);
+MODULE_SCOPE TkTextSegment * TkTextMakeStartEndMark(TkText *textPtr, Tk_SegType const *typePtr);
+MODULE_SCOPE TkTextSegment * TkTextMakeMark(TkText *textPtr, const char *name);
+MODULE_SCOPE TkTextSegment * TkTextMakeNewMark(TkText *textPtr, const char *name);
+MODULE_SCOPE void	TkTextUnsetMark(TkText *textPtr, TkTextSegment *markPtr);
+inline bool		TkTextIsStartEndMarker(const TkTextSegment *segPtr);
+inline bool		TkTextIsSpecialMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsPrivateMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsSpecialOrPrivateMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsNormalOrSpecialMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsNormalMark(const TkTextSegment *segPtr);
+inline bool		TkTextIsStableMark(const TkTextSegment *segPtr);
+MODULE_SCOPE const char * TkTextMarkName(const TkSharedText *sharedTextPtr, const TkText *textPtr,
+			    const TkTextSegment *markPtr);
+MODULE_SCOPE void	TkTextUpdateCurrentMark(TkSharedText *sharedTextPtr);
+MODULE_SCOPE void	TkTextSaveCursorIndex(TkText *textPtr);
+MODULE_SCOPE bool	TkTextTriggerWatchCursor(TkText *textPtr);
+MODULE_SCOPE void	TkTextInsertGetBBox(TkText *textPtr, int x, int y, int height, XRectangle *bbox);
+MODULE_SCOPE bool	TkTextDrawBlockCursor(TkText *textPtr);
+MODULE_SCOPE unsigned	TkTextGetCursorWidth(TkText *textPtr, int *x, int *offs);
+MODULE_SCOPE void	TkTextEventuallyRepick(TkText *textPtr);
+MODULE_SCOPE bool	TkTextPendingSync(const TkText *textPtr);
+MODULE_SCOPE void	TkTextPickCurrent(TkText *textPtr, XEvent *eventPtr);
+MODULE_SCOPE int	TkTextGetFirstXPixel(const TkText *textPtr);
+MODULE_SCOPE int	TkTextGetFirstYPixel(const TkText *textPtr);
+MODULE_SCOPE int	TkTextGetLastXPixel(const TkText *textPtr);
+MODULE_SCOPE int	TkTextGetLastYPixel(const TkText *textPtr);
+MODULE_SCOPE unsigned	TkTextCountVisibleImages(const TkText *textPtr);
+MODULE_SCOPE unsigned	TkTextCountVisibleWindows(const TkText *textPtr);
+MODULE_SCOPE bool	TkTextPixelIndex(TkText *textPtr, int x, int y,
+			    TkTextIndex *indexPtr, bool *nearest);
+MODULE_SCOPE Tcl_Obj *	TkTextNewIndexObj(const TkTextIndex *indexPtr);
+MODULE_SCOPE void	TkTextRedrawRegion(TkText *textPtr, int x, int y, int width, int height);
+MODULE_SCOPE bool	TkTextRedrawTag(const TkSharedText *sharedTextPtr, TkText *textPtr,
+			    const TkTextIndex *index1Ptr, const TkTextIndex *index2Ptr,
+			    const TkTextTag *tagPtr, bool affectsDisplayGeometry);
+MODULE_SCOPE void	TkTextRelayoutWindow(TkText *textPtr, int mask);
+MODULE_SCOPE void	TkTextCheckLineMetricUpdate(const TkText *textPtr);
+MODULE_SCOPE void	TkTextCheckDisplayLineConsistency(const TkText *textPtr);
+MODULE_SCOPE int	TkTextScanCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TkTextSeeCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TkTextSetYView(TkText *textPtr, TkTextIndex *indexPtr, int pickPlace);
+MODULE_SCOPE int	TkTextTagCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TkTextImageCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE bool	TkTextImageIndex(TkText *textPtr, const char *name, TkTextIndex *indexPtr);
+MODULE_SCOPE void	TkTextImageAddClient(TkSharedText *sharedTextPtr, TkText *textPtr);
+MODULE_SCOPE TkTextSegment * TkTextMakeImage(TkText *textPtr, Tcl_Obj *options);
+MODULE_SCOPE int	TkTextWindowCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE bool	TkTextWindowIndex(TkText *textPtr, const char *name, TkTextIndex *indexPtr);
+MODULE_SCOPE TkTextSegment * TkTextMakeWindow(TkText *textPtr, Tcl_Obj *options);
+MODULE_SCOPE int	TkTextYviewCmd(TkText *textPtr, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TkTextGetViewOffset(TkText *textPtr, int *x, int *y);
+MODULE_SCOPE void	TkTextWinFreeClient(Tcl_HashEntry *hPtr, TkTextEmbWindowClient *client);
+MODULE_SCOPE void	TkTextIndexSetPosition(TkTextIndex *indexPtr,
+			    int byteIndex, TkTextSegment *segPtr);
+MODULE_SCOPE int	TkTextSegToIndex(const TkTextSegment *segPtr);
+MODULE_SCOPE int	TkTextIndexPrint(const TkSharedText *sharedTextPtr, const TkText *textPtr,
+				const struct TkTextIndex *indexPtr, char *string);
+MODULE_SCOPE void	TkTextIndexSetByteIndex(TkTextIndex *indexPtr, int byteIndex);
+MODULE_SCOPE void	TkTextIndexSetByteIndex2(TkTextIndex *indexPtr,
+			    TkTextLine *linePtr, int byteIndex);
+inline void		TkTextIndexSetEpoch(TkTextIndex *indexPtr, unsigned epoch);
+inline void		TkTextIndexUpdateEpoch(TkTextIndex *indexPtr, unsigned epoch);
+MODULE_SCOPE void	TkTextIndexSetSegment(TkTextIndex *indexPtr, TkTextSegment *segPtr);
+inline void		TkTextIndexSetPeer(TkTextIndex *indexPtr, TkText *textPtr);
+MODULE_SCOPE bool	TkTextIndexIsEmpty(const TkTextIndex *indexPtr);
+MODULE_SCOPE void	TkTextIndexSetLine(TkTextIndex *indexPtr, TkTextLine *linePtr);
+MODULE_SCOPE void	TkTextIndexSetToStartOfLine(TkTextIndex *indexPtr);
+MODULE_SCOPE void	TkTextIndexSetToStartOfLine2(TkTextIndex *indexPtr, TkTextLine *linePtr);
+MODULE_SCOPE void	TkTextIndexSetToEndOfLine2(TkTextIndex *indexPtr, TkTextLine *linePtr);
+MODULE_SCOPE void	TkTextIndexSetToLastChar(TkTextIndex *indexPtr);
+inline void		TkTextIndexSetToLastChar2(TkTextIndex *indexPtr, TkTextLine *linePtr);
+MODULE_SCOPE void	TkTextIndexSetupToStartOfText(TkTextIndex *indexPtr, TkText *textPtr,
+			    TkTextBTree tree);
+MODULE_SCOPE void	TkTextIndexSetupToEndOfText(TkTextIndex *indexPtr, TkText *textPtr,
+			    TkTextBTree tree);
+MODULE_SCOPE bool	TkTextIndexAddToByteIndex(TkTextIndex *indexPtr, int numBytes);
+inline TkTextLine *	TkTextIndexGetLine(const TkTextIndex *indexPtr);
+MODULE_SCOPE int	TkTextIndexGetByteIndex(const TkTextIndex *indexPtr);
+MODULE_SCOPE unsigned	TkTextIndexGetLineNumber(const TkTextIndex *indexPtr, const TkText *textPtr);
+inline TkTextSegment *	TkTextIndexGetSegment(const TkTextIndex *indexPtr);
+MODULE_SCOPE TkTextSegment * TkTextIndexGetContentSegment(const TkTextIndex *indexPtr, int *offset);
+MODULE_SCOPE TkTextSegment * TkTextIndexGetFirstSegment(const TkTextIndex *indexPtr, int *offset);
+inline TkSharedText *	TkTextIndexGetShared(const TkTextIndex *indexPtr);
+MODULE_SCOPE void	TkTextIndexClear(TkTextIndex *indexPtr, TkText *textPtr);
+MODULE_SCOPE void	TkTextIndexClear2(TkTextIndex *indexPtr, TkText *textPtr, TkTextBTree tree);
+inline void		TkTextIndexInvalidate(TkTextIndex *indexPtr);
+MODULE_SCOPE void	TkTextIndexToByteIndex(TkTextIndex *indexPtr);
+MODULE_SCOPE void	TkTextIndexMakeShared(TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextIndexIsZero(const TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextIndexIsStartOfLine(const TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextIndexIsEndOfLine(const TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextIndexIsStartOfText(const TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextIndexIsEndOfText(const TkTextIndex *indexPtr);
+inline bool		TkTextIndexSameLines(const TkTextIndex *indexPtr1, const TkTextIndex *indexPtr2);
+MODULE_SCOPE bool	TkTextIndexIsEqual(const TkTextIndex *indexPtr1, const TkTextIndex *indexPtr2);
+MODULE_SCOPE int	TkTextIndexCompare(const TkTextIndex *indexPtr1, const TkTextIndex *indexPtr2);
+inline void		TkTextIndexSave(TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextIndexRebuild(TkTextIndex *indexPtr);
+MODULE_SCOPE int	TkTextIndexRestrictToStartRange(TkTextIndex *indexPtr);
+MODULE_SCOPE int	TkTextIndexRestrictToEndRange(TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextIndexEnsureBeforeLastChar(TkTextIndex *indexPtr);
+MODULE_SCOPE bool	TkTextSkipElidedRegion(TkTextIndex *indexPtr);
+
+/*
+ * Debugging info macro:
+ */
+
+#define TK_TEXT_DEBUG(expr)	{ if (tkTextDebug) { expr; } }
+#define TK_BTREE_DEBUG(expr)	{ if (tkBTreeDebug) { expr; } }
+
+/*
+ * Backport definitions for Tk 8.6/8.5.
+ */
+
+#if TK_MAJOR_VERSION == 8 && TK_MINOR_VERSION < 7
+
+# if TCL_UTF_MAX > 4
+#  define TkUtfToUniChar Tcl_UtfToUniChar
+# else /* if TCL_UTF_MAX <= 4 */
+inline int TkUtfToUniChar(const char *src, int *chPtr);
+# endif /* TCL_UTF_MAX > 4 */
+
+#endif /* end of backport for 8.6/8.5 */
+
+/*
+ * Backport definitions for Tk 8.5. Tk 8.6/8.7 under Mac OS X has event loop
+ * issues, so backporting is important.
+ */
+
+#if TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION == 5
+
+#ifndef CLANG_ASSERT
+# define CLANG_ASSERT(expr) assert(expr)
+#endif
+
+#ifndef DEF_TEXT_INSERT_UNFOCUSSED
+# define DEF_TEXT_INSERT_UNFOCUSSED "none"
+#endif
+
+MODULE_SCOPE struct TkTextSegment * TkTextSetMark(struct TkText *textPtr, const char *name,
+			    struct TkTextIndex *indexPtr);
+MODULE_SCOPE int	TkBTreeNumLines(TkTextBTree tree, const struct TkText *textPtr);
+MODULE_SCOPE int	TkTextGetIndex(Tcl_Interp *interp, struct TkText *textPtr,
+			    const char *string, struct TkTextIndex *indexPtr);
+MODULE_SCOPE int	TkTextIndexBackBytes(const struct TkText *textPtr,
+			    const struct TkTextIndex *srcPtr, int count, struct TkTextIndex *dstPtr);
+MODULE_SCOPE int	TkTextIndexForwBytes(const struct TkText *textPtr,
+			    const struct TkTextIndex *srcPtr, int count, struct TkTextIndex *dstPtr);
+MODULE_SCOPE struct TkTextIndex *TkTextMakeByteIndex(TkTextBTree tree, const struct TkText *textPtr,
+			    int lineIndex, int byteIndex, struct TkTextIndex *indexPtr);
+MODULE_SCOPE int	TkTextPrintIndex(const struct TkText *textPtr,
+			    const struct TkTextIndex *indexPtr, char *string);
+MODULE_SCOPE int	TkTextXviewCmd(struct TkText *textPtr, Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TkTextChanged(struct TkSharedText *sharedTextPtr, struct TkText *textPtr,
+			    const struct TkTextIndex *index1Ptr, const struct TkTextIndex *index2Ptr);
+MODULE_SCOPE int	TkBTreeNumLines(TkTextBTree tree, const struct TkText *textPtr);
+MODULE_SCOPE void	TkTextInsertDisplayProc(struct TkText *textPtr, struct TkTextDispChunk *chunkPtr,
+			    int x, int y, int height, int baseline, Display *display, Drawable dst,
+			    int screenY);
+
+# define TkNewWindowObj(tkwin) Tcl_NewStringObj(Tk_PathName(tkwin), -1)
+# define Tcl_BackgroundException(interp, code) Tcl_BackgroundError(interp)
+
+/*
+ * Windows needs this.
+ */
+
+# undef TCL_STORAGE_CLASS
+# define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION == 5 */
+
+#undef STRUCT
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+# define _TK_NEED_IMPLEMENTATION
+# include "tkTextPriv.h"
+#else
+# undef inline
+#endif
+
+#endif /* _TKTEXT */
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 105
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: src/tktext/tkTextBTree.c
===================================================================
--- src/tktext/tkTextBTree.c	(revision 0)
+++ src/tktext/tkTextBTree.c	(working copy)
@@ -0,0 +1,15971 @@
+/*
+ * tkTextBTree.c --
+ *
+ * This file contains code that manages the B-tree representation of text
+ * for Tk's text widget and implements the character, hyphen, branch and
+ * link segment types.
+ *
+ * Copyright (c) 1992-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1995 Sun Microsystems, Inc.
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkInt.h"
+#include "tkText.h"
+#include "tkTextPriv.h"
+#include "tkTextTagSet.h"
+#include <assert.h>
+
+#ifndef MIN
+# define MIN(a,b) (((int) a) < ((int) b) ? a : b)
+#endif
+#ifndef MAX
+# define MAX(a,b) (((int) a) < ((int) b) ? b : a)
+#endif
+#ifndef ABS
+# define ABS(a)   (a < 0 ? -a : a)
+#endif
+
+#if NDEBUG
+# define DEBUG(expr)
+#else
+# define DEBUG(expr) expr
+#endif
+
+/*
+ * Implementation notes:
+ *
+ * Most of this file is independent of the text widget implementation and
+ * representation now. Without much effort this could be developed further
+ * into a new Tcl object type of which the Tk text widget is one example of a
+ * client.
+ * Note by GC: this independency is not useful, any sophisticated implementation
+ * is specialised and in general not sharable. The independency has been broken
+ * with the revised implementation (TkTextRedrawTag will be called here).
+ *
+ * The B-tree is set up with a dummy last line of text which must not be
+ * displayed, and must _never_ have a non-zero pixel count. This dummy line is
+ * a historical convenience to avoid other code having to deal with NULL
+ * TkTextLines. Since Tk 8.5, with pixel line height calculations and peer
+ * widgets, this dummy line is becoming somewhat of a liability, and special
+ * case code has been required to deal with it. It is probably a good idea to
+ * investigate removing the dummy line completely. This could result in an
+ * overall simplification (although it would require new special case code to
+ * deal with the fact that '.text index end' would then not really point to a
+ * valid line, rather it would point to the beginning of a non-existent line
+ * one beyond all current lines - we could perhaps define that as a
+ * TkTextIndex with a NULL TkTextLine ptr).
+ * Note by GC: the dummy line is quite useful, for instance it contains
+ * mark segments.
+ */
+
+/*
+ * Upper and lower bounds on how many children a node may have: rebalance when
+ * either of these limits is exceeded. MAX_CHILDREN should be twice
+ * MIN_CHILDREN, and MIN_CHILDREN must be >= 2.
+ */
+
+#define MIN_CHILDREN 16
+#define MAX_CHILDREN (2*MIN_CHILDREN)
+
+/*
+ * The data structure below defines a node in the B-tree.
+ */
+
+typedef struct TkBTreeNodePixelInfo {
+    uint32_t pixels;		/* Number of vertical display pixels. */
+    uint32_t numDispLines;	/* NUmber of display lines. */
+} NodePixelInfo;
+
+typedef struct Node {
+    struct Node *parentPtr;	/* Pointer to parent node, or NULL if this is the root. */
+    struct Node *nextPtr;	/* Next in list of siblings with the same parent node, or
+    				 * NULL for end of list. */
+    struct Node *childPtr;	/* List of children (used if level > 0). */
+    TkTextLine *linePtr;	/* Level > 0: first line in leftmost leaf; else first line
+    				 * in children. */
+    TkTextLine *lastPtr;	/* Level > 0: Last line in rightmost leaf; else last line
+    				 * in children. */
+    TkTextTagSet *tagonPtr;	/* The union of tagonPtr over all childrens/lines. */
+    TkTextTagSet *tagoffPtr;	/* The union of tagoffPtr over all childrens/lines. */
+    NodePixelInfo *pixelInfo;	/* Array containing pixel information in the subtree rooted here,
+    				 * one entry for each peer widget. */
+    uint32_t level;		/* Level of this node in the B-tree. 0 refers to the bottom of
+    				 * the tree (children are lines, not nodes). */
+    uint32_t size;		/* Sum of size over all lines belonging to this node. */
+    uint32_t numChildren;	/* Number of children of this node. */
+    uint32_t numLines;		/* Total number of lines (leaves) in the subtree rooted here. */
+    uint32_t numLogicalLines;	/* Total number of logical lines (a line whose predecessing line
+    				 * don't have an elided newline). */
+    uint32_t numBranches;	/* Counting the number of branches in this node. */
+} Node;
+
+/*
+ * Used to avoid having to allocate and deallocate arrays on the fly for
+ * commonly used functions. Must be > 0.
+ */
+
+#define PIXEL_CLIENTS 8
+
+/*
+ * Number of segments inside a section of segments. MAX_TEXT_SEGS must be
+ * greater than MIN_TEXT_SEGS. Also take into account that the sum
+ * (MAX_TEXT_SEGS + NUM_TEXT_SEGS) should not exceed the bit length of
+ * 'length' in struct TkTextSection.
+ */
+
+#define MIN_TEXT_SEGS 20
+#define MAX_TEXT_SEGS 60
+#define NUM_TEXT_SEGS (MAX_TEXT_SEGS - MIN_TEXT_SEGS)
+
+/*
+ * Definition of flags for UpdateElideInfo.
+ */
+
+enum { ELISION_WILL_BE_REMOVED, ELISION_HAS_BEEN_ADDED, ELISION_HAS_BEEN_CHANGED };
+
+typedef struct TkTextMyBTree BTree; /* see TkTextPriv.h */
+
+/*
+ * Variable that indicates whether to enable consistency checks for debugging.
+ */
+
+bool tkBTreeDebug = false;
+
+/*
+ * Macros that determine how much space to allocate for new segments:
+ */
+
+/* Computer math magic: (k/8)*8 == k & -8 */
+#define CSEG_CAPACITY(chars) ((int) (chars + 8) & -8)
+#define CSEG_SIZE(capacity) ((unsigned) (Tk_Offset(TkTextSegment, body) + capacity))
+
+/*
+ * Helper struct for SplitSeg.
+ */
+
+typedef struct SplitInfo {
+    int offset;		/* Out: Offset for insertion, -1 if SplitSeg
+    			 * did not increase/decrease the segment. */
+    int increase;	/* In: Additional bytes required for the insertion of new chars.
+    			 * Can be negative, in this case the size will be decreased.
+			 */
+    bool splitted;	/* Out: Flag whether a split has been done. */
+    bool forceSplit;	/* In: The char segment must be split after offset, because a
+    			 * newline will be inserted, and we shift the content after
+			 * offset into the new line. */
+    TkTextTagSet *tagInfoPtr;
+    			/* in: Tag information of new segment, can be NULL.
+			 * Out: Tag information of char segment, when inserting. */
+} SplitInfo;
+
+/*
+ * Forward declarations for functions defined in this file:
+ */
+
+struct UndoTokenInsert;
+
+static unsigned		AdjustPixelClient(BTree *treePtr, unsigned defaultHeight, Node *nodePtr,
+			    TkTextLine *startLine, TkTextLine *endLine, unsigned useReference,
+			    unsigned newPixelReferences, unsigned *numDispLinesPtr);
+static TkTextSegment *	JoinCharSegments(const TkSharedText *sharedTextPtr, TkTextSegment *segPtr);
+static void		CleanupSplitPoint(TkTextSegment *segPtr, TkSharedText *sharedTextPtr);
+static void		CharCheckProc(const TkSharedText *sharedTextPtr, const TkTextSegment *segPtr);
+static bool		CharDeleteProc(TkTextBTree tree, TkTextSegment *segPtr, int flags);
+static Tcl_Obj *	CharInspectProc(const TkSharedText *sharedTextPtr, const TkTextSegment *segPtr);
+static TkTextSegment *	CleanupCharSegments(const TkSharedText *sharedTextPtr, TkTextSegment *segPtr);
+static bool		HyphenDeleteProc(TkTextBTree tree, TkTextSegment *segPtr, int flags);
+static void		HyphenCheckProc(const TkSharedText *sharedTextPtr, const TkTextSegment *segPtr);
+static Tcl_Obj *	HyphenInspectProc(const TkSharedText *sharedTextPtr,
+			    const TkTextSegment *segPtr);
+static TkTextSegment *	IncreaseCharSegment(TkTextSegment *segPtr, unsigned offset, int chunkSize);
+static void		FreeLine(const BTree *treePtr, TkTextLine *linePtr);
+static void		LinkSegment(TkTextLine *linePtr, TkTextSegment *predPtr, TkTextSegment *succPtr);
+static void		LinkMark(const TkSharedText *sharedTextPtr, TkTextLine *linePtr,
+			    TkTextSegment *prevPtr, TkTextSegment *segPtr);
+static void		LinkSwitch(TkTextLine *linePtr, TkTextSegment *predPtr, TkTextSegment *succPtr);
+static TkTextSegment *	MakeCharSeg(TkTextSection *sectionPtr, TkTextTagSet *tagInfoPtr,
+			    unsigned newSize, const char *string, unsigned length);
+static TkTextSegment *	CopyCharSeg(TkTextSegment *segPtr, unsigned offset,
+			    unsigned length, unsigned newSize);
+static TkTextSegment *	SplitCharSegment(TkTextSegment *segPtr, unsigned index);
+static void		CheckNodeConsistency(const TkSharedText *sharedTextPtr, const Node *nodePtr,
+			    const Node *rootPtr, unsigned references);
+static void		RebuildSections(TkSharedText *sharedTextPtr, TkTextLine *linePtr,
+			    bool propagateChangeOfNumBranches);
+static bool		CheckSegments(const TkSharedText *sharedTextPtr, const TkTextLine *linePtr);
+static bool		CheckSections(const TkTextLine *linePtr);
+static bool		CheckSegmentItems(const TkSharedText *sharedTextPtr, const TkTextLine *linePtr);
+static void		FreeNode(Node *nodePtr);
+static void		DestroyNode(TkTextBTree tree, Node *nodePtr);
+static void		DeleteEmptyNode(BTree *treePtr, Node *nodePtr);
+static TkTextSegment *	FindTagStart(TkTextSearch *searchPtr, const TkTextIndex *stopIndex);
+static TkTextSegment *	FindTagEnd(TkTextSearch *searchPtr, const TkTextIndex *stopIndex);
+static void		Rebalance(BTree *treePtr, Node *nodePtr);
+static void		RemovePixelClient(BTree *treePtr, Node *nodePtr, unsigned useReference,
+			    int overwriteWithLast);
+static TkTextTagSet *	MakeTagInfo(TkText *textPtr, TkTextSegment *segPtr);
+static TkTextLine *	InsertNewLine(TkSharedText *sharedTextPtr, Node *nodePtr,
+			    TkTextLine *prevLinePtr, TkTextSegment *segPtr);
+static TkTextSegment *	SplitSeg(const TkTextIndex *indexPtr, SplitInfo *splitInfo);
+static TkTextSegment *	PrepareInsertIntoCharSeg(TkTextSegment *segPtr,
+			    unsigned offset, SplitInfo *splitInfo);
+static void		SplitSection(TkTextSection *sectionPtr);
+static void		JoinSections(TkTextSection *sectionPtr);
+static void		FreeSections(TkTextSection *sectionPtr);
+static TkTextSegment *	UnlinkSegment(TkTextSegment *segPtr);
+static void		UnlinkSegmentAndCleanup(const TkSharedText *sharedTextPtr,
+			    TkTextSegment *segPtr);
+static unsigned		CountSegments(const TkTextSection *sectionPtr);
+static unsigned		ComputeSectionSize(const TkTextSegment *segPtr);
+static void		BranchCheckProc(const TkSharedText *sharedTextPtr, const TkTextSegment *segPtr);
+static bool		BranchDeleteProc(TkTextBTree tree, TkTextSegment *segPtr, int flags);
+static void		BranchRestoreProc(TkTextSegment *segPtr);
+static Tcl_Obj *	BranchInspectProc(const TkSharedText *sharedTextPtr,
+			    const TkTextSegment *segPtr);
+static void		LinkCheckProc(const TkSharedText *sharedTextPtr, const TkTextSegment *segPtr);
+static bool		LinkDeleteProc(TkTextBTree tree, TkTextSegment *segPtr, int flags);
+static void		LinkRestoreProc(TkTextSegment *segPtr);
+static Tcl_Obj *	LinkInspectProc(const TkSharedText *sharedTextPtr, const TkTextSegment *segPtr);
+static bool		ProtectionMarkDeleteProc(TkTextBTree tree, TkTextSegment *segPtr, int flags);
+static void		ProtectionMarkCheckProc(const TkSharedText *sharedTextPtr,
+			    const TkTextSegment *segPtr);
+static void		AddPixelCount(BTree *treePtr, TkTextLine *linePtr,
+			    const TkTextLine *refLinePtr, NodePixelInfo *changeToPixels);
+static void		SubtractPixelInfo(BTree *treePtr, TkTextLine *linePtr);
+static void		SubtractPixelCount2(BTree *treePtr, Node *nodePtr, int changeToLineCount,
+			    int changeToLogicalLineCount, int changeToBranchCount, int changeToSize,
+			    const NodePixelInfo *changeToPixelInfo);
+static void		DeleteIndexRange(TkSharedText *sharedTextPtr,
+			    TkTextIndex *indexPtr1, TkTextIndex *indexPtr2, int flags,
+			    const struct UndoTokenInsert *undoToken, TkTextUndoInfo *redoInfo);
+static void		DeleteRange(TkSharedText *sharedTextPtr,
+			    TkTextSegment *firstSegPtr, TkTextSegment *lastSegPtr,
+			    int flags, TkTextUndoInfo *redoInfo);
+static void		UpdateNodeTags(const TkSharedText *sharedTextPtr, Node *nodePtr);
+static void		MakeUndoIndex(const TkSharedText *sharedTextPtr, const TkTextIndex *indexPtr,
+			    TkTextUndoIndex *undoIndexPtr, int gravity);
+static bool		UndoIndexIsEqual(const TkTextUndoIndex *indexPtr1,
+			    const TkTextUndoIndex *indexPtr2);
+static void		AddTagToNode(Node *nodePtr, TkTextTag *tag, bool setTagoff);
+static void		RemoveTagFromNode(Node *nodePtr, TkTextTag *tag);
+static void		UpdateElideInfo(TkSharedText *sharedTextPtr, TkTextTag *tagPtr,
+			    TkTextSegment *firstSegPtr, TkTextSegment *lastSegPtr, unsigned reason);
+static bool		SegmentIsElided(const TkSharedText *sharedTextPtr, const TkTextSegment *segPtr,
+			    const TkText *textPtr);
+static TkTextLine *	GetStartLine(const TkSharedText *sharedTextPtr, const TkText *textPtr);
+static TkTextLine *	GetLastLine(const TkSharedText *sharedTextPtr, const TkText *textPtr);
+static void		ReInsertSegment(const TkSharedText *sharedTextPtr,
+			    const TkTextUndoIndex *indexPtr, TkTextSegment *segPtr, bool updateNode);
+
+/*
+ * Type record for character segments:
+ */
+
+const Tk_SegType tkTextCharType = {
+    "character",		/* name */
+    SEG_GROUP_CHAR,		/* group */
+    GRAVITY_NEUTRAL,		/* gravity */
+    CharDeleteProc,		/* deleteProc */
+    NULL,			/* restoreProc */
+    TkTextCharLayoutProc,	/* layoutProc */
+    CharCheckProc,		/* checkProc */
+    CharInspectProc		/* inspectProc */
+};
+
+/*
+ * Type record for hyphenation support.
+ */
+
+const Tk_SegType tkTextHyphenType = {
+    "hyphen",			/* name */
+    SEG_GROUP_HYPHEN,		/* group */
+    GRAVITY_NEUTRAL,		/* gravity */
+    HyphenDeleteProc,		/* deleteProc */
+    NULL,			/* restoreProc */
+    TkTextCharLayoutProc,	/* layoutProc */
+    HyphenCheckProc,		/* checkProc */
+    HyphenInspectProc		/* inspectProc */
+};
+
+/*
+ * Type record for segments marking a branch for normal/elided text:
+ */
+
+const Tk_SegType tkTextBranchType = {
+    "branch",			/* name */
+    SEG_GROUP_BRANCH,		/* group */
+    GRAVITY_RIGHT,		/* gravity */
+    BranchDeleteProc,		/* deleteProc */
+    BranchRestoreProc,		/* restoreProc */
+    NULL,			/* layoutProc */
+    BranchCheckProc,		/* checkProc */
+    BranchInspectProc		/* inspectProc */
+};
+
+/*
+ * Type record for segments marking a link for a switched chain:
+ */
+
+const Tk_SegType tkTextLinkType = {
+    "connection",		/* name */
+    SEG_GROUP_BRANCH,		/* group */
+    GRAVITY_LEFT,		/* gravity */
+    LinkDeleteProc,		/* deleteProc */
+    LinkRestoreProc,		/* restoreProc */
+    NULL,			/* layoutProc */
+    LinkCheckProc,		/* checkProc */
+    LinkInspectProc		/* inspectProc */
+};
+
+/*
+ * Type record for the deletion marks.
+ */
+
+const Tk_SegType tkTextProtectionMarkType = {
+    "protection",		/* name */
+    SEG_GROUP_PROTECT,		/* group */
+    GRAVITY_NEUTRAL,		/* gravity */
+    ProtectionMarkDeleteProc,	/* deleteProc */
+    NULL,			/* restoreProc */
+    NULL,			/* layoutProc */
+    ProtectionMarkCheckProc,	/* checkProc */
+    NULL			/* inspectProc */
+};
+
+/*
+ * We need some private undo/redo stuff.
+ */
+
+typedef struct UndoTagChange {
+    TkTextTagSet *tagInfoPtr;
+    uint32_t skip;
+    uint32_t size;
+} UndoTagChange;
+
+static void UndoTagPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void UndoTagDestroy(TkSharedText *, TkTextUndoToken *token, bool);
+static Tcl_Obj *UndoTagGetCommand(const TkSharedText *, const TkTextUndoToken *);
+
+static void UndoClearTagsPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void RedoClearTagsPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void UndoClearTagsDestroy(TkSharedText *, TkTextUndoToken *token, bool);
+static Tcl_Obj *UndoClearTagsGetCommand(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *UndoClearTagsInspect(const TkSharedText *, const TkTextUndoToken *);
+
+static void UndoDeletePerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void RedoDeletePerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void UndoDeleteDestroy(TkSharedText *, TkTextUndoToken *token, bool);
+static Tcl_Obj *UndoDeleteGetCommand(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *UndoDeleteInspect(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *RedoDeleteInspect(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *RedoInsertInspect(const TkSharedText *, const TkTextUndoToken *);
+
+static void UndoInsertPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static Tcl_Obj *UndoInsertGetCommand(const TkSharedText *, const TkTextUndoToken *);
+
+static void UndoGetRange(const TkSharedText *, const TkTextUndoToken *, TkTextIndex *, TkTextIndex *);
+
+static const Tk_UndoType undoTokenTagType = {
+    TK_TEXT_UNDO_TAG,		/* action */
+    UndoTagGetCommand,		/* commandProc */
+    UndoTagPerform,		/* undoProc */
+    UndoTagDestroy,		/* destroyProc */
+    UndoGetRange,		/* rangeProc */
+    TkBTreeUndoTagInspect	/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenTagType = {
+    TK_TEXT_REDO_TAG,		/* action */
+    UndoTagGetCommand,		/* commandProc */
+    UndoTagPerform,		/* undoProc */
+    UndoTagDestroy,		/* destroyProc */
+    UndoGetRange,		/* rangeProc */
+    TkBTreeUndoTagInspect	/* inspectProc */
+};
+
+static const Tk_UndoType undoTokenClearTagsType = {
+    TK_TEXT_UNDO_TAG_CLEAR,	/* action */
+    UndoClearTagsGetCommand,	/* commandProc */
+    UndoClearTagsPerform,	/* undoProc */
+    UndoClearTagsDestroy,	/* destroyProc */
+    UndoGetRange,		/* rangeProc */
+    UndoClearTagsInspect	/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenClearTagsType = {
+    TK_TEXT_REDO_TAG_CLEAR,	/* action */
+    UndoClearTagsGetCommand,	/* commandProc */
+    RedoClearTagsPerform,	/* undoProc */
+    NULL,			/* destroyProc */
+    UndoGetRange,		/* rangeProc */
+    UndoClearTagsGetCommand	/* inspectProc */
+};
+
+static const Tk_UndoType undoTokenDeleteType = {
+    TK_TEXT_UNDO_DELETE,	/* action */
+    UndoDeleteGetCommand,	/* commandProc */
+    UndoDeletePerform,		/* undoProc */
+    UndoDeleteDestroy,		/* destroyProc */
+    UndoGetRange,		/* rangeProc */
+    UndoDeleteInspect		/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenDeleteType = {
+    TK_TEXT_REDO_DELETE,	/* action */
+    UndoDeleteGetCommand,	/* commandProc */
+    RedoDeletePerform,		/* undoProc */
+    NULL,			/* destroyProc */
+    UndoGetRange,		/* rangeProc */
+    RedoDeleteInspect		/* inspectProc */
+};
+
+static const Tk_UndoType undoTokenInsertType = {
+    TK_TEXT_UNDO_INSERT,	/* action */
+    UndoInsertGetCommand,	/* commandProc */
+    UndoInsertPerform,		/* undoProc */
+    NULL,			/* destroyProc */
+    UndoGetRange,		/* rangeProc */
+    UndoInsertGetCommand	/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenInsertType = {
+    TK_TEXT_REDO_INSERT,	/* action */
+    UndoInsertGetCommand,	/* commandProc */
+    UndoDeletePerform,		/* undoProc */
+    UndoDeleteDestroy,		/* destroyProc */
+    UndoGetRange,		/* rangeProc */
+    RedoInsertInspect		/* inspectProc */
+};
+
+/* Derivation of TkTextUndoTokenRange */
+typedef struct UndoTokenDelete {
+    const Tk_UndoType *undoType;
+    TkTextUndoIndex startIndex;	/* Start of deletion range. */
+    TkTextUndoIndex endIndex;	/* End of deletion range. */
+    TkTextSegment **segments;	/* Array containing the deleted segments. */
+    uint32_t numSegments:31;	/* Number of segments. */
+    uint32_t inclusive:1;	/* Inclusive bounds? */
+} UndoTokenDelete;
+
+/* Derivation of TkTextUndoTokenRange */
+typedef struct UndoTokenInsert {
+    const Tk_UndoType *undoType;
+    TkTextUndoIndex startIndex;	/* Start of insertion range. */
+    TkTextUndoIndex endIndex;	/* End of insertion range. */
+} UndoTokenInsert;
+
+/* Derivation of TkTextUndoTokenRange */
+typedef struct UndoTokenTagChange {
+    const Tk_UndoType *undoType;
+    TkTextUndoIndex startIndex;	/* Start of insertion range. */
+    TkTextUndoIndex endIndex;	/* End of insertion range. */
+    TkTextTag *tagPtr;		/* Added/removed tag. */
+    int32_t *lengths;		/* Array of tagged lengths (in byte size): if negative: skip this part;
+    				 * if positive: tag/untag this part. Last entry is 0 (zero). This
+				 * attribute can be NULL. Any part outside of this array will be
+				 * tagged/untagged. */
+} UndoTokenTagChange;
+
+/* Derivation of TkTextUndoTokenRange */
+typedef struct UndoTokenTagClear {
+    const Tk_UndoType *undoType;
+    TkTextUndoIndex startIndex;	/* Start of clearing range. */
+    TkTextUndoIndex endIndex;	/* End of clearing range. */
+    UndoTagChange *changeList;
+    unsigned changeListSize;
+} UndoTokenTagClear;
+
+/* Derivation of TkTextUndoTokenRange */
+typedef struct RedoTokenClearTags {
+    const Tk_UndoType *undoType;
+    TkTextUndoIndex startIndex;	/* Start of clearing range. */
+    TkTextUndoIndex endIndex;	/* End of clearing range. */
+} RedoTokenClearTags;
+
+/*
+ * Pointer to int, for some portable pointer hacks - it's guaranteed that
+ * 'uintptr_'t and 'void *' are convertible in both directions (C99 7.18.1.4).
+ */
+
+typedef union {
+    void *ptr;
+    uintptr_t flag;
+} __ptr_to_int;
+
+#define POINTER_IS_MARKED(ptr)	(((__ptr_to_int *) &ptr)->flag & (uintptr_t) 1)
+#define MARK_POINTER(ptr)	(((__ptr_to_int *) &ptr)->flag |= (uintptr_t) 1)
+#define UNMARK_POINTER(ptr)	(((__ptr_to_int *) &ptr)->flag &= ~(uintptr_t) 1)
+#define UNMARKED_INT(ptr)	(((__ptr_to_int *) &ptr)->flag & ~(uintptr_t) 1)
+
+DEBUG_ALLOC(extern unsigned tkTextCountNewSegment);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroySegment);
+DEBUG_ALLOC(extern unsigned tkTextCountNewNode);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroyNode);
+DEBUG_ALLOC(extern unsigned tkTextCountNewPixelInfo);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroyPixelInfo);
+DEBUG_ALLOC(extern unsigned tkTextCountNewLine);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroyLine);
+DEBUG_ALLOC(extern unsigned tkTextCountNewSection);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroySection);
+DEBUG_ALLOC(extern unsigned tkTextCountNewUndoToken);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroyDispInfo);
+
+/*
+ * Some helpers, especially for tag set operations.
+ */
+
+static unsigned
+GetByteLength(
+    Tcl_Obj *objPtr)
+{
+    assert(objPtr);
+
+    if (!objPtr->bytes) {
+	Tcl_GetString(objPtr);
+    }
+    return objPtr->length;
+}
+
+static bool
+SegIsAtStartOfLine(
+    const TkTextSegment *segPtr)
+{
+    while (segPtr && segPtr->size == 0) {
+	segPtr = segPtr->prevPtr;
+    }
+    return !segPtr;
+}
+
+static bool
+SegIsAtEndOfLine(
+    const TkTextSegment *segPtr)
+{
+    while (segPtr && segPtr->size == 0) {
+	segPtr = segPtr->nextPtr;
+    }
+    return !segPtr->nextPtr;
+}
+
+static TkTextSegment *
+GetPrevTagInfoSegment(
+    TkTextSegment *segPtr)
+{
+    assert(segPtr);
+
+    TkTextLine *linePtr = segPtr->sectionPtr->linePtr;
+
+    for (segPtr = segPtr->prevPtr; segPtr; segPtr = segPtr->prevPtr) {
+	if (segPtr->tagInfoPtr) {
+	    return segPtr;
+	}
+    }
+
+    return (linePtr = linePtr->prevPtr) ? linePtr->lastPtr : NULL;
+}
+
+static TkTextSegment *
+GetNextTagInfoSegment(
+    TkTextSegment *segPtr)
+{
+    assert(segPtr);
+
+    for ( ; !segPtr->tagInfoPtr; segPtr = segPtr->nextPtr) {
+	assert(segPtr);
+    }
+    return segPtr;
+}
+
+static TkTextSegment *
+GetFirstTagInfoSegment(
+    const TkText *textPtr,	/* can be NULL */
+    const TkTextLine *linePtr)
+{
+    TkTextSegment *segPtr;
+
+    assert(linePtr);
+
+    if (textPtr && linePtr == textPtr->startMarker->sectionPtr->linePtr) {
+	segPtr = textPtr->startMarker;
+    } else {
+	segPtr = linePtr->segPtr;
+    }
+
+    return GetNextTagInfoSegment(segPtr);
+}
+
+static bool
+TagSetTestBits(
+    const TkTextTagSet *tagInfoPtr,
+    const TkBitField *bitField)		/* can be NULL */
+{
+    assert(tagInfoPtr);
+
+    if (TkTextTagSetIsEmpty(tagInfoPtr)) {
+	return false;
+    }
+    return !bitField || !TkTextTagBitContainsSet(bitField, tagInfoPtr);
+}
+
+static bool
+TagSetTestDisjunctiveBits(
+    const TkTextTagSet *tagInfoPtr,
+    const TkBitField *bitField)		/* can be NULL */
+{
+    assert(tagInfoPtr);
+
+    if (bitField) {
+	return TkTextTagSetDisjunctiveBits(tagInfoPtr, bitField);
+    }
+    return !TkTextTagSetIsEmpty(tagInfoPtr);
+}
+
+static bool
+TagSetTestDontContainsAny(
+    const TkTextTagSet *tagonPtr,
+    const TkTextTagSet *tagoffPtr,
+    const TkBitField *bitField)		/* can be NULL */
+{
+    assert(tagonPtr);
+    assert(tagoffPtr);
+
+    return !TagSetTestDisjunctiveBits(tagonPtr, bitField)
+	    || TagSetTestDisjunctiveBits(tagoffPtr, bitField);
+}
+
+static bool
+TestTag(
+    const TkTextTagSet *tagInfoPtr,
+    const TkTextTag *tagPtr)	/* can be NULL */
+{
+    return tagPtr ? TkTextTagSetTest(tagInfoPtr, tagPtr->index) : TkTextTagSetAny(tagInfoPtr);
+}
+
+static void
+TagSetAssign(
+    TkTextTagSet **dstRef,
+    TkTextTagSet *srcPtr)
+{
+    if (*dstRef != srcPtr) {
+	TkTextTagSetDecrRefCount(*dstRef);
+	TkTextTagSetIncrRefCount(srcPtr);
+	*dstRef = srcPtr;
+    }
+}
+
+static void
+TagSetReplace(
+    TkTextTagSet **dstRef,
+    TkTextTagSet *srcPtr)
+{
+    TkTextTagSetDecrRefCount(*dstRef);
+    *dstRef = srcPtr;
+}
+
+static TkTextTagSet *
+TagSetAdd(
+    TkTextTagSet *tagInfoPtr,
+    const TkTextTag *tagPtr)
+{
+#if !TK_TEXT_DONT_USE_BITFIELDS
+    if (tagPtr->index >= TkTextTagSetSize(tagInfoPtr)) {
+	assert(tagPtr->index < tagPtr->sharedTextPtr->tagInfoSize);
+	tagInfoPtr = TkTextTagSetResize(tagInfoPtr, tagPtr->sharedTextPtr->tagInfoSize);
+    }
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+    return TkTextTagSetAdd(tagInfoPtr, tagPtr->index);
+}
+
+static TkTextTagSet *
+TagSetErase(
+    TkTextTagSet *tagInfoPtr,
+    const TkTextTag *tagPtr)
+{
+    if (tagPtr->index >= TkTextTagSetSize(tagInfoPtr)) {
+	return tagInfoPtr;
+    }
+    if (TkTextTagSetIsEmpty(tagInfoPtr = TkTextTagSetErase(tagInfoPtr, tagPtr->index))) {
+	TagSetAssign(&tagInfoPtr, tagPtr->sharedTextPtr->emptyTagInfoPtr);
+    }
+    return tagInfoPtr;
+}
+
+static TkTextTagSet *
+TagSetAddOrErase(
+    TkTextTagSet *tagInfoPtr,
+    const TkTextTag *tagPtr,
+    bool add)
+{
+    return add ? TagSetAdd(tagInfoPtr, tagPtr) : TagSetErase(tagInfoPtr, tagPtr);
+}
+
+static TkTextTagSet *
+TagSetRemove(
+    TkTextTagSet *tagInfoPtr,
+    const TkTextTagSet *otherInfoPtr,
+    const TkSharedText *sharedTextPtr)
+{
+    if (TkTextTagSetIsEmpty(tagInfoPtr = TkTextTagSetRemove(tagInfoPtr, otherInfoPtr))) {
+	TagSetAssign(&tagInfoPtr, sharedTextPtr->emptyTagInfoPtr);
+    }
+    return tagInfoPtr;
+}
+
+static TkTextTagSet *
+TagSetRemoveBits(
+    TkTextTagSet *tagInfoPtr,
+    const TkBitField *otherInfoPtr,
+    const TkSharedText *sharedTextPtr)
+{
+    if (TkTextTagSetIsEmpty(tagInfoPtr = TkTextTagSetRemoveBits(tagInfoPtr, otherInfoPtr))) {
+	TagSetAssign(&tagInfoPtr, sharedTextPtr->emptyTagInfoPtr);
+    }
+    return tagInfoPtr;
+}
+
+static TkTextTagSet *
+TagSetJoin(
+    TkTextTagSet *tagInfoPtr,		/* can be NULL */
+    const TkTextTagSet *otherInfoPtr)
+{
+    if (!tagInfoPtr) {
+	TkTextTagSetIncrRefCount(tagInfoPtr = (TkTextTagSet *) otherInfoPtr);
+    } else {
+	tagInfoPtr = TkTextTagSetJoin(tagInfoPtr, otherInfoPtr);
+    }
+    return tagInfoPtr;
+}
+
+static TkTextTagSet *
+TagSetJoinNonIntersection(
+    TkTextTagSet *tagInfoPtr,
+    const TkTextTagSet *otherInfoPtr1,
+    const TkTextTagSet *otherInfoPtr2,
+    const TkSharedText *sharedTextPtr)
+{
+    assert(tagInfoPtr);
+    assert(otherInfoPtr1);
+    assert(otherInfoPtr2);
+
+    if (otherInfoPtr1 == otherInfoPtr2) {
+	/* This is especially catching the case that both otherInfoPtr are empty. */
+	return tagInfoPtr;
+    }
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+    if (TkTextTagSetSize(tagInfoPtr) < sharedTextPtr->tagInfoSize) {
+	unsigned size = MAX(TkTextTagSetSize(otherInfoPtr1), TkTextTagSetSize(otherInfoPtr2));
+	tagInfoPtr = TkTextTagSetResize(tagInfoPtr, MAX(size, sharedTextPtr->tagInfoSize));
+    }
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+    tagInfoPtr = TkTextTagSetJoinNonIntersection(tagInfoPtr, otherInfoPtr1, otherInfoPtr2);
+
+    if (TkTextTagSetIsEmpty(tagInfoPtr)) {
+	TagSetAssign(&tagInfoPtr, sharedTextPtr->emptyTagInfoPtr);
+    }
+
+    return tagInfoPtr;
+}
+
+static TkTextTagSet *
+TagSetIntersect(
+    TkTextTagSet *tagInfoPtr,		/* can be NULL */
+    const TkTextTagSet *otherInfoPtr,
+    const TkSharedText *sharedTextPtr)
+{
+    if (!tagInfoPtr) {
+	TkTextTagSetIncrRefCount(tagInfoPtr = (TkTextTagSet *) otherInfoPtr);
+    } else if (TkTextTagSetIsEmpty(tagInfoPtr = TkTextTagSetIntersect(tagInfoPtr, otherInfoPtr))) {
+	TagSetAssign(&tagInfoPtr, sharedTextPtr->emptyTagInfoPtr);
+    }
+    return tagInfoPtr;
+}
+
+static TkTextTagSet *
+TagSetIntersectBits(
+    TkTextTagSet *tagInfoPtr,
+    const TkBitField *otherInfoPtr,
+    const TkSharedText *sharedTextPtr)
+{
+    if (TkTextTagSetIsEmpty(tagInfoPtr = TkTextTagSetIntersectBits(tagInfoPtr, otherInfoPtr))) {
+	TagSetAssign(&tagInfoPtr, sharedTextPtr->emptyTagInfoPtr);
+    }
+    return tagInfoPtr;
+}
+
+static TkTextTagSet *
+TagSetComplementTo(
+    TkTextTagSet *tagInfoPtr,
+    const TkTextTagSet *otherInfoPtr,
+    const TkSharedText *sharedTextPtr)
+{
+    if (TkTextTagSetIsEmpty(tagInfoPtr = TkTextTagSetComplementTo(tagInfoPtr, otherInfoPtr))) {
+	TagSetAssign(&tagInfoPtr, sharedTextPtr->emptyTagInfoPtr);
+    }
+    return tagInfoPtr;
+}
+
+static TkTextTagSet *
+TagSetJoinComplementTo(
+    TkTextTagSet *tagInfoPtr,
+    const TkTextTagSet *otherInfoPtr1,
+    const TkTextTagSet *otherInfoPtr2,
+    const TkSharedText *sharedTextPtr)
+{
+    if (otherInfoPtr2 == sharedTextPtr->emptyTagInfoPtr) {
+	return tagInfoPtr;
+    }
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+    if (TkTextTagSetSize(tagInfoPtr) < sharedTextPtr->tagInfoSize) {
+	tagInfoPtr = TkTextTagSetResize(tagInfoPtr, sharedTextPtr->tagInfoSize);
+    }
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+    if (TkTextTagSetIsEmpty(
+	    tagInfoPtr = TkTextTagSetJoinComplementTo(tagInfoPtr, otherInfoPtr1, otherInfoPtr2))) {
+	TagSetAssign(&tagInfoPtr, sharedTextPtr->emptyTagInfoPtr);
+    }
+    return tagInfoPtr;
+}
+
+static TkTextTagSet *
+TagSetJoinOfDifferences(
+    TkTextTagSet *tagInfoPtr,
+    const TkTextTagSet *otherInfoPtr1,
+    const TkTextTagSet *otherInfoPtr2,
+    const TkSharedText *sharedTextPtr)
+{
+#if !TK_TEXT_DONT_USE_BITFIELDS
+    if (TkTextTagSetSize(tagInfoPtr) < sharedTextPtr->tagInfoSize) {
+	tagInfoPtr = TkTextTagSetResize(tagInfoPtr, sharedTextPtr->tagInfoSize);
+    }
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+    return TkTextTagSetJoinOfDifferences(tagInfoPtr, otherInfoPtr1, otherInfoPtr2);
+}
+
+static TkTextTagSet *
+TagSetTestAndSet(
+    TkTextTagSet *tagInfoPtr,
+    const TkTextTag *tagPtr)
+{
+    unsigned tagIndex = tagPtr->index;
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+    if (tagPtr->index >= TkTextTagSetSize(tagInfoPtr)) {
+	tagInfoPtr = TkTextTagSetResize(tagInfoPtr, tagPtr->sharedTextPtr->tagInfoSize);
+	return TkTextTagSetAdd(tagInfoPtr, tagIndex);
+    }
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+    return TkTextTagSetTestAndSet(tagInfoPtr, tagIndex);
+}
+
+static bool
+LineTestAllSegments(
+    const TkTextLine *linePtr,
+    const TkTextTag *tagPtr,
+    bool tagged)
+{
+    unsigned tagIndex = tagPtr->index;
+
+    return TkTextTagSetTest(linePtr->tagonPtr, tagIndex) == tagged
+	    && (!tagged || !TkTextTagSetTest(linePtr->tagoffPtr, tagIndex));
+}
+
+static bool
+LineTestIfAnyIsTagged(
+    TkTextSegment *firstPtr,
+    TkTextSegment *lastPtr,
+    unsigned tagIndex)
+{
+    assert(firstPtr || !lastPtr);
+
+    for ( ; firstPtr != lastPtr; firstPtr = firstPtr->nextPtr) {
+	if (firstPtr->tagInfoPtr && TkTextTagSetTest(firstPtr->tagInfoPtr, tagIndex)) {
+	    return true;
+	}
+    }
+
+    return false;
+}
+
+static bool
+LineTestIfAnyIsUntagged(
+    TkTextSegment *firstSegPtr,
+    TkTextSegment *lastSegPtr,
+    unsigned tagIndex)
+{
+    assert(firstSegPtr);
+
+    for ( ; firstSegPtr != lastSegPtr; firstSegPtr = firstSegPtr->nextPtr) {
+	if (firstSegPtr->tagInfoPtr) {
+	    if (!TkTextTagSetTest(firstSegPtr->tagInfoPtr, tagIndex)) {
+		return true;
+	    }
+	}
+    }
+
+    return false;
+}
+
+static bool
+LineTestIfToggleIsOpen(
+    const TkTextLine *linePtr,	/* can be NULL */
+    unsigned tagIndex)
+{
+    return linePtr && TkTextTagSetTest(linePtr->lastPtr->tagInfoPtr, tagIndex);
+}
+
+static bool
+LineTestIfToggleIsClosed(
+    const TkTextLine *linePtr,	/* can be NULL */
+    unsigned tagIndex)
+{
+    return !linePtr || !TkTextTagSetTest(GetFirstTagInfoSegment(NULL, linePtr)->tagInfoPtr, tagIndex);
+}
+
+static bool
+LineTestToggleFwd(
+    const TkTextLine *linePtr,
+    unsigned tagIndex,
+    bool testTagon)
+{
+    assert(linePtr);
+
+    /*
+     * testTagon == true: Test whether given tag is starting a range inside this line.
+     * In this case this function assumes that this tag is not open at end of previous line.
+     */
+
+    if (testTagon) {
+	return TkTextTagSetTest(linePtr->tagonPtr, tagIndex);
+    }
+
+    /*
+     * testTagon == false: Test whether given tag is ending a range inside this line.
+     * In this case this function assumes that this tag is open at end of previous line.
+     */
+
+    return TkTextTagSetTest(linePtr->tagoffPtr, tagIndex)
+	    || !TkTextTagSetTest(linePtr->tagonPtr, tagIndex);
+}
+
+static bool
+LineTestToggleBack(
+    const TkTextLine *linePtr,
+    unsigned tagIndex,
+    bool testTagon)
+{
+    assert(linePtr);
+
+    /*
+     * testTagon == true: Test whether given tag is starting a range inside this line.
+     * In this case this function assumes that this tag is already open at start of next line.
+     */
+
+    if (testTagon) {
+	return TkTextTagSetTest(linePtr->tagonPtr, tagIndex)
+	    && (TkTextTagSetTest(linePtr->tagoffPtr, tagIndex)
+		|| !LineTestIfToggleIsOpen(linePtr->prevPtr, tagIndex));
+    }
+
+    /*
+     * testTagon == false: Test whether given tag is ending a range inside this line.
+     * In this case this function assumes that this tag is not open at start of next line.
+     */
+
+    return TkTextTagSetTest(linePtr->tagoffPtr, tagIndex)
+	    || LineTestIfToggleIsOpen(linePtr->prevPtr, tagIndex)
+	    || TkTextTagSetTest(GetFirstTagInfoSegment(NULL, linePtr)->tagInfoPtr, tagIndex);
+}
+
+static bool
+NodeTestAnySegment(
+    const Node *nodePtr,
+    unsigned tagIndex,
+    bool tagged)
+{
+    /*
+     * tagged == true:  test whether any segments is tagged with specified tag.
+     * tagged == false: test whether any segments is not tagged with specified tag.
+     */
+
+    return TkTextTagSetTest(nodePtr->tagonPtr, tagIndex) == tagged
+	    && (tagged || TkTextTagSetTest(nodePtr->tagoffPtr, tagIndex));
+}
+
+static bool
+NodeTestAllSegments(
+    const Node *nodePtr,
+    unsigned tagIndex,
+    bool tagged)
+{
+    return TkTextTagSetTest(nodePtr->tagonPtr, tagIndex) == tagged
+	    && (!tagged || !TkTextTagSetTest(nodePtr->tagoffPtr, tagIndex));
+}
+
+static bool
+NodeTestToggleFwd(
+    const Node *nodePtr,
+    unsigned tagIndex,
+    bool testTagon)
+{
+    assert(nodePtr);
+
+    /*
+     * testTagon == true: Test whether given tag is starting a range inside this node.
+     * In this case this function assumes that this tag is not open at end of previous line
+     * (line before first line of this node).
+     */
+
+    if (testTagon) {
+	return TkTextTagSetTest(nodePtr->tagonPtr, tagIndex);
+    }
+
+    /*
+     * testTagon == false: Test whether given tag is ending a range inside this node.
+     * In this case this function assumes that this tag is open at end of previous line
+     * (line before first line of this node).
+     */
+
+    return TkTextTagSetTest(nodePtr->tagoffPtr, tagIndex)
+	    || !TkTextTagSetTest(nodePtr->tagonPtr, tagIndex);
+}
+
+static bool
+NodeTestToggleBack(
+    const Node *nodePtr,
+    unsigned tagIndex,
+    bool testTagon)
+{
+    assert(nodePtr);
+
+    /*
+     * testTagon == true: Test whether given tag is starting a range inside this node.
+     * In this case this function assumes that this tag is already open at start of next line
+     * (line after last line of this node).
+     */
+
+    if (testTagon) {
+	return TkTextTagSetTest(nodePtr->tagonPtr, tagIndex)
+	    && (TkTextTagSetTest(nodePtr->tagoffPtr, tagIndex)
+		|| !LineTestIfToggleIsOpen(nodePtr->linePtr->prevPtr, tagIndex));
+    }
+
+    /*
+     * testTagon == false: Test whether given tag is ending a range inside this node.
+     * In this case this function assumes that this tag is not already open at start of next line
+     * (line after last line of this node).
+     */
+
+    return TkTextTagSetTest(nodePtr->tagoffPtr, tagIndex)
+	|| LineTestIfToggleIsOpen(nodePtr->linePtr->prevPtr, tagIndex);
+}
+
+static void
+RecomputeLineTagInfo(
+    TkTextLine *linePtr,
+    const TkTextSegment *lastSegPtr,
+    const TkSharedText *sharedTextPtr)
+{
+    const TkTextSegment *segPtr;
+    TkTextTagSet *tagonPtr = NULL;
+    TkTextTagSet *tagoffPtr = NULL;
+
+    assert(linePtr);
+    assert(!lastSegPtr || lastSegPtr->sectionPtr->linePtr == linePtr);
+
+    /*
+     * Update the line tag information after inserting tagged characters.
+     * This function is not updating the tag information of the B-Tree.
+     */
+
+    for (segPtr = linePtr->segPtr; segPtr != lastSegPtr; segPtr = segPtr->nextPtr) {
+	if (segPtr->tagInfoPtr) {
+	    tagonPtr = TagSetJoin(tagonPtr, segPtr->tagInfoPtr);
+	    tagoffPtr = TagSetIntersect(tagoffPtr, segPtr->tagInfoPtr, sharedTextPtr);
+	}
+    }
+
+    if (!tagonPtr) {
+	TkTextTagSetIncrRefCount(tagonPtr = sharedTextPtr->emptyTagInfoPtr);
+	TkTextTagSetIncrRefCount(tagoffPtr = sharedTextPtr->emptyTagInfoPtr);
+    } else {
+	tagoffPtr = TagSetComplementTo(tagoffPtr, tagonPtr, sharedTextPtr);
+    }
+
+    TagSetReplace(&linePtr->tagonPtr, tagonPtr);
+    TagSetReplace(&linePtr->tagoffPtr, tagoffPtr);
+}
+
+static unsigned
+GetDisplayLines(
+    const TkTextLine *linePtr,
+    unsigned ref)
+{
+    return TkBTreeGetNumberOfDisplayLines(linePtr->pixelInfo + ref);
+}
+
+static void
+SetLineHasChanged(
+    const TkSharedText *sharedTextPtr,
+    TkTextLine *linePtr)
+{
+    if (!linePtr->logicalLine) {
+	 linePtr = TkBTreeGetLogicalLine(sharedTextPtr, NULL, linePtr);
+    }
+    linePtr->changed = true;
+}
+
+/*
+ * Some helpers for segment creation and testing.
+ */
+
+static TkTextSegment *
+MakeSegment(
+    unsigned segByteSize,
+    unsigned contentSize,
+    const Tk_SegType *segType)
+{
+    TkTextSegment *segPtr;
+
+    assert(segType != &tkTextCharType);
+
+    segPtr = memset(malloc(segByteSize), 0, segByteSize);
+    segPtr->typePtr = segType;
+    segPtr->size = contentSize;
+    segPtr->refCount = 1;
+    DEBUG_ALLOC(tkTextCountNewSegment++);
+    return segPtr;
+}
+
+static TkTextSegment * MakeBranch() { return MakeSegment(SEG_SIZE(TkTextBranch), 0, &tkTextBranchType); }
+static TkTextSegment * MakeLink()   { return MakeSegment(SEG_SIZE(TkTextLink),   0, &tkTextLinkType);   }
+static TkTextSegment * MakeHyphen() { return MakeSegment(SEG_SIZE(TkTextHyphen), 1, &tkTextHyphenType); }
+
+static bool
+IsBranchSection(
+    const TkTextSection *sectionPtr)
+{
+    assert(sectionPtr);
+    return sectionPtr->nextPtr && sectionPtr->nextPtr->segPtr->prevPtr->typePtr == &tkTextBranchType;
+}
+
+static bool
+IsLinkSection(
+    const TkTextSection *sectionPtr)
+{
+    assert(sectionPtr);
+    return sectionPtr->segPtr->typePtr == &tkTextLinkType;
+}
+
+/*
+ * Some functions for the undo/redo mechanism.
+ */
+
+static void
+SetNodeLastPointer(
+    Node *nodePtr,
+    TkTextLine *linePtr)
+{
+    nodePtr->lastPtr = linePtr;
+    while (!nodePtr->nextPtr && (nodePtr = nodePtr->parentPtr)) {
+	nodePtr->lastPtr = linePtr;
+    }
+}
+
+static Tcl_Obj *
+MakeTagInfoObj(
+    const TkSharedText *sharedTextPtr,
+    const TkTextTagSet *tagInfoPtr)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    TkTextTag **tagLookup = sharedTextPtr->tagLookup;
+    unsigned i = TkTextTagSetFindFirst(tagInfoPtr);
+
+    for ( ; i != TK_TEXT_TAG_SET_NPOS; i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	const TkTextTag *tagPtr = tagLookup[i];
+	Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(tagPtr->name, -1));
+    }
+
+    return objPtr;
+}
+
+static void
+UndoGetRange(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item,
+    TkTextIndex *startIndex,
+    TkTextIndex *endIndex)
+{
+    const TkTextUndoTokenRange *token = (const TkTextUndoTokenRange *) item;
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->startIndex, startIndex);
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->endIndex, endIndex);
+}
+
+/* DELETE ********************************************************************/
+
+static Tcl_Obj *
+UndoDeleteGetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("delete", -1));
+    return objPtr;
+}
+
+static Tcl_Obj *
+UndoDeleteInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    Tcl_Obj *objPtr = UndoDeleteGetCommand(sharedTextPtr, item);
+    TkTextSegment **segments = ((const UndoTokenDelete *) item)->segments;
+    unsigned numSegments = ((const UndoTokenDelete *) item)->numSegments;
+    const TkTextSegment *segPtr;
+
+    for (segPtr = *segments++; numSegments > 0; segPtr = *segments++, --numSegments) {
+	assert(segPtr->typePtr->inspectProc);
+	Tcl_ListObjAppendElement(NULL, objPtr, segPtr->typePtr->inspectProc(sharedTextPtr, segPtr));
+    }
+
+    return objPtr;
+}
+
+static void
+UndoDeletePerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    TkTextLine *linePtr, *startLinePtr, *newLinePtr;
+    TkTextSegment *segPtr, *prevPtr, *nextPtr;
+    TkTextSegment *firstPtr, *lastPtr;
+    TkTextSegment *prevSegPtr;
+    Node *nodePtr;
+    NodePixelInfo *changeToPixelInfo;
+    BTree *treePtr = (BTree *) sharedTextPtr->tree;
+    UndoTokenDelete *undoToken = (UndoTokenDelete *) undoInfo->token;
+    TkTextSegment * const *segments = undoToken->segments;
+    TkTextTagSet *tagonPtr;
+    TkTextTagSet *tagoffPtr;
+    TkTextTagSet *additionalTagoffPtr;
+    unsigned numSegments = undoToken->numSegments - 1;
+    unsigned changeToLineCount = 0;
+    unsigned changeToLogicalLineCount = 0;
+    unsigned changeToBranchCount = 0;
+    unsigned size = 0;
+    bool reinsertFirstSegment = true;
+    unsigned i;
+
+    assert(segments);
+    assert(segments[0]);
+
+    changeToPixelInfo = treePtr->pixelInfoBuffer;
+    memset(changeToPixelInfo, 0, sizeof(changeToPixelInfo[0])*treePtr->numPixelReferences);
+    prevPtr = lastPtr = NULL;
+
+    if (undoToken->startIndex.lineIndex == -1) {
+	prevPtr = undoToken->startIndex.u.markPtr;
+	linePtr = prevPtr->sectionPtr->linePtr;
+	reinsertFirstSegment = false;
+    } else {
+	linePtr = TkBTreeFindLine(sharedTextPtr->tree, NULL, undoToken->startIndex.lineIndex);
+    }
+
+    startLinePtr = linePtr;
+    nodePtr = startLinePtr->parentPtr;
+    firstPtr = segPtr = *segments++;
+    firstPtr->protectionFlag = true;
+    prevSegPtr = NULL;
+
+    if (numSegments > 0) {
+	nextPtr = *segments++;
+	numSegments -= 1;
+    } else {
+	nextPtr = NULL;
+    }
+
+    TkTextTagSetIncrRefCount(tagonPtr = sharedTextPtr->emptyTagInfoPtr);
+    TkTextTagSetIncrRefCount(tagoffPtr = sharedTextPtr->emptyTagInfoPtr);
+    additionalTagoffPtr = NULL;
+
+    while (segPtr) {
+	if (POINTER_IS_MARKED(segPtr)) {
+	    TkTextSection *sectionPtr;
+
+	    UNMARK_POINTER(segPtr);
+
+	    assert(segPtr->typePtr != &tkTextCharType);
+	    assert(segPtr->sectionPtr);
+
+	    /*
+	     * This is a re-inserted segment, it will move.
+	     */
+
+	    sectionPtr = segPtr->sectionPtr;
+	    UNMARK_POINTER(segPtr);
+	    UnlinkSegment(segPtr);
+	    JoinSections(sectionPtr);
+	} else {
+	    size += segPtr->size;
+	}
+	lastPtr = segPtr;
+	DEBUG(segPtr->sectionPtr = NULL);
+	if (reinsertFirstSegment) {
+	    ReInsertSegment(sharedTextPtr, &undoToken->startIndex, segPtr, false);
+	    reinsertFirstSegment = false;
+	} else {
+	    LinkSegment(linePtr, prevPtr, segPtr);
+	}
+	if (segPtr->typePtr == &tkTextCharType) {
+	    assert(!segPtr->typePtr->restoreProc);
+
+	    if (prevSegPtr) {
+		if ((prevSegPtr = CleanupCharSegments(sharedTextPtr, prevSegPtr))->nextPtr != segPtr) {
+		    segPtr = prevSegPtr;
+		}
+	    }
+
+	    if (segPtr->body.chars[segPtr->size - 1] == '\n') {
+		newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr, linePtr, segPtr->nextPtr);
+		AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+		changeToLineCount += 1;
+		changeToLogicalLineCount += linePtr->logicalLine;
+		RecomputeLineTagInfo(linePtr, NULL, sharedTextPtr);
+		tagonPtr = TkTextTagSetJoin(tagonPtr, linePtr->tagonPtr);
+		tagoffPtr = TkTextTagSetJoin(tagoffPtr, linePtr->tagoffPtr);
+		additionalTagoffPtr = TagSetIntersect(additionalTagoffPtr,
+			linePtr->tagonPtr, sharedTextPtr);
+		linePtr = newLinePtr;
+		segPtr = NULL;
+	    }
+
+	    prevSegPtr = segPtr;
+	} else {
+	    if (segPtr->typePtr->restoreProc) {
+		if (segPtr->typePtr == &tkTextBranchType) {
+		    changeToBranchCount += 1;
+		}
+		segPtr->typePtr->restoreProc(segPtr);
+	    }
+	    prevSegPtr = NULL;
+	}
+	prevPtr = segPtr;
+	if ((segPtr = nextPtr)) {
+	    if (numSegments > 0) {
+		nextPtr = *segments++;
+		numSegments -= 1;
+	    } else {
+		nextPtr = NULL;
+	    }
+	}
+    }
+
+    RecomputeLineTagInfo(linePtr, NULL, sharedTextPtr);
+    tagonPtr = TkTextTagSetJoin(tagonPtr, linePtr->tagonPtr);
+    tagoffPtr = TkTextTagSetJoin(tagoffPtr, linePtr->tagoffPtr);
+    additionalTagoffPtr = TagSetIntersect(additionalTagoffPtr, linePtr->tagonPtr, sharedTextPtr);
+    tagoffPtr = TagSetJoinComplementTo(tagoffPtr, additionalTagoffPtr, tagonPtr, sharedTextPtr);
+    tagoffPtr = TkTextTagSetRemove(tagoffPtr, nodePtr->tagoffPtr);
+    tagonPtr = TkTextTagSetRemove(tagonPtr, nodePtr->tagonPtr);
+    tagonPtr = TkTextTagSetRemove(tagonPtr, tagoffPtr);
+
+    /*
+     * Update the B-Tree tag information.
+     */
+
+    for (i = TkTextTagSetFindFirst(tagoffPtr);
+	    i != TK_TEXT_TAG_SET_NPOS;
+	    i = TkTextTagSetFindNext(tagoffPtr, i)) {
+	if (!TkTextTagSetTest(nodePtr->tagoffPtr, i)) {
+	    AddTagToNode(nodePtr, sharedTextPtr->tagLookup[i], true);
+	}
+    }
+
+    for (i = TkTextTagSetFindFirst(tagonPtr);
+	    i != TK_TEXT_TAG_SET_NPOS;
+	    i = TkTextTagSetFindNext(tagonPtr, i)) {
+	AddTagToNode(nodePtr, sharedTextPtr->tagLookup[i], false);
+    }
+
+    TkTextTagSetDecrRefCount(tagonPtr);
+    TkTextTagSetDecrRefCount(tagoffPtr);
+    TkTextTagSetDecrRefCount(additionalTagoffPtr);
+
+    /*
+     * Rebuild sections, and increase the epoch.
+     */
+
+    RebuildSections(sharedTextPtr, linePtr, true);
+    TkBTreeIncrEpoch(sharedTextPtr->tree);
+
+    /*
+     * Cleanup char segments.
+     */
+
+    CleanupSplitPoint(firstPtr, sharedTextPtr);
+    CleanupSplitPoint(lastPtr, sharedTextPtr);
+
+    /*
+     * Prevent that the destroy function will delete these segments.
+     * This also makes the token reusable.
+     */
+
+    free(undoToken->segments);
+    undoToken->segments = NULL;
+    undoToken->numSegments = 0;
+
+    /*
+     * Update the redo information.
+     */
+
+    if (redoInfo) {
+	undoToken->undoType = &redoTokenDeleteType;
+	redoInfo->token = (TkTextUndoToken *) undoToken;
+	redoInfo->byteSize = 0;
+    }
+
+    /*
+     * Increment the line and pixel counts in all the parent nodes of the
+     * insertion point, then rebalance the tree if necessary.
+     */
+
+    SubtractPixelCount2(treePtr, nodePtr, -changeToLineCount,
+	    -changeToLogicalLineCount, -changeToBranchCount, -size, changeToPixelInfo);
+    linePtr->parentPtr->numChildren += changeToLineCount;
+
+    if (nodePtr->numChildren > MAX_CHILDREN) {
+	Rebalance(treePtr, nodePtr);
+    }
+
+    /*
+     * This line now needs to have its height recalculated. This has to be done after Rebalance.
+     */
+
+    TkTextInvalidateLineMetrics(sharedTextPtr, NULL,
+	    startLinePtr, changeToLineCount, TK_TEXT_INVALIDATE_INSERT);
+
+    TK_BTREE_DEBUG(TkBTreeCheck((TkTextBTree) treePtr));
+}
+
+static void
+UndoDeleteDestroy(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *token,
+    bool reused)
+{
+    TkTextSegment **segments = ((UndoTokenDelete *) token)->segments;
+    unsigned numSegments = ((UndoTokenDelete *) token)->numSegments;
+
+    assert(!reused);
+
+    if (numSegments > 0) {
+	TkTextSegment *segPtr;
+
+	for (segPtr = *segments++; numSegments > 0; segPtr = *segments++, --numSegments) {
+	    UNMARK_POINTER(segPtr);
+	    assert(segPtr->typePtr);
+	    assert(segPtr->typePtr->deleteProc);
+	    segPtr->typePtr->deleteProc(sharedTextPtr->tree, segPtr, DELETE_BRANCHES | DELETE_MARKS);
+	}
+
+	free(((UndoTokenDelete *) token)->segments);
+    }
+}
+
+static Tcl_Obj *
+RedoDeleteInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    Tcl_Obj *objPtr = UndoDeleteGetCommand(sharedTextPtr, item);
+
+#if 0 /* not possible to inspect the range, because this range may be deleted */
+    TkTextIndex startIndex, endIndex;
+    char buf[TK_POS_CHARS];
+
+    UndoGetRange(sharedTextPtr, item, &startIndex, &endIndex);
+    TkTextIndexPrint(sharedTextPtr, NULL, &startIndex, buf);
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(buf, -1));
+    TkTextIndexPrint(sharedTextPtr, NULL, &endIndex, buf);
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(buf, -1));
+#endif
+
+    return objPtr;
+}
+
+static void
+RedoDeletePerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    const UndoTokenDelete *token = (const UndoTokenDelete *) undoInfo->token;
+
+    if (token->startIndex.lineIndex == -1 && token->endIndex.lineIndex == -1) {
+	TkTextSegment *segPtr1 = token->startIndex.u.markPtr;
+	TkTextSegment *segPtr2 = token->endIndex.u.markPtr;
+	int flags = token->inclusive ? DELETE_INCLUSIVE : 0;
+
+	DeleteRange(sharedTextPtr, segPtr1, segPtr2, flags, redoInfo);
+
+	segPtr1->protectionFlag = true;
+	segPtr2->protectionFlag = true;
+	CleanupSplitPoint(segPtr1, sharedTextPtr);
+	CleanupSplitPoint(segPtr2, sharedTextPtr);
+	TkBTreeIncrEpoch(sharedTextPtr->tree);
+
+	TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+    } else {
+	TkTextIndex index1, index2;
+
+	TkBTreeUndoIndexToIndex(sharedTextPtr, &token->startIndex, &index1);
+	TkBTreeUndoIndexToIndex(sharedTextPtr, &token->endIndex, &index2);
+	DeleteIndexRange(sharedTextPtr, &index1, &index2, 0, (UndoTokenInsert *) token, redoInfo);
+    }
+}
+
+/* INSERT ********************************************************************/
+
+static Tcl_Obj *
+UndoInsertGetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("insert", -1));
+    return objPtr;
+}
+
+static void
+UndoInsertPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    struct UndoTokenInsert *token = (UndoTokenInsert *) undoInfo->token;
+    TkTextIndex index1, index2;
+
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->startIndex, &index1);
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->endIndex, &index2);
+    DeleteIndexRange(sharedTextPtr, &index1, &index2, 0, token, redoInfo);
+    if (redoInfo && redoInfo->token) {
+	redoInfo->token->undoType = &redoTokenInsertType;
+    }
+}
+
+static Tcl_Obj *
+RedoInsertInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    TkTextSegment **segments = ((const UndoTokenDelete *) item)->segments;
+    unsigned numSegments = ((const UndoTokenDelete *) item)->numSegments;
+    const TkTextSegment *segPtr;
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("insert", -1));
+
+    for (segPtr = *segments++; numSegments > 0; segPtr = *segments++, --numSegments) {
+	UNMARK_POINTER(segPtr);
+	assert(segPtr->typePtr->inspectProc);
+	Tcl_ListObjAppendElement(NULL, objPtr, segPtr->typePtr->inspectProc(sharedTextPtr, segPtr));
+    }
+
+    return objPtr;
+}
+
+/* TAG ADD/REMOVE ************************************************************/
+
+static Tcl_Obj *
+UndoTagGetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenTagChange *token = (const UndoTokenTagChange *) item;
+    bool isRedo = (item->undoType == &redoTokenTagType);
+    bool add = (isRedo == POINTER_IS_MARKED(token->tagPtr));
+    Tcl_Obj *objPtr = Tcl_NewObj();
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("tag", -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(add ? "add" : "remove", -1));
+    return objPtr;
+}
+
+Tcl_Obj *
+TkBTreeUndoTagInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenTagChange *token = (const UndoTokenTagChange *) item;
+    Tcl_Obj *objPtr = UndoTagGetCommand(sharedTextPtr, item);
+    TkTextTag *tagPtr = token->tagPtr;
+
+    UNMARK_POINTER(tagPtr);
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(tagPtr->name, -1));
+    return objPtr;
+}
+
+static void
+UndoTagPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    UndoTokenTagChange *token = (UndoTokenTagChange *) undoInfo->token;
+    TkTextTag *tagPtr = token->tagPtr;
+    bool remove = POINTER_IS_MARKED(tagPtr);
+    bool add = (isRedo != remove);
+    TkTextIndex index1, index2;
+
+    UNMARK_POINTER(tagPtr);
+    TkTextEnableTag(sharedTextPtr, tagPtr);
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->startIndex, &index1);
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->endIndex, &index2);
+
+    if (token->lengths) {
+	TkTextIndex nextIndex = index1;
+	const int32_t *len;
+
+	for (len = token->lengths; *len; ++len) {
+	    int length = *len;
+
+	    TkTextIndexForwBytes(NULL, &nextIndex, ABS(length), &nextIndex);
+
+	    if (length > 0) {
+		TkBTreeTag(sharedTextPtr, NULL, &index1, &nextIndex, tagPtr, add, NULL,
+			TkTextTagChangedUndoRedo);
+	    }
+
+	    index1 = nextIndex;
+	}
+
+	TkBTreeTag(sharedTextPtr, NULL, &index1, &index2, tagPtr, add, NULL, TkTextTagChangedUndoRedo);
+    } else {
+	TkBTreeTag(sharedTextPtr, NULL, &index1, &index2, tagPtr, add, NULL, TkTextTagChangedUndoRedo);
+    }
+
+    if (redoInfo) {
+	redoInfo->token = undoInfo->token;
+	redoInfo->token->undoType = isRedo? &undoTokenTagType : &redoTokenTagType;
+    }
+}
+
+static void
+UndoTagDestroy(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *item,
+    bool reused)
+{
+    if (!reused) {
+	UndoTokenTagChange *token = (UndoTokenTagChange *) item;
+
+	UNMARK_POINTER(token->tagPtr);
+	TkTextReleaseTag(sharedTextPtr, token->tagPtr, NULL);
+	free(token->lengths);
+	token->lengths = NULL;
+    }
+}
+
+/* TAG CLEAR *****************************************************************/
+
+static Tcl_Obj *
+UndoClearTagsGetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("tag", -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("clear", -1));
+    return objPtr;
+}
+
+static Tcl_Obj *
+UndoClearTagsInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenTagClear *token = (const UndoTokenTagClear *) item;
+    Tcl_Obj *objPtr = UndoClearTagsGetCommand(sharedTextPtr, item);
+    Tcl_Obj *objPtr2 = Tcl_NewObj();
+    unsigned i;
+
+    for (i = 0; i < token->changeListSize; ++i) {
+	const UndoTagChange *change = token->changeList + i;
+
+	Tcl_ListObjAppendElement(NULL, objPtr2, MakeTagInfoObj(sharedTextPtr, change->tagInfoPtr));
+	Tcl_ListObjAppendElement(NULL, objPtr2, Tcl_NewIntObj(change->skip));
+	Tcl_ListObjAppendElement(NULL, objPtr2, Tcl_NewIntObj(change->size));
+    }
+
+    Tcl_ListObjAppendElement(NULL, objPtr, objPtr2);
+    return objPtr;
+}
+
+static void
+UndoClearTagsPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    UndoTokenTagClear *token = (UndoTokenTagClear *) undoInfo->token;
+    const UndoTagChange *entry = token->changeList;
+    TkTextSegment *firstSegPtr = NULL, *lastSegPtr = NULL;
+    TkTextIndex startIndex, endIndex;
+    unsigned n = token->changeListSize;
+    bool anyChanges = false;
+    bool affectsDisplayGeometry = false;
+    bool updateElideInfo = false;
+    TkTextSegment *segPtr;
+    TkTextLine *linePtr;
+    Node *nodePtr;
+    int offs = 0;
+    unsigned i;
+
+    assert(token->changeListSize > 0);
+
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->startIndex, &startIndex);
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->endIndex, &endIndex);
+
+    linePtr = TkTextIndexGetLine(&startIndex);
+    segPtr = linePtr->segPtr;
+    nodePtr = linePtr->parentPtr;
+
+    for (i = 0; i < n; ++i, ++entry) {
+	unsigned skip = entry->skip;
+	unsigned size = entry->size;
+
+	while (size > 0) {
+	    while (linePtr->size - offs <= skip) {
+		assert(linePtr->nextPtr);
+		skip -= linePtr->size - offs;
+		if (anyChanges) {
+		    RecomputeLineTagInfo(linePtr, NULL, sharedTextPtr);
+		    if (nodePtr != linePtr->nextPtr->parentPtr) {
+			UpdateNodeTags(sharedTextPtr, nodePtr);
+			nodePtr = linePtr->nextPtr->parentPtr;
+		    }
+		    anyChanges = false;
+		}
+		linePtr = linePtr->nextPtr;
+		segPtr = linePtr->segPtr;
+		offs = 0;
+	    }
+	    if (segPtr == segPtr->sectionPtr->segPtr) {
+		TkTextSection *sectionPtr = segPtr->sectionPtr;
+
+		while (sectionPtr->size <= skip) {
+		    skip -= sectionPtr->size;
+		    offs += sectionPtr->size;
+		    if (!(sectionPtr = sectionPtr->nextPtr)) {
+			if (anyChanges) {
+			    RecomputeLineTagInfo(linePtr, NULL, sharedTextPtr);
+			    if (nodePtr != linePtr->nextPtr->parentPtr) {
+				UpdateNodeTags(sharedTextPtr, nodePtr);
+				nodePtr = linePtr->nextPtr->parentPtr;
+			    }
+			    anyChanges = false;
+			}
+			linePtr = linePtr->nextPtr;
+			assert(linePtr);
+			sectionPtr = linePtr->segPtr->sectionPtr;
+			offs = 0;
+		    }
+		    segPtr = sectionPtr->segPtr;
+		}
+	    }
+	    while (segPtr->size <= skip) {
+		skip -= segPtr->size;
+		offs += segPtr->size;
+		if (!(segPtr = segPtr->nextPtr)) {
+		    if (anyChanges) {
+			RecomputeLineTagInfo(linePtr, NULL, sharedTextPtr);
+			if (nodePtr != linePtr->nextPtr->parentPtr) {
+			    UpdateNodeTags(sharedTextPtr, nodePtr);
+			    nodePtr = linePtr->nextPtr->parentPtr;
+			}
+			anyChanges = false;
+		    }
+		    linePtr = linePtr->nextPtr;
+		    assert(linePtr);
+		    segPtr = linePtr->segPtr;
+		    offs = 0;
+		}
+	    }
+	    while (size > 0 && segPtr) {
+		while (segPtr->size == 0) {
+		    segPtr = segPtr->nextPtr;
+		}
+		if (size != segPtr->size) {
+		    if (skip > 0) {
+			assert(skip < segPtr->size);
+			offs += skip;
+			segPtr = SplitCharSegment(segPtr, skip)->nextPtr;
+		    }
+		    if (size < segPtr->size) {
+			segPtr = SplitCharSegment(segPtr, size);
+		    }
+		}
+		assert(segPtr->size <= size);
+		size -= segPtr->size;
+		offs += segPtr->size;
+		if (TkTextTagSetIntersectsBits(entry->tagInfoPtr, sharedTextPtr->affectGeometryTags)) {
+		    affectsDisplayGeometry = true;
+		}
+		if (TkTextTagSetIntersectsBits(entry->tagInfoPtr, sharedTextPtr->elisionTags)) {
+		    updateElideInfo = true;
+		}
+		TkTextTagSetDecrRefCount(segPtr->tagInfoPtr);
+		TkTextTagSetIncrRefCount(segPtr->tagInfoPtr = entry->tagInfoPtr);
+		if (!firstSegPtr) { firstSegPtr = segPtr; }
+		lastSegPtr = segPtr;
+		segPtr = segPtr->nextPtr;
+		anyChanges = true;
+		skip = 0;
+	    }
+	}
+    }
+
+    RecomputeLineTagInfo(linePtr, NULL, sharedTextPtr);
+    UpdateNodeTags(sharedTextPtr, linePtr->parentPtr);
+    if (updateElideInfo) {
+	UpdateElideInfo(sharedTextPtr, NULL, firstSegPtr, lastSegPtr, ELISION_HAS_BEEN_CHANGED);
+    }
+    firstSegPtr->protectionFlag = true;
+    lastSegPtr->protectionFlag = true;
+    CleanupSplitPoint(firstSegPtr, sharedTextPtr);
+    CleanupSplitPoint(lastSegPtr, sharedTextPtr);
+    TkBTreeIncrEpoch(sharedTextPtr->tree);
+    TkTextRedrawTag(sharedTextPtr, NULL, &startIndex, &endIndex, NULL, affectsDisplayGeometry);
+
+    if (redoInfo) {
+	RedoTokenClearTags *redoToken = malloc(sizeof(RedoTokenClearTags));
+	redoToken->undoType = &redoTokenClearTagsType;
+	redoToken->startIndex = token->startIndex;
+	redoToken->endIndex = token->endIndex;
+	redoInfo->token = (TkTextUndoToken *) redoToken;
+	DEBUG_ALLOC(tkTextCountNewUndoToken++);
+    }
+
+    TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+}
+
+static void
+UndoClearTagsDestroy(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *token,
+    bool reused)
+{
+    UndoTokenTagClear *myToken = (UndoTokenTagClear *) token;
+    UndoTagChange *changeList = myToken->changeList;
+    unsigned i, n = myToken->changeListSize;
+
+    assert(!reused);
+
+    for (i = 0; i < n; ++i) {
+	TkTextTagSetDecrRefCount(changeList[i].tagInfoPtr);
+    }
+
+    free(changeList);
+}
+
+static void
+RedoClearTagsPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    RedoTokenClearTags *token = (RedoTokenClearTags *) undoInfo->token;
+    TkTextIndex index1, index2;
+
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->startIndex, &index1);
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->endIndex, &index2);
+    TkBTreeClearTags(sharedTextPtr, NULL, &index1, &index2, redoInfo, true, TkTextTagChangedUndoRedo);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeCreate --
+ *
+ *	This function is called to create a new text B-tree.
+ *
+ * Results:
+ *	The return value is a pointer to a new B-tree containing one line with
+ *	nothing but a newline character.
+ *
+ * Side effects:
+ *	Memory is allocated and initialized.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextBTree
+TkBTreeCreate(
+    TkSharedText *sharedTextPtr,
+    unsigned epoch)
+{
+    BTree *treePtr;
+    Node *rootPtr;
+    TkTextLine *linePtr, *linePtr2;
+    TkTextSegment *segPtr;
+
+    /*
+     * The tree will initially have two empty lines. The first line contains
+     * the start marker, this marker will never move. The second line isn't
+     * actually part of the tree's contents, but its presence makes several
+     * operations easier. The second line contains the end marker. The tree
+     * will have one node, which is also the root of the tree.
+     *
+     * The tree currently has no registered clients, so all pixel count
+     * pointers are simply NULL.
+     */
+
+    rootPtr = memset(malloc(sizeof(Node)), 0, sizeof(Node));
+    DEBUG_ALLOC(tkTextCountNewNode++);
+
+    treePtr = memset(malloc(sizeof(BTree)), 0, sizeof(BTree));
+    treePtr->rootPtr = rootPtr;
+    treePtr->sharedTextPtr = sharedTextPtr;
+    treePtr->stateEpoch = epoch;
+    sharedTextPtr->tree = (TkTextBTree) treePtr;
+
+    assert(!sharedTextPtr->startMarker->nextPtr);
+    linePtr = InsertNewLine(sharedTextPtr, rootPtr, NULL, sharedTextPtr->startMarker);
+    segPtr = MakeCharSeg(NULL, sharedTextPtr->emptyTagInfoPtr, 1, "\n", 1);
+    LinkSegment(linePtr, sharedTextPtr->startMarker, segPtr);
+
+    assert(!sharedTextPtr->endMarker->nextPtr);
+    linePtr2 = InsertNewLine(sharedTextPtr, rootPtr, linePtr, sharedTextPtr->endMarker);
+    segPtr = MakeCharSeg(NULL, sharedTextPtr->emptyTagInfoPtr, 1, "\n", 1);
+    LinkSegment(linePtr2, sharedTextPtr->endMarker, segPtr);
+
+    rootPtr->linePtr = linePtr;
+    rootPtr->lastPtr = linePtr2;
+    rootPtr->size = 2;
+    rootPtr->numLines = 2;
+    rootPtr->numLogicalLines = 2;
+    rootPtr->numChildren = 2;
+    TkTextTagSetIncrRefCount(rootPtr->tagonPtr = sharedTextPtr->emptyTagInfoPtr);
+    TkTextTagSetIncrRefCount(rootPtr->tagoffPtr = sharedTextPtr->emptyTagInfoPtr);
+
+    if (tkBTreeDebug) {
+	sharedTextPtr->refCount += 1;
+	TkBTreeCheck((TkTextBTree) treePtr);
+	sharedTextPtr->refCount -= 1;
+    }
+
+    return (TkTextBTree) treePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetStartLine --
+ *
+ *	This function returns the first line for given text widget, if
+ *	NULL it returns the first line of shared resource.
+ *
+ * Results:
+ *	The first line in this widget (or shared resource).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextLine *
+GetStartLine(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr)
+{
+    return textPtr ? TkBTreeGetStartLine(textPtr) : sharedTextPtr->startMarker->sectionPtr->linePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetLastLine --
+ *
+ *	This function returns the last line for given text widget.
+ *
+ * Results:
+ *	The last line in this widget.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextLine *
+GetLastLine(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr)
+{
+    TkTextLine *endLine;
+
+    assert(sharedTextPtr || textPtr);
+
+    if (!textPtr) {
+	return sharedTextPtr->endMarker->sectionPtr->linePtr;
+    }
+
+    endLine = textPtr->endMarker->sectionPtr->linePtr;
+    return endLine->nextPtr ? endLine->nextPtr : endLine;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeNumLines --
+ *
+ *	This function returns a count of the number of lines of text
+ *	present in a given B-tree.
+ *
+ * Results:
+ *	The return value is a count of the number of usable lines in tree
+ *	(i.e. it doesn't include the dummy line that is just used to mark the
+ *	end of the tree).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkBTreeNumLines(
+    TkTextBTree tree,		/* Information about tree. */
+    const TkText *textPtr)	/* Relative to this client of the B-tree. */
+{
+    int count;
+
+    if (textPtr) {
+	count = TkBTreeLinesTo(tree, NULL, TkBTreeGetLastLine(textPtr), NULL);
+	count -= TkBTreeLinesTo(tree, NULL, TkBTreeGetStartLine(textPtr), NULL);
+    } else {
+	count = TkBTreeGetRoot(tree)->numLines - 1;
+    }
+
+    return count;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeAddClient --
+ *
+ *	This function is called to provide a client with access to a given
+ *	B-tree. If the client wishes to make use of the B-tree's pixel height
+ *	storage, caching and calculation mechanisms, then a non-negative
+ *	'defaultHeight' must be provided. In this case the return value is a
+ *	pixel tree reference which must be provided in all of the B-tree API
+ *	which refers to or modifies pixel heights:
+ *
+ *	TkBTreeAdjustPixelHeight,
+ *	TkBTreeFindPixelLine,
+ *	TkBTreeNumPixels,
+ *	TkBTreePixelsTo,
+ *	(and two private functions AdjustPixelClient, RemovePixelClient).
+ *
+ *	If this is not provided, then the above functions must never be called
+ *	for this client.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory may be allocated and initialized.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeAddClient(
+    TkTextBTree tree,		/* B-tree to add a client to. */
+    TkText *textPtr,		/* Client to add. */
+    int defaultHeight)		/* Default line height for the new client, or
+				 * -1 if no pixel heights are to be kept. */
+{
+    BTree *treePtr = (BTree *) tree;
+
+    assert(treePtr);
+
+    if (defaultHeight >= 0) {
+	unsigned useReference = treePtr->numPixelReferences;
+
+	AdjustPixelClient(treePtr, defaultHeight, treePtr->rootPtr, TkBTreeGetStartLine(textPtr),
+		TkBTreeGetLastLine(textPtr), useReference, useReference + 1, NULL);
+
+	textPtr->pixelReference = useReference;
+	treePtr->numPixelReferences += 1;
+	treePtr->pixelInfoBuffer = realloc(treePtr->pixelInfoBuffer,
+		sizeof(treePtr->pixelInfoBuffer[0])*treePtr->numPixelReferences);
+    } else {
+	textPtr->pixelReference = -1;
+    }
+
+    treePtr->clients += 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeClientRangeChanged --
+ *
+ *	Called when the -startindex or -endindex options of a text widget client
+ *	of the B-tree have changed.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Lots of processing of the B-tree is done, with potential for memory to
+ *	be allocated and initialized for the pixel heights of the widget.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeClientRangeChanged(
+    TkText *textPtr,		/* Client whose start, end have changed. */
+    unsigned defaultHeight)	/* Default line height for the new client, or
+				 * zero if no pixel heights are to be kept. */
+{
+    BTree *treePtr = (BTree *) textPtr->sharedTextPtr->tree;
+    TkTextLine *startLine = TkBTreeGetStartLine(textPtr);
+    TkTextLine *endLine = TkBTreeGetLastLine(textPtr);
+
+    AdjustPixelClient(treePtr, defaultHeight, treePtr->rootPtr, startLine,
+	    endLine, textPtr->pixelReference, treePtr->numPixelReferences, NULL);
+
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeRemoveClient --
+ *
+ *	Remove a client widget from its B-tree, cleaning up the pixel arrays
+ *	which it uses if necessary. If this is the last such widget, we also
+ *	destroy the whole tree.
+ *
+ * Results:
+ *	All tree-specific aspects of the given client are deleted. If no more
+ *	references exist, then the given tree is also deleted (in which case
+ *	'tree' must not be used again).
+ *
+ * Side effects:
+ *	Memory may be freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeRemoveClient(
+    TkTextBTree tree,		/* Tree to remove client from. */
+    TkText *textPtr)		/* Client to remove. */
+{
+    BTree *treePtr = (BTree *) tree;
+    int pixelReference = textPtr->pixelReference;
+
+    if (treePtr->clients == 1) {
+	/*
+	 * The last reference to the tree.
+	 */
+
+	DestroyNode(tree, treePtr->rootPtr);
+	free(treePtr);
+	return;
+    }
+
+    if (pixelReference == -1) {
+	/*
+	 * A client which doesn't care about pixels.
+	 */
+
+	treePtr->clients -= 1;
+    } else {
+	/*
+	 * Clean up pixel data for the given reference.
+	 */
+
+	if (pixelReference == (treePtr->numPixelReferences - 1)) {
+	    /*
+	     * The widget we're removing has the last index, so deletion is easier.
+	     */
+
+	    RemovePixelClient(treePtr, treePtr->rootPtr, pixelReference, -1);
+	} else {
+	    TkText *adjustPtr;
+
+	    RemovePixelClient(treePtr, treePtr->rootPtr, pixelReference, pixelReference);
+
+	    /*
+	     * Now we need to adjust the 'pixelReference' of the peer widget
+	     * whose storage we've just moved.
+	     */
+
+	    adjustPtr = treePtr->sharedTextPtr->peers;
+	    while (adjustPtr) {
+		if (adjustPtr->pixelReference == treePtr->numPixelReferences - 1) {
+		    adjustPtr->pixelReference = pixelReference;
+		    break;
+		}
+		adjustPtr = adjustPtr->next;
+	    }
+	    assert(adjustPtr);
+	}
+
+	treePtr->numPixelReferences -= 1;
+	treePtr->clients -= 1;
+	treePtr->pixelInfoBuffer = realloc(treePtr->pixelInfoBuffer,
+		sizeof(treePtr->pixelInfoBuffer[0])*treePtr->numPixelReferences);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * AdjustPixelClient --
+ *
+ *	Utility function used to update all data structures for the existence
+ *	of a new peer widget based on this B-tree, or for the modification of
+ *	the start, end lines of an existing peer widget.
+ *
+ *	Immediately _after_ calling this, treePtr->numPixelReferences and
+ *	treePtr->clients should be adjusted if needed (i.e. if this is a new
+ *	peer).
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	All the storage for Nodes and TkTextLines in the tree may be adjusted.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static unsigned
+AdjustPixelClient(
+    BTree *treePtr,		/* Pointer to tree. */
+    unsigned defaultHeight,	/* Default pixel line height, which can be zero. */
+    Node *nodePtr,		/* Adjust from this node downwards. */
+    TkTextLine *startLine,	/* First line for this pixel client. */
+    TkTextLine *endLine,	/* Last line for this pixel client. */
+    unsigned useReference,	/* Pixel reference for the client we are adding or changing. */
+    unsigned newPixelReferences,/* New number of pixel references to this B-tree. */
+    unsigned *numDispLinesPtr)	/* Number of display lines in this sub-tree, can be NULL. */
+{
+    unsigned pixelCount = 0;
+    unsigned numDispLines = 0;
+
+    assert(startLine);
+    assert(endLine);
+    assert(!nodePtr->parentPtr == !numDispLinesPtr);
+
+    /*
+     * Traverse entire tree down from nodePtr, reallocating pixel structures
+     * for each Node and TkTextLine, adding room for the new peer's pixel
+     * information (1 extra int per Node, 2 extra ints per TkTextLine). Also
+     * copy the information from the last peer into the new space (so it
+     * contains something sensible).
+     */
+
+    if (nodePtr->level > 0) {
+	Node *loopPtr = nodePtr->childPtr;
+
+	while (loopPtr) {
+	    pixelCount += AdjustPixelClient(treePtr, defaultHeight, loopPtr,
+		    startLine, endLine, useReference, newPixelReferences, &numDispLines);
+	    loopPtr = loopPtr->nextPtr;
+	}
+    } else {
+	TkTextLine *linePtr = nodePtr->linePtr;
+	TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+	unsigned height = 0;
+	unsigned epoch = 1;
+
+	for ( ; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+	    if (linePtr == startLine) {
+		height = defaultHeight;
+		epoch = 0;
+	    } else if (linePtr == endLine) {
+		height = 0;
+		epoch = 1;
+	    }
+
+	    /*
+	     * Notice that for the very last line, we are never counting and
+	     * therefore this always has a height of 0 and an epoch of 1.
+	     */
+
+	    if (newPixelReferences > treePtr->numPixelReferences) {
+		DEBUG_ALLOC(if (!linePtr->pixelInfo) tkTextCountNewPixelInfo++);
+		linePtr->pixelInfo = realloc(linePtr->pixelInfo,
+			sizeof(linePtr->pixelInfo[0])*newPixelReferences);
+		memset(&linePtr->pixelInfo[useReference], 0, sizeof(TkTextPixelInfo));
+	    } else if (linePtr->pixelInfo[useReference].dispLineInfo) {
+		free(linePtr->pixelInfo[useReference].dispLineInfo);
+		linePtr->pixelInfo[useReference].dispLineInfo = NULL;
+		DEBUG_ALLOC(tkTextCountDestroyDispInfo++);
+	    }
+
+	    linePtr->pixelInfo[useReference].epoch = epoch;
+	    pixelCount += (linePtr->pixelInfo[useReference].height = height);
+	    numDispLines += GetDisplayLines(linePtr, useReference);
+	}
+    }
+
+    if (newPixelReferences > treePtr->numPixelReferences) {
+	DEBUG_ALLOC(if (!nodePtr->pixelInfo) tkTextCountNewPixelInfo++);
+	nodePtr->pixelInfo = realloc(nodePtr->pixelInfo,
+		sizeof(nodePtr->pixelInfo[0])*newPixelReferences);
+    }
+    nodePtr->pixelInfo[useReference].pixels = pixelCount;
+    nodePtr->pixelInfo[useReference].numDispLines = numDispLines;
+    if (numDispLinesPtr) {
+	*numDispLinesPtr += numDispLines;
+    }
+    return pixelCount;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * RemovePixelClient --
+ *
+ *	Utility function used to update all data structures for the removal of
+ *	a peer widget which used to be based on this B-tree.
+ *
+ *	Immediately _after_ calling this, treePtr->clients should be
+ *	decremented.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	All the storage for Nodes and TkTextLines in the tree may be adjusted.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+RemovePixelClient(
+    BTree *treePtr,		/* Pointer to tree. */
+    Node *nodePtr,		/* Adjust from this node downwards. */
+    unsigned useReference,	/* Pixel reference for the client we are removing. */
+    int overwriteWithLast)	/* Over-write this peer widget's information with the last one. */
+{
+    /*
+     * Traverse entire tree down from nodePtr, reallocating pixel structures
+     * for each Node and TkTextLine, removing space allocated for one peer. If
+     * 'overwriteWithLast' is not -1, then copy the information which was in
+     * the last slot on top of one of the others (i.e. it's not the last one
+     * we're deleting).
+     */
+
+    if (overwriteWithLast != -1) {
+	nodePtr->pixelInfo[overwriteWithLast] = nodePtr->pixelInfo[treePtr->numPixelReferences - 1];
+    }
+    if (treePtr->numPixelReferences == 1) {
+	free(nodePtr->pixelInfo);
+	nodePtr->pixelInfo = NULL;
+	DEBUG_ALLOC(tkTextCountDestroyPixelInfo++);
+    } else {
+	nodePtr->pixelInfo = realloc(nodePtr->pixelInfo,
+		sizeof(nodePtr->pixelInfo[0])*(treePtr->numPixelReferences - 1));
+    }
+    if (nodePtr->level != 0) {
+	nodePtr = nodePtr->childPtr;
+	while (nodePtr) {
+	    RemovePixelClient(treePtr, nodePtr, useReference, overwriteWithLast);
+	    nodePtr = nodePtr->nextPtr;
+	}
+    } else {
+	TkTextLine *linePtr = nodePtr->linePtr;
+	TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+
+	while (linePtr != lastPtr) {
+	    if (linePtr->pixelInfo[useReference].dispLineInfo) {
+		free(linePtr->pixelInfo[useReference].dispLineInfo);
+		DEBUG_ALLOC(tkTextCountDestroyDispInfo++);
+	    }
+	    if (overwriteWithLast != -1) {
+		linePtr->pixelInfo[overwriteWithLast] =
+			linePtr->pixelInfo[treePtr->numPixelReferences - 1];
+	    }
+	    if (treePtr->numPixelReferences == 1) {
+		free(linePtr->pixelInfo);
+		linePtr->pixelInfo = NULL;
+		DEBUG_ALLOC(tkTextCountDestroyPixelInfo++);
+	    } else {
+		linePtr->pixelInfo = realloc(linePtr->pixelInfo,
+			sizeof(linePtr->pixelInfo[0])*(treePtr->numPixelReferences - 1));
+	    }
+	    linePtr = linePtr->nextPtr;
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeJoinUndoInsert --
+ *
+ *	Joins an undo token with another token.
+ *
+ * Results:
+ *	Return whether the join was possible.
+ *
+ * Side effects:
+ *	The first given will be modified.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkBTreeJoinUndoInsert(
+    TkTextUndoToken *token1,
+    unsigned byteSize1,
+    TkTextUndoToken *token2,
+    unsigned byteSize2)
+{
+    struct UndoTokenInsert *myToken1 = (UndoTokenInsert *) token1;
+    struct UndoTokenInsert *myToken2 = (UndoTokenInsert *) token2;
+
+    if (UndoIndexIsEqual(&myToken1->endIndex, &myToken2->startIndex)) {
+	/* append to first token */
+	myToken1->endIndex = myToken2->endIndex;
+    } else if (UndoIndexIsEqual(&myToken1->startIndex, &myToken2->endIndex)) {
+	/* prepend to first token */
+	myToken1->startIndex = myToken2->startIndex;
+    } else {
+	return false;
+    }
+
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeJoinUndoDelete --
+ *
+ *	Joins an undo token with another token.
+ *
+ * Results:
+ *	Return whether the join was possible.
+ *
+ * Side effects:
+ *	The first given will be modified.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkBTreeJoinUndoDelete(
+    TkTextUndoToken *token1,
+    unsigned byteSize1,
+    TkTextUndoToken *token2,
+    unsigned byteSize2)
+{
+    struct UndoTokenDelete *myToken1 = (UndoTokenDelete *) token1;
+    struct UndoTokenDelete *myToken2 = (UndoTokenDelete *) token2;
+
+    if (myToken1->inclusive != myToken2->inclusive) {
+	return false;
+    }
+
+    if (UndoIndexIsEqual(&myToken1->startIndex, &myToken2->startIndex)) {
+	unsigned numSegments1 = myToken1->numSegments;
+
+	if (myToken2->endIndex.lineIndex == -1) {
+	    myToken1->endIndex = myToken2->endIndex;
+	} else if (myToken1->endIndex.lineIndex != -1) {
+	    myToken1->endIndex.u.byteIndex += byteSize2;
+	} else if (myToken2->endIndex.lineIndex != -1) {
+	    myToken1->endIndex.u.byteIndex = myToken2->endIndex.u.byteIndex + byteSize1;
+	    myToken1->endIndex.lineIndex = myToken2->endIndex.lineIndex;
+	} else if (myToken2->startIndex.lineIndex != -1) {
+	    myToken1->endIndex.u.byteIndex = myToken2->startIndex.u.byteIndex + byteSize1 + byteSize2;
+	    myToken1->endIndex.lineIndex = myToken2->startIndex.lineIndex;
+	} else {
+	    myToken1->endIndex.u.byteIndex = myToken1->startIndex.u.byteIndex + byteSize1 + byteSize2;
+	    myToken1->endIndex.lineIndex = myToken1->startIndex.lineIndex;
+	}
+
+	myToken1->numSegments += myToken2->numSegments;
+	myToken1->segments = realloc(myToken1->segments,
+		myToken1->numSegments*sizeof(myToken1->segments[0]));
+	memcpy(myToken1->segments + numSegments1, myToken2->segments,
+		myToken2->numSegments*sizeof(myToken2->segments[0]));
+	free(myToken2->segments);
+	myToken2->numSegments = 0;
+    } else if (UndoIndexIsEqual(&myToken1->startIndex, &myToken2->endIndex)) {
+	unsigned numSegments1 = myToken1->numSegments;
+	TkTextSegment **segments;
+
+	if (myToken2->startIndex.lineIndex == -1) {
+	    myToken1->startIndex = myToken2->startIndex;
+	} else if (myToken2->endIndex.lineIndex != -1) {
+	    myToken1->startIndex.u.byteIndex = myToken2->endIndex.u.byteIndex - byteSize1;
+	    myToken1->startIndex.lineIndex = myToken2->endIndex.lineIndex;
+	} else if (myToken1->endIndex.lineIndex != -1) {
+	    myToken1->startIndex.u.byteIndex = myToken1->endIndex.u.byteIndex - byteSize1 - byteSize2;
+	    myToken1->startIndex.lineIndex = myToken1->endIndex.lineIndex;
+	} else {
+	    myToken1->startIndex.u.byteIndex = myToken1->startIndex.u.byteIndex + byteSize1 + byteSize2;
+	    myToken1->startIndex.lineIndex = myToken1->startIndex.lineIndex;
+	}
+
+	myToken1->numSegments += myToken2->numSegments;
+	segments = malloc(myToken1->numSegments*sizeof(segments[0]));
+	memcpy(segments, myToken2->segments, myToken2->numSegments*sizeof(myToken2->segments[0]));
+	memcpy(segments + myToken2->numSegments, myToken1->segments,
+		numSegments1*sizeof(myToken1->segments[0]));
+	free(myToken1->segments);
+	free(myToken2->segments);
+	myToken1->segments = segments;
+	myToken2->numSegments = 0;
+    } else {
+	return false;
+    }
+
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeDestroy --
+ *
+ *	Delete a B-tree, recycling all of the storage it contains.
+ *
+ * Results:
+ *	The tree is deleted, so 'tree' should never again be used.
+ *
+ * Side effects:
+ *	Memory is freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeDestroy(
+    TkTextBTree tree)		/* Tree to clean up. */
+{
+    BTree *treePtr = (BTree *) tree;
+
+    /*
+     * There's no need to loop over each client of the tree, calling
+     * 'TkBTreeRemoveClient', since the 'DestroyNode' will clean everything up
+     * itself.
+     */
+
+    DestroyNode(tree, treePtr->rootPtr);
+    free(treePtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeHaveElidedSegments --
+ *
+ *	Return whether this tree contains elided segments.
+ *
+ * Results:
+ *	'true' if this tree contains elided segments, otherwise 'false'.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkBTreeHaveElidedSegments(
+    const TkSharedText *sharedTextPtr)
+{
+    return TkBTreeGetRoot(sharedTextPtr->tree)->numBranches > 0;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FreeNode --
+ *
+ *	Free the storage of a node.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The storage of given node will be freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+FreeNode(
+    Node *nodePtr)	/* Free storage of this node. */
+{
+    assert(nodePtr->level > 0 || nodePtr->linePtr);
+    TkTextTagSetDecrRefCount(nodePtr->tagonPtr);
+    TkTextTagSetDecrRefCount(nodePtr->tagoffPtr);
+    free(nodePtr->pixelInfo);
+    DEBUG(nodePtr->linePtr = NULL); /* guarded deallocation */
+    free(nodePtr);
+    DEBUG_ALLOC(tkTextCountDestroyPixelInfo++);
+    DEBUG_ALLOC(tkTextCountDestroyNode++);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DestroyNode --
+ *
+ *	This is a recursive utility function used during the deletion of a
+ *	B-tree.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	All the storage for nodePtr and its descendants is freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+DestroyNode(
+    TkTextBTree tree,
+    Node *nodePtr)	/* Destroy from this node downwards. */
+{
+    if (nodePtr->level == 0) {
+	TkTextLine *linePtr;
+	TkTextLine *lastPtr;
+	TkTextSegment *segPtr;
+	TkTextSection *sectionPtr;
+
+	lastPtr = nodePtr->lastPtr->nextPtr;
+	linePtr = nodePtr->linePtr;
+
+	while (linePtr != lastPtr) {
+	    TkTextLine *nextPtr = linePtr->nextPtr;
+	    segPtr = linePtr->segPtr;
+	    sectionPtr = segPtr->sectionPtr;
+	    while (segPtr) {
+		TkTextSegment *nextPtr = segPtr->nextPtr;
+		assert(segPtr->typePtr); /* still existing? */
+		assert(segPtr->sectionPtr->linePtr == linePtr);
+		assert(segPtr->typePtr->deleteProc);
+		segPtr->typePtr->deleteProc(tree, segPtr, TREE_GONE);
+		segPtr = nextPtr;
+	    }
+	    FreeSections(sectionPtr);
+	    FreeLine((const BTree *) tree, linePtr);
+	    linePtr = nextPtr;
+	}
+    } else {
+	Node *childPtr = nodePtr->childPtr;
+
+	while (childPtr) {
+	    Node *nextPtr = childPtr->nextPtr;
+	    DestroyNode(tree, childPtr);
+	    childPtr = nextPtr;
+	}
+    }
+    FreeNode(nodePtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeResetDisplayLineCounts --
+ *
+ *	Reset the display line counts for given line range.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Updates overall data structures so display line count is consistent.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+PropagateDispLineChange(
+    Node *nodePtr,
+    unsigned pixelReference,
+    int subtractFromDispLines,
+    int subtractFromPixels)
+{
+    if (subtractFromDispLines != 0 || subtractFromPixels != 0) {
+	for ( ; nodePtr; nodePtr = nodePtr->parentPtr) {
+	    NodePixelInfo *pixelInfo = nodePtr->pixelInfo + pixelReference;
+	    pixelInfo->numDispLines -= subtractFromDispLines;
+	    pixelInfo->pixels -= subtractFromPixels;
+	}
+    }
+}
+
+void
+TkBTreeResetDisplayLineCounts(
+    TkText *textPtr,
+    TkTextLine *linePtr,	/* Start at this line. */
+    unsigned numLines)		/* Number of succeeding lines to reset (includes the start line). */
+{
+    Node *nodePtr = linePtr->parentPtr;
+    unsigned pixelReference = textPtr->pixelReference;
+    int changeToDispLines = 0;
+    int changeToPixels = 0;
+
+    assert(textPtr->pixelReference != -1);
+
+    for ( ; numLines > 0; --numLines) {
+	TkTextPixelInfo *pixelInfo = TkBTreeLinePixelInfo(textPtr, linePtr);
+
+	changeToDispLines += (int) GetDisplayLines(linePtr, pixelReference);
+	changeToPixels += pixelInfo->height;
+	pixelInfo->epoch = 0;
+	pixelInfo->height = 0;
+	linePtr = linePtr->nextPtr;
+
+	if (pixelInfo->dispLineInfo) {
+	    free(pixelInfo->dispLineInfo);
+	    pixelInfo->dispLineInfo = NULL;
+	    DEBUG_ALLOC(tkTextCountDestroyDispInfo++);
+	}
+
+	if (nodePtr != linePtr->parentPtr) {
+	    PropagateDispLineChange(nodePtr, pixelReference, changeToDispLines, changeToPixels);
+	    changeToDispLines = 0;
+	    changeToPixels = 0;
+	    nodePtr = linePtr->parentPtr;
+	}
+    }
+
+    PropagateDispLineChange(nodePtr, pixelReference, changeToDispLines, changeToPixels);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeAdjustPixelHeight --
+ *
+ *	Adjust the pixel height of a given logical line to the specified
+ *	value.
+ *
+ * Results:
+ *	Total number of valid pixels currently known in the tree.
+ *
+ * Side effects:
+ *	Updates overall data structures so pixel height count is consistent.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+PropagatePixelCountChange(
+    Node *nodePtr,
+    unsigned pixelReference,
+    int changeToPixels,
+    int changeToDispLines)
+{
+    /*
+     * Increment the pixel counts also in all the parent nodes.
+     */
+
+    for ( ; nodePtr; nodePtr = nodePtr->parentPtr) {
+	NodePixelInfo *pixelInfo = nodePtr->pixelInfo + pixelReference;
+
+	pixelInfo->pixels += changeToPixels;
+	pixelInfo->numDispLines += changeToDispLines;
+    }
+}
+
+void
+TkBTreeAdjustPixelHeight(
+    const TkText *textPtr,	/* Client of the B-tree. */
+    TkTextLine *linePtr,	/* The logical line to update. */
+    int newPixelHeight,		/* The line's known height in pixels. */
+    unsigned mergedLines,	/* The number of extra lines which have been merged with this one
+    				 * (due to elided eols). They will have their pixel height set to
+				 * zero, and the total pixel height associated with the given linePtr. */
+    unsigned numDispLines)	/* The new number of display lines for this logical line. */
+{
+    Node *nodePtr = linePtr->parentPtr;
+    unsigned pixelReference = textPtr->pixelReference;
+    int changeToPixels = 0;
+    int changeToDispLines = 0;
+
+    assert(textPtr->pixelReference != -1);
+    assert(linePtr->logicalLine || linePtr == GetStartLine(textPtr->sharedTextPtr, textPtr));
+
+    while (true) {
+	/*
+	 * Do this before updating the line height.
+	 */
+
+	changeToDispLines += (int) numDispLines - (int) GetDisplayLines(linePtr, pixelReference);
+	changeToPixels += newPixelHeight - linePtr->pixelInfo[pixelReference].height;
+
+	linePtr->pixelInfo[pixelReference].height = newPixelHeight;
+
+	if (mergedLines == 0) {
+	    if (changeToPixels || changeToDispLines) {
+		PropagatePixelCountChange(nodePtr, pixelReference, changeToPixels, changeToDispLines);
+	    }
+	    return;
+	}
+
+	/*
+	 * Any merged logical lines must have their height set to zero.
+	 */
+
+	linePtr = linePtr->nextPtr;
+	newPixelHeight = 0;
+	mergedLines -= 1;
+	numDispLines = 0;
+
+	if (nodePtr != linePtr->parentPtr) {
+	    if (changeToPixels || changeToDispLines) {
+		PropagatePixelCountChange(nodePtr, pixelReference, changeToPixels, changeToDispLines);
+	    }
+	    changeToPixels = 0;
+	    changeToDispLines = 0;
+	    nodePtr = linePtr->parentPtr;
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeUpdatePixelHeights --
+ *
+ *	Update the pixel heights, starting with given line. This function
+ *	assumes that all logical lines will have monospaced line heights.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Updates overall data structures so pixel height count is consistent.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeUpdatePixelHeights(
+    const TkText *textPtr,	/* Client of the B-tree. */
+    TkTextLine *linePtr,	/* Start with this logical line. */
+    int numLines,		/* Number of lines for update (inclusively start line). If negative,
+    				 * this is the number of deleted lines. */
+    unsigned epoch)		/* Current line metric epoch. */
+{
+    Node *nodePtr = linePtr->parentPtr;
+    unsigned pixelReference = textPtr->pixelReference;
+    int lineHeight = textPtr->lineHeight;
+    int changeToDispLines = 0;
+    int changeToPixels = 0;
+    int nlines = ABS(numLines);
+
+    assert(textPtr->pixelReference >= 0);
+    assert(textPtr->wrapMode == TEXT_WRAPMODE_NONE);
+    assert(lineHeight > 0);
+
+    for ( ; nlines > 0; --nlines) {
+	TkTextPixelInfo *pixelInfo = TkBTreeLinePixelInfo(textPtr, linePtr);
+
+	if (pixelInfo->dispLineInfo) {
+	    changeToDispLines -= (int) GetDisplayLines(linePtr, pixelReference);
+	    if (pixelInfo->height > 0) {
+		changeToDispLines += 1;
+	    }
+	    if (pixelInfo->dispLineInfo) {
+		free(pixelInfo->dispLineInfo);
+		pixelInfo->dispLineInfo = NULL;
+		DEBUG_ALLOC(tkTextCountDestroyDispInfo++);
+	    }
+	}
+
+	pixelInfo->epoch = epoch;
+	changeToPixels -= pixelInfo->height;
+
+	if (pixelInfo->height == 0) {
+	    changeToDispLines += 1;
+	}
+
+	pixelInfo->height = lineHeight;
+
+	if (numLines > 0) {
+	    changeToPixels += lineHeight;
+	}
+
+	linePtr = linePtr->nextPtr;
+
+	if (nodePtr != linePtr->parentPtr) {
+	    if (changeToPixels || changeToDispLines) {
+		PropagatePixelCountChange(nodePtr, pixelReference, changeToPixels, changeToDispLines);
+	    }
+	    changeToDispLines = 0;
+	    changeToPixels = 0;
+	    nodePtr = linePtr->parentPtr;
+	}
+    }
+
+    if (changeToPixels || changeToDispLines) {
+	PropagatePixelCountChange(nodePtr, pixelReference, changeToPixels, changeToDispLines);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * SubtractPixelInfo --
+ *
+ *	Decrement the line and pixel counts in all the parent nodes.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The pixel counts in the B-tree will be adjusted.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+SubtractPixelInfo(
+    BTree *treePtr,		/* Tree that is being affected. */
+    TkTextLine *linePtr)	/* This line will be deleted. */
+{
+    Node *nodePtr = linePtr->parentPtr;
+    unsigned ref;
+
+    for ( ; nodePtr; nodePtr = nodePtr->parentPtr) {
+	NodePixelInfo *dst = nodePtr->pixelInfo;
+
+	nodePtr->numLines -= 1;
+	nodePtr->numLogicalLines -= linePtr->logicalLine;
+	nodePtr->size -= linePtr->size;
+
+	for (ref = 0; ref < treePtr->numPixelReferences; ++ref, ++dst) {
+	    dst->pixels -= linePtr->pixelInfo[ref].height;
+	    dst->numDispLines -= GetDisplayLines(linePtr, ref);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * SubtractPixelCount2 --
+ *
+ *	Decrement the line and pixel counts in all the parent nodes.
+ *	This function can also be used for incrementation, simply negate
+ *	the values 'changeToLineCount' and 'changeToPixelInfo'.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The pixel counts in the B-tree will be adjusted.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+SubtractPixelCount2(
+    BTree *treePtr,			/* Tree that is being affected. */
+    Node *nodePtr,			/* Node that will be adjusted. */
+    int changeToLineCount,		/* Number of lines removed. */
+    int changeToLogicalLineCount,	/* Number of logical lines removed. */
+    int changeToBranchCount,		/* Number of branches removed. */
+    int changeToSize,			/* Subtract this size. */
+    const NodePixelInfo *changeToPixelInfo)
+					/* Values for pixel info adjustment. */
+{
+    unsigned ref;
+
+    assert(changeToLineCount != 0 || changeToLogicalLineCount == 0);
+    assert(changeToLineCount != 0 || changeToBranchCount == 0);
+
+    if (changeToLineCount != 0) {
+	for ( ; nodePtr; nodePtr = nodePtr->parentPtr) {
+	    NodePixelInfo *dst = nodePtr->pixelInfo;
+	    const NodePixelInfo *src = changeToPixelInfo;
+
+	    nodePtr->numLines -= changeToLineCount;
+	    nodePtr->numLogicalLines -= changeToLogicalLineCount;
+	    nodePtr->numBranches -= changeToBranchCount;
+	    nodePtr->size -= changeToSize;
+
+	    for (ref = 0; ref < treePtr->numPixelReferences; ++ref, ++dst, ++src) {
+		dst->pixels -= src->pixels;
+		dst->numDispLines -= src->numDispLines;
+	    }
+	}
+    } else if (changeToSize != 0) {
+	for ( ; nodePtr; nodePtr = nodePtr->parentPtr) {
+	    nodePtr->size -= changeToSize;
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * AddPixelCount --
+ *
+ *	Set up a starting default height, which will be re-adjusted later.
+ *	We need to do this for each referenced widget.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory will be allocated.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+AddPixelCount(
+    BTree *treePtr,
+    TkTextLine *linePtr,
+    const TkTextLine *refLinePtr,
+    NodePixelInfo *changeToPixelInfo)
+{
+    unsigned ref;
+
+    /*
+     * Set up a starting default height, which will be re-adjusted later.
+     * We need to do this for each referenced widget.
+     */
+
+    linePtr->pixelInfo = malloc(sizeof(TkTextPixelInfo)*treePtr->numPixelReferences);
+    DEBUG_ALLOC(tkTextCountNewPixelInfo++);
+
+    for (ref = 0; ref < treePtr->numPixelReferences; ++ref) {
+	TkTextPixelInfo *pixelInfo = linePtr->pixelInfo + ref;
+	const TkTextPixelInfo *refPixelInfo = refLinePtr->pixelInfo + ref;
+	NodePixelInfo *pixelInfoChange = changeToPixelInfo + ref;
+	int height = refPixelInfo->height;
+	int numDispLines = height > 0;
+
+	pixelInfo->dispLineInfo = NULL;
+	pixelInfo->height = height;
+	pixelInfo->epoch = 0;
+	pixelInfoChange->pixels -= height;
+	pixelInfoChange->numDispLines -= numDispLines;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextTestTag --
+ *
+ *	Return whether the segment at specified position is tagged with
+ *	specified tag.
+ *
+ * Results:
+ *	Returns whether this text is tagged with specified tag.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextTestTag(
+    const TkTextIndex *indexPtr,/* The character in the text for which display information is wanted. */
+    const TkTextTag *tagPtr)	/* Test for this tag. */
+{
+    assert(tagPtr);
+    return TkTextTagSetTest(TkTextIndexGetContentSegment(indexPtr, NULL)->tagInfoPtr, tagPtr->index);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIsElided --
+ *
+ *	Special case to just return information about elided attribute.
+ *	Just need to keep track of invisibility settings for each priority,
+ *	pick highest one active at end.
+ *
+ * Results:
+ *	Returns whether this text should be elided or not.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+TestIfElided(
+    const TkTextTag *tagPtr)
+{
+    int highestPriority = -1;
+    bool elide = false;
+
+    for ( ; tagPtr; tagPtr = tagPtr->nextPtr) {
+	if (tagPtr->elideString && tagPtr->priority > highestPriority) {
+	    elide = tagPtr->elide;
+	    highestPriority = tagPtr->priority;
+	}
+    }
+
+    return elide;
+}
+
+bool
+TkTextIsElided(
+    const TkTextIndex *indexPtr)/* The character in the text for which display information is wanted. */
+{
+    return TkBTreeGetRoot(indexPtr->tree)->numBranches > 0 && TestIfElided(TkBTreeGetTags(indexPtr));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * SegmentIsElided --
+ *
+ *	Return information about elided attribute of this segment.
+ *
+ * Results:
+ *	Returns whether this component should be elided or not.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+SegmentIsElided(
+    const TkSharedText *sharedTextPtr,
+    const TkTextSegment *segPtr,
+    const TkText *textPtr)		/* can be NULL */
+{
+    assert(segPtr->tagInfoPtr);
+
+    return TkTextTagSetIntersectsBits(segPtr->tagInfoPtr, sharedTextPtr->elisionTags)
+	    && TestIfElided(TkBTreeGetSegmentTags(sharedTextPtr, segPtr, textPtr));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextSegmentIsElided --
+ *
+ *	Return information about elided attribute of this segment.
+ *
+ * Results:
+ *	Returns whether this component should be elided or not.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextSegmentIsElided(
+    const TkText *textPtr,
+    const TkTextSegment *segPtr)
+{
+    TkSharedText *sharedTextPtr;
+
+    assert(segPtr->tagInfoPtr);
+    assert(textPtr);
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+    return TkBTreeHaveElidedSegments(sharedTextPtr) && SegmentIsElided(sharedTextPtr, segPtr, textPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * InsertNewLine --
+ *
+ *	This function makes a new line, and inserts the given segment as
+ *	the first segment in new line. All the required actions to fulfill
+ *	the consistency of the B-Tree will be done. But this function is
+ *	not rebalancing the B-Tree, nor is it changing the pixel count of
+ *	the peers.
+ *
+ * Results:
+ *	The return value is the new line.
+ *
+ * Side effects:
+ *	All the required changes to fulfill the consistency of the
+ *	B-Tree, except rebalancing.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+HasElidedNewline(
+    const TkSharedText *sharedTextPtr,
+    const TkTextLine *linePtr)
+{
+    return TkBTreeHaveElidedSegments(sharedTextPtr)
+	    && SegmentIsElided(sharedTextPtr, linePtr->lastPtr, NULL);
+}
+
+static TkTextLine *
+InsertNewLine(
+    TkSharedText *sharedTextPtr,/* Handle to shared text resource. */
+    Node *nodePtr,		/* The node which will contain the new line. */
+    TkTextLine *prevLinePtr,	/* Predecessor of the new line, can be NULL. */
+    TkTextSegment *segPtr)	/* First segment of this line. */
+{
+    TkTextLine *newLinePtr;
+    TkTextSegment *prevPtr;
+    TkTextSegment *lastPtr = segPtr;
+
+    assert(segPtr);
+    assert(nodePtr);
+    assert(segPtr->sectionPtr || !segPtr->prevPtr);
+    assert(!segPtr->prevPtr || segPtr->prevPtr->sectionPtr->linePtr == prevLinePtr);
+    assert(!segPtr->prevPtr || prevLinePtr);
+    assert(!prevLinePtr || prevLinePtr->parentPtr == nodePtr);
+
+    prevPtr = segPtr->prevPtr;
+
+    if (prevPtr) {
+	prevPtr->nextPtr = NULL;
+	lastPtr = prevLinePtr->lastPtr;
+	prevLinePtr->lastPtr = prevPtr;
+	segPtr->prevPtr = NULL;
+    }
+
+    newLinePtr = memset(malloc(sizeof(TkTextLine)), 0, sizeof(TkTextLine));
+    newLinePtr->parentPtr = nodePtr;
+    newLinePtr->prevPtr = prevLinePtr;
+    newLinePtr->segPtr = segPtr;
+    newLinePtr->lastPtr = lastPtr;
+    newLinePtr->logicalLine = true;
+    newLinePtr->changed = true;
+    DEBUG_ALLOC(tkTextCountNewLine++);
+
+    TkTextTagSetIncrRefCount(newLinePtr->tagonPtr = sharedTextPtr->emptyTagInfoPtr);
+    TkTextTagSetIncrRefCount(newLinePtr->tagoffPtr = sharedTextPtr->emptyTagInfoPtr);
+
+    if (prevLinePtr) {
+	newLinePtr->logicalLine = !HasElidedNewline(sharedTextPtr, prevLinePtr);
+	if ((newLinePtr->nextPtr = prevLinePtr->nextPtr)) {
+	    newLinePtr->nextPtr->prevPtr = newLinePtr;
+	}
+	prevLinePtr->nextPtr = newLinePtr;
+    }
+
+    if (segPtr->sectionPtr) {
+	if (prevPtr && prevPtr->sectionPtr == segPtr->sectionPtr) {
+	    if ((segPtr->sectionPtr = segPtr->sectionPtr->nextPtr)) {
+		segPtr->sectionPtr->prevPtr = NULL;
+	    }
+	    prevPtr->sectionPtr->nextPtr = NULL;
+	} else {
+	    if (segPtr->sectionPtr->prevPtr) {
+		segPtr->sectionPtr->prevPtr->nextPtr = NULL;
+	    }
+	    segPtr->sectionPtr->prevPtr = NULL;
+	}
+    }
+
+    RebuildSections(sharedTextPtr, newLinePtr, false);
+
+    if (newLinePtr->numBranches > 0 || newLinePtr->numLinks > 0) {
+	assert(prevLinePtr);
+	assert(prevLinePtr->numBranches >= newLinePtr->numBranches);
+	assert(prevLinePtr->numLinks >= newLinePtr->numLinks);
+	prevLinePtr->numBranches -= newLinePtr->numBranches;
+	prevLinePtr->numLinks -= newLinePtr->numLinks;
+    }
+
+    if (prevPtr) {
+	prevPtr->sectionPtr->size = ComputeSectionSize(prevPtr->sectionPtr->segPtr);
+	prevPtr->sectionPtr->length = CountSegments(prevPtr->sectionPtr);
+	assert(prevPtr->sectionPtr->length == CountSegments(prevPtr->sectionPtr)); /* checks overflow */
+	prevPtr->sectionPtr->linePtr->size -= newLinePtr->size;
+    }
+
+    if (nodePtr->lastPtr == prevLinePtr) {
+	SetNodeLastPointer(nodePtr, newLinePtr);
+    }
+
+    assert(!prevLinePtr || CheckSections(prevLinePtr));
+    return newLinePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * MakeTagInfo --
+ *
+ *	Find the associated tag information of the adjacent segment
+ *	depending on the current tagging mode. This function is
+ *	incrementing the reference count of the returned tag information
+ *	set.
+ *
+ * Results:
+ *	The associated tag information.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextTagSet *
+GetPrevLineTagSet(
+    TkText *textPtr,
+    TkTextSegment *segPtr)
+{
+    TkTextLine *linePtr = segPtr->sectionPtr->linePtr->prevPtr;
+
+    if (!linePtr) {
+	return textPtr->sharedTextPtr->emptyTagInfoPtr;
+    }
+
+    /*
+     * Didn't find any tag information in this line, so try the last segment of the
+     * previous line, this segment must have a tag information.
+     */
+
+    segPtr = linePtr->lastPtr;
+    assert(segPtr->tagInfoPtr);
+    return segPtr->tagInfoPtr;
+}
+
+static TkTextTagSet *
+MakeTagInfo(
+    TkText *textPtr,
+    TkTextSegment *segPtr)	/* The first inserted text segment. */
+{
+    TkTextTagSet *tagInfoPtr = textPtr->sharedTextPtr->emptyTagInfoPtr;
+
+    assert(segPtr);
+    assert(textPtr);
+    assert(textPtr->insertMarkPtr);
+
+    switch (textPtr->tagging) {
+    case TK_TEXT_TAGGING_WITHIN: {
+	/*
+	 * This is the traditional tagging mode. Search for the tags on both sides
+	 * of the inserted text.
+	 */
+
+	TkTextSegment *segPtr2;
+	TkTextTagSet *tagInfoPtr2 = NULL;
+
+	for (segPtr2 = segPtr->nextPtr; !segPtr2->tagInfoPtr; segPtr2 = segPtr2->nextPtr) {
+	    assert(segPtr2);
+	}
+	TkTextTagSetIncrRefCount(tagInfoPtr = segPtr2->tagInfoPtr);
+	segPtr2 = segPtr;
+	while (!tagInfoPtr2) {
+	    segPtr2 = segPtr2->prevPtr;
+	    if (!segPtr2) {
+		tagInfoPtr2 = GetPrevLineTagSet(textPtr, segPtr);
+	    } else if (segPtr2->tagInfoPtr) {
+		tagInfoPtr2 = segPtr2->tagInfoPtr;
+	    }
+	}
+	return TagSetIntersect(tagInfoPtr, tagInfoPtr2, textPtr->sharedTextPtr);
+    }
+    case TK_TEXT_TAGGING_GRAVITY:
+	/*
+	 * Search for a adjcacent content segment which will provide the appropriate tag
+	 * information, the direction of the search depends on the gravity of the "insert"
+	 * mark. If we cannot find a segment, then the tag information will be empty.
+	 */
+
+	if (textPtr->insertMarkPtr->typePtr == &tkTextLeftMarkType) {
+	    if ((segPtr = segPtr->nextPtr)) {
+		while (segPtr->typePtr->gravity != GRAVITY_LEFT || segPtr->typePtr == &tkTextLinkType) {
+		    if (segPtr->tagInfoPtr) {
+			if (segPtr->typePtr == &tkTextCharType) {
+			    tagInfoPtr = segPtr->tagInfoPtr;
+			}
+			TkTextTagSetIncrRefCount(tagInfoPtr);
+			return tagInfoPtr;
+		    }
+		    segPtr = segPtr->nextPtr;
+		    assert(segPtr);
+		}
+	    }
+	} else {
+	    if (!segPtr->prevPtr) {
+		TkTextTagSetIncrRefCount(tagInfoPtr = GetPrevLineTagSet(textPtr, segPtr));
+		return tagInfoPtr;
+	    }
+	    while (segPtr->typePtr->gravity != GRAVITY_RIGHT || segPtr->typePtr == &tkTextBranchType) {
+		if (segPtr->tagInfoPtr) {
+		    if (segPtr->typePtr == &tkTextCharType) {
+			tagInfoPtr = segPtr->tagInfoPtr;
+		    }
+		    TkTextTagSetIncrRefCount(tagInfoPtr);
+		    return tagInfoPtr;
+		}
+		if (!segPtr->prevPtr) {
+		    TkTextTagSetIncrRefCount(tagInfoPtr = GetPrevLineTagSet(textPtr, segPtr));
+		    return tagInfoPtr;
+		}
+		segPtr = segPtr->prevPtr;
+	    }
+	}
+	break;
+    case TK_TEXT_TAGGING_NONE:
+    	/*
+	 * The new text will not be tagged.
+	 */
+	break;
+    }
+
+    return tagInfoPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeLoad --
+ *
+ *	Load the given content into the widget. The content must be the
+ *	result of the "inspect" command.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	The B-Tree structure will change, and some segments will be
+ *	added.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+LoadError(
+    Tcl_Interp *interp,		/* Current interpreter. */
+    const char *msg,		/* Error message, can be NULL. */
+    int index0,			/* List index at level 0. */
+    int index1,			/* List index at level 1, is -1 if undefined. */
+    int index2,			/* List index at level 2, is -1 if undefined. */
+    TkTextTagSet *tagInfoPtr)	/* Decrement reference count if not NULL. */
+{
+    char buf[100] = { '\0' };
+    Tcl_Obj *errObjPtr = NULL;
+
+    if (!msg) {
+	Tcl_IncrRefCount(errObjPtr = Tcl_GetObjResult(interp));
+	msg = Tcl_GetString(errObjPtr);
+    }
+    if (tagInfoPtr) {
+	TkTextTagSetDecrRefCount(tagInfoPtr);
+    }
+    if (index0 >= 0) {
+	if (index1 >= 0) {
+	    if (index2 >= 0) {
+		snprintf(buf, sizeof(buf), " (at index %d %d %d)", index0, index1, index2);
+	    } else {
+		snprintf(buf, sizeof(buf), " (at index %d %d)", index0, index1);
+	    }
+	} else {
+	    snprintf(buf, sizeof(buf), " (at index %d)", index0);
+	}
+    }
+    Tcl_SetObjResult(interp, Tcl_ObjPrintf("error while loading%s: %s", buf, msg));
+    Tcl_SetErrorCode(interp, "TK", "TEXT", "LOAD", NULL);
+    if (errObjPtr) {
+	Tcl_DecrRefCount(errObjPtr);
+    }
+    return TCL_ERROR;
+}
+
+static bool
+LoadMakeTagInfo(
+    TkText *textPtr,
+    TkTextTagSet **tagInfoPtr,
+    Tcl_Obj *obj)
+{
+    int objc, i;
+    Tcl_Obj **objv;
+
+    if (Tcl_ListObjGetElements(textPtr->interp, obj, &objc, &objv) != TCL_OK) {
+	return false;
+    }
+    if (!*tagInfoPtr) {
+	TkTextTagSetIncrRefCount(*tagInfoPtr = textPtr->sharedTextPtr->emptyTagInfoPtr);
+    }
+    for (i = 0; i < objc; ++i) {
+	*tagInfoPtr = TagSetAdd(*tagInfoPtr, TkTextCreateTag(textPtr, Tcl_GetString(objv[i]), NULL));
+    }
+    return true;
+}
+
+static bool
+LoadRemoveTags(
+    TkText *textPtr,
+    TkTextTagSet **tagInfoPtr,
+    Tcl_Obj *obj)
+{
+    int objc, i;
+    Tcl_Obj **objv;
+
+    assert(*tagInfoPtr);
+
+    if (Tcl_ListObjGetElements(textPtr->interp, obj, &objc, &objv) != TCL_OK) {
+	return false;
+    }
+    for (i = 0; i < objc; ++i) {
+	*tagInfoPtr = TagSetErase(*tagInfoPtr, TkTextCreateTag(textPtr, Tcl_GetString(objv[i]), NULL));
+    }
+    return true;
+}
+
+static TkTextSegment *
+LoadPerformElision(
+    TkText *textPtr,
+    TkTextSegment *segPtr,	/* newly inserted segment */
+    TkTextSegment **branchPtr,	/* last inserted branch segment */
+    TkTextSegment *contentPtr,	/* last char/hyphen/image/window segment in current line */
+    bool *isElided)		/* elided state of last inserted segment */
+{
+    TkTextSegment *nextPtr = segPtr; /* next segment to insert into line */
+    bool elide = SegmentIsElided(textPtr->sharedTextPtr, segPtr, textPtr);
+
+    if (elide != *isElided) {
+	TkTextSegment *linkPtr;
+
+	if (elide) {
+	    nextPtr = *branchPtr = MakeBranch();
+	    (*branchPtr)->nextPtr = segPtr;
+	    segPtr->prevPtr = *branchPtr;
+	} else {
+	    assert(*branchPtr);
+	    linkPtr = MakeLink();
+	    linkPtr->body.link.prevPtr = *branchPtr;
+	    (*branchPtr)->body.branch.nextPtr = linkPtr;
+	    if (contentPtr) {
+		linkPtr->nextPtr = contentPtr->nextPtr;
+		linkPtr->prevPtr = contentPtr;
+		contentPtr->nextPtr = linkPtr;
+	    } else {
+		linkPtr->nextPtr = segPtr;
+		segPtr->prevPtr = linkPtr;
+		nextPtr = linkPtr;
+	    }
+	}
+
+	*isElided = elide;
+    }
+
+    return nextPtr;
+}
+
+int
+TkBTreeLoad(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Obj *content)		/* New content of this text widget. */
+{
+    enum {
+	STATE_START        = 1 << 0,
+	STATE_SETUP        = 1 << 1,
+	STATE_CONFIG       = 1 << 2,
+	STATE_LEFT         = 1 << 3,
+	STATE_RIGHT        = 1 << 4,
+	STATE_LEFT_INSERT  = 1 << 5,
+	STATE_RIGHT_INSERT = 1 << 6,
+	STATE_TEXT         = 1 << 7,
+	STATE_BREAK        = 1 << 8
+    };
+
+    Tcl_Obj **objv;
+    int objc, i;
+    int byteLength;
+    TkTextTagSet *tagInfoPtr;
+    TkSharedText *sharedTextPtr;
+    TkTextSegment *segPtr;
+    TkTextSegment *charSegPtr;
+    TkTextSegment *nextSegPtr;
+    TkTextSegment *branchPtr;
+    TkTextSegment *hyphPtr;
+    TkTextSegment *embPtr;
+    TkTextSegment *contentPtr;
+    TkTextLine *linePtr;
+    TkTextLine *newLinePtr;
+    TkTextLine *startLinePtr;
+    BTree *treePtr;
+    NodePixelInfo *changeToPixelInfo;
+    Tcl_Interp *interp = textPtr->interp;
+    TkTextState textState;
+    const char *name;
+    const char *s;
+    unsigned tagInfoCount;
+    unsigned state;
+    int changeToLineCount;
+    int changeToLogicalLineCount;
+    int changeToBranchCount;
+    int size;
+    bool isElided;
+    bool isInsert;
+
+    if (Tcl_ListObjGetElements(interp, content, &objc, &objv) != TCL_OK) {
+	return LoadError(interp, "list of items expected", -1, -1, -1, NULL);
+    }
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+    treePtr = (BTree *) sharedTextPtr->tree;
+    linePtr = startLinePtr = treePtr->rootPtr->linePtr;
+    segPtr = linePtr->segPtr;
+    contentPtr = NULL;
+    branchPtr = NULL;
+    hyphPtr = NULL;
+    tagInfoPtr = NULL;
+    changeToLineCount = 0;
+    changeToLogicalLineCount = 0;
+    changeToBranchCount = 0;
+    tagInfoCount = 0;
+    textState = textPtr->state;
+    textPtr->state = TK_TEXT_STATE_NORMAL;
+    isElided = false;
+    state = STATE_START;
+    size = 0;
+
+    assert(segPtr->typePtr != &tkTextCharType);
+
+    changeToPixelInfo = treePtr->pixelInfoBuffer;
+    memset(changeToPixelInfo, 0, sizeof(changeToPixelInfo[0])*treePtr->numPixelReferences);
+
+    while (segPtr->nextPtr->typePtr != &tkTextCharType) {
+	segPtr = segPtr->nextPtr;
+    }
+    charSegPtr = NULL;
+
+    for (i = 0; i < objc; ++i) {
+	const char *type;
+	Tcl_Obj **argv;
+	int argc;
+
+	if (Tcl_ListObjGetElements(interp, objv[i], &argc, &argv) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	if (argc == 0) {
+	    return LoadError(interp, "empty item", i, 0, -1, tagInfoPtr);
+	}
+
+	type = Tcl_GetString(argv[0]);
+
+	switch (type[0]) {
+	case 's': {
+	    /*
+	     * {"setup" pathname configuration}
+	     */
+
+	    Tcl_Obj **objv;
+	    int objc;
+
+	    if (strcmp(type, "setup") != 0) {
+		return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	    }
+	    if (state != STATE_START) {
+		return LoadError(interp, "unexpected \"setup\" item", i, -1, -1, tagInfoPtr);
+	    }
+	    if (argc != 3) {
+		return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+	    }
+	    if (Tcl_ListObjGetElements(interp, argv[2], &objc, &objv) != TCL_OK
+		    || TkConfigureText(interp, textPtr, objc, objv) != TCL_OK) {
+		return LoadError(interp, NULL, i, 2, -1, tagInfoPtr);
+	    }
+	    textState = textPtr->state;
+	    textPtr->state = TK_TEXT_STATE_READONLY;
+	    state = STATE_SETUP;
+	    break;
+	}
+	case 'b':
+	    switch (type[1]) {
+	    case 'r':
+		/*
+		 * {"break" taginfo ?taginfo?}
+		 */
+
+		if (strcmp(type, "break") != 0) {
+		    return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+		}
+		if (tagInfoCount == 0) {
+		    tagInfoCount = argc - 1;
+		}
+		if (argc < 2 || 3 < argc || argc - tagInfoCount != 1) {
+		    return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+		}
+		if (!LoadMakeTagInfo(textPtr, &tagInfoPtr, argv[1])) {
+		    return LoadError(interp, "list of tag names expected", i, 1, -1, tagInfoPtr);
+		}
+		if (charSegPtr && TkTextTagSetIsEqual(tagInfoPtr, charSegPtr->tagInfoPtr)) {
+		    charSegPtr = IncreaseCharSegment(charSegPtr, charSegPtr->size, 1);
+		    charSegPtr->body.chars[charSegPtr->size - 1] = '\n';
+		    linePtr->lastPtr = charSegPtr;
+		    RebuildSections(sharedTextPtr, linePtr, true);
+		} else {
+		    nextSegPtr = charSegPtr = MakeCharSeg(NULL, tagInfoPtr, 1, "\n", 1);
+		    if (sharedTextPtr->numElisionTags > 0) {
+			nextSegPtr = LoadPerformElision(textPtr, charSegPtr, &branchPtr, contentPtr,
+				&isElided);
+		    }
+		    if (segPtr) {
+			segPtr->nextPtr = nextSegPtr;
+			nextSegPtr->prevPtr = segPtr;
+			linePtr->lastPtr = charSegPtr;
+			RebuildSections(sharedTextPtr, linePtr, true);
+		    } else {
+			newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr,
+				linePtr, nextSegPtr);
+			AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+			linePtr = newLinePtr;
+		    }
+		}
+		changeToLineCount += 1;
+		if (!isElided) {
+		    changeToLogicalLineCount += 1;
+		}
+		size += 1;
+		contentPtr = charSegPtr;
+		segPtr = charSegPtr = NULL;
+		state = STATE_BREAK;
+		RecomputeLineTagInfo(linePtr, NULL, sharedTextPtr);
+		if (argc != 3) {
+		    TkTextTagSetDecrRefCount(tagInfoPtr);
+		    tagInfoPtr = NULL;
+		} else if (!LoadRemoveTags(textPtr, &tagInfoPtr, argv[2])) {
+		    return LoadError(interp, "list of tag names expected", i, 2, -1, tagInfoPtr);
+		}
+		break;
+	    case 'i': {
+		TkTextTag *tagPtr;
+
+		/*
+		 * {"bind" tagname event script}
+		 */
+
+		if (strcmp(type, "bind") != 0) {
+		    return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+		}
+		if (argc != 4) {
+		    return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+		}
+		tagPtr = TkTextCreateTag(textPtr, Tcl_GetString(argv[1]), NULL);
+		if (TkTextBindEvent(interp, argc - 2, argv + 2, textPtr->sharedTextPtr,
+			&sharedTextPtr->tagBindingTable, tagPtr->name) != TCL_OK) {
+		    return LoadError(interp, NULL, i, 2, -1, tagInfoPtr);
+		}
+		state = STATE_TEXT;
+		break;
+	    }
+	    }
+	    break;
+	case 'c': {
+	    /*
+	     * {"configure" tagname ?configuration?}
+	     */
+
+	    Tcl_Obj **objv;
+	    int objc;
+
+	    if (strcmp(type, "configure") != 0) {
+		return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	    }
+	    if (!(state & (STATE_START|STATE_SETUP|STATE_CONFIG))) {
+		return LoadError(interp, "unexpected \"configure\" item", i, -1, -1, tagInfoPtr);
+	    }
+	    if (argc == 2) {
+		TkTextCreateTag(textPtr, Tcl_GetString(argv[1]), NULL);
+	    } else if (argc != 3) {
+		return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+	    } else if (Tcl_ListObjGetElements(interp, argv[2], &objc, &objv) != TCL_OK
+		    && TkConfigureTag(interp, textPtr, Tcl_GetString(argv[1]), objc, objv) != TCL_OK) {
+		return LoadError(interp, NULL, i, 2, -1, tagInfoPtr);
+	    }
+	    state = STATE_CONFIG;
+	    break;
+	}
+	case 't':
+	    /*
+	     * {"text" content taginfo ?taginfo?}
+	     */
+
+	    if (strcmp(type, "text") != 0) {
+		return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	    }
+	    if (tagInfoCount == 0) {
+		tagInfoCount = argc - 2;
+	    }
+	    if (argc < 3 || 4 < argc || argc - tagInfoCount != 2) {
+		return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+	    }
+	    if (!LoadMakeTagInfo(textPtr, &tagInfoPtr, argv[2])) {
+		return LoadError(interp, "list of tag names expected", i, 2, -1, tagInfoPtr);
+	    }
+	    for (s = Tcl_GetString(argv[1]); *s; ++s) {
+		switch (UCHAR(*s)) {
+		case 0x0a:
+		    return LoadError(interp, "newline not allowed in text content",
+			    i, 1, -1, tagInfoPtr);
+		case 0xc2:
+		    if (UCHAR(s[1]) == 0xad) {
+			return LoadError(interp, "soft hyphen (U+002D) not allowed in text content",
+				i, 1, -1, tagInfoPtr);
+		    }
+		    break;
+		}
+	    }
+	    byteLength = GetByteLength(argv[1]);
+	    if (charSegPtr && TkTextTagSetIsEqual(tagInfoPtr, charSegPtr->tagInfoPtr)) {
+		int size = charSegPtr->size;
+		charSegPtr = IncreaseCharSegment(charSegPtr, size, byteLength);
+		memcpy(charSegPtr->body.chars + size, Tcl_GetString(argv[1]), byteLength);
+	    } else {
+		nextSegPtr = charSegPtr = MakeCharSeg(NULL, tagInfoPtr,
+			byteLength, Tcl_GetString(argv[1]), byteLength);
+		if (sharedTextPtr->numElisionTags > 0) {
+		    nextSegPtr = LoadPerformElision(textPtr, charSegPtr, &branchPtr, contentPtr,
+			    &isElided);
+		}
+		if (segPtr) {
+		    segPtr->nextPtr = nextSegPtr;
+		    nextSegPtr->prevPtr = segPtr;
+		} else {
+		    newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr, linePtr, nextSegPtr);
+		    AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+		    linePtr = newLinePtr;
+		}
+	    }
+	    size += byteLength;
+	    contentPtr = segPtr = charSegPtr;
+	    state = STATE_TEXT;
+	    if (argc != 4) {
+		TkTextTagSetDecrRefCount(tagInfoPtr);
+		tagInfoPtr = NULL;
+	    } else if (!LoadRemoveTags(textPtr, &tagInfoPtr, argv[3])) {
+		return LoadError(interp, "list of tag names expected", i, 3, -1, tagInfoPtr);
+	    }
+	    break;
+	case 'h':
+	    /*
+	     * {"hyphen" taginfo ?taginfo?}
+	     */
+
+	    if (strcmp(type, "hyphen") != 0) {
+		return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	    }
+	    if (tagInfoCount == 0) {
+		tagInfoCount = argc - 1;
+	    }
+	    if (argc < 2 || 3 < argc || argc - tagInfoCount != 1) {
+		return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+	    }
+	    if (!LoadMakeTagInfo(textPtr, &tagInfoPtr, argv[1])) {
+		return LoadError(interp, "list of tag names expected", i, 1, -1, tagInfoPtr);
+	    }
+	    nextSegPtr = hyphPtr = MakeHyphen();
+	    TkTextTagSetIncrRefCount(hyphPtr->tagInfoPtr = tagInfoPtr);
+	    if (sharedTextPtr->numElisionTags > 0) {
+		nextSegPtr = LoadPerformElision(textPtr, charSegPtr, &branchPtr, contentPtr, &isElided);
+	    }
+	    if (segPtr) {
+		segPtr->nextPtr = nextSegPtr;
+		nextSegPtr->prevPtr = segPtr;
+	    } else {
+		newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr, linePtr, nextSegPtr);
+		AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+		linePtr = newLinePtr;
+	    }
+	    size += 1;
+	    contentPtr = segPtr = hyphPtr;
+	    state = STATE_TEXT;
+	    if (argc != 3) {
+		TkTextTagSetDecrRefCount(tagInfoPtr);
+		tagInfoPtr = NULL;
+	    } else if (!LoadRemoveTags(textPtr, &tagInfoPtr, argv[2])) {
+		return LoadError(interp, "list of tag names expected", i, 2, -1, tagInfoPtr);
+	    }
+	    break;
+	case 'l':
+	    /*
+	     * {"left" markname}
+	     */
+
+	    if (strcmp(type, "left") != 0) {
+		return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	    }
+	    name = Tcl_GetString(argv[1]);
+	    isInsert = (strcmp(name, "insert") == 0);
+	    if (sharedTextPtr->steadyMarks
+		    ? state == STATE_RIGHT_INSERT || (isInsert && state == STATE_LEFT)
+		    : state == STATE_RIGHT) {
+		return LoadError(interp, "unexpected \"left\" item", i, -1, -1, tagInfoPtr);
+	    }
+	    if (argc != 2) {
+		return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+	    }
+	    if (isInsert) {
+		UnlinkSegment(nextSegPtr = textPtr->insertMarkPtr);
+	    } else if (!(nextSegPtr = TkTextMakeNewMark(textPtr, name))) {
+		return LoadError(interp, "mark already exists", i, 1, -1, tagInfoPtr);
+	    }
+	    nextSegPtr->typePtr = &tkTextLeftMarkType;
+	    if (segPtr) {
+		segPtr->nextPtr = nextSegPtr;
+		nextSegPtr->prevPtr = segPtr;
+	    } else {
+		newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr, linePtr, nextSegPtr);
+		AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+		linePtr = newLinePtr;
+	    }
+	    segPtr = nextSegPtr;
+	    contentPtr = NULL;
+	    state = isInsert ? STATE_LEFT_INSERT : STATE_LEFT;
+	    break;
+	case 'r':
+	    /*
+	     * {"right" markname}
+	     */
+
+	    if (strcmp(type, "right") != 0) {
+		return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	    }
+	    if (argc != 2) {
+		return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+	    }
+	    name = Tcl_GetString(argv[1]);
+	    isInsert = (strcmp(name, "insert") == 0);
+	    if (isInsert
+		    && sharedTextPtr->steadyMarks
+		    && (state & (STATE_LEFT|STATE_RIGHT))) {
+		return LoadError(interp, "unexpected \"insert\" mark", i, -1, -1, tagInfoPtr);
+	    }
+	    if (isInsert) {
+		UnlinkSegment(nextSegPtr = textPtr->insertMarkPtr);
+	    } else if (!(nextSegPtr = TkTextMakeNewMark(textPtr, name))) {
+		return LoadError(interp, "mark already exists", i, 1, -1, tagInfoPtr);
+	    }
+	    assert(nextSegPtr->typePtr == &tkTextRightMarkType);
+	    if (segPtr) {
+		segPtr->nextPtr = nextSegPtr;
+		nextSegPtr->prevPtr = segPtr;
+	    } else {
+		newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr, linePtr, nextSegPtr);
+		AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+		linePtr = newLinePtr;
+	    }
+	    segPtr = nextSegPtr;
+	    contentPtr = NULL;
+	    state = isInsert ? STATE_RIGHT_INSERT : STATE_RIGHT;
+	    break;
+	case 'e':
+	    /*
+	     * {"elide" "on"}, {"elide" "off"}
+	     * These elements will be skipped, nevertheless we check the syntax.
+	     */
+
+	    if (strcmp(type, "elide") != 0) {
+		return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	    }
+	    if (argc != 2) {
+		return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+	    }
+	    if (strcmp(Tcl_GetString(argv[1]), "on") != 0
+		    && strcmp(Tcl_GetString(argv[1]), "off") != 0) {
+		return LoadError(interp, "\"on\" or \"off\" expected", i, 0, -1, tagInfoPtr);
+	    }
+	    state = STATE_TEXT;
+	    break;
+	case 'i':
+	    /*
+	     * {"image" options tagInfo ?tagInfo?}
+	     */
+
+	    if (strcmp(type, "image") != 0) {
+		return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	    }
+	    if (tagInfoCount == 0) {
+		tagInfoCount = argc - 2;
+	    }
+	    if (argc < 3 || 4 < argc || argc - tagInfoCount != 2) {
+		return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+	    }
+	    if (!(embPtr = TkTextMakeImage(textPtr, argv[1]))) {
+		return LoadError(interp, Tcl_GetString(Tcl_GetObjResult(interp)), i, 1, -1, tagInfoPtr);
+	    }
+	    if (!LoadMakeTagInfo(textPtr, &tagInfoPtr, argv[2])) {
+		return LoadError(interp, "list of tag names expected", i, 2, -1, tagInfoPtr);
+	    }
+	    TkTextTagSetIncrRefCount((nextSegPtr = embPtr)->tagInfoPtr = tagInfoPtr);
+	    if (sharedTextPtr->numElisionTags > 0) {
+		nextSegPtr = LoadPerformElision(textPtr, embPtr, &branchPtr, contentPtr, &isElided);
+	    }
+	    if (segPtr) {
+		segPtr->nextPtr = nextSegPtr;
+		nextSegPtr->prevPtr = segPtr;
+	    } else {
+		newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr, linePtr, nextSegPtr);
+		AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+		linePtr = newLinePtr;
+	    }
+	    size += 1;
+	    contentPtr = segPtr = embPtr;
+	    state = STATE_TEXT;
+	    if (argc != 4) {
+		TkTextTagSetDecrRefCount(tagInfoPtr);
+		tagInfoPtr = NULL;
+	    } else if (!LoadRemoveTags(textPtr, &tagInfoPtr, argv[3])) {
+		return LoadError(interp, "list of tag names expected", i, 3, -1, tagInfoPtr);
+	    }
+	    break;
+	case 'w':
+	    /*
+	     * {"window" options tagInfo ?tagInfo?}
+	     */
+
+	    if (strcmp(type, "window") != 0) {
+		return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	    }
+	    if (tagInfoCount == 0) {
+		tagInfoCount = argc - 2;
+	    }
+	    if (argc < 3 || 4 < argc || argc - tagInfoCount != 2) {
+		return LoadError(interp, "wrong number of items", i, -1, -1, tagInfoPtr);
+	    }
+	    if (!(embPtr = TkTextMakeImage(textPtr, argv[1]))) {
+		return LoadError(interp, Tcl_GetString(Tcl_GetObjResult(interp)), i, 1, -1, tagInfoPtr);
+	    }
+	    if (!LoadMakeTagInfo(textPtr, &tagInfoPtr, argv[2])) {
+		return LoadError(interp, "list of tag names expected", i, 2, -1, tagInfoPtr);
+	    }
+	    TkTextTagSetIncrRefCount((nextSegPtr = embPtr)->tagInfoPtr = tagInfoPtr);
+	    if (sharedTextPtr->numElisionTags > 0) {
+		nextSegPtr = LoadPerformElision(textPtr, embPtr, &branchPtr, contentPtr, &isElided);
+	    }
+	    if (segPtr) {
+		segPtr->nextPtr = nextSegPtr;
+		nextSegPtr->prevPtr = segPtr;
+	    } else {
+		newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr, linePtr, nextSegPtr);
+		AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+		linePtr = newLinePtr;
+	    }
+	    size += 1;
+	    contentPtr = segPtr = embPtr;
+	    state = STATE_TEXT;
+	    if (argc != 4) {
+		TkTextTagSetDecrRefCount(tagInfoPtr);
+		tagInfoPtr = NULL;
+	    } else if (!LoadRemoveTags(textPtr, &tagInfoPtr, argv[3])) {
+		return LoadError(interp, "list of tag names expected", i, 3, -1, tagInfoPtr);
+	    }
+	    break;
+	default:
+	    return LoadError(interp, "invalid item identifier", i, 0, -1, tagInfoPtr);
+	}
+    }
+
+    /*
+     * Possible we have to add last newline.
+     */
+
+    if (state != STATE_BREAK) {
+	if (charSegPtr && TkTextTagSetIsEmpty(charSegPtr->tagInfoPtr)) {
+	    charSegPtr = IncreaseCharSegment(charSegPtr, charSegPtr->size, 1);
+	    charSegPtr->body.chars[charSegPtr->size - 1] = '\n';
+	    linePtr->lastPtr = charSegPtr;
+	    RebuildSections(sharedTextPtr, linePtr, true);
+	} else {
+	    nextSegPtr = charSegPtr = MakeCharSeg(NULL, sharedTextPtr->emptyTagInfoPtr, 1, "\n", 1);
+	    if (segPtr) {
+		segPtr->nextPtr = nextSegPtr;
+		nextSegPtr->prevPtr = segPtr;
+		linePtr->lastPtr = charSegPtr;
+		RebuildSections(sharedTextPtr, linePtr, true);
+	    } else {
+		newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr,
+			linePtr, nextSegPtr);
+		AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+		linePtr = newLinePtr;
+	    }
+	}
+	size += 1;
+	RecomputeLineTagInfo(linePtr, NULL, sharedTextPtr);
+    } else {
+	changeToLineCount -= 1;
+	if (!isElided) {
+	    changeToLogicalLineCount -= 1;
+	}
+    }
+
+    textPtr->state = textState;
+
+    if (tagInfoPtr) {
+	TkTextTagSetDecrRefCount(tagInfoPtr);
+    }
+
+    SubtractPixelCount2(treePtr, startLinePtr->parentPtr, -changeToLineCount,
+	    -changeToLogicalLineCount, -changeToBranchCount, -size, changeToPixelInfo);
+    startLinePtr->parentPtr->numChildren += changeToLineCount;
+    UpdateNodeTags(sharedTextPtr, startLinePtr->parentPtr);
+
+    if (startLinePtr->parentPtr->numChildren > MAX_CHILDREN) {
+	Rebalance(treePtr, startLinePtr->parentPtr);
+    }
+
+    TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeInsertChars --
+ *
+ *	Insert characters at a given position in a B-tree.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Characters are added to the B-tree at the given position. If the
+ *	string contains newlines, new lines will be added, which could cause
+ *	the structure of the B-tree to change.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeInsertChars(
+    TkTextBTree tree,		/* Tree to insert into. */
+    TkTextIndex *indexPtr,	/* Indicates where to insert text. When the function returns,
+    				 * this index contains the new position. */
+    const char *string,		/* Pointer to bytes to insert (may contain newlines, must be
+    				 * null-terminated). */
+    TkTextTagSet *tagInfoPtr,	/* Tag information for the new segments, can be NULL. */
+    TkTextTag *hyphenTagPtr,	/* Tag information for hyphen segments, can be NULL. If not NULL
+    				 * this is a list of tags connected via 'nextPtr'. */
+    TkTextUndoInfo *undoInfo)	/* Undo information, can be NULL. */
+{
+    TkSharedText *sharedTextPtr;
+    TkTextSegment *prevPtr;	/* The segment just before the first new segment (NULL means new
+    				 * segment is at beginning of line). */
+    TkTextLine *linePtr;	/* Current line (new segments are added to this line). */
+    int changeToLineCount;	/* Counts change to total number of lines in file. */
+    int changeToLogicalLineCount;
+				/* Counts change to total number of logical lines in file. */
+    NodePixelInfo *changeToPixelInfo;
+    TkTextSegment *segPtr = NULL;
+    TkTextSegment *firstSegPtr;
+    TkTextSegment *lastSegPtr;
+    TkTextLine *newLinePtr;
+    TkTextLine *firstLinePtr;
+    TkTextTagSet *emptyTagInfoPtr;
+    TkTextTagSet *hyphenTagInfoPtr = NULL;
+    TkTextTagSet *myTagInfoPtr;
+    TkTextTag *tagPtr;
+    TkTextTag *hyphenElideTagPtr = NULL;
+    TkTextIndex index;
+    UndoTokenInsert *undoToken = NULL;
+    BTree *treePtr = (BTree *) tree;
+    bool split = true;
+    SplitInfo info;
+    unsigned chunkSize = 0; /* satisifies the compiler */
+    unsigned size = 0;
+    int hyphenRules = 0;
+
+    assert(*string); /* otherwise tag information might become erroneous */
+    assert(indexPtr->textPtr);
+
+    sharedTextPtr = treePtr->sharedTextPtr;
+
+    if (undoInfo) {
+	undoToken = malloc(sizeof(UndoTokenInsert));
+	undoToken->undoType = &undoTokenInsertType;
+	undoInfo->token = (TkTextUndoToken *) undoToken;
+	undoInfo->byteSize = 0;
+	MakeUndoIndex(sharedTextPtr, indexPtr, &undoToken->startIndex, GRAVITY_LEFT);
+	DEBUG_ALLOC(tkTextCountNewUndoToken++);
+    }
+
+    emptyTagInfoPtr = sharedTextPtr->emptyTagInfoPtr;
+    firstSegPtr = lastSegPtr = NULL;
+    prevPtr = NULL;
+    memset(&info, 0, sizeof(SplitInfo));
+    info.offset = -1;
+    info.tagInfoPtr = tagInfoPtr;
+    firstLinePtr = linePtr = TkTextIndexGetLine(indexPtr);
+    index = *indexPtr;
+    TkTextIndexGetByteIndex(indexPtr); /* we need byte offset */
+    changeToLineCount = 0;
+    changeToLogicalLineCount = 0;
+    changeToPixelInfo = treePtr->pixelInfoBuffer;
+    SetLineHasChanged(sharedTextPtr, linePtr);
+
+    if (tagInfoPtr && !TkTextTagSetContains(linePtr->parentPtr->tagonPtr, tagInfoPtr)) {
+	unsigned i;
+
+	/*
+	 * Update the tag information of the B-Tree. Because the content of
+	 * the node cannot be empty (it contains at least one newline char)
+	 * we have also to add all new tags, not yet used inside this node,
+	 * to the tagoff information.
+	 */
+
+	for (i = TkTextTagSetFindFirst(tagInfoPtr);
+		i != TK_TEXT_TAG_SET_NPOS;
+		i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	    if (!TkTextTagSetTest(linePtr->parentPtr->tagonPtr, i)) {
+		AddTagToNode(linePtr->parentPtr, sharedTextPtr->tagLookup[i], true);
+	    }
+	}
+    }
+
+    if (hyphenTagPtr) {
+	int highestPriority = -1;
+	TkText *textPtr = index.textPtr;
+
+	for (tagPtr = hyphenTagPtr; tagPtr; tagPtr = tagPtr->nextPtr) {
+	    if (!TkTextTagSetTest(linePtr->parentPtr->tagonPtr, tagPtr->index)) {
+		AddTagToNode(linePtr->parentPtr, tagPtr, true);
+	    }
+	    if (tagPtr->elideString
+		    && tagPtr->priority > highestPriority
+		    && (!tagPtr->textPtr || tagPtr->textPtr == textPtr)) {
+		highestPriority = (hyphenElideTagPtr = tagPtr)->priority;
+	    }
+	}
+    }
+
+    DEBUG(indexPtr->discardConsistencyCheck = true);
+
+    /*
+     * Chop the string up into lines and create a new segment for each line,
+     * plus a new line for the leftovers from the previous line.
+     */
+
+    while (*string) {
+	bool isNewline = false;
+	const char *strEnd = NULL;
+	const char *s;
+
+	for (s = string; !strEnd; ++s) {
+	    switch (UCHAR(*s)) {
+	    case 0x00:
+		/* nul */
+	    	strEnd = s;
+		break;
+	    case 0x0a:
+		/* line feed */
+		strEnd = s + 1;
+		isNewline = true;
+		break;
+	    case 0xc2:
+		if (UCHAR(s[1]) == 0xad) {
+		    /* soft hyphen (U+002D) */
+		    strEnd = s;
+		    hyphenRules = 0;
+		}
+	    	break;
+	    case 0xff:
+	    	/*
+		 * Hyphen support (0xff is not allowed in UTF-8 strings, it's a private flag
+		 * denoting a soft hyphen, see ParseHyphens [tkText.c]).
+		 */
+
+		strEnd = s;
+
+		switch (*++s) {
+		case '-': hyphenRules = 0; break;
+		case '+': hyphenRules = TK_TEXT_HYPHEN_MASK; break;
+		default:  hyphenRules = UCHAR(*s); break;
+		}
+		break;
+	    }
+	}
+
+	chunkSize = strEnd - string;
+
+	if (chunkSize == 0) {
+	    TkTextTag *tagPtr;
+
+	    prevPtr = SplitSeg(indexPtr, NULL);
+	    segPtr = MakeHyphen();
+	    segPtr->body.hyphen.rules = hyphenRules;
+	    LinkSegment(linePtr, prevPtr, segPtr);
+	    SplitSection(segPtr->sectionPtr);
+	    TkBTreeIncrEpoch(tree);
+	    if (hyphenTagInfoPtr) {
+		assert(firstSegPtr);
+		TkTextTagSetIncrRefCount(segPtr->tagInfoPtr = hyphenTagInfoPtr);
+	    } else {
+		if (tagInfoPtr) {
+		    assert(tagInfoPtr == info.tagInfoPtr);
+		    TkTextTagSetIncrRefCount(segPtr->tagInfoPtr = tagInfoPtr);
+		    if (!firstSegPtr) {
+			firstSegPtr = segPtr;
+		    }
+		} else {
+		    assert(!firstSegPtr);
+		    assert(!info.tagInfoPtr);
+		    tagInfoPtr = segPtr->tagInfoPtr = MakeTagInfo(index.textPtr, segPtr);
+		    info.tagInfoPtr = tagInfoPtr;
+		}
+		for (tagPtr = hyphenTagPtr; tagPtr; tagPtr = tagPtr->nextPtr) {
+		    segPtr->tagInfoPtr = TagSetAdd(segPtr->tagInfoPtr, tagPtr);
+		}
+		hyphenTagInfoPtr = segPtr->tagInfoPtr;
+	    }
+	    info.offset = -1;
+	    prevPtr = segPtr;
+	    split = false;
+	    size += segPtr->size;
+	} else {
+	    size += chunkSize;
+
+	    if (split) {
+		info.increase = chunkSize;
+		info.forceSplit = isNewline;
+		prevPtr = SplitSeg(indexPtr, &info);
+	    }
+	    if (info.offset >= 0) {
+		/*
+		 * Fill increased/decreased char segment.
+		 */
+		segPtr = prevPtr;
+		assert(segPtr->size >= info.offset + chunkSize);
+		memcpy(segPtr->body.chars + info.offset, string, chunkSize);
+		segPtr->sectionPtr->size += chunkSize;
+		linePtr->size += chunkSize;
+		assert(!tagInfoPtr || TkTextTagSetIsEqual(tagInfoPtr, segPtr->tagInfoPtr));
+		tagInfoPtr = segPtr->tagInfoPtr;
+	    } else {
+		/*
+		 * Insert new segment.
+		 */
+
+		segPtr = MakeCharSeg(NULL, tagInfoPtr, chunkSize, string, chunkSize);
+		LinkSegment(linePtr, prevPtr, segPtr);
+		SplitSection(segPtr->sectionPtr);
+		TkBTreeIncrEpoch(tree);
+	    }
+	    prevPtr = segPtr;
+
+	    assert(!firstSegPtr || tagInfoPtr);
+
+	    if (!firstSegPtr) {
+		firstSegPtr = segPtr;
+
+		if (!tagInfoPtr) {
+		    if (segPtr->tagInfoPtr) {
+			tagInfoPtr = segPtr->tagInfoPtr;
+		    } else {
+			tagInfoPtr = MakeTagInfo(index.textPtr, segPtr);
+		    }
+		    info.tagInfoPtr = tagInfoPtr;
+		}
+	    }
+
+	    if (!segPtr->tagInfoPtr) {
+		TkTextTagSetIncrRefCount(segPtr->tagInfoPtr = tagInfoPtr);
+	    } else {
+		assert(TkTextTagSetIsEqual(tagInfoPtr, segPtr->tagInfoPtr));
+	    }
+	}
+
+	assert(prevPtr);
+	lastSegPtr = segPtr;
+	string = strEnd + (chunkSize == 0 ? 2 : 0);
+	TkTextIndexAddToByteIndex(indexPtr, MAX(chunkSize, 1));
+
+	if (!isNewline) {
+	    continue;
+	}
+
+	/*
+	 * Update line tag information.
+	 */
+
+	if (changeToLineCount == 0
+		&& (hyphenTagInfoPtr
+		    || (tagInfoPtr && linePtr->tagonPtr != tagInfoPtr)
+		    || linePtr->tagoffPtr != emptyTagInfoPtr)) {
+	    /*
+	     * In this case we have to recompute the line tag information, because
+	     * the line will be split before segPtr->nextPtr.
+	     */
+	    RecomputeLineTagInfo(linePtr, segPtr->nextPtr, sharedTextPtr);
+	}
+
+	assert(segPtr->nextPtr);
+
+	split = info.splitted;
+	info.splitted = false;
+	info.offset = -1;
+
+	/*
+	 * This chunk ended with a newline, so create a new text line and move
+	 * the remainder of the old line to it.
+	 */
+
+	if (changeToLineCount == 0) {
+	    memset(changeToPixelInfo, 0, sizeof(changeToPixelInfo[0])*treePtr->numPixelReferences);
+	}
+
+	newLinePtr = InsertNewLine(sharedTextPtr, linePtr->parentPtr, linePtr, segPtr->nextPtr);
+	AddPixelCount(treePtr, newLinePtr, linePtr, changeToPixelInfo);
+	if (hyphenTagInfoPtr) {
+	    assert(TkTextTagSetContains(hyphenTagInfoPtr, tagInfoPtr));
+	    assert(linePtr->tagoffPtr == emptyTagInfoPtr);
+	    TagSetAssign(&newLinePtr->tagonPtr, hyphenTagInfoPtr);
+	    TagSetAssign(&newLinePtr->tagoffPtr, hyphenTagInfoPtr);
+	    newLinePtr->tagoffPtr = TagSetRemove(newLinePtr->tagoffPtr, tagInfoPtr, sharedTextPtr);
+	} else if (tagInfoPtr) {
+	    TagSetAssign(&newLinePtr->tagonPtr, tagInfoPtr);
+	}
+	TkTextIndexSetByteIndex2(indexPtr, newLinePtr, 0);
+	prevPtr = NULL;
+	linePtr = newLinePtr;
+	changeToLineCount += 1;
+	changeToLogicalLineCount += linePtr->logicalLine;
+    }
+
+    /*
+     * Update line tag information of last line.
+     */
+
+    assert(tagInfoPtr || hyphenTagInfoPtr);
+
+    if (changeToLineCount == 0) {
+	if (hyphenTagInfoPtr) {
+	    assert(TkTextTagSetContains(hyphenTagInfoPtr, tagInfoPtr));
+	    linePtr->tagoffPtr = TagSetJoinNonIntersection(
+		    linePtr->tagoffPtr, linePtr->tagonPtr, hyphenTagInfoPtr, sharedTextPtr);
+	    linePtr->tagonPtr = TkTextTagSetJoin(linePtr->tagonPtr, hyphenTagInfoPtr);
+	    myTagInfoPtr = hyphenTagInfoPtr;
+	} else if (linePtr->tagonPtr != tagInfoPtr || linePtr->tagoffPtr != emptyTagInfoPtr) {
+	    linePtr->tagoffPtr = TagSetJoinNonIntersection(
+		    linePtr->tagoffPtr, linePtr->tagonPtr, tagInfoPtr, sharedTextPtr);
+	    linePtr->tagonPtr = TkTextTagSetJoin(linePtr->tagonPtr, tagInfoPtr);
+	}
+    } else {
+	SetLineHasChanged(sharedTextPtr, linePtr);
+	RecomputeLineTagInfo(linePtr, NULL, sharedTextPtr);
+    }
+
+    myTagInfoPtr = hyphenTagInfoPtr ? hyphenTagInfoPtr : tagInfoPtr;
+
+    if (myTagInfoPtr) {
+	Node *nodePtr = linePtr->parentPtr;
+
+	if (nodePtr->tagonPtr != emptyTagInfoPtr) {
+	    unsigned i;
+
+	    /*
+	     * Update the tag information of the B-Tree. Any tag in tagon of this
+	     * node, which is not contained in myTagInfoPtr, has to be added to the
+	     * tagoff information of this node.
+	     */
+
+	    for (i = TkTextTagSetFindFirst(nodePtr->tagonPtr);
+		    i != TK_TEXT_TAG_SET_NPOS;
+		    i = TkTextTagSetFindNext(nodePtr->tagonPtr, i)) {
+		if (!TkTextTagSetTest(myTagInfoPtr, i)) {
+		    AddTagToNode(nodePtr, sharedTextPtr->tagLookup[i], true);
+		}
+	    }
+	}
+    }
+
+    if (undoInfo) {
+	MakeUndoIndex(sharedTextPtr, indexPtr, &undoToken->endIndex, GRAVITY_LEFT);
+    }
+
+    /*
+     * Increment the line and pixel counts in all the parent nodes of the
+     * insertion point, then rebalance the tree if necessary.
+     */
+
+    SubtractPixelCount2(treePtr, linePtr->parentPtr, -changeToLineCount,
+	    -changeToLogicalLineCount, 0, -size, changeToPixelInfo);
+
+    if ((linePtr->parentPtr->numChildren += changeToLineCount) > MAX_CHILDREN) {
+	Rebalance(treePtr, linePtr->parentPtr);
+    }
+
+    /*
+     * This line now needs to have its height recalculated. This has to be done after Rebalance.
+     */
+
+    TkTextInvalidateLineMetrics(sharedTextPtr, NULL, firstLinePtr,
+	    changeToLineCount, TK_TEXT_INVALIDATE_INSERT);
+ 
+    /*
+     * Next step: update elision states if needed.
+     */
+
+    if (tagInfoPtr
+	    && tagInfoPtr != emptyTagInfoPtr
+	    && TkTextTagSetIntersectsBits(tagInfoPtr, sharedTextPtr->elisionTags)) {
+	int highestPriority = -1;
+	TkTextTag *tagPtr = NULL;
+	TkText *textPtr = index.textPtr;
+	unsigned i = TkTextTagSetFindFirst(tagInfoPtr);
+
+	/*
+	 * We have to update the elision info, but only for the tag with the highest
+	 * elide priority. This has to be done after TkTextInvalidateLineMetrics.
+	 */
+
+	for ( ; i != TK_TEXT_TAG_SET_NPOS; i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	    TkTextTag *tPtr = sharedTextPtr->tagLookup[i];
+
+	    assert(tPtr);
+	    assert(!tPtr->isDisabled);
+
+	    if (tPtr->elideString
+		    && tPtr->priority > highestPriority
+		    && (!tPtr->textPtr || tPtr->textPtr == textPtr)) {
+		highestPriority = (tagPtr = tPtr)->priority;
+	    }
+	}
+
+	if (tagPtr) {
+	    firstSegPtr->protectionFlag = true;
+	    lastSegPtr->protectionFlag = true;
+
+	    UpdateElideInfo(sharedTextPtr, tagPtr, firstSegPtr, lastSegPtr, ELISION_HAS_BEEN_ADDED);
+
+	    CleanupSplitPoint(firstSegPtr, sharedTextPtr);
+	    CleanupSplitPoint(lastSegPtr, sharedTextPtr);
+
+	    if (hyphenElideTagPtr == tagPtr) {
+		hyphenElideTagPtr = NULL;
+	    }
+	}
+    }
+
+    if (hyphenElideTagPtr) {
+	firstSegPtr->protectionFlag = true;
+	lastSegPtr->protectionFlag = true;
+
+	UpdateElideInfo(sharedTextPtr, hyphenElideTagPtr, firstSegPtr, lastSegPtr,
+		ELISION_HAS_BEEN_ADDED);
+
+	CleanupSplitPoint(firstSegPtr, sharedTextPtr);
+	CleanupSplitPoint(lastSegPtr, sharedTextPtr);
+    }
+
+    TkTextIndexSetEpoch(indexPtr, TkBTreeIncrEpoch(tree));
+
+    TK_BTREE_DEBUG(TkBTreeCheck(indexPtr->tree));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * MakeUndoIndex --
+ *
+ *	Find undo/redo index of given segment. We prefer a predecessing
+ *	mark segment at the same byte index, because such a mark is stable
+ *	enough to work as a predecessor segment (e.g. for insertion),
+ *	but alternatively, if no predecessing mark segments exists, we
+ *	will store the line index, byte index, and possible offset inside
+ *	a chain of (splitted) char segments. The gravity is specifiying
+ *	the direction where we are searching for a mark, either at left
+ *	side (for a starting index), or at right side (for an ending index).
+ *
+ * Results:
+ *	'indexPtr' will be filled appropriately.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+MakeUndoIndex(
+    const TkSharedText *sharedTextPtr,
+    const TkTextIndex *indexPtr,	/* Convert this index. */
+    TkTextUndoIndex *undoIndexPtr,	/* Pointer to resulting index. */
+    int gravity)			/* +1 = right gravity, -1 = left gravity */
+{
+    TkTextSegment *segPtr;
+
+    assert(indexPtr);
+    assert(gravity == GRAVITY_LEFT || gravity == GRAVITY_RIGHT);
+
+    /*
+     * At first, try to find a neighboring mark segment at the same byte
+     * index, but we cannot use the special marks "insert" and "current",
+     * and we cannot not use private marks.
+     */
+
+    if (sharedTextPtr->steadyMarks
+	    && (segPtr = TkTextIndexGetSegment(indexPtr))
+	    && segPtr->typePtr->group == SEG_GROUP_MARK) {
+	TkTextSegment *searchPtr = (gravity == GRAVITY_LEFT) ? segPtr->prevPtr : segPtr->nextPtr;
+
+	while (searchPtr && TkTextIsSpecialOrPrivateMark(searchPtr)) {
+	    searchPtr = (gravity == GRAVITY_LEFT) ? searchPtr->prevPtr : searchPtr->nextPtr;
+	}
+
+	if (searchPtr && TkTextIsStableMark(searchPtr)) {
+	    undoIndexPtr->u.markPtr = searchPtr;
+	    undoIndexPtr->lineIndex = -1;
+	    return;
+	}
+    }
+
+    undoIndexPtr->lineIndex = TkTextIndexGetLineNumber(indexPtr, NULL);
+    undoIndexPtr->u.byteIndex = TkTextIndexGetByteIndex(indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeMakeUndoIndex --
+ *
+ *	Find undo/redo index of given segment. We prefer a predecessing
+ *	mark segment at the same byte index, because such a mark is stable
+ *	enough to work as a predecessor segment (e.g. for insertion),
+ *	but alternatively, if no predecessing mark segments exists, we
+ *	will store the line index, byte index, and possible offset inside
+ *	a chain of (splitted) char segments. The search for the mark segment
+ *	will be done at the left side of the specified segment.
+ *
+ * Results:
+ *	'indexPtr' will be filled appropriately.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeMakeUndoIndex(
+    const TkSharedText *sharedTextPtr,
+    TkTextSegment *segPtr,	/* Find index of this segment. */
+    TkTextUndoIndex *indexPtr)	/* Pointer to resulting index. */
+{
+    TkTextIndex index;
+
+    assert(segPtr);
+    assert(segPtr->typePtr);    /* expired? */
+    assert(segPtr->sectionPtr); /* linked? */
+    assert(segPtr->typePtr != &tkTextCharType);
+
+    TkTextIndexClear2(&index, NULL, sharedTextPtr->tree);
+    TkTextIndexSetSegment(&index, segPtr);
+    MakeUndoIndex(sharedTextPtr, &index, indexPtr, GRAVITY_LEFT);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeUndoIndexToIndex --
+ *
+ *	Convert an undo/redo index to a normal index.
+ *
+ * Results:
+ *	'dstPtr' will be filled appropriately.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeUndoIndexToIndex(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoIndex *srcPtr,
+    TkTextIndex *dstPtr)
+{
+    TkTextIndexClear2(dstPtr, NULL, sharedTextPtr->tree);
+
+    if (srcPtr->lineIndex == -1) {
+	TkTextIndexSetSegment(dstPtr, srcPtr->u.markPtr);
+    } else {
+	TkTextLine *linePtr = TkBTreeFindLine(sharedTextPtr->tree, NULL, srcPtr->lineIndex);
+	assert(linePtr);
+	TkTextIndexSetByteIndex2(dstPtr, linePtr, srcPtr->u.byteIndex);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UndoIndexIsEqual --
+ *
+ *	Test whether both indices are equal. Note that this test
+ *	may return false even if both indices are referring the
+ *	same position.
+ *
+ * Results:
+ *	Return whether both indices are (probably) equal.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+UndoIndexIsEqual(
+    const TkTextUndoIndex *indexPtr1,
+    const TkTextUndoIndex *indexPtr2)
+{
+    if (indexPtr1->lineIndex == -1) {
+	return indexPtr2->u.markPtr && indexPtr1->u.markPtr == indexPtr2->u.markPtr;
+    }
+
+    if (indexPtr2->lineIndex == -1) {
+	return indexPtr1->u.markPtr && indexPtr1->u.markPtr == indexPtr2->u.markPtr;
+    }
+
+    return indexPtr1->lineIndex == indexPtr2->lineIndex
+	    && indexPtr1->u.byteIndex == indexPtr2->u.byteIndex;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ReInsertSegment --
+ *
+ *	Re-insert a previously removed segment at the given index.
+ *	This function is not handling the special cases when a
+ *	char segment will be inserted (join with neighbors, handling
+ *	of newline char, updating the line tag information), the caller
+ *	is responsible for this.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	A segment will be inserted into a segment chain.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+ReInsertSegment(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoIndex *indexPtr,
+    TkTextSegment *segPtr,
+    bool updateNode)
+{
+    TkTextSegment *prevPtr;
+    TkTextLine *linePtr;
+
+    assert(sharedTextPtr);
+    assert(indexPtr);
+    assert(segPtr);
+    assert(!TkTextIsSpecialOrPrivateMark(segPtr));
+
+    if (indexPtr->lineIndex == -1) {
+	prevPtr = indexPtr->u.markPtr;
+	linePtr = prevPtr->sectionPtr->linePtr;
+
+	if (updateNode) {
+	    TkTextIndex index;
+
+	    linePtr = TkBTreeFindLine(sharedTextPtr->tree, NULL, indexPtr->lineIndex);
+	    TkTextIndexClear2(&index, NULL, sharedTextPtr->tree);
+	    TkTextIndexSetByteIndex2(&index, linePtr, indexPtr->u.byteIndex);
+	    TkBTreeLinkSegment(sharedTextPtr, segPtr, &index);
+	    return;
+	}
+    } else {
+	TkTextIndex index;
+
+	assert(indexPtr->lineIndex >= 0);
+	assert(indexPtr->u.byteIndex >= 0);
+
+	linePtr = TkBTreeFindLine(sharedTextPtr->tree, NULL, indexPtr->lineIndex);
+	TkTextIndexClear2(&index, NULL, sharedTextPtr->tree);
+	TkTextIndexSetByteIndex2(&index, linePtr, indexPtr->u.byteIndex);
+
+	if (updateNode) {
+	    TkBTreeLinkSegment(sharedTextPtr, segPtr, &index);
+	    return;
+	}
+
+	prevPtr = SplitSeg(&index, NULL);
+    }
+
+    LinkSegment(linePtr, prevPtr, segPtr);
+    SplitSection(segPtr->sectionPtr);
+    TkBTreeIncrEpoch(sharedTextPtr->tree);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeReInsertSegment --
+ *
+ *	Re-insert a previously removed segment at the given index.
+ *	This function is not handling the special cases when a
+ *	char segment will be inserted (join with neighbors, handling
+ *	of newline char, updating the line tag information), the caller
+ *	is responsible for this.
+ *
+ *	This function is updating the B-Tree.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	A segment will be inserted into a segment chain.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeReInsertSegment(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoIndex *indexPtr,
+    TkTextSegment *segPtr)
+{
+    ReInsertSegment(sharedTextPtr, indexPtr, segPtr, true);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * LinkMark --
+ *
+ *	This function adds a mark segment to a B-tree at given location.
+ *	It takes into account some rules about positions of marks and
+ *	switches.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	'succPtr' will be linked into its tree.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+LinkMark(
+    const TkSharedText *sharedTextPtr,
+    TkTextLine *linePtr,
+    TkTextSegment *prevPtr,
+    TkTextSegment *segPtr)
+{
+    assert(segPtr->typePtr->group == SEG_GROUP_MARK);
+
+    /*
+     * Start markers will be the left most mark.
+     * End markers will be the right most mark.
+     */
+
+    if (segPtr->startEndMarkFlag) {
+	if (segPtr->typePtr == &tkTextLeftMarkType) {
+	    /* This is a start marker. */
+	    while (prevPtr
+		    && prevPtr->typePtr->group == SEG_GROUP_MARK
+		    && !prevPtr->startEndMarkFlag) {
+		prevPtr = prevPtr->prevPtr;
+	    }
+	} else {
+	    /* This is an end marker. */
+	    if (!prevPtr
+		    && linePtr->segPtr->typePtr->group == SEG_GROUP_MARK
+		    && !linePtr->segPtr->startEndMarkFlag) {
+		prevPtr = linePtr->segPtr;
+	    }
+	    if (prevPtr) {
+		while (prevPtr->nextPtr
+			&& prevPtr->nextPtr->typePtr->group == SEG_GROUP_MARK
+			&& !prevPtr->nextPtr->startEndMarkFlag) {
+		    prevPtr = prevPtr->nextPtr;
+		}
+	    }
+	}
+    } else {
+	if (!prevPtr
+		&& linePtr->segPtr->startEndMarkFlag
+		&& linePtr->segPtr->typePtr == &tkTextLeftMarkType) {
+	    prevPtr = linePtr->segPtr;
+	}
+	if (prevPtr) {
+	    while (prevPtr->nextPtr
+		    && prevPtr->nextPtr->startEndMarkFlag
+		    && prevPtr->nextPtr->typePtr == &tkTextLeftMarkType) {
+		prevPtr = prevPtr->nextPtr;
+	    }
+	}
+	while (prevPtr
+		&& prevPtr->startEndMarkFlag
+		&& prevPtr->typePtr == &tkTextRightMarkType) {
+	    prevPtr = prevPtr->prevPtr;
+	}
+    }
+
+    /*
+     * We have to ensure that a branch will not be followed by marks,
+     * and a link will not be preceded by marks.
+     */
+
+    assert(!prevPtr || prevPtr->nextPtr);	/* mark cannot be last segment */
+    assert(linePtr->segPtr);			/* dito */
+
+    if (TkBTreeHaveElidedSegments(sharedTextPtr)) {
+	if (prevPtr) {
+	    if (prevPtr->typePtr == &tkTextBranchType) {
+		prevPtr = prevPtr->prevPtr;
+	    } else if (prevPtr->nextPtr->typePtr == &tkTextLinkType) {
+		prevPtr = prevPtr->nextPtr;
+	    }
+	} else if (linePtr->segPtr->typePtr == &tkTextLinkType) {
+	    prevPtr = linePtr->segPtr;
+	}
+    }
+
+    LinkSegment(linePtr, prevPtr, segPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * LinkSwitch --
+ *
+ *	This function adds a new branch/link segment to a B-tree at given
+ *	location. It takes into account that a branch will never be
+ *	followed by marks, and a link will never by preceded by marks.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	'succPtr' will be linked into its tree.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+LinkSwitch(
+    TkTextLine *linePtr,	/* Pointer to line. */
+    TkTextSegment *predPtr,	/* Pointer to segment within this line, can be NULL. */
+    TkTextSegment *succPtr)	/* Link this segment after predPtr. */
+{
+    assert(predPtr || linePtr);
+    assert(succPtr);
+    assert(succPtr->typePtr->group == SEG_GROUP_BRANCH);
+
+    /*
+     * Note that the (temporary) protected segments are transparent.
+     */
+
+    if (succPtr->typePtr == &tkTextBranchType) {
+	if (!predPtr && (linePtr->segPtr->typePtr->group & (SEG_GROUP_MARK|SEG_GROUP_PROTECT))) {
+	    predPtr = linePtr->segPtr;
+	}
+	if (predPtr) {
+	    while (predPtr->nextPtr
+		    && (predPtr->nextPtr->typePtr->group & (SEG_GROUP_MARK|SEG_GROUP_PROTECT))) {
+		predPtr = predPtr->nextPtr;
+		assert(predPtr); /* mark cannot be last segment */
+	    }
+	}
+    } else { /* if (succPtr->typePtr == &tkTextLinkType) */
+	while (predPtr && (predPtr->typePtr->group & (SEG_GROUP_MARK|SEG_GROUP_PROTECT))) {
+	    predPtr = predPtr->prevPtr;
+	}
+    }
+
+    LinkSegment(linePtr, predPtr, succPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * LinkSegment --
+ *
+ *	This function adds a new segment to a B-tree at given location.
+ *	Note that this function is not updating the tag information of
+ *	the line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	'succPtr' will be linked into its tree after 'predPtr', or
+ *	at start of given line if 'predPtr' is NULL.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+LinkSegment(
+    TkTextLine *linePtr,	/* Pointer to line. */
+    TkTextSegment *predPtr,	/* Pointer to segment within this line, can be NULL. */
+    TkTextSegment *succPtr)	/* Link this segment after predPtr. */
+{
+    assert(predPtr || linePtr);
+    assert(succPtr);
+    assert(!succPtr->sectionPtr); /* unlinked? */
+
+    if (predPtr) {
+	if (predPtr->typePtr == &tkTextBranchType) {
+	    succPtr->sectionPtr = predPtr->nextPtr->sectionPtr;
+	    succPtr->sectionPtr->segPtr = succPtr;
+	} else {
+	    succPtr->sectionPtr = predPtr->sectionPtr;
+	}
+	succPtr->nextPtr = predPtr->nextPtr;
+	succPtr->prevPtr = predPtr;
+	predPtr->nextPtr = succPtr;
+	if (linePtr->lastPtr == predPtr) {
+	    linePtr->lastPtr = succPtr;
+	}
+    } else {
+	assert(linePtr->segPtr);
+	if (linePtr->segPtr->typePtr == &tkTextLinkType) {
+	    TkTextSection *newSectionPtr;
+
+	    newSectionPtr = malloc(sizeof(TkTextSection));
+	    newSectionPtr->linePtr = linePtr;
+	    newSectionPtr->segPtr = succPtr;
+	    newSectionPtr->nextPtr = linePtr->segPtr->sectionPtr->nextPtr;
+	    newSectionPtr->prevPtr = NULL;
+	    newSectionPtr->size = 0;
+	    newSectionPtr->length = 0;
+	    linePtr->segPtr->sectionPtr->prevPtr = newSectionPtr;
+	} else {
+	    succPtr->sectionPtr = linePtr->segPtr->sectionPtr;
+	    succPtr->sectionPtr->segPtr = succPtr;
+	}
+	succPtr->nextPtr = linePtr->segPtr;
+	succPtr->prevPtr = NULL;
+	linePtr->segPtr = succPtr;
+    }
+    if (succPtr->nextPtr) {
+	succPtr->nextPtr->prevPtr = succPtr;
+    }
+    linePtr->size += succPtr->size;
+    succPtr->sectionPtr->size += succPtr->size;
+    succPtr->sectionPtr->length += 1;
+    assert(succPtr->sectionPtr->length != 0); /* test for overflow */
+
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UnlinkSegmentAndCleanup --
+ *
+ *	This function removes a segment from a B-tree. Furthermore
+ *	it will do a cleanup with the predecessing segment.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	'segPtr' will be unlinked from its tree, possibly a cleanup will
+ *	be done.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+UnlinkSegmentAndCleanup(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    TkTextSegment *segPtr)		/* Unlink this segment. */
+{
+    TkTextSegment *prevPtr;
+
+    assert(segPtr);
+
+    prevPtr = segPtr->prevPtr;
+    UnlinkSegment(segPtr);
+
+    if (prevPtr && prevPtr->typePtr == &tkTextCharType) {
+	CleanupCharSegments(sharedTextPtr, prevPtr);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UnlinkSegment --
+ *
+ *	This function removes a segment from a B-tree.
+ *
+ * Results:
+ *	The predecessor of the unlinked segment.
+ *
+ * Side effects:
+ *	'segPtr' will be unlinked from its tree.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+FreeSection(
+    TkTextSection *sectionPtr)
+{
+    assert(sectionPtr->linePtr);
+    assert(!(sectionPtr->linePtr = NULL));
+    free(sectionPtr);
+    DEBUG_ALLOC(tkTextCountDestroySection++);
+}
+
+static TkTextSegment *
+UnlinkSegment(
+    TkTextSegment *segPtr)	/* Unlink this segment. */
+{
+    TkTextSegment *prevPtr = segPtr->prevPtr;
+
+    if (prevPtr) {
+	prevPtr->nextPtr = segPtr->nextPtr;
+    } else {
+	segPtr->sectionPtr->linePtr->segPtr = segPtr->nextPtr;
+    }
+    if (segPtr->nextPtr) {
+	segPtr->nextPtr->prevPtr = prevPtr;
+    }
+    if (segPtr->sectionPtr->segPtr == segPtr) {
+	segPtr->sectionPtr->segPtr = segPtr->nextPtr;
+    }
+    if (segPtr->sectionPtr->linePtr->lastPtr == segPtr) {
+	segPtr->sectionPtr->linePtr->lastPtr = prevPtr;
+    }
+    segPtr->sectionPtr->linePtr->size -= segPtr->size;
+    if (--segPtr->sectionPtr->length == 0) {
+	/*
+	 * This can happen in rare cases, e.g. the line is starting with a Branch.
+	 * We have to free the unused section.
+	 */
+	FreeSection(segPtr->sectionPtr);
+	segPtr->nextPtr->sectionPtr->prevPtr = NULL;
+    } else {
+	segPtr->sectionPtr->size -= segPtr->size;
+    }
+    segPtr->sectionPtr = NULL;
+    return prevPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * ComputeSectionSize --
+ *
+ *	Count the sum of all sizes in current section starting at
+ *	given section.
+ *
+ * Results:
+ *	The return value is the sum.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static unsigned
+ComputeSectionSize(
+    const TkTextSegment *segPtr)	/* Start counting at this segment. */
+{
+    const TkTextSection *sectionPtr = segPtr->sectionPtr;
+    unsigned size = 0;
+
+    for ( ; segPtr && segPtr->sectionPtr == sectionPtr; segPtr = segPtr->nextPtr) {
+	size += segPtr->size;
+    }
+
+    return size;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CountSegments --
+ *
+ *	Count the number of segments belonging to the given section.
+ *
+ * Results:
+ *	The return value is the count.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static unsigned
+CountSegments(
+    const TkTextSection *sectionPtr)	/* Pointer to section of text segments. */
+{
+    const TkTextSegment *segPtr;
+    unsigned count = 0;
+
+    for (segPtr = sectionPtr->segPtr;
+	    segPtr && segPtr->sectionPtr == sectionPtr;
+	    segPtr = segPtr->nextPtr, ++count) {
+	/* empty body */
+    }
+
+    return count;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * SplitSection --
+ *
+ *	This function is called after new segments has been added to a
+ *	section. It ensures that no more than MAX_TEXT_SEGS segments will
+ *	belong to this section, by reducing the number of segments. If
+ *	necessary a new section will be created.
+ *
+ *	It is guaranteed that a split operation will be performed in
+ *	constant time.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The section referred to by sectionPtr may change, and also the
+ *	the neighboring sections may change.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+SplitSection(
+    TkTextSection *sectionPtr)	/* Pointer to section of text segments. */
+{
+    TkTextSegment *segPtr, *splitSegPtr;
+    TkTextSection *newSectionPtr, *prevPtr, *nextPtr;
+    int length;
+    int lengthLHS, lengthRHS;
+    int shiftLHS, shiftRHS;
+    int capacityLHS, capacityRHS;
+
+    assert(!sectionPtr->prevPtr || sectionPtr->prevPtr->length <= MAX_TEXT_SEGS);
+    assert(!sectionPtr->nextPtr || sectionPtr->nextPtr->length <= MAX_TEXT_SEGS);
+
+    if ((length = sectionPtr->length) <= NUM_TEXT_SEGS) {
+	return;
+    }
+
+    /*
+     * The correctness of this implementation depends on the fact that
+     * a section can never contain more than MAX_TEXT_SEGS+NUM_TEXT_SEGS
+     * segments.
+     */
+    assert(length <= MAX_TEXT_SEGS + NUM_TEXT_SEGS);
+
+    segPtr = sectionPtr->nextPtr ? sectionPtr->nextPtr->segPtr->prevPtr : sectionPtr->linePtr->lastPtr;
+    for (lengthLHS = length - 1; lengthLHS > NUM_TEXT_SEGS; --lengthLHS) {
+	segPtr = segPtr->prevPtr;
+    }
+    splitSegPtr = segPtr;
+
+    /*
+     * We have to take into account that a branch segment must be
+     * the last segment inside a section, and a link segment must
+     * be the first segment inside a section.
+     */
+
+    prevPtr = sectionPtr->prevPtr;
+    nextPtr = sectionPtr->nextPtr;
+
+    if (prevPtr && IsBranchSection(prevPtr)) {
+	prevPtr = NULL; /* we cannot shift to the left */
+    }
+    if (nextPtr && IsLinkSection(nextPtr)) {
+	nextPtr = NULL; /* we cannot shift to the right */
+    }
+
+    lengthLHS = prevPtr ? prevPtr->length : 0;
+    lengthRHS = nextPtr ? nextPtr->length : 0;
+
+    capacityLHS = lengthLHS ? MAX(0, NUM_TEXT_SEGS - lengthLHS) : 0;
+    capacityRHS = lengthRHS ? MAX(0, NUM_TEXT_SEGS - lengthRHS) : 0;
+
+    /*
+     * We have to consider two cases:
+     *
+     * =====================================================================
+     * (capacityLHS + capacityRHS < length - MAX_TEXT_SEGS) OR
+     * (lengthRHS == 0 AND capacityLHS < length - NUM_TEXT_SEGS):
+     * =====================================================================
+     *
+     * 1. Shift as many segments as possible to the left segment (if
+     *    exisiting), but the length of NUM_TEXT_SEGS should not be
+     *    exceeded.
+     *
+     * 2. We have to insert a new section at the right. Shift segments into
+     *    this new segment, until this section has NUM_TEXT_SEGS segments.
+     *
+     * =====================================================================
+     * otherwise:
+     * =====================================================================
+     *
+     * In this case this section will reduced while shifting to left and
+     * right neighbors, so that each neighbor will not exceed NUM_TEXT_SEGS
+     * segments with this operation.
+     */
+
+    if (capacityLHS + capacityRHS < length - MAX_TEXT_SEGS
+	    || (lengthRHS == 0 && capacityLHS < length - NUM_TEXT_SEGS)) {
+	if (capacityLHS) {
+	    TkTextSegment *segPtr = sectionPtr->segPtr;
+	    int i;
+
+	    for (i = capacityLHS; i < capacityLHS; ++i) {
+		sectionPtr->size -= segPtr->size;
+		sectionPtr->length -= 1;
+		sectionPtr->prevPtr->size += segPtr->size;
+		sectionPtr->prevPtr->length += 1;
+		assert(sectionPtr->prevPtr->length != 0); /* test for overflow */
+		segPtr->sectionPtr = sectionPtr->prevPtr;
+		segPtr = segPtr->nextPtr;
+		splitSegPtr = splitSegPtr->nextPtr;
+	    }
+	    sectionPtr->segPtr = segPtr;
+	}
+
+	assert(splitSegPtr);
+	assert(lengthRHS == 0 || length - capacityLHS >= MIN_TEXT_SEGS);
+
+	newSectionPtr = malloc(sizeof(TkTextSection));
+	newSectionPtr->linePtr = sectionPtr->linePtr;
+	newSectionPtr->segPtr = splitSegPtr;
+	newSectionPtr->nextPtr = sectionPtr->nextPtr;
+	newSectionPtr->prevPtr = sectionPtr;
+	newSectionPtr->size = 0;
+	newSectionPtr->length = 0;
+	if (sectionPtr->nextPtr) {
+	    sectionPtr->nextPtr->prevPtr = newSectionPtr;
+	}
+	sectionPtr->nextPtr = newSectionPtr;
+	DEBUG_ALLOC(tkTextCountNewSection++);
+
+	for ( ; splitSegPtr && splitSegPtr->sectionPtr == sectionPtr;
+		splitSegPtr = splitSegPtr->nextPtr) {
+	    newSectionPtr->size += splitSegPtr->size;
+	    newSectionPtr->length += 1;
+	    assert(newSectionPtr->length != 0); /* test for overflow */
+	    sectionPtr->size -= splitSegPtr->size;
+	    sectionPtr->length -= 1;
+	    splitSegPtr->sectionPtr = newSectionPtr;
+	}
+    } else {
+	int exceed;
+
+	shiftLHS = MIN(capacityLHS, MAX(0, length - NUM_TEXT_SEGS));
+	shiftRHS = MIN(capacityRHS, length - NUM_TEXT_SEGS - shiftLHS);
+
+	if (shiftLHS > 0) {
+	    TkTextSegment *segPtr = sectionPtr->segPtr;
+
+	    for ( ; shiftLHS > 0; --shiftLHS) {
+		sectionPtr->size -= segPtr->size;
+		sectionPtr->length -= 1;
+		sectionPtr->prevPtr->size += segPtr->size;
+		sectionPtr->prevPtr->length += 1;
+		assert(sectionPtr->prevPtr->length != 0); /* test for overflow */
+		segPtr->sectionPtr = sectionPtr->prevPtr;
+		segPtr = segPtr->nextPtr;
+	    }
+	    sectionPtr->segPtr = segPtr;
+	}
+
+	if (shiftRHS > 0) {
+	    /*
+	     * Reduce the split until it fits the capacity of the neighbor.
+	     */
+
+	    exceed = length - NUM_TEXT_SEGS - shiftLHS - shiftRHS;
+	    for ( ; exceed > 0; splitSegPtr = splitSegPtr->nextPtr, --exceed) {
+		/* empty loop body */
+	    }
+
+	    assert(splitSegPtr);
+	    sectionPtr->nextPtr->segPtr = splitSegPtr;
+	    while (splitSegPtr && splitSegPtr->sectionPtr == sectionPtr) {
+		sectionPtr->size -= splitSegPtr->size;
+		sectionPtr->length -= 1;
+		sectionPtr->nextPtr->size += splitSegPtr->size;
+		sectionPtr->nextPtr->length += 1;
+		assert(sectionPtr->nextPtr->length != 0); /* test for overflow */
+		splitSegPtr->sectionPtr = sectionPtr->nextPtr;
+		splitSegPtr = splitSegPtr->nextPtr;
+	    }
+	}
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * JoinSections --
+ *
+ *	This function is called after segments has been removed from a
+ *	section. It ensures that either at least MIN_TEXT_SEGS will belong
+ *	to this section, or that this section will be removed. Of course
+ *	this must be ensured only if this section is not the rightmost
+ *	section of this line.
+ *
+ *	It is guaranteed that a join operation will be constant in constant
+ *	time.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The section referred to by sectionPtr may change, and also the
+ *	the neighboring sections may change. The section referred to by
+ *	sectionPtr will be destroyed if not needed anymore.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+JoinSections(
+    TkTextSection *sectionPtr)	/* Pointer to section of text segments. */
+{
+    TkTextSegment *segPtr;
+    bool isBranchSegment, isLinkSegment;
+    int length;
+
+    assert(!sectionPtr->prevPtr || sectionPtr->prevPtr->length <= MAX_TEXT_SEGS);
+    assert(!sectionPtr->nextPtr || sectionPtr->nextPtr->length <= MAX_TEXT_SEGS);
+
+    length = sectionPtr->length;
+
+    if (length == 0) {
+	/*
+	 * This section is empty, so remove it. Note that this
+	 * cannot happen if the line contains only one section.
+	 */
+	assert(sectionPtr->prevPtr);
+	assert(sectionPtr->length == 0);
+	sectionPtr->prevPtr->nextPtr = sectionPtr->nextPtr;
+	if (sectionPtr->nextPtr) {
+	    sectionPtr->nextPtr->prevPtr = sectionPtr->prevPtr;
+	}
+	FreeSection(sectionPtr);
+	return;
+    }
+
+    isBranchSegment = IsBranchSection(sectionPtr);
+    isLinkSegment = IsLinkSection(sectionPtr);
+
+    if (sectionPtr->nextPtr
+	    && !isBranchSegment
+	    && !IsLinkSection(sectionPtr->nextPtr)
+	    && length < MIN_TEXT_SEGS) {
+	/*
+	 * This section does not end with a Branch, we have a right
+	 * neighbor, and the length of this section has undershot
+	 * MIN_TEXT_SEGS segments. We have to remove this section,
+	 * while shifting the content to the neighbors.
+	 */
+
+	int lengthRHS = 0, capacity, shift;
+
+	if (sectionPtr->prevPtr && !isLinkSegment && !IsBranchSection(sectionPtr->prevPtr)) {
+	    int lengthLHS = sectionPtr->prevPtr->length;
+	    assert(lengthLHS > 0);
+
+	    /*
+	     * Move segments to left neighbor, but regard that the
+	     * neighbor will not exceed NUM_TEXT_SEGS segments with
+	     * this operation.
+	     */
+
+	    if ((capacity = MAX(0, NUM_TEXT_SEGS - lengthLHS)) > 0) {
+		shift = MIN(capacity, length);
+		segPtr = sectionPtr->segPtr;
+		for ( ; lengthLHS < NUM_TEXT_SEGS && 0 < shift; --shift) {
+		    length -= 1;
+		    sectionPtr->prevPtr->size += segPtr->size;
+		    sectionPtr->prevPtr->length += 1;
+		    assert(sectionPtr->prevPtr->length != 0); /* test for overflow */
+		    sectionPtr->size -= segPtr->size;
+		    sectionPtr->length -= 1;
+		    segPtr->sectionPtr = sectionPtr->prevPtr;
+		    segPtr = segPtr->nextPtr;
+		}
+		sectionPtr->segPtr = segPtr;
+	    }
+	}
+
+	if (length > 0) {
+	    lengthRHS = sectionPtr->nextPtr->length;
+	    assert(lengthRHS > 0);
+
+	    /*
+	     * Move the remaining segments to right neighbor. Here
+	     * it may happen that MAX_TEXT_SEGS will be exceeded.
+	     */
+
+	    sectionPtr->nextPtr->segPtr = sectionPtr->segPtr;
+	    sectionPtr->nextPtr->size += sectionPtr->size;
+	    sectionPtr->nextPtr->length += sectionPtr->length;
+	    assert(sectionPtr->nextPtr->length >= sectionPtr->length); /* test for overflow */
+	    for (segPtr = sectionPtr->segPtr;
+		    segPtr && segPtr->sectionPtr == sectionPtr;
+		    segPtr = segPtr->nextPtr) {
+		segPtr->sectionPtr = sectionPtr->nextPtr;
+	    }
+	}
+
+	if (sectionPtr->prevPtr) {
+	    sectionPtr->prevPtr->nextPtr = sectionPtr->nextPtr;
+	}
+	sectionPtr->nextPtr->prevPtr = sectionPtr->prevPtr;
+	FreeSection(sectionPtr);
+
+	if (lengthRHS + length > MAX_TEXT_SEGS) {
+	    /*
+	     * Right shift operation has exceeded MAX_TEXT_SEGS, so we
+	     * have to split the right neighbor.
+	     */
+	    SplitSection(sectionPtr->nextPtr);
+	}
+    } else if (length > NUM_TEXT_SEGS) {
+	int lengthRHS, shift;
+
+	/*
+	 * Move some segments to the neighbors for a better dstribution,
+	 * but do not exceed NUM_TEXT_SEGS segments of the neighbors
+	 * with this operation. Also do not undershot NUM_TEXT_SEGS of
+	 * current section.
+	 */
+
+	if (sectionPtr->prevPtr
+		&& !isLinkSegment
+	    	&& !IsBranchSection(sectionPtr->prevPtr)) {
+	    int lengthLHS = sectionPtr->prevPtr->length;
+
+	    if (lengthLHS < NUM_TEXT_SEGS) {
+		shift = MIN(length - NUM_TEXT_SEGS, NUM_TEXT_SEGS - lengthLHS);
+		assert(shift < length);
+		if (shift > 0) {
+		    segPtr = sectionPtr->segPtr;
+		    for ( ; shift > 0; --shift, --length) {
+			sectionPtr->prevPtr->size += segPtr->size;
+			sectionPtr->prevPtr->length += 1;
+			assert(sectionPtr->prevPtr->length != 0); /* test for overflow */
+			sectionPtr->size -= segPtr->size;
+			sectionPtr->length -= 1;
+			segPtr->sectionPtr = sectionPtr->prevPtr;
+			segPtr = segPtr->nextPtr;
+		    }
+		    sectionPtr->segPtr = segPtr;
+		}
+	    }
+	}
+
+	if (sectionPtr->nextPtr && !isBranchSegment && !IsLinkSection(sectionPtr->nextPtr)) {
+	    lengthRHS = sectionPtr->nextPtr->length;
+
+	    if (lengthRHS < NUM_TEXT_SEGS) {
+		shift = MIN(length - NUM_TEXT_SEGS, NUM_TEXT_SEGS - lengthRHS);
+		assert(shift < length);
+		if (shift > 0) {
+		    int i;
+		    segPtr = sectionPtr->segPtr;
+		    for (i = length - shift; i > 0; --i) {
+			segPtr = segPtr->nextPtr;
+		    }
+		    sectionPtr->nextPtr->segPtr = segPtr;
+		    for ( ; shift > 0; --shift) {
+			sectionPtr->nextPtr->size += segPtr->size;
+			sectionPtr->nextPtr->length += 1;
+			assert(sectionPtr->nextPtr->length != 0); /* test for overflow */
+			sectionPtr->size -= segPtr->size;
+			sectionPtr->length -= 1;
+			segPtr->sectionPtr = sectionPtr->nextPtr;
+			segPtr = segPtr->nextPtr;
+		    }
+		    assert(segPtr->sectionPtr != sectionPtr);
+		}
+	    }
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * RebuildSections --
+ *
+ *	The line has massively changed, so we have to rebuild all the sections
+ *	in this line. This function will also recompute the total char size in
+ *	this line. Furthermore superfluous sections will be freed.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Possibly new sections will be allocated, some sections may be freed,
+ *	many sections will be modified, and the char size of the line will be
+ *	modified.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+PropagateChangeOfNumBranches(
+    Node *nodePtr,
+    int changeToNumBranches)
+{
+    for ( ; nodePtr; nodePtr = nodePtr->parentPtr) {
+	nodePtr->numBranches += changeToNumBranches;
+	assert((int) nodePtr->numBranches >= 0);
+    }
+}
+
+static void
+RebuildSections(
+    TkSharedText *sharedTextPtr,
+    TkTextLine *linePtr,		/* Pointer to existing line */
+    bool propagateChangeOfNumBranches)	/* Should we propagate a change in number of branches
+    					 * to B-Tree? */
+{
+    TkTextSection *sectionPtr, *prevSectionPtr;
+    TkTextSegment *segPtr;
+    unsigned length;
+    int changeToNumBranches;
+
+    prevSectionPtr = NULL;
+    sectionPtr = linePtr->segPtr->sectionPtr;
+
+    assert(!sectionPtr || !sectionPtr->prevPtr);
+    assert(!linePtr->lastPtr->nextPtr);
+    assert(!propagateChangeOfNumBranches
+	    || TkBTreeGetRoot(sharedTextPtr->tree)->numBranches >= linePtr->numBranches);
+
+    changeToNumBranches = -linePtr->numBranches;
+    linePtr->numBranches = 0;
+    linePtr->numLinks = 0;
+    linePtr->size = 0;
+
+    for (segPtr = linePtr->segPtr; segPtr; ) {
+	if (!sectionPtr) {
+	    TkTextSection *newSectionPtr;
+
+	    newSectionPtr = memset(malloc(sizeof(TkTextSection)), 0, sizeof(TkTextSection));
+	    if (prevSectionPtr) {
+		prevSectionPtr->nextPtr = newSectionPtr;
+	    } else {
+		linePtr->segPtr->sectionPtr = newSectionPtr;
+	    }
+	    newSectionPtr->prevPtr = prevSectionPtr;
+	    sectionPtr = newSectionPtr;
+	    DEBUG_ALLOC(tkTextCountNewSection++);
+	} else {
+	    sectionPtr->size = 0;
+	    sectionPtr->length = 0;
+	}
+
+	sectionPtr->segPtr = segPtr;
+	sectionPtr->linePtr = linePtr;
+
+	if (segPtr->typePtr == &tkTextLinkType) {
+	    linePtr->numLinks += 1;
+	}
+
+	/*
+	 * It is important to consider that a Branch is always at the end
+	 * of a section, and a Link is always at the start of a section.
+	 */
+
+	for (length = 0; length < NUM_TEXT_SEGS; ++length) {
+	    TkTextSegment *prevPtr = segPtr;
+
+	    sectionPtr->size += segPtr->size;
+	    sectionPtr->length += 1;
+	    assert(sectionPtr->length != 0); /* test for overflow */
+	    segPtr->sectionPtr = sectionPtr;
+	    segPtr = segPtr->nextPtr;
+
+	    if (prevPtr->typePtr == &tkTextBranchType) {
+		linePtr->numBranches += 1;
+		break;
+	    }
+	    if (!segPtr || segPtr->typePtr == &tkTextLinkType) {
+		break;
+	    }
+	}
+
+	linePtr->size += sectionPtr->size;
+	prevSectionPtr = sectionPtr;
+	sectionPtr = sectionPtr->nextPtr;
+    }
+
+    if (propagateChangeOfNumBranches && (changeToNumBranches += linePtr->numBranches) != 0) {
+	PropagateChangeOfNumBranches(linePtr->parentPtr, changeToNumBranches);
+    }
+
+    if (sectionPtr) {
+	/*
+	 * Free unused sections.
+	 */
+	if (sectionPtr->prevPtr) {
+	    sectionPtr->prevPtr->nextPtr = NULL;
+	}
+	FreeSections(sectionPtr);
+    }
+
+    assert(CheckSections(linePtr));
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * FreeSections --
+ *
+ *	This function is freeing all sections belonging to the text line
+ *	starting at sectionPtr.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	All the section structures in this line starting at sectionPtr will
+ *	be freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+FreeSections(
+    TkTextSection *sectionPtr)	/* Pointer to first section to be freed. */
+{
+    TkTextSection *nextPtr;
+
+    while (sectionPtr) {
+	assert(sectionPtr->linePtr); /* otherwise already freed */
+	nextPtr = sectionPtr->nextPtr;
+	FreeSection(sectionPtr);
+	sectionPtr = nextPtr;
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkBTreeFreeSegment --
+ *
+ *	Decrement reference counter and free the segment if not
+ *	referenced anymore.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The reference counter will be decrement, and if zero,
+ *	then the storage for this segment will be freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+void
+TkBTreeFreeSegment(
+    TkTextSegment *segPtr)
+{
+    assert(segPtr->refCount > 0);
+
+    if (--segPtr->refCount == 0) {
+	if (segPtr->tagInfoPtr) {
+	    TkTextTagSetDecrRefCount(segPtr->tagInfoPtr);
+	}
+	FREE_SEGMENT(segPtr);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * FreeLine --
+ *
+ *	Free all resources of the given line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Some storage will be freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+FreeLine(
+    const BTree *treePtr,
+    TkTextLine *linePtr)
+{
+    int i;
+
+    assert(linePtr->parentPtr);
+    DEBUG(linePtr->parentPtr = NULL);
+
+    for (i = 0; i < treePtr->numPixelReferences; ++i) {
+	TkTextDispLineInfo *dispLineInfo = linePtr->pixelInfo[i].dispLineInfo;
+
+	if (dispLineInfo) {
+	    free(dispLineInfo);
+	    DEBUG_ALLOC(tkTextCountDestroyDispInfo++);
+	}
+    }
+
+    TkTextTagSetDecrRefCount(linePtr->tagoffPtr);
+    TkTextTagSetDecrRefCount(linePtr->tagonPtr);
+    free(linePtr->pixelInfo);
+    DEBUG(linePtr->pixelInfo = NULL);
+    free(linePtr);
+    DEBUG_ALLOC(tkTextCountDestroyPixelInfo++);
+    DEBUG_ALLOC(tkTextCountDestroyLine++);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MakeCharSeg --
+ *
+ *	Make new char segment with given text.
+ *
+ * Results:
+ *	The return value is a pointer to the new segment.
+ *
+ * Side effects:
+ *	Storage for new segment will be allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextSegment *
+MakeCharSeg(
+    TkTextSection *sectionPtr,	/* Section of new segment, can be NULL. */
+    TkTextTagSet *tagInfoPtr,	/* Tga information for new segment, can be NULL. */
+    unsigned newSize,		/* Character size of the new segment. */
+    const char *string,		/* New text content. */
+    unsigned length)		/* Number of characters to copy. */
+{
+    unsigned capacity;
+    TkTextSegment *newPtr;
+
+    assert(length <= newSize);
+
+    capacity = CSEG_CAPACITY(newSize);
+    newPtr = memset(malloc(CSEG_SIZE(capacity)), 0, SEG_SIZE(0));
+    newPtr->typePtr = &tkTextCharType;
+    newPtr->sectionPtr = sectionPtr;
+    newPtr->size = newSize;
+    newPtr->refCount = 1;
+    memcpy(newPtr->body.chars, string, length);
+    memset(newPtr->body.chars + length, 0, capacity - length);
+    if ((newPtr->tagInfoPtr = tagInfoPtr)) {
+	TkTextTagSetIncrRefCount(tagInfoPtr);
+    }
+    DEBUG_ALLOC(tkTextCountNewSegment++);
+    return newPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CopyCharSeg --
+ *
+ *	Make new char segment, and copy text from given segment.
+ *
+ * Results:
+ *	The return value is a pointer to the new segment.
+ *
+ * Side effects:
+ *	Storage for new segment will be allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextSegment *
+CopyCharSeg(
+    TkTextSegment *segPtr,	/* Copy text from this segment. */
+    unsigned offset,		/* Copy text starting at this offset. */
+    unsigned length,		/* Number of characters to copy. */
+    unsigned newSize)		/* Character size of the new segment. */
+{
+    assert(segPtr);
+    assert(segPtr->typePtr == &tkTextCharType);
+    assert(segPtr->size >= offset + length);
+
+    return MakeCharSeg(segPtr->sectionPtr, segPtr->tagInfoPtr, newSize,
+	    segPtr->body.chars + offset, length);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * SplitCharSegment --
+ *
+ *	This function implements splitting for character segments.
+ *
+ * Results:
+ *	The return value is a pointer to a chain of two segments that have the
+ *	same characters as segPtr except split among the two segments.
+ *
+ * Side effects:
+ *	Storage for segPtr is freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextSegment *
+SplitCharSegment(
+    TkTextSegment *segPtr,	/* Pointer to segment to split. */
+    unsigned index)		/* Position within segment at which to split. */
+{
+    TkTextSegment *newPtr1, *newPtr2;
+
+    assert(segPtr);
+    assert(segPtr->typePtr == &tkTextCharType);
+    assert(segPtr->sectionPtr); /* otherwise segment is freed */
+    assert(index > 0);
+    assert(index < segPtr->size);
+
+    newPtr1 = CopyCharSeg(segPtr, 0, index, index);
+    newPtr2 = CopyCharSeg(segPtr, index, segPtr->size - index, segPtr->size - index);
+
+    newPtr1->nextPtr = newPtr2;
+    newPtr1->prevPtr = segPtr->prevPtr;
+    newPtr2->nextPtr = segPtr->nextPtr;
+    newPtr2->prevPtr = newPtr1;
+
+    if (segPtr->prevPtr) {
+	segPtr->prevPtr->nextPtr = newPtr1;
+    } else {
+	segPtr->sectionPtr->linePtr->segPtr = newPtr1;
+    }
+    if (segPtr->nextPtr) {
+	segPtr->nextPtr->prevPtr = newPtr2;
+    }
+    if (segPtr->sectionPtr->segPtr == segPtr) {
+	segPtr->sectionPtr->segPtr = newPtr1;
+    }
+    if (segPtr->sectionPtr->linePtr->lastPtr == segPtr) {
+	segPtr->sectionPtr->linePtr->lastPtr = newPtr2;
+    }
+    newPtr1->sectionPtr->length += 1;
+    assert(newPtr1->sectionPtr->length != 0); /* test for overflow */
+    TkBTreeFreeSegment(segPtr);
+    return newPtr1;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * IncreaseCharSegment --
+ *
+ *	This function make a larger (or smaller) char segment, the new
+ *	segment will replace the old one.
+ *
+ * Results:
+ *	The return value is a pointer to the new segment.
+ *
+ * Side effects:
+ *	Storage for old segment is freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextSegment *
+IncreaseCharSegment(
+    TkTextSegment *segPtr,	/* Pointer to segment. */
+    unsigned offset,		/* Split point in char segment. */
+    int chunkSize)		/* Add/subtract this size to the new segment. */
+{
+    TkTextSegment *newPtr;
+
+    assert(chunkSize != 0);
+
+    newPtr = CopyCharSeg(segPtr, 0, offset, segPtr->size + chunkSize);
+    if (chunkSize > 0) {
+	memcpy(newPtr->body.chars + offset + chunkSize,
+		segPtr->body.chars + offset,
+		segPtr->size - offset);
+    }
+    newPtr->nextPtr = segPtr->nextPtr;
+    newPtr->prevPtr = segPtr->prevPtr;
+
+    if (segPtr->prevPtr) {
+	segPtr->prevPtr->nextPtr = newPtr;
+    } else {
+	segPtr->sectionPtr->linePtr->segPtr = newPtr;
+    }
+    if (segPtr->nextPtr) {
+	segPtr->nextPtr->prevPtr = newPtr;
+    }
+    if (segPtr->sectionPtr) {
+	if (segPtr->sectionPtr->segPtr == segPtr) {
+	    segPtr->sectionPtr->segPtr = newPtr;
+	}
+	if (segPtr->sectionPtr->linePtr->lastPtr == segPtr) {
+	    segPtr->sectionPtr->linePtr->lastPtr = newPtr;
+	}
+    }
+    TkBTreeFreeSegment(segPtr);
+    return newPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * PrepareInsertIntoCharSeg --
+ *
+ *	This function is called within SplitSeg() to finalize the work:
+ *
+ *	a) We want to insert chars, and segPtr is a char segment, so
+ *	   we will change the size of the segment (this may require a
+ *	   replacement with a newly segment). If 'splitInfo->forceSplit'
+ *	   is set, and offset is not zero, then we must split because
+ *	   in this case the caller will insert chars with a trailing
+ *	   newline.
+ *
+ *	b) We want to insert chars, and segPtr is not a char segment,
+ *	   just return segPtr, the caller will insert a new segment.
+ *
+ *	c) We want to insert a non-char segment, so we must split
+ *	   anyway if offset > 0, and the latter case only happens
+ *	   in case of char segments.
+ *
+ * Results:
+ *	The return value is a pointer to a segment, probably NULL if the
+ *	given segment is NULL. 'splitInfo->offset' will be updated with
+ *	offset (insertion point) in increased/decreased segment, or with
+ *	-1 if we didn't increase/decrease the segment.
+ *
+ * Side effects:
+ *	The segment referred by 'segPtr' may become modified or replaced.
+ *	Pobably a new char segment will be inserted.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextSegment *
+PrepareInsertIntoCharSeg(
+    TkTextSegment *segPtr,	/* Split or modify this segment. */
+    unsigned offset,		/* Offset in segment. */
+    SplitInfo *splitInfo)	/* Additional arguments. */
+{
+    assert(splitInfo);
+    assert(!splitInfo->splitted);
+    assert(splitInfo->increase != 0);
+    assert(segPtr);
+    assert(segPtr->typePtr == &tkTextCharType);
+    assert(offset <= segPtr->size);
+    assert(offset < segPtr->size || segPtr->body.chars[segPtr->size - 1] != '\n');
+
+    /*
+     * We must not split if the new char content will be appended
+     * to the current content (i.e. offset == segPtr->size).
+     */
+
+    if (splitInfo->forceSplit && offset < segPtr->size) {
+	unsigned newSize, decreasedSize;
+	TkTextSegment *newPtr;
+
+	splitInfo->splitted = true;
+
+	if (offset == 0 && segPtr == segPtr->sectionPtr->linePtr->segPtr) {
+	    /*
+	     * This is a bit tricky: we are not doing a split here, because inserting
+	     * a newline at start of line is an implicit split (the callee inserts a
+	     * new line), and the callee has to know that he can join the next content
+	     * part into this char segment. Note that 'splitInfo->offset' is still
+	     * negative, this has the effect that this segment will be shifted to the
+	     * next line until an insertion of chars will be done.
+	     */
+	    return NULL;
+	}
+
+	/*
+	 * We must split after offset for the new line.
+	 */
+
+	newSize = segPtr->size - offset;
+	decreasedSize = segPtr->size - newSize;
+	newPtr = CopyCharSeg(segPtr, offset, newSize, newSize);
+	DEBUG(newPtr->sectionPtr = NULL);
+	memset(segPtr->body.chars + decreasedSize, 0, segPtr->size - decreasedSize);
+	segPtr->size = decreasedSize;
+	newPtr->size = 0; /* temporary; LinkSegment() should not change total size */
+	LinkSegment(segPtr->sectionPtr->linePtr, segPtr, newPtr);
+	newPtr->size = newSize;
+	SplitSection(segPtr->sectionPtr);
+    }
+
+    unsigned oldCapacity = CSEG_CAPACITY(segPtr->size);
+    unsigned newCapacity = CSEG_CAPACITY(segPtr->size + splitInfo->increase);
+
+    if (oldCapacity != newCapacity) {
+	/*
+	 * We replace this segment by a larger (or smaller) one.
+	 */
+	segPtr = IncreaseCharSegment(segPtr, offset, splitInfo->increase);
+    } else {
+	/*
+	 * This segment has the right capacity for new content, so it's just
+	 * an insertion/replacement. We did consider the trailing nul byte.
+	 */
+	if (splitInfo->increase > 0) {
+	    memmove(segPtr->body.chars + offset + splitInfo->increase,
+		    segPtr->body.chars + offset,
+		    segPtr->size - offset);
+	} else {
+	    memset(segPtr->body.chars + offset, 0, newCapacity - offset);
+	}
+	segPtr->size += splitInfo->increase;
+    }
+
+    splitInfo->offset = offset;
+    return segPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * SplitSeg --
+ *
+ *	This function is called before adding or deleting segments. It does
+ *	three things: (a) it finds the segment containing indexPtr; (b) if
+ *	there are several such segments (because some segments have zero
+ *	length) then it picks the first segment that does not have left
+ *	gravity; (c) if the index refers to the middle of a segment and we
+ *	want to insert a segment without chars (splitInfo is NULL), then it
+ *	splits the segment so that the index now refers to the beginning of
+ *	a segment.
+ *
+ * Results:
+ *	The return value is a pointer to the segment just before the segment
+ *	corresponding to indexPtr (as described above). If the segment
+ *	corresponding to indexPtr is the first in its line then the return
+ *	value is NULL.
+ *
+ * Side effects:
+ *	The segment referred to by indexPtr may be either split or replaced
+ *	by a larger one.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+CanInsertLeft(
+    const TkText *textPtr,
+    int offset,
+    TkTextSegment *segPtr)
+{
+    TkTextSegment *prevPtr;
+
+    assert(segPtr->tagInfoPtr);
+
+    if (!TkTextTagSetIsEmpty(segPtr->tagInfoPtr)) {
+	switch (textPtr->tagging) {
+	    case TK_TEXT_TAGGING_GRAVITY:
+		return offset > 0 || textPtr->insertMarkPtr->typePtr == &tkTextLeftMarkType;
+	    case TK_TEXT_TAGGING_WITHIN:
+		if (offset > 0) {
+		    return true; /* inserting into a char segment */
+		}
+		prevPtr = GetPrevTagInfoSegment(segPtr);
+		return prevPtr && TkTextTagSetContains(prevPtr->tagInfoPtr, segPtr->tagInfoPtr);
+	    case TK_TEXT_TAGGING_NONE:
+		if (offset == 0) {
+		    return false;
+		}
+		prevPtr = GetPrevTagInfoSegment(segPtr);
+		return !prevPtr || TkTextTagSetIsEmpty(prevPtr->tagInfoPtr);
+	}
+    }
+    return true;
+}
+
+static bool
+CanInsertRight(
+    const TkText *textPtr,
+    TkTextSegment *prevPtr,
+    TkTextSegment *segPtr)
+{
+    assert(prevPtr->tagInfoPtr);
+
+    switch (textPtr->tagging) {
+	case TK_TEXT_TAGGING_GRAVITY:
+	    return textPtr->insertMarkPtr->typePtr == &tkTextRightMarkType;
+	case TK_TEXT_TAGGING_WITHIN:
+	    return TkTextTagSetContains(GetNextTagInfoSegment(segPtr)->tagInfoPtr, prevPtr->tagInfoPtr);
+	case TK_TEXT_TAGGING_NONE:
+	    return TkTextTagSetIsEmpty(prevPtr->tagInfoPtr);
+    }
+    return false; /* never reached */
+}
+
+static TkTextSegment *
+SplitSeg(
+    const TkTextIndex *indexPtr,/* Index identifying position at which to split a segment. */
+    SplitInfo *splitInfo)	/* Additional arguments for split, only given when inserting chars. */
+{
+    TkTextSegment *segPtr;
+    int count;
+
+    if (splitInfo) {
+	/*
+	 * We assume that 'splitInfo' is already initialized.
+	 */
+
+	assert(splitInfo->offset == -1);
+	assert(splitInfo->increase != 0);
+	assert(!splitInfo->splitted);
+    }
+
+    assert(indexPtr->textPtr || !splitInfo);
+
+    if (TkTextIndexGetShared(indexPtr)->steadyMarks) {
+	/*
+	 * With steadymarks we need the exact position, if given by a mark.
+	 */
+
+	segPtr = TkTextIndexGetSegment(indexPtr);
+	if (segPtr && segPtr->typePtr->group == SEG_GROUP_MARK) {
+	    count = 0;
+	} else {
+	    segPtr = TkTextIndexGetFirstSegment(indexPtr, &count);
+	}
+    } else {
+	segPtr = TkTextIndexGetFirstSegment(indexPtr, &count);
+    }
+
+    for ( ; segPtr; segPtr = segPtr->nextPtr) {
+	if (segPtr->size > count) {
+	    if (splitInfo && segPtr->typePtr == &tkTextCharType) {
+		TkTextSegment *prevPtr;
+
+		if (splitInfo->tagInfoPtr
+		    	? TkTextTagSetIsEqual(segPtr->tagInfoPtr, splitInfo->tagInfoPtr)
+			: CanInsertLeft(indexPtr->textPtr, count, segPtr)) {
+		    /*
+		     * Insert text into this char segment.
+		     */
+		    splitInfo->tagInfoPtr = segPtr->tagInfoPtr;
+		    return PrepareInsertIntoCharSeg(segPtr, count, splitInfo);
+		}
+		if (count > 0) {
+		    /*
+		     * We have different tags for the new char segment, so we need a split.
+		     */
+		    return SplitCharSegment(segPtr, count);
+		}
+		if ((prevPtr = segPtr->prevPtr)
+			&& prevPtr->typePtr == &tkTextCharType
+			&& (splitInfo->tagInfoPtr
+			    ? TkTextTagSetIsEqual(prevPtr->tagInfoPtr, splitInfo->tagInfoPtr)
+			    : CanInsertRight(indexPtr->textPtr, prevPtr, segPtr))) {
+		    /*
+		     * Append more content at the end of the preceding char segment.
+		     */
+		    splitInfo->tagInfoPtr = prevPtr->tagInfoPtr;
+		    return PrepareInsertIntoCharSeg(prevPtr, prevPtr->size, splitInfo);
+		}
+	    }
+	    if (count == 0) {
+		/*
+		 * We are one segment too far ahead. This case must
+		 * also catch hyphens, embedded images, and windows.
+		 */
+		return segPtr->prevPtr;
+	    }
+	    /*
+	     * Actually a split of a char segment necessary.
+	     */
+	    segPtr = SplitCharSegment(segPtr, count);
+	    TkTextIndexToByteIndex((TkTextIndex *) indexPtr); /* mutable due to concept */
+	    return segPtr;
+	}
+	if (count == 0 && segPtr->typePtr->gravity == GRAVITY_RIGHT) {
+	    TkTextSegment *prevPtr = segPtr->prevPtr;
+	    assert(segPtr->size == 0);
+	    if (splitInfo
+		    && prevPtr
+		    && prevPtr->typePtr == &tkTextCharType
+		    && (splitInfo->tagInfoPtr
+			? TkTextTagSetIsEqual(prevPtr->tagInfoPtr, splitInfo->tagInfoPtr)
+			: CanInsertRight(indexPtr->textPtr, prevPtr, segPtr))) {
+		/*
+		 * Append more content at the end of the preceding char segment.
+		 */
+		splitInfo->tagInfoPtr = prevPtr->tagInfoPtr;
+		return PrepareInsertIntoCharSeg(prevPtr, prevPtr->size, splitInfo);
+	    }
+	    /*
+	     * Right gravity is inserting at left side.
+	     */
+	    return prevPtr;
+	}
+	count -= segPtr->size;
+    }
+    assert(!"SplitSeg reached end of line!");
+    return NULL;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkBTreeMakeCharSegment --
+ *
+ *	Make new char segment with given text.
+ *
+ * Results:
+ *	The return value is a pointer to the new segment.
+ *
+ * Side effects:
+ *	Storage for new segment will be allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+TkTextSegment *
+TkBTreeMakeCharSegment(
+    const char *string,
+    unsigned length,
+    TkTextTagSet *tagInfoPtr)	/* can be NULL */
+{
+    TkTextSegment *newPtr;
+    unsigned memsize = CSEG_SIZE(length + 1);
+
+    assert(string);
+    assert(tagInfoPtr);
+
+    newPtr = memset(malloc(memsize), 0, memsize);
+    newPtr->typePtr = &tkTextCharType;
+    newPtr->size = length;
+    newPtr->refCount = 1;
+    TkTextTagSetIncrRefCount(newPtr->tagInfoPtr = tagInfoPtr);
+    memcpy(newPtr->body.chars, string, length);
+    newPtr->body.chars[length] = '\0';
+    DEBUG_ALLOC(tkTextCountNewSegment++);
+    return newPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UpdateNodeTags --
+ *
+ *	Update the node tag information after the tag information in any
+ *	line of this node has been changed.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Information is deleted/added from/to the B-tree.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+RemoveTagoffFromNode(
+    Node *nodePtr,
+    TkTextTag *tagPtr)
+{
+    Node *parentPtr;
+    unsigned tagIndex = tagPtr->index;
+
+    assert(tagPtr);
+    assert(!tagPtr->isDisabled);
+    assert(nodePtr->level == 0);
+    assert(TkTextTagSetTest(nodePtr->tagoffPtr, tagIndex));
+
+    nodePtr->tagoffPtr = TagSetErase(nodePtr->tagoffPtr, tagPtr);
+
+    while ((parentPtr = nodePtr->parentPtr)) {
+	for (nodePtr = parentPtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+	    if (TkTextTagSetTest(nodePtr->tagonPtr, tagIndex)) {
+		return; /* still referenced in this node */
+	    }
+	}
+	parentPtr->tagoffPtr = TagSetErase(nodePtr->tagoffPtr, tagPtr);
+    }
+}
+
+static void
+AddTagoffToNode(
+    Node *nodePtr,
+    const TkTextTagSet *tagoffPtr)
+{
+    assert(nodePtr->level == 0);
+
+    do {
+	nodePtr->tagoffPtr = TkTextTagSetJoin(nodePtr->tagoffPtr, tagoffPtr);
+    } while ((nodePtr = nodePtr->parentPtr));
+}
+
+static void
+UpdateNodeTags(
+    const TkSharedText *sharedTextPtr,
+    Node *nodePtr)
+{
+    const TkTextLine *linePtr = nodePtr->linePtr;
+    const TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+    TkTextTagSet *tagonPtr;
+    TkTextTagSet *tagoffPtr;
+    TkTextTagSet *additionalTagoffPtr;
+    TkTextTagSet *nodeTagonPtr;
+    TkTextTagSet *nodeTagoffPtr;
+    unsigned i;
+
+    assert(nodePtr->level == 0);
+    assert(linePtr);
+
+    TkTextTagSetIncrRefCount(tagonPtr = linePtr->tagonPtr);
+    TkTextTagSetIncrRefCount(tagoffPtr = linePtr->tagoffPtr);
+    TkTextTagSetIncrRefCount(additionalTagoffPtr = tagonPtr);
+    TkTextTagSetIncrRefCount(nodeTagonPtr = nodePtr->tagonPtr);
+    TkTextTagSetIncrRefCount(nodeTagoffPtr = nodePtr->tagoffPtr);
+
+    if (linePtr != lastPtr) {
+	for (linePtr = linePtr->nextPtr; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+	    tagonPtr = TkTextTagSetJoin(tagonPtr, linePtr->tagonPtr);
+	    tagoffPtr = TkTextTagSetJoin(tagoffPtr, linePtr->tagoffPtr);
+	    additionalTagoffPtr = TagSetIntersect(additionalTagoffPtr, linePtr->tagonPtr, sharedTextPtr);
+	}
+    }
+
+    if (!TkTextTagSetIsEqual(tagonPtr, nodeTagonPtr) || !TkTextTagSetIsEqual(tagoffPtr, nodeTagoffPtr)) {
+	if (additionalTagoffPtr) {
+	    tagoffPtr = TagSetJoinComplementTo(tagoffPtr, additionalTagoffPtr, tagonPtr, sharedTextPtr);
+	    TkTextTagSetDecrRefCount(additionalTagoffPtr);
+	} else {
+	    TagSetAssign(&tagoffPtr, tagonPtr);
+	}
+
+	for (i = TkTextTagSetFindFirst(nodeTagonPtr);
+		i != TK_TEXT_TAG_SET_NPOS;
+		i = TkTextTagSetFindNext(nodeTagonPtr, i)) {
+	    if (!TkTextTagSetTest(tagonPtr, i)) {
+		RemoveTagFromNode(nodePtr, sharedTextPtr->tagLookup[i]);
+	    }
+	}
+
+	for (i = TkTextTagSetFindFirst(tagonPtr);
+		i != TK_TEXT_TAG_SET_NPOS;
+		i = TkTextTagSetFindNext(tagonPtr, i)) {
+	    if (!TkTextTagSetTest(nodeTagonPtr, i)) {
+		AddTagToNode(nodePtr, sharedTextPtr->tagLookup[i], false);
+	    }
+	}
+
+	if (!TkTextTagSetContains(tagoffPtr, nodeTagoffPtr)) {
+	    for (i = TkTextTagSetFindFirst(nodeTagoffPtr);
+		    i != TK_TEXT_TAG_SET_NPOS;
+		    i = TkTextTagSetFindNext(nodeTagoffPtr, i)) {
+		if (!TkTextTagSetTest(tagoffPtr, i) && TkTextTagSetTest(tagonPtr, i)) {
+		    RemoveTagoffFromNode(nodePtr, sharedTextPtr->tagLookup[i]);
+		}
+	    }
+	}
+
+	AddTagoffToNode(nodePtr, tagoffPtr);
+
+	assert(TkTextTagSetIsEqual(tagonPtr, nodePtr->tagonPtr));
+	assert(TkTextTagSetIsEqual(tagoffPtr, nodePtr->tagoffPtr));
+    } else if (additionalTagoffPtr) {
+	TkTextTagSetDecrRefCount(additionalTagoffPtr);
+    }
+
+    TkTextTagSetDecrRefCount(tagonPtr);
+    TkTextTagSetDecrRefCount(tagoffPtr);
+    TkTextTagSetDecrRefCount(nodeTagonPtr);
+    TkTextTagSetDecrRefCount(nodeTagoffPtr);
+}
+/*
+ *----------------------------------------------------------------------
+ *
+ * DeleteRange --
+ *
+ *	Delete a range of segments from a B-tree. The caller must make sure
+ *	that the final newline of the B-tree will not be affected.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Information is deleted from the B-tree. This can cause the internal
+ *	structure of the B-tree to change.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+SetNodeFirstPointer(
+    Node *nodePtr,
+    TkTextLine *linePtr)
+{
+    TkTextLine *oldLinePtr = nodePtr->linePtr;
+
+    nodePtr->linePtr = linePtr;
+    while ((nodePtr = nodePtr->parentPtr) && nodePtr->linePtr == oldLinePtr) {
+	nodePtr->linePtr = linePtr;
+    }
+}
+
+static void
+MoveSegmentToLeft(
+    TkTextSegment *branchPtr,
+    TkTextSegment *movePtr)	/* movePtr will become a predecessor of branchPtr */
+{
+    assert(movePtr);
+    assert(branchPtr);
+    assert(branchPtr->sectionPtr->linePtr == movePtr->sectionPtr->linePtr);
+    assert(movePtr->nextPtr != branchPtr);
+    assert(branchPtr->nextPtr);
+    assert(movePtr->prevPtr);
+
+    movePtr->prevPtr->nextPtr = movePtr->nextPtr;
+    if (movePtr->nextPtr) {
+	movePtr->nextPtr->prevPtr = movePtr->prevPtr;
+    }
+    movePtr->nextPtr = branchPtr;
+
+    if (branchPtr->prevPtr) {
+	branchPtr->prevPtr->nextPtr = movePtr;
+    }
+    branchPtr->prevPtr = movePtr;
+
+    /*
+     * We don't care about the sections, they will be rebuilt later,
+     * but ensure that the order of the sections will not change.
+     */
+
+    if (--movePtr->sectionPtr->length == 0) {
+	FreeSection(movePtr->sectionPtr);
+    }
+    movePtr->sectionPtr = branchPtr->sectionPtr;
+}
+
+static void
+MoveSegmentToRight(
+    TkTextSegment *linkPtr,
+    TkTextSegment *movePtr)	/* movePtr will become a successor of linkPtr */
+{
+    assert(movePtr);
+    assert(linkPtr);
+    assert(linkPtr->sectionPtr->linePtr == movePtr->sectionPtr->linePtr);
+    assert(movePtr->prevPtr != linkPtr);
+    assert(linkPtr->prevPtr);
+    assert(movePtr->nextPtr);
+
+    if (movePtr->prevPtr) {
+	movePtr->prevPtr->nextPtr = movePtr->nextPtr;
+    }
+    movePtr->nextPtr->prevPtr = movePtr->prevPtr;
+    movePtr->prevPtr = linkPtr;
+
+    if (linkPtr->nextPtr) {
+	linkPtr->nextPtr->prevPtr = movePtr;
+    }
+    linkPtr->nextPtr = movePtr;
+
+    /*
+     * We don't care about the sections, they will be rebuilt later,
+     * but ensure that the order of the sections will not change.
+     */
+
+    if (--linkPtr->sectionPtr->length == 0) {
+	FreeSection(linkPtr->sectionPtr);
+    }
+    linkPtr->sectionPtr = movePtr->sectionPtr;
+}
+
+static void
+DeleteRange(
+    TkSharedText *sharedTextPtr,/* Handle to shared text resource. */
+    TkTextSegment *firstSegPtr,	/* Indicates the segment just before where the deletion starts. */
+    TkTextSegment *lastSegPtr,	/* Indicates the last segment where the deletion stops (exclusive
+    				 * this segment). FirstSegPtr and lastSegPtr may belong to
+				 * different lines. */
+    int flags,			/* Flags controlling the deletion. If DELETE_INCLUSIVE is set then
+    				 * also firstSegPtr and lastSegPtr will be deleted. */
+    TkTextUndoInfo *undoInfo)	/* Store undo information, can be NULL. */
+{
+    BTree *treePtr;
+    TkTextSegment *prevPtr;
+    TkTextSegment *nextPtr;
+    TkTextSegment *segPtr;
+    TkTextSegment **segments;
+    TkTextSegment *prevLinkPtr;
+    TkTextSection *firstSectionPtr;
+    TkTextSection *prevSectionPtr;
+    TkTextSection *lastSectionPtr;
+    TkTextSection *sectionPtr;
+    TkTextLine *linePtr1;
+    TkTextLine *linePtr2;
+    TkTextLine *nextLinePtr;
+    TkTextLine *curLinePtr;
+    Node *curNodePtr;
+    Node *nodePtr1;
+    Node *nodePtr2;
+    unsigned numSegments;
+    unsigned maxSegments;
+    unsigned byteSize;
+    unsigned lineDiff;
+    bool steadyMarks;
+    int lineNo1;
+    int lineNo2;
+
+    assert(firstSegPtr);
+    assert(lastSegPtr);
+    assert(!undoInfo || undoInfo->token);
+
+    assert(!(flags & DELETE_INCLUSIVE)
+	    || firstSegPtr->typePtr->group & (SEG_GROUP_MARK|SEG_GROUP_PROTECT));
+    assert(!(flags & DELETE_INCLUSIVE)
+	    || lastSegPtr->typePtr->group & (SEG_GROUP_MARK|SEG_GROUP_PROTECT));
+    assert((firstSegPtr->typePtr->group == SEG_GROUP_PROTECT) ==
+	    (lastSegPtr->typePtr->group == SEG_GROUP_PROTECT));
+
+    assert(firstSegPtr->nextPtr);
+
+    if (TkBTreeHaveElidedSegments(sharedTextPtr)) {
+	/*
+	 * Include the surrounding branches and links into the deletion range.
+	 */
+
+	assert(firstSegPtr->typePtr != &tkTextBranchType);
+	assert(lastSegPtr->typePtr != &tkTextLinkType);
+
+	if (!sharedTextPtr->steadyMarks || !TkTextIsStableMark(firstSegPtr)) {
+	    for (segPtr = firstSegPtr->prevPtr; segPtr && segPtr->size == 0; segPtr = segPtr->prevPtr) {
+		if (segPtr->typePtr == &tkTextBranchType) {
+		    /* firstSegPtr will become predecessor of this branch */
+		    MoveSegmentToLeft(segPtr, firstSegPtr);
+		    segPtr = firstSegPtr;
+		}
+	    }
+	}
+
+	if (!sharedTextPtr->steadyMarks || !TkTextIsStableMark(lastSegPtr)) {
+	    for (segPtr = lastSegPtr->nextPtr; segPtr && segPtr->size == 0; segPtr = segPtr->nextPtr) {
+		if (segPtr->typePtr == &tkTextLinkType) {
+		    /* lastSegPtr will become successor of this link */
+		    MoveSegmentToRight(segPtr, lastSegPtr);
+		    segPtr = lastSegPtr;
+		}
+	    }
+	}
+    }
+
+    treePtr = (BTree *) sharedTextPtr->tree;
+    curLinePtr = firstSegPtr->sectionPtr->linePtr;
+    sectionPtr = curLinePtr->segPtr->sectionPtr;
+    prevSectionPtr = curLinePtr->lastPtr->sectionPtr;
+    prevPtr = firstSegPtr;
+    segPtr = firstSegPtr->nextPtr;
+    steadyMarks = sharedTextPtr->steadyMarks;
+    numSegments = 0;
+    segments = NULL;
+
+    linePtr1 = sectionPtr->linePtr;
+    linePtr2 = lastSegPtr->sectionPtr->linePtr;
+    nodePtr1 = linePtr1->parentPtr;
+    nodePtr2 = linePtr2->parentPtr;
+    lineNo1 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, linePtr1, NULL);
+    lineNo2 = linePtr1 == linePtr2 ? lineNo1 : TkBTreeLinesTo(sharedTextPtr->tree, NULL, linePtr2, NULL);
+    lineDiff = linePtr1->size;
+
+    SetLineHasChanged(sharedTextPtr, linePtr1);
+    if (linePtr1 != linePtr2) {
+	SetLineHasChanged(sharedTextPtr, linePtr2);
+    }
+
+    if (undoInfo) {
+	/* reserve the first entry if needed */
+	numSegments = (flags & DELETE_INCLUSIVE) && TkTextIsStableMark(firstSegPtr) ? 1 : 0;
+	maxSegments = 100;
+	segments = malloc(maxSegments * sizeof(TkTextSegment *));
+	DEBUG(segments[0] = NULL);
+    } else {
+	flags |= DELETE_BRANCHES;
+    }
+
+    /*
+     * This line now needs to have its height recalculated. This has to be done
+     * before the lines will be removed.
+     */
+
+    TkTextInvalidateLineMetrics(treePtr->sharedTextPtr, NULL,
+	    linePtr1, lineNo2 - lineNo1, TK_TEXT_INVALIDATE_DELETE);
+
+    /*
+     * Connect start and end point.
+     */
+
+    firstSegPtr->nextPtr = lastSegPtr;
+    lastSegPtr->prevPtr = firstSegPtr;
+
+    if (nodePtr1 != nodePtr2 && nodePtr2->lastPtr == linePtr2) {
+	/*
+	 * This node is going to be deleted.
+	 */
+	nodePtr2 = NULL;
+    }
+
+    /*
+     * Delete all of the segments between firstSegPtr (exclusive) and lastSegPtr (exclusive).
+     */
+
+    curNodePtr = curLinePtr->parentPtr;
+    assert(curLinePtr->nextPtr);
+    prevLinkPtr = NULL;
+    firstSectionPtr = NULL;
+    lastSectionPtr = NULL;
+    byteSize = 0;
+
+    while (segPtr != lastSegPtr) {
+	if (!segPtr) {
+	    /*
+	     * We just ran off the end of a line.
+	     */
+
+	    if (curLinePtr != linePtr1) {
+		/*
+		 * Join unused section, RebuildSections will reuse/delete those sections.
+		 */
+
+		prevSectionPtr->nextPtr = firstSectionPtr;
+		firstSectionPtr->prevPtr = prevSectionPtr;
+		prevSectionPtr = lastSectionPtr;
+
+		if (curNodePtr == nodePtr1 || curNodePtr == nodePtr2) {
+		    /*
+		     * Update only those nodes which will not be deleted,
+		     * because DeleteEmptyNode will do a faster update.
+		     */
+		    SubtractPixelInfo(treePtr, curLinePtr);
+		    if (curLinePtr->numBranches) {
+			PropagateChangeOfNumBranches(curLinePtr->parentPtr, -curLinePtr->numBranches);
+		    }
+		}
+
+		if (--curNodePtr->numChildren == 0) {
+		    DeleteEmptyNode(treePtr, curNodePtr);
+		}
+	    }
+	    curLinePtr = curLinePtr->nextPtr;
+	    curNodePtr = curLinePtr->parentPtr;
+	    segPtr = curLinePtr->segPtr;
+	    firstSectionPtr = curLinePtr->segPtr->sectionPtr;
+	    lastSectionPtr = curLinePtr->lastPtr->sectionPtr;
+	} else {
+	    assert(segPtr->sectionPtr->linePtr == curLinePtr);
+	    assert(segPtr->typePtr->deleteProc);
+	    nextPtr = segPtr->nextPtr;
+	    byteSize += segPtr->size;
+	    if (undoInfo && !TkTextIsSpecialOrPrivateMark(segPtr)) {
+		if (numSegments == maxSegments) {
+		    maxSegments = MAX(50, numSegments * 2);
+		    segments = realloc(segments, maxSegments * sizeof(TkTextSegment *));
+		}
+		if (segPtr->tagInfoPtr) {
+		    segPtr->tagInfoPtr = TagSetRemoveBits(segPtr->tagInfoPtr,
+			    sharedTextPtr->dontUndoTags, sharedTextPtr);
+		}
+		segments[numSegments++] = segPtr;
+		segPtr->refCount += 1;
+	    }
+	    if (!segPtr->typePtr->deleteProc((TkTextBTree) treePtr, segPtr, flags)) {
+		assert(segPtr->typePtr); /* really still living? */
+		assert(segPtr->typePtr->group == SEG_GROUP_MARK
+			|| segPtr->typePtr->group == SEG_GROUP_BRANCH);
+
+		if (prevLinkPtr && segPtr->typePtr == &tkTextBranchType) {
+		    /*
+		     * This is a superfluous link/branch pair, delete both.
+		     */
+
+		    /* make new relationship (old one is already saved) */
+		    prevLinkPtr->body.link.prevPtr->body.branch.nextPtr = segPtr->body.branch.nextPtr;
+		    segPtr->body.branch.nextPtr->body.link.prevPtr = prevLinkPtr->body.link.prevPtr;
+		    /* remove this pair from chain */
+		    nextPtr = segPtr->nextPtr;
+		    UnlinkSegment(segPtr);
+		    TkBTreeFreeSegment(segPtr);
+		    UnlinkSegmentAndCleanup(sharedTextPtr, prevLinkPtr);
+		    TkBTreeFreeSegment(prevLinkPtr);
+		    if (nextPtr->prevPtr && nextPtr->prevPtr->typePtr == &tkTextCharType) {
+			TkTextSegment *sPtr = CleanupCharSegments(sharedTextPtr, nextPtr);
+			if (sPtr != nextPtr) { nextPtr = nextPtr->nextPtr; }
+		    }
+		    prevLinkPtr = NULL;
+		} else {
+		    /*
+		     * This segment refuses to die, it's either a switch with a counterpart
+		     * outside of the deletion range, or it's a mark. Link this segment
+		     * after prevPtr.
+		     */
+
+		    assert(prevPtr);
+		    DEBUG(segPtr->sectionPtr = NULL);
+
+		    if (segPtr->typePtr == &tkTextLinkType) {
+			assert(!prevLinkPtr);
+			prevLinkPtr = segPtr;
+			LinkSwitch(linePtr1, prevPtr, segPtr);
+
+			if (prevPtr->typePtr->group != SEG_GROUP_MARK) {
+			    prevPtr = segPtr;
+			}
+		    } else {
+			assert(segPtr->typePtr->group == SEG_GROUP_MARK);
+			LinkMark(sharedTextPtr, linePtr1, prevPtr, segPtr);
+
+			/*
+			 * Option 'steadymarks' is off:
+			 * 'prevPtr' will be advanced only if the segment don't has right gravity.
+			 *
+			 * Option 'steadymarks' is on:
+			 * 'prevPtr' will always be advanced, because we keep the order of the marks.
+			 */
+
+			if (steadyMarks || segPtr->typePtr->gravity != GRAVITY_RIGHT) {
+			    prevPtr = segPtr;
+			}
+		    }
+
+		    assert(segPtr->prevPtr);
+		    segPtr->sectionPtr = segPtr->prevPtr->sectionPtr;
+
+		    if (segments && !TkTextIsSpecialOrPrivateMark(segPtr)) {
+			/* Mark this segment as re-inserted. */
+			MARK_POINTER(segments[numSegments - 1]);
+		    }
+
+		    /*
+		     * Prevent an overflow of the section length, because this may happen
+		     * when deleting segments. The section length doesn't matter here,
+		     * because the section structure will be rebuilt later. But LinkSegment
+		     * will trap into an assertion if we do not prevent this.
+		     */
+		    DEBUG(segPtr->sectionPtr->length = 0);
+		}
+	    }
+	    segPtr = nextPtr;
+	}
+    }
+
+    nextLinePtr = linePtr1->nextPtr;
+
+    if (linePtr1 != linePtr2) {
+	/*
+	 * Finalize update of B-tree (children and pixel count).
+	 */
+
+	nodePtr2 = linePtr2->parentPtr;
+	if (nodePtr1 != nodePtr2) {
+	    SetNodeLastPointer(nodePtr1, linePtr1);
+	}
+
+	if (--nodePtr2->numChildren == 0) {
+	    assert(nodePtr2->lastPtr == linePtr2);
+	    DeleteEmptyNode(treePtr, nodePtr2);
+	    nodePtr2 = NULL;
+	} else {
+	    SubtractPixelInfo(treePtr, linePtr2);
+	    assert(nodePtr2->lastPtr != linePtr2 || nodePtr1 == nodePtr2);
+	    if (nodePtr1 != nodePtr2) {
+		SetNodeFirstPointer(nodePtr2, linePtr2->nextPtr);
+	    } else if (nodePtr2->lastPtr == linePtr2) {
+		SetNodeLastPointer(nodePtr2, linePtr1);
+	    }
+	    assert(nodePtr2->numLines == nodePtr2->numChildren);
+	}
+
+	/*
+	 * The beginning and end of the deletion range are in different lines,
+	 * so join the two lines and discard the ending line.
+	 */
+
+	linePtr1->lastPtr = linePtr2->lastPtr;
+	if ((linePtr1->nextPtr = linePtr2->nextPtr)) {
+	    linePtr1->nextPtr->prevPtr = linePtr1;
+	}
+	prevSectionPtr->nextPtr = firstSectionPtr;
+	firstSectionPtr->prevPtr = prevSectionPtr;
+    }
+
+    if (TkBTreeHaveElidedSegments(sharedTextPtr)) {
+	/*
+	 * We have moved surrounding branches and links into the deletion range,
+	 * now we have to revert this (for remaining switches) before RebuildSections
+	 * will be invoked.
+	 */
+
+	if (firstSegPtr->size == 0 && firstSegPtr->nextPtr->typePtr == &tkTextBranchType) {
+	    TkTextSegment *leftSegPtr = firstSegPtr;
+	    TkTextSegment *branchPtr = firstSegPtr;
+
+	    while (leftSegPtr && leftSegPtr->prevPtr && leftSegPtr->prevPtr->size == 0) {
+		leftSegPtr = leftSegPtr->prevPtr;
+	    }
+	    do {
+		TkTextSegment *nextPtr = branchPtr->nextPtr;
+		/* branchPtr will become a predecessor of leftSegPtr */
+		MoveSegmentToLeft(leftSegPtr, branchPtr);
+		branchPtr = nextPtr;
+	    } while (branchPtr->typePtr == &tkTextBranchType);
+	}
+
+	if (lastSegPtr->size == 0
+		&& lastSegPtr->prevPtr
+		&& lastSegPtr->prevPtr->typePtr == &tkTextLinkType) {
+	    TkTextSegment *rightPtr = lastSegPtr;
+	    TkTextSegment *linkPtr = lastSegPtr->prevPtr;
+
+	    while (rightPtr && rightPtr->nextPtr->size == 0) {
+		rightPtr = rightPtr->nextPtr;
+	    }
+	    do {
+		TkTextSegment *prevPtr = linkPtr->prevPtr;
+		/* linkPtr will become a successor of rightPtr */
+		MoveSegmentToRight(rightPtr, linkPtr);
+		linkPtr = prevPtr;
+	    } while (linkPtr && linkPtr->typePtr == &tkTextLinkType);
+	}
+    }
+
+    /*
+     * Rebuild the sections in the new line. This must be done before other
+     * cleanups will be done. Be sure that the first segment really points
+     * to the first section, because LinkSegment may have changed this pointer.
+     */
+
+    linePtr1->segPtr->sectionPtr = sectionPtr;
+    RebuildSections(sharedTextPtr, linePtr1, true);
+
+    /*
+     * Recompute the line tag information of first line.
+     */
+
+    RecomputeLineTagInfo(linePtr1, NULL, sharedTextPtr);
+
+    /*
+     * Update the size of the node which holds the first line.
+     */
+
+    lineDiff -= linePtr1->size;
+    for (curNodePtr = nodePtr1; curNodePtr; curNodePtr = curNodePtr->parentPtr) {
+	curNodePtr->size -= lineDiff;
+    }
+
+    /*
+     * Finally delete the bounding segments if necessary. This cannot be
+     * done before RebuildSections has been performed. We are doing this
+     * as a separate step, this is avoiding special cases in the main
+     * deletion loop. Also consider that only marks (including protection
+     * marks) are allowed as deletable boundaries.
+     */
+
+    if (flags & DELETE_INCLUSIVE) {
+	unsigned countChanges = 0;
+
+	assert(firstSegPtr->typePtr->group & (SEG_GROUP_MARK|SEG_GROUP_PROTECT));
+	assert(lastSegPtr->typePtr->group & (SEG_GROUP_MARK|SEG_GROUP_PROTECT));
+
+	/*
+	 * Do not unlink the special/private marks.
+	 * And don't forget the undo chain.
+	 */
+
+	if (!TkTextIsSpecialOrPrivateMark(firstSegPtr)) {
+	    UnlinkSegment(firstSegPtr);
+	    assert(firstSegPtr->typePtr->deleteProc);
+	    if (!firstSegPtr->typePtr->deleteProc((TkTextBTree) treePtr, firstSegPtr, flags)) {
+		assert(!"mark refuses to die"); /* this should not happen */
+	    } else if (segments && TkTextIsStableMark(firstSegPtr)) {
+		firstSegPtr->refCount += 1;
+		assert(!segments[0]); /* this slot must be reserved */
+		segments[0] = firstSegPtr;
+	    }
+	    countChanges += 1;
+	}
+	if (!TkTextIsSpecialOrPrivateMark(lastSegPtr)) {
+	    UnlinkSegment(lastSegPtr);
+	    assert(lastSegPtr->typePtr->deleteProc);
+	    if (!lastSegPtr->typePtr->deleteProc((TkTextBTree) treePtr, lastSegPtr, flags)) {
+		assert(!"mark refuses to die"); /* this should not happen */
+	    } else if (segments && TkTextIsStableMark(lastSegPtr)) {
+		if (numSegments == maxSegments) {
+		    maxSegments += 2;
+		    segments = realloc(segments, maxSegments * sizeof(TkTextSegment *));
+		}
+		segments[numSegments++] = lastSegPtr;
+		lastSegPtr->refCount += 1;
+	    }
+	    countChanges += 1;
+	}
+	if (countChanges == 0) {
+	    flags &= ~DELETE_INCLUSIVE;
+	}
+    }
+
+    /*
+     * Do final update of nodes which contains the first/last line. This
+     * has to be performed before any rebalance of the B-Tree will be done.
+     */
+
+    if (nodePtr2 && nodePtr2 != nodePtr1) {
+	assert(nodePtr2 == linePtr2->nextPtr->parentPtr);
+	UpdateNodeTags(sharedTextPtr, nodePtr2);
+    }
+    UpdateNodeTags(sharedTextPtr, nodePtr1);
+
+    /*
+     * Now its time to deallocate all unused lines.
+     */
+
+    curLinePtr = nextLinePtr;
+    nextLinePtr = linePtr2->nextPtr;
+    while (curLinePtr != nextLinePtr) {
+	TkTextLine *nextLinePtr = curLinePtr->nextPtr;
+	FreeLine(treePtr, curLinePtr);
+	curLinePtr = nextLinePtr;
+    }
+
+    /*
+     * Finish the setup of the redo information.
+     */
+
+    if (undoInfo) {
+	UndoTokenDelete *undoToken = (UndoTokenDelete *) undoInfo->token;
+
+	assert(numSegments == 0 || segments[0]);
+
+	if (numSegments + 1 != maxSegments) {
+	    segments = realloc(segments, (numSegments + 1)*sizeof(TkTextSegment *));
+	}
+	undoToken->segments = segments;
+	undoToken->numSegments = numSegments;
+	undoToken->inclusive = !!(flags & DELETE_INCLUSIVE);
+	undoInfo->byteSize = byteSize;
+    }
+
+#if SUPPORT_DEPRECATED_STARTLINE_ENDLINE
+    {
+	TkText *peer;
+	bool oldBTreeDebug = tkBTreeDebug;
+
+	tkBTreeDebug = false;
+
+	/*
+	 * We have to adjust startline/endline.
+	 */
+
+	for (peer = sharedTextPtr->peers; peer; peer = peer->next) {
+	    if (peer->startLine) {
+		peer->startLine = peer->startMarker->sectionPtr->linePtr;
+		if (!SegIsAtStartOfLine(peer->startMarker)) {
+		    TkTextIndex index;
+		    TkTextIndexClear2(&index, NULL, sharedTextPtr->tree);
+		    TkTextIndexSetToStartOfLine2(&index, peer->startLine);
+		    TkBTreeUnlinkSegment(sharedTextPtr, peer->startMarker);
+		    TkBTreeLinkSegment(sharedTextPtr, peer->startMarker, &index);
+		}
+	    }
+	    if (peer->endLine) {
+		TkTextLine *endLinePtr = peer->endMarker->sectionPtr->linePtr;
+		bool atEndOfLine = SegIsAtEndOfLine(peer->endMarker);
+		bool atStartOfLine = SegIsAtStartOfLine(peer->endMarker);
+
+		if ((!atEndOfLine || atStartOfLine) && peer->startLine != endLinePtr) {
+		    TkTextIndex index;
+
+		    assert(endLinePtr->prevPtr);
+		    TkTextInvalidateLineMetrics(NULL, peer, endLinePtr->prevPtr, 1,
+			    TK_TEXT_INVALIDATE_DELETE);
+		    peer->endLine = endLinePtr;
+		    TkTextIndexClear2(&index, NULL, sharedTextPtr->tree);
+		    TkTextIndexSetToLastChar2(&index, endLinePtr->prevPtr);
+		    TkBTreeUnlinkSegment(sharedTextPtr, peer->endMarker);
+		    TkBTreeLinkSegment(sharedTextPtr, peer->endMarker, &index);
+		} else {
+		    assert(endLinePtr->nextPtr);
+		    peer->endLine = endLinePtr->nextPtr;
+		}
+	    }
+	}
+
+	tkBTreeDebug = oldBTreeDebug;
+    }
+#endif
+
+    /*
+     * Don't forget to increase the epoch.
+     */
+
+    TkBTreeIncrEpoch(sharedTextPtr->tree);
+
+    /*
+     * Rebalance the node of the last deleted line, but only if the start line is
+     * not contained in same node.
+     */
+
+    if (nodePtr2 && nodePtr2 != nodePtr1) {
+	Rebalance(treePtr, nodePtr2);
+	nodePtr1 = linePtr1->parentPtr; /* may have changed during rebalancing */
+    }
+
+    /*
+     * Lastly, rebalance the first node of the range.
+     */
+
+    if (linePtr1 != linePtr2) {
+	Rebalance(treePtr, nodePtr1);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeDeleteIndexRange --
+ *
+ *	Delete a range of characters from a B-tree. The caller must make sure
+ *	that the final newline of the B-tree is never deleted.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Information is deleted from the B-tree. This can cause the internal
+ *	structure of the B-tree to change. Note: because of changes to the
+ *	B-tree structure, the indices pointed to by indexPtr1 and indexPtr2
+ *	should not be used after this function returns.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+DeleteIndexRange(
+    TkSharedText *sharedTextPtr,/* Handle to shared text resource. */
+    TkTextIndex *indexPtr1,	/* Indicates first character that is to be deleted. */
+    TkTextIndex *indexPtr2,	/* Indicates character just after the last one that is to be deleted. */
+    int flags,			/* Flags controlling the deletion. */
+    const UndoTokenInsert *undoToken,
+    				/* Perform undo, can be NULL. */
+    TkTextUndoInfo *redoInfo)	/* Store undo information, can be NULL. */
+{
+    TkTextSegment *segPtr1;	/* The segment just before the start of the deletion range. */
+    TkTextSegment *segPtr2;	/* The segment just after the end of the deletion range. */
+    TkTextSegment *firstPtr;
+    TkTextSegment *lastPtr;
+    TkTextLine *linePtr1 = TkTextIndexGetLine(indexPtr1);
+    TkTextLine *linePtr2 = TkTextIndexGetLine(indexPtr2);
+    int myFlags = flags;
+
+    assert(sharedTextPtr);
+    assert(indexPtr1->tree == indexPtr2->tree);
+    assert(indexPtr1->textPtr == indexPtr2->textPtr);
+    assert((flags & DELETE_MARKS)
+	    ? TkTextIndexCompare(indexPtr1, indexPtr2) <= 0
+	    : TkTextIndexCompare(indexPtr1, indexPtr2) < 0);
+
+    /*
+     * Take care when doing the splits, none of the resulting segment pointers
+     * should become invalid, so we will use protection marks to avoid this.
+     */
+
+    segPtr1 = TkTextIndexGetSegment(indexPtr1);
+    segPtr2 = TkTextIndexGetSegment(indexPtr2);
+
+    assert(!sharedTextPtr->protectionMark[0]->sectionPtr); /* this protection mark must be unused */
+    assert(!sharedTextPtr->protectionMark[1]->sectionPtr); /* this protection mark must be unused */
+
+    if (segPtr1 && TkTextIsStableMark(segPtr1)) {
+	firstPtr = segPtr1;
+	if (!(flags & DELETE_INCLUSIVE) && !(segPtr2 && TkTextIsStableMark(segPtr2))) {
+	    LinkSegment(linePtr1, segPtr1->prevPtr, firstPtr = sharedTextPtr->protectionMark[0]);
+	    myFlags |= DELETE_INCLUSIVE;
+	}
+    } else {
+	segPtr1 = SplitSeg(indexPtr1, NULL);
+	if (segPtr1) { segPtr1->protectionFlag = true; }
+	LinkSegment(linePtr1, segPtr1, firstPtr = sharedTextPtr->protectionMark[0]);
+	myFlags |= DELETE_INCLUSIVE;
+    }
+
+    if (segPtr2 && TkTextIsStableMark(segPtr2)) {
+	lastPtr = segPtr2;
+	if (!(flags & DELETE_INCLUSIVE) && (myFlags & DELETE_INCLUSIVE)) {
+	    LinkSegment(linePtr2, segPtr2, lastPtr = sharedTextPtr->protectionMark[1]);
+	}
+    } else {
+	segPtr2 = SplitSeg(indexPtr2, NULL);
+	LinkSegment(linePtr2, segPtr2, lastPtr = sharedTextPtr->protectionMark[1]);
+	segPtr2 = lastPtr->nextPtr;
+	segPtr2->protectionFlag = true;
+	myFlags |= DELETE_INCLUSIVE;
+    }
+
+    TkBTreeIncrEpoch(sharedTextPtr->tree);
+
+    if (redoInfo) {
+	UndoTokenDelete *redoToken;
+
+	redoToken = malloc(sizeof(UndoTokenDelete));
+	redoToken->undoType = &undoTokenDeleteType;
+	redoToken->segments = NULL;
+	redoToken->numSegments = 0;
+	if (undoToken) {
+	    redoToken->startIndex = undoToken->startIndex;
+	    redoToken->endIndex = undoToken->endIndex;
+	} else {
+	    if (segPtr1 && TkTextIsStableMark(segPtr1) && !(flags & DELETE_MARKS)) {
+		redoToken->startIndex.u.markPtr = segPtr1;
+		redoToken->startIndex.lineIndex = -1;
+	    } else {
+		TkTextIndex index = *indexPtr1;
+		TkTextIndexSetSegment(&index, firstPtr);
+		MakeUndoIndex(sharedTextPtr, &index, &redoToken->startIndex, GRAVITY_LEFT);
+	    }
+	    if (segPtr2 && TkTextIsStableMark(segPtr2) && !(flags & DELETE_MARKS)) {
+		redoToken->endIndex.u.markPtr = segPtr2;
+		redoToken->endIndex.lineIndex = -1;
+	    } else {
+		TkTextIndex index = *indexPtr2;
+		TkTextIndexSetSegment(&index, lastPtr);
+		MakeUndoIndex(sharedTextPtr, &index, &redoToken->endIndex, GRAVITY_RIGHT);
+	    }
+	}
+	redoInfo->token = (TkTextUndoToken *) redoToken;
+	redoInfo->byteSize = 0;
+	DEBUG_ALLOC(tkTextCountNewUndoToken++);
+    }
+
+    DeleteRange(sharedTextPtr, firstPtr, lastPtr, myFlags, redoInfo);
+
+    CleanupSplitPoint(segPtr1, sharedTextPtr);
+    CleanupSplitPoint(segPtr2, sharedTextPtr);
+
+    /*
+     * The indices are no longer valid.
+     */
+
+    DEBUG(TkTextIndexInvalidate(indexPtr1));
+    DEBUG(TkTextIndexInvalidate(indexPtr2));
+
+    TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+}
+
+void
+TkBTreeDeleteIndexRange(
+    TkSharedText *sharedTextPtr,/* Handle to shared text resource. */
+    TkTextIndex *indexPtr1,	/* Indicates first character that is to be deleted. */
+    TkTextIndex *indexPtr2,	/* Indicates character just after the last one that is to be deleted. */
+    int flags,			/* Flags controlling the deletion. */
+    TkTextUndoInfo *undoInfo)	/* Store undo information, can be NULL. */
+{
+    DeleteIndexRange(sharedTextPtr, indexPtr1, indexPtr2, flags, NULL, undoInfo);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeFindLine --
+ *
+ *	Find a particular line in a B-tree based on its line number.
+ *
+ * Results:
+ *	The return value is a pointer to the line structure for the line whose
+ *	index is "line", or NULL if no such line exists.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextLine *
+TkBTreeFindLine(
+    TkTextBTree tree,		/* B-tree in which to find line. */
+    const TkText *textPtr,	/* Relative to this client of the B-tree. */
+    int line)			/* Index of desired line. */
+{
+    BTree *treePtr = (BTree *) tree;
+    Node *nodePtr;
+    TkTextLine *linePtr;
+
+    assert(tree || textPtr);
+
+    if (!treePtr) {
+	tree = textPtr->sharedTextPtr->tree;
+	treePtr = (BTree *) tree;
+    }
+
+    nodePtr = treePtr->rootPtr;
+    if (line < 0 || nodePtr->numLines <= line) {
+	return NULL;
+    }
+
+    /*
+     * Check for any start/end offset for this text widget.
+     */
+
+    if (textPtr) {
+	line += TkBTreeLinesTo(tree, NULL, TkBTreeGetStartLine(textPtr), NULL);
+	if (line >= nodePtr->numLines) {
+	    return NULL;
+	}
+	if (line > TkBTreeLinesTo(tree, NULL, TkBTreeGetLastLine(textPtr), NULL)) {
+	    return NULL;
+	}
+    }
+
+    if (line == 0) {
+	return nodePtr->linePtr;
+    }
+    if (line == nodePtr->numLines - 1) {
+	return nodePtr->lastPtr;
+    }
+
+    /*
+     * Work down through levels of the tree until a node is found at level 0.
+     */
+
+    while (nodePtr->level > 0) {
+	for (nodePtr = nodePtr->childPtr;
+		nodePtr && nodePtr->numLines <= line;
+		nodePtr = nodePtr->nextPtr) {
+	    line -= nodePtr->numLines;
+	}
+	assert(nodePtr);
+    }
+
+    /*
+     * Work through the lines attached to the level-0 node.
+     */
+
+    for (linePtr = nodePtr->linePtr; line > 0; linePtr = linePtr->nextPtr, --line) {
+	assert(linePtr != nodePtr->lastPtr->nextPtr);
+    }
+    return linePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeFindPixelLine --
+ *
+ *	Find a particular line in a B-tree based on its pixel count.
+ *
+ * Results:
+ *	The return value is a pointer to the line structure for the line which
+ *	contains the pixel "pixels", or NULL if no such line exists. If the
+ *	first line is of height 20, then pixels 0-19 will return it, and
+ *	pixels = 20 will return the next line.
+ *
+ *	If pixelOffset is non-NULL, it is set to the amount by which 'pixels'
+ *	exceeds the first pixel located on the returned line. This should
+ *	always be non-negative.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextLine *
+TkBTreeFindPixelLine(
+    TkTextBTree tree,		/* B-tree to use. */
+    const TkText *textPtr,	/* Relative to this client of the B-tree. */
+    int pixels,			/* Pixel index of desired line. */
+    int32_t *pixelOffset)	/* Used to return offset. */
+{
+    BTree *treePtr = (BTree *) tree;
+    Node *nodePtr;
+    TkTextLine *linePtr;
+    unsigned pixelReference;
+
+    assert(textPtr);
+    assert(textPtr->pixelReference != -1);
+
+    pixelReference = textPtr->pixelReference;
+    nodePtr = treePtr->rootPtr;
+
+    if (0 > pixels) {
+	return NULL;
+    }
+    if (pixels >= nodePtr->pixelInfo[pixelReference].pixels) {
+	return TkBTreeGetLastLine(textPtr);
+    }
+
+    /*
+     * Work down through levels of the tree until a node is found at level 0.
+     */
+
+    while (nodePtr->level != 0) {
+	for (nodePtr = nodePtr->childPtr;
+		nodePtr->pixelInfo[pixelReference].pixels <= pixels;
+		nodePtr = nodePtr->nextPtr) {
+	    assert(nodePtr);
+	    pixels -= nodePtr->pixelInfo[pixelReference].pixels;
+	}
+    }
+
+    /*
+     * Work through the lines attached to the level-0 node.
+     */
+
+    for (linePtr = nodePtr->linePtr;
+	    linePtr->pixelInfo[pixelReference].height <= pixels;
+	    linePtr = linePtr->nextPtr) {
+	assert(linePtr != nodePtr->lastPtr->nextPtr);
+	pixels -= linePtr->pixelInfo[pixelReference].height;
+    }
+
+    assert(linePtr);
+
+    if (textPtr->endMarker != textPtr->sharedTextPtr->endMarker) {
+	TkTextLine *endLinePtr = textPtr->endMarker->sectionPtr->linePtr;
+
+	if (TkBTreeLinesTo(tree, textPtr, linePtr, NULL) >
+		TkBTreeLinesTo(tree, textPtr, endLinePtr, NULL)) {
+	    linePtr = endLinePtr;
+	}
+    }
+
+    if (pixelOffset) {
+	*pixelOffset = pixels;
+    }
+
+    return linePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreePixelsTo --
+ *
+ *	Given a pointer to a line in a B-tree, return the numerical pixel
+ *	index of the top of that line (i.e. the result does not include the
+ *	height of the logical line for given line).
+ *
+ *	Since the last line of text (the artificial one) has zero height by
+ *	defintion, calling this with the last line will return the total
+ *	number of pixels in the widget.
+ *
+ * Results:
+ *	The result is the pixel height of the top of the logical line which
+ *	belongs to given line.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkBTreePixelsTo(
+    const TkText *textPtr,	/* Relative to this client of the B-tree. */
+    const TkTextLine *linePtr)	/* Pointer to existing line in B-tree. */
+{
+    const TkSharedText *sharedTextPtr;
+    Node *nodePtr, *parentPtr;
+    unsigned pixelReference;
+    unsigned index;
+
+    assert(textPtr);
+    assert(textPtr->pixelReference != -1);
+
+    if (linePtr == TkBTreeGetStartLine(textPtr)) {
+	return 0;
+    }
+
+    pixelReference = textPtr->pixelReference;
+    sharedTextPtr = textPtr->sharedTextPtr;
+
+    if (linePtr == TkBTreeGetLastLine(textPtr)) {
+	index = ((BTree *) sharedTextPtr->tree)->rootPtr->pixelInfo[pixelReference].pixels;
+    } else {
+	linePtr = TkBTreeGetLogicalLine(sharedTextPtr, textPtr, (TkTextLine *) linePtr);
+
+	/*
+	 * First count how many pixels precede this line in its level-0 node.
+	 */
+
+	nodePtr = linePtr->parentPtr;
+	index = 0;
+
+	if (linePtr == nodePtr->lastPtr->nextPtr) {
+	    index = nodePtr->pixelInfo[pixelReference].pixels;
+	} else {
+	    TkTextLine *linePtr2;
+
+	    for (linePtr2 = nodePtr->linePtr; linePtr2 != linePtr; linePtr2 = linePtr2->nextPtr) {
+		assert(linePtr2);
+		assert(linePtr2->pixelInfo);
+		index += linePtr2->pixelInfo[pixelReference].height;
+	    }
+	}
+
+	/*
+	 * Now work up through the levels of the tree one at a time, counting how
+	 * many pixels are in nodes preceding the current node.
+	 */
+
+	for (parentPtr = nodePtr->parentPtr;
+		parentPtr;
+		nodePtr = parentPtr, parentPtr = parentPtr->parentPtr) {
+	    Node *nodePtr2;
+
+	    for (nodePtr2 = parentPtr->childPtr; nodePtr2 != nodePtr; nodePtr2 = nodePtr2->nextPtr) {
+		assert(nodePtr2);
+		index += nodePtr2->pixelInfo[pixelReference].pixels;
+	    }
+	}
+    }
+
+    return index;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeLinesTo --
+ *
+ *	Given a pointer to a line in a B-tree, return the numerical index of
+ *	that line.
+ *
+ * Results:
+ *	The result is the index of linePtr within the tree, where zero
+ *	corresponds to the first line in the tree. also the derivation
+ *	will be set (if given), in case that the given line is before
+ *	first line in this widget the deviation will be positive, and
+ *	if given line is after last line in this client then the deviation
+ *	will be negative.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkBTreeLinesTo(
+    TkTextBTree tree,
+    const TkText *textPtr,	/* Relative to this client of the B-tree, can be NULL. */
+    const TkTextLine *linePtr,	/* Pointer to existing line in B-tree. */
+    int *deviation)		/* Deviation to existing line, can be NULL. */
+{
+    const TkTextLine *linePtr2;
+    const Node *nodePtr;
+    const Node *parentPtr;
+    const Node *nodePtr2;
+    unsigned index;
+
+    assert(linePtr);
+
+    if (textPtr) {
+	if (linePtr == textPtr->startMarker->sectionPtr->linePtr) {
+	    if (deviation) { *deviation = 0; }
+	    return 0;
+	}
+	if (!linePtr->nextPtr && textPtr->endMarker == textPtr->sharedTextPtr->endMarker) {
+	    if (deviation) { *deviation = 0; }
+	    return TkBTreeGetRoot(tree)->numLines - 1;
+	}
+    } else {
+	if (!linePtr->prevPtr) {
+	    if (deviation) { *deviation = 0; }
+	    return 0;
+	}
+	if (!linePtr->nextPtr) {
+	    if (deviation) { *deviation = 0; }
+	    return TkBTreeGetRoot(tree)->numLines - 1;
+	}
+    }
+
+    /*
+     * First count how many lines precede this one in its level-0 node.
+     */
+
+    nodePtr = linePtr->parentPtr;
+    index = 0;
+    for (linePtr2 = nodePtr->linePtr; linePtr2 != linePtr; linePtr2 = linePtr2->nextPtr) {
+	assert(linePtr2);
+	index += 1;
+    }
+
+    /*
+     * Now work up through the levels of the tree one at a time, counting how
+     * many lines are in nodes preceding the current node.
+     */
+
+    for (parentPtr = nodePtr->parentPtr;
+	    parentPtr;
+	    nodePtr = parentPtr, parentPtr = parentPtr->parentPtr) {
+	for (nodePtr2 = parentPtr->childPtr; nodePtr2 != nodePtr; nodePtr2 = nodePtr2->nextPtr) {
+	    assert(nodePtr2);
+	    index += nodePtr2->numLines;
+	}
+    }
+
+    if (textPtr) {
+        /*
+         * The index to return must be relative to textPtr, not to the entire
+         * tree. Take care to never return a negative index when linePtr
+         * denotes a line before -startindex, or an index larger than the
+         * number of lines in textPtr when linePtr is a line past -endindex.
+         */
+
+        unsigned indexStart, indexEnd;
+
+	indexStart = TkBTreeLinesTo(tree, NULL, TkBTreeGetStartLine(textPtr), NULL);
+	indexEnd = TkBTreeLinesTo(tree, NULL, TkBTreeGetLastLine(textPtr), NULL);
+
+        if (index < indexStart) {
+	    if (deviation) { *deviation = indexStart - index; }
+            index = 0;
+        } else if (index > indexEnd) {
+	    if (deviation) { *deviation = indexEnd - index; }
+            index = indexEnd;
+        } else {
+	    if (deviation) { *deviation = 0; }
+            index -= indexStart;
+        }
+    } else if (deviation) {
+	*deviation = 0;
+    }
+
+    return index;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeLinkSegment --
+ *
+ *	This function adds a new segment to a B-tree at a given location.
+ *	This function cannot be used for char segments, or for switches.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	'segPtr' will be linked into its tree.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeLinkSegment(
+    const TkSharedText *sharedTextPtr,
+    				/* Handle to shared text resource. */
+    TkTextSegment *segPtr,	/* Pointer to new segment to be added to
+				 * B-tree. Should be completely initialized by caller except for
+				 * nextPtr field. */
+    TkTextIndex *indexPtr)	/* Where to add segment: it gets linked in just before the segment
+    				 * indicated here. */
+{
+    TkTextSegment *prevPtr;
+    TkTextLine *linePtr;
+
+    assert(!segPtr->sectionPtr); /* otherwise still in use */
+    assert(segPtr->typePtr->group != SEG_GROUP_CHAR);
+    assert(segPtr->typePtr->group != SEG_GROUP_PROTECT);
+    assert(segPtr->typePtr->group != SEG_GROUP_BRANCH);
+    assert(segPtr->size == 0 || segPtr->tagInfoPtr || indexPtr->textPtr);
+
+    linePtr = TkTextIndexGetLine(indexPtr);
+
+    if (sharedTextPtr->steadyMarks) {
+	prevPtr = TkTextIndexGetSegment(indexPtr);
+
+	if (prevPtr && prevPtr->typePtr->group == SEG_GROUP_MARK) {
+	    /*
+	     * We have steady marks, and the insertion point is a mark segment,
+	     * so insert the new segment according to the gravity of this mark.
+	     */
+
+	    if (prevPtr->typePtr == &tkTextRightMarkType) {
+		prevPtr = prevPtr->prevPtr;
+	    }
+	} else {
+	    prevPtr = SplitSeg(indexPtr, NULL);
+	}
+    } else {
+	prevPtr = SplitSeg(indexPtr, NULL);
+    }
+
+    if (segPtr->typePtr->group == SEG_GROUP_MARK) {
+	LinkMark(sharedTextPtr, linePtr, prevPtr, segPtr);
+    } else {
+	LinkSegment(linePtr, prevPtr, segPtr);
+    }
+    SplitSection(segPtr->sectionPtr);
+    TkBTreeIncrEpoch(indexPtr->tree);
+
+    if (segPtr->size > 0) {
+	TkTextSegment *prevPtr = segPtr->prevPtr;
+	TkTextSegment *nextPtr = segPtr->nextPtr;
+	TkTextTagSet *tagoffPtr;
+	Node *nodePtr;
+
+	SetLineHasChanged(sharedTextPtr, linePtr);
+
+	/*
+	 * We have to update the tag information of the line and the related node.
+	 */
+
+	while (prevPtr && !prevPtr->tagInfoPtr) {
+	    prevPtr = prevPtr->prevPtr;
+	}
+	while (nextPtr && !nextPtr->tagInfoPtr) {
+	    nextPtr = nextPtr->nextPtr;
+	}
+
+	if (segPtr->tagInfoPtr) {
+	    linePtr->tagonPtr = TkTextTagSetJoin(linePtr->tagonPtr, segPtr->tagInfoPtr);
+	} else {
+	    segPtr->tagInfoPtr = MakeTagInfo(indexPtr->textPtr, segPtr);
+	}
+
+	TkTextTagSetIncrRefCount(tagoffPtr = sharedTextPtr->emptyTagInfoPtr);
+	if (prevPtr) { tagoffPtr = TkTextTagSetJoin(tagoffPtr, prevPtr->tagInfoPtr); }
+	if (nextPtr) { tagoffPtr = TkTextTagSetJoin(tagoffPtr, nextPtr->tagInfoPtr); }
+	tagoffPtr = TkTextTagSetRemove(tagoffPtr, segPtr->tagInfoPtr);
+
+	if (!TkTextTagSetContains(linePtr->tagoffPtr, tagoffPtr)) {
+	    linePtr->tagoffPtr = TkTextTagSetJoin(linePtr->tagoffPtr, tagoffPtr);
+	    AddTagoffToNode(linePtr->parentPtr, tagoffPtr);
+	}
+	TkTextTagSetDecrRefCount(tagoffPtr);
+
+	/*
+	 * Propagate change of size in B-Tree.
+	 */
+
+	for (nodePtr = linePtr->parentPtr; nodePtr; nodePtr = nodePtr->parentPtr) {
+	    nodePtr->size += segPtr->size;
+	}
+    }
+
+    TK_BTREE_DEBUG(TkBTreeCheck(indexPtr->tree));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeUnlinkSegment --
+ *
+ *	This function unlinks a segment from its line in a B-tree.
+ *	This function cannot be used for char segments, or for switches.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	SegPtr will be unlinked from linePtr. The segment itself isn't
+ *	modified by this function, but the section containing this
+ *	segment will be modified.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeUnlinkSegment(
+    const TkSharedText *sharedTextPtr,
+    TkTextSegment *segPtr)	/* Segment to be unlinked. */
+{
+    TkTextSegment *prevPtr;
+    TkTextSection *sectionPtr;
+    TkTextLine *linePtr;
+
+    assert(segPtr->typePtr != &tkTextCharType);
+    assert(segPtr->typePtr != &tkTextLinkType);
+    assert(segPtr->typePtr != &tkTextBranchType);
+    assert(segPtr->typePtr != &tkTextHyphenType);
+    assert(segPtr->typePtr->group != SEG_GROUP_PROTECT);
+    assert(segPtr->typePtr->group != SEG_GROUP_BRANCH);
+
+    prevPtr = segPtr->prevPtr;
+    sectionPtr = segPtr->sectionPtr;
+    assert(sectionPtr); /* segment is already freed? */
+    assert(sectionPtr->linePtr); /* section is already freed? */
+    UnlinkSegment(segPtr);
+    linePtr = sectionPtr->linePtr;
+    JoinSections(sectionPtr);
+    if (prevPtr && prevPtr->typePtr == &tkTextCharType) {
+	CleanupCharSegments(sharedTextPtr, prevPtr);
+    }
+    TkBTreeIncrEpoch(sharedTextPtr->tree);
+
+    assert((segPtr->size == 0) == !segPtr->tagInfoPtr);
+
+    if (segPtr->size > 0) {
+	Node *nodePtr;
+
+	SetLineHasChanged(sharedTextPtr, linePtr);
+
+	if (!TkTextTagSetIsEmpty(linePtr->tagoffPtr)) {
+	    RecomputeLineTagInfo(sectionPtr->linePtr, NULL, sharedTextPtr);
+	    UpdateNodeTags(sharedTextPtr, sectionPtr->linePtr->parentPtr);
+	}
+
+	/*
+	 * Propagate change of size in B-Tree.
+	 */
+
+	for (nodePtr = linePtr->parentPtr; nodePtr; nodePtr = nodePtr->parentPtr) {
+	    nodePtr->size -= segPtr->size;
+	}
+    }
+
+    TK_BTREE_DEBUG(if (!segPtr->startEndMarkFlag) TkBTreeCheck(sharedTextPtr->tree));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * AddTagToNode --
+ *
+ *	Add the specified tag to the given node, so we can check whether
+ *	any segment in this node contains this tag.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Updates the tag information of some nodes in the B-Tree.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static unsigned
+CountChildsWithTag(
+    const Node *nodePtr,
+    unsigned tagIndex)
+{
+    unsigned count = 0;
+
+    if (nodePtr->level == 0) {
+	const TkTextLine *linePtr;
+	const TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+
+	for (linePtr = nodePtr->linePtr; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+	    if (TkTextTagSetTest(linePtr->tagonPtr, tagIndex)) {
+		count += 1;
+	    }
+	}
+    } else {
+	const Node *childPtr;
+
+	for (childPtr = nodePtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+	    if (TkTextTagSetTest(childPtr->tagonPtr, tagIndex)) {
+		count += 1;
+	    }
+	}
+    }
+
+    return count;
+}
+
+static void
+AddTagToNode(
+    Node *nodePtr,
+    TkTextTag *tagPtr,
+    bool setTagoff)
+{
+    unsigned rootLevel;
+
+    assert(tagPtr);
+    assert(!tagPtr->isDisabled);
+    assert(nodePtr->level == 0);
+
+    if (!tagPtr->rootPtr) {
+	tagPtr->rootPtr = nodePtr;
+    }
+
+    rootLevel = tagPtr->rootPtr->level;
+
+    do {
+	TkTextTagSet *tagInfoPtr = TagSetTestAndSet(nodePtr->tagonPtr, tagPtr);
+
+	if (!tagInfoPtr) {
+	    Node *rootPtr = nodePtr;
+
+	    /*
+	     * This tag is already included, but possibly we have to push up the tag root.
+	     */
+
+	    while (rootLevel < rootPtr->level) {
+		rootLevel = (tagPtr->rootPtr = tagPtr->rootPtr->parentPtr)->level;
+	    }
+	    while (rootLevel == rootPtr->level && rootPtr != tagPtr->rootPtr) {
+		rootLevel = (tagPtr->rootPtr = tagPtr->rootPtr->parentPtr)->level;
+		rootPtr = rootPtr->parentPtr;
+	    }
+
+	    if (setTagoff) {
+		/*
+		 * And still we have to propagate the tagoff information.
+		 */
+
+		do {
+		    if (!(tagInfoPtr = TagSetTestAndSet(nodePtr->tagoffPtr, tagPtr))) {
+			return;
+		    }
+		    nodePtr->tagoffPtr = tagInfoPtr;
+		} while ((nodePtr = nodePtr->parentPtr));
+	    }
+
+	    return;
+	}
+
+	nodePtr->tagonPtr = tagInfoPtr;
+
+	if (setTagoff) {
+	    nodePtr->tagoffPtr = TagSetAdd(nodePtr->tagoffPtr, tagPtr);
+	} else {
+	    unsigned nchilds = CountChildsWithTag(nodePtr, tagPtr->index);
+
+	    if (nchilds == 0) {
+		nodePtr->tagoffPtr = TagSetErase(nodePtr->tagoffPtr, tagPtr);
+		assert(!nodePtr->parentPtr || nodePtr->parentPtr->numChildren > 1);
+		setTagoff = true; /* but parent now has tagoff */
+	    } else if (nchilds < nodePtr->numLines) {
+		nodePtr->tagoffPtr = TagSetAdd(nodePtr->tagoffPtr, tagPtr);
+		setTagoff = true; /* propagate to parent */
+	    }
+	}
+
+	if (rootLevel == nodePtr->level && nodePtr != tagPtr->rootPtr) {
+	    /*
+	     * The old tag root is at the same level in the tree as this node,
+	     * but it isn't at this node. Move the tag root up one level.
+	     */
+	    rootLevel = (tagPtr->rootPtr = tagPtr->rootPtr->parentPtr)->level;
+	}
+    } while ((nodePtr = nodePtr->parentPtr));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * RemoveTagFromNode --
+ *
+ *	Remove the specified tag from the given node, so we can check whether
+ *	any segment in this node contains this tag.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Updates the tag information of some nodes in the B-Tree.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+RemoveTagFromNode(
+    Node *nodePtr,
+    TkTextTag *tagPtr)
+{
+    Node *parentPtr;
+
+    assert(tagPtr);
+    assert(!tagPtr->isDisabled);
+    assert(nodePtr->level == 0);
+    assert(TkTextTagSetTest(nodePtr->tagonPtr, tagPtr->index));
+
+    nodePtr->tagonPtr = TagSetErase(nodePtr->tagonPtr, tagPtr);
+    nodePtr->tagoffPtr = TagSetErase(nodePtr->tagoffPtr, tagPtr);
+
+    if (nodePtr == tagPtr->rootPtr) {
+	tagPtr->rootPtr = NULL;
+
+	while ((nodePtr = nodePtr->parentPtr)) {
+	    nodePtr->tagonPtr = TagSetErase(nodePtr->tagonPtr, tagPtr);
+	    nodePtr->tagoffPtr = TagSetErase(nodePtr->tagoffPtr, tagPtr);
+	};
+    } else if ((parentPtr = nodePtr->parentPtr)) {
+	unsigned tagIndex = tagPtr->index;
+	Node *childPtr = NULL;
+
+	tagPtr->rootPtr = NULL;
+
+	do {
+	    unsigned count = 0;
+
+	    /*
+	     * Test if any of the children is still referencing the tag.
+	     */
+
+	    for (nodePtr = parentPtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+		if (TkTextTagSetTest(nodePtr->tagonPtr, tagIndex)) {
+		    if (!childPtr) { childPtr = nodePtr; }
+		    count += 1;
+		}
+	    }
+
+	    if (count == 0) {
+		parentPtr->tagonPtr = TagSetErase(parentPtr->tagonPtr, tagPtr);
+		parentPtr->tagoffPtr = TagSetErase(parentPtr->tagoffPtr, tagPtr);
+	    } else {
+		if (count > 1) {
+		    /* this is now the best candidate for pushing down the root */
+		    tagPtr->rootPtr = parentPtr;
+		}
+		parentPtr->tagoffPtr = TagSetAdd(parentPtr->tagoffPtr, tagPtr);
+	    }
+	} while ((parentPtr = parentPtr->parentPtr));
+
+	if (childPtr && !tagPtr->rootPtr) {
+	    /*
+	     * We have to search down for a new tag root.
+	     */
+
+	    tagPtr->rootPtr = childPtr;
+
+	    while (childPtr->level > 0) {
+		unsigned count = 0;
+
+		for (nodePtr = childPtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+		    if (TkTextTagSetTest(nodePtr->tagonPtr, tagIndex)) {
+			childPtr = nodePtr;
+			count += 1;
+		    }
+		}
+
+		assert(count > 0);
+
+		if (count > 1) {
+		    break;
+		}
+
+		tagPtr->rootPtr = childPtr;
+	    }
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeUpdateElideInfo --
+ *
+ *	This function will be called if the elide info of any tag has been
+ *	changed.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Some branches and links may be inserted, or removed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+PropagateChangeToLineCount(
+    Node *nodePtr,
+    int changeToLogicalLineCount)
+{
+    if (changeToLogicalLineCount) {
+	for ( ; nodePtr; nodePtr = nodePtr->parentPtr) {
+	    nodePtr->numLogicalLines += changeToLogicalLineCount;
+	}
+    }
+}
+
+static TkTextSegment *
+FindNextLink(
+    const TkSharedText *sharedTextPtr,
+    TkTextSegment *segPtr)
+{
+    TkTextSection *sectionPtr = segPtr->sectionPtr;
+    TkTextLine *linePtr = sectionPtr->linePtr;
+
+    if (linePtr->numLinks > 0) {
+	sectionPtr = sectionPtr->nextPtr;
+	while (sectionPtr) {
+	    if (sectionPtr->segPtr->typePtr == &tkTextLinkType) {
+		return sectionPtr->segPtr;
+	    }
+	}
+    }
+
+    linePtr = TkBTreeNextLogicalLine(sharedTextPtr, NULL, linePtr)->prevPtr;
+    assert(linePtr);
+    if (linePtr->numLinks == 0) {
+	linePtr = linePtr->nextPtr;
+	assert(linePtr);
+    }
+    sectionPtr = linePtr->segPtr->sectionPtr;
+
+    while (true) {
+	if (sectionPtr->segPtr->typePtr == &tkTextLinkType) {
+	    return sectionPtr->segPtr;
+	}
+	sectionPtr = sectionPtr->nextPtr;
+	assert(sectionPtr);
+    }
+
+    return NULL; /* never reached */
+}
+
+static void
+UpdateElideInfo(
+    TkSharedText *sharedTextPtr,
+    TkTextTag *tagPtr,		/* can be NULL */
+    TkTextSegment *firstSegPtr,
+    TkTextSegment *lastSegPtr,
+    unsigned reason)
+{
+    TkTextSegment *prevBranchPtr;
+    TkTextSegment *lastBranchPtr;
+    TkTextSegment *prevLinkPtr;
+    TkTextSegment *lastLinkPtr;
+    TkTextSegment *newBranchPtr;
+    TkTextSegment *startSegPtr;
+    TkTextSegment *deletedBranchPtr;
+    TkTextSegment *deletedLinkPtr;
+    TkTextSegment *endSegPtr;
+    TkTextSegment *segPtr;
+    TkTextLine *linePtr;
+    TkTextLine *lastLinePtr;
+    TkTextLine *startLinePtr;
+    TkTextLine *endLinePtr;
+    TkText *oldTextPtr;
+    TkText *textPtr;
+    Node *nodePtr;
+    bool anyChanges;
+    bool actualElidden;
+    int changeToLogicalLineCount;
+
+    /*
+     * --------------------------------------------------------------------------
+     * This function will be called in four cases:
+     * --------------------------------------------------------------------------
+     * 1. A tag with elide information has been added to the specified region.
+     *
+     * 2. A tag with elide information will be removed from the specified region.
+     *
+     *		Because the removal has not yet been done, we will temporarily
+     *		disable this tag for further processing of the region.
+     *
+     * 3. The elide state of a tag has been changed.
+     *
+     *		Here we need the elide state of the predecessing segment before
+     *		the tag has been changed, thus we will temporarily reset the elide
+     *		state as long as we are computing this predecessing elide state.
+     *
+     * 4. All tags will be removed from the specified region.
+     */
+
+    assert(tagPtr || reason == ELISION_WILL_BE_REMOVED);
+    assert(tagPtr || TkBTreeHaveElidedSegments(sharedTextPtr));
+
+    /*
+     * This function assumes that the start/end points are already protected.
+     */
+
+    assert(firstSegPtr->protectionFlag);
+    assert(lastSegPtr->protectionFlag);
+
+    linePtr = firstSegPtr->sectionPtr->linePtr;
+    prevBranchPtr = lastBranchPtr = newBranchPtr = NULL;
+    deletedBranchPtr = deletedLinkPtr = NULL;
+    prevLinkPtr = lastLinkPtr = NULL;
+    anyChanges = false;
+    oldTextPtr = textPtr = NULL;
+    lastLinePtr = lastSegPtr->sectionPtr->linePtr;
+    changeToLogicalLineCount = 0;
+    nodePtr = NULL;
+    startLinePtr = NULL;
+    endLinePtr = NULL;
+
+    /*
+     * Ensure that the range will include final branches.
+     */
+
+    endSegPtr = lastSegPtr;
+    while (endSegPtr->size == 0) {
+	endSegPtr = endSegPtr->nextPtr;
+	assert(endSegPtr);
+    }
+    if (!(endSegPtr = endSegPtr->nextPtr)) {
+	endSegPtr = lastLinePtr->nextPtr ? lastLinePtr->nextPtr->segPtr : lastLinePtr->segPtr;
+    }
+    while (endSegPtr->size == 0) {
+	endSegPtr = endSegPtr->nextPtr;
+	assert(endSegPtr);
+    }
+
+    /*
+     * Prepare the tag for finding the actual elide state.
+     */
+
+    if (tagPtr && reason == ELISION_HAS_BEEN_CHANGED) {
+	tagPtr->elide = !tagPtr->elide;
+    }
+
+    /*
+     * At first find the elide state of the segment which is predecessing the
+     * specified region.
+     */
+
+    startSegPtr = firstSegPtr;
+    do {
+	if (!(startSegPtr = startSegPtr->prevPtr) && linePtr->prevPtr) {
+	    startSegPtr = linePtr->prevPtr->lastPtr;
+	}
+    } while (startSegPtr && !startSegPtr->tagInfoPtr);
+
+    actualElidden = startSegPtr && SegmentIsElided(sharedTextPtr, startSegPtr, NULL);
+
+    /*
+     * Now find next segment for start of range.
+     */
+
+    if (startSegPtr) {
+	startSegPtr = startSegPtr->nextPtr;
+    }
+    if (!startSegPtr) {
+	startSegPtr = firstSegPtr->sectionPtr->linePtr->segPtr;
+    }
+
+    /*
+     * We have found the predecessing elide state, now reset/prepare the tag
+     * for further processing.
+     */
+
+    if (tagPtr) {
+	if (reason == ELISION_HAS_BEEN_CHANGED) {
+	    tagPtr->elide = !tagPtr->elide;
+	} else if (reason == ELISION_WILL_BE_REMOVED) {
+	    oldTextPtr = tagPtr->textPtr;
+	    /* this little trick is disabling the tag */
+	    tagPtr->textPtr = (TkText *) tagPtr;
+	    textPtr = sharedTextPtr->peers;
+	}
+    }
+
+    endSegPtr->protectionFlag = true;
+    linePtr = startSegPtr->sectionPtr->linePtr;
+    lastLinePtr = lastSegPtr->sectionPtr->linePtr;
+    segPtr = startSegPtr;
+    SetLineHasChanged(sharedTextPtr, linePtr);
+
+    while (true) {
+	if (!segPtr) {
+	    if (anyChanges) {
+		/*
+		 * The branches and links are influencing the section structure.
+		 */
+		RebuildSections(sharedTextPtr, linePtr, true);
+		TkBTreeIncrEpoch(sharedTextPtr->tree);
+	    }
+
+	    anyChanges = false;
+	    if (linePtr->logicalLine) {
+		linePtr->changed = true;
+	    }
+	    linePtr = linePtr->nextPtr;
+	    assert(linePtr);
+
+	    if (linePtr != endSegPtr->sectionPtr->linePtr) {
+		while (linePtr != lastLinePtr
+			&& linePtr->numLinks == 0
+			&& linePtr->numBranches == 0
+			&& !TestTag(linePtr->tagonPtr, tagPtr)) {
+		    /* Skip (nearly) unaffected line. */
+		    if (linePtr->logicalLine == actualElidden) {
+			if (nodePtr && linePtr->parentPtr != nodePtr) {
+			    PropagateChangeToLineCount(nodePtr, changeToLogicalLineCount);
+			    changeToLogicalLineCount = 0;
+			}
+			changeToLogicalLineCount += linePtr->logicalLine ? -1 : +1;
+			linePtr->logicalLine = !actualElidden;
+			nodePtr = linePtr->parentPtr;
+			endLinePtr = linePtr;
+		    }
+		    if (linePtr->logicalLine) {
+			linePtr->changed = true;
+		    }
+		    linePtr = linePtr->nextPtr;
+		}
+	    }
+
+	    if (linePtr->logicalLine == actualElidden) {
+		if (nodePtr && linePtr->parentPtr != nodePtr) {
+		    PropagateChangeToLineCount(nodePtr, changeToLogicalLineCount);
+		    changeToLogicalLineCount = 0;
+		}
+		changeToLogicalLineCount += linePtr->logicalLine ? -1 : +1;
+		linePtr->logicalLine = !actualElidden;
+		nodePtr = linePtr->parentPtr;
+		endLinePtr = linePtr;
+	    }
+
+	    segPtr = linePtr->segPtr;
+	}
+	if (segPtr->tagInfoPtr) {
+	    bool shouldBeElidden = tagPtr ? SegmentIsElided(sharedTextPtr, segPtr, textPtr) : false;
+	    bool somethingHasChanged = false;
+
+	    if (prevBranchPtr) {
+		if (!shouldBeElidden || actualElidden) {
+		    /*
+		     * Remove expired branch.
+		     */
+
+		    assert(TkBTreeHaveElidedSegments(sharedTextPtr));
+		    assert(prevBranchPtr->sectionPtr->linePtr->numBranches > 0);
+
+		    UnlinkSegmentAndCleanup(sharedTextPtr, prevBranchPtr);
+		    if (deletedBranchPtr) {
+			TkBTreeFreeSegment(prevBranchPtr);
+		    } else {
+			deletedBranchPtr = prevBranchPtr;
+		    }
+		    lastBranchPtr = NULL;
+		    somethingHasChanged = true;
+		}
+	    } else if (prevLinkPtr) {
+		if (shouldBeElidden || !actualElidden) {
+		    /*
+		     * Remove expired link.
+		     */
+
+		    UnlinkSegmentAndCleanup(sharedTextPtr, prevLinkPtr);
+		    if (deletedLinkPtr) {
+			TkBTreeFreeSegment(prevLinkPtr);
+		    } else {
+			deletedLinkPtr = prevLinkPtr;
+		    }
+		    lastBranchPtr = NULL;
+		    somethingHasChanged = true;
+		}
+	    } else if (actualElidden != shouldBeElidden) {
+		if (shouldBeElidden) {
+		    /*
+		     * We have to insert a branch.
+		     */
+
+		    if (deletedBranchPtr) {
+			lastBranchPtr = deletedBranchPtr;
+			deletedBranchPtr = NULL;
+		    } else {
+			lastBranchPtr = MakeBranch();
+		    }
+		    LinkSwitch(linePtr, segPtr->prevPtr, lastBranchPtr);
+		    newBranchPtr = lastBranchPtr;
+		    somethingHasChanged = true;
+		} else { /* if (!actualElidden) */
+		    /*
+		     * We have to insert a link.
+		     */
+
+		    if (!lastBranchPtr) {
+			/*
+			 * The related branch is starting outside of this range,
+			 * so we have to search for it.
+			 */
+			lastBranchPtr = TkBTreeFindStartOfElidedRange(sharedTextPtr, NULL, firstSegPtr);
+			assert(lastBranchPtr->typePtr == &tkTextBranchType);
+		    }
+
+		    if (deletedLinkPtr) {
+			lastLinkPtr = deletedLinkPtr;
+			deletedLinkPtr = NULL;
+		    } else {
+			lastLinkPtr = MakeLink();
+		    }
+
+		    /* connect the branches */
+		    lastBranchPtr->body.branch.nextPtr = lastLinkPtr;
+		    lastLinkPtr->body.link.prevPtr = lastBranchPtr;
+		    /* finally link new segment */
+		    LinkSwitch(linePtr, segPtr->prevPtr, lastLinkPtr);
+		    newBranchPtr = lastBranchPtr = NULL;
+		    somethingHasChanged = true;
+		}
+	    }
+
+	    if (somethingHasChanged) {
+		if (!startLinePtr) { startLinePtr = linePtr; }
+		endLinePtr = linePtr;
+		lastLinkPtr = NULL;
+		anyChanges = true;
+	    }
+
+	    actualElidden = shouldBeElidden;
+	    prevBranchPtr = prevLinkPtr = NULL;
+	} else if (segPtr->typePtr == &tkTextBranchType) {
+	    lastBranchPtr = prevBranchPtr = segPtr;
+	    lastLinkPtr = prevLinkPtr = NULL;
+	} else if (segPtr->typePtr == &tkTextLinkType) {
+	    lastBranchPtr = prevBranchPtr = NULL;
+	    lastLinkPtr = prevLinkPtr = segPtr;
+	}
+	if (segPtr == endSegPtr) {
+	    break;
+	}
+	segPtr = segPtr->nextPtr;
+    }
+
+    if (newBranchPtr) {
+	/*
+	 * Connect the inserted branch.
+	 */
+
+	if (!lastLinkPtr) {
+	    if (reason == ELISION_HAS_BEEN_CHANGED) { tagPtr->elide = !tagPtr->elide; }
+	    actualElidden = SegmentIsElided(sharedTextPtr, endSegPtr, NULL);
+	    if (reason == ELISION_HAS_BEEN_CHANGED) { tagPtr->elide = !tagPtr->elide; }
+
+	    if (actualElidden) {
+		/*
+		 * In this case the related link is outside of the range,
+		 * so we have to search for it.
+		 */
+
+		lastLinkPtr = FindNextLink(sharedTextPtr, lastSegPtr);
+		assert(lastLinkPtr);
+	    } else {
+		if (deletedLinkPtr) {
+		    lastLinkPtr = deletedLinkPtr;
+		    deletedLinkPtr = NULL;
+		} else {
+		    lastLinkPtr = MakeLink();
+		}
+		lastLinePtr = endSegPtr->sectionPtr->linePtr;
+		LinkSwitch(lastLinePtr, endSegPtr->prevPtr, lastLinkPtr);
+		if (linePtr == lastLinePtr) {
+		    anyChanges = true;
+		} else {
+		    RebuildSections(sharedTextPtr, lastLinePtr, true);
+		}
+	    }
+	}
+
+	newBranchPtr->body.branch.nextPtr = lastLinkPtr;
+	lastLinkPtr->body.link.prevPtr = newBranchPtr;
+    }
+
+    if (deletedBranchPtr) { TkBTreeFreeSegment(deletedBranchPtr); }
+    if (deletedLinkPtr) { TkBTreeFreeSegment(deletedLinkPtr); }
+
+    if (linePtr->logicalLine) {
+	linePtr->changed = true;
+    }
+
+    if (anyChanges) {
+	/* The branches and links are influencing the section structure. */
+	RebuildSections(sharedTextPtr, linePtr, true);
+    }
+
+    if (endSegPtr != lastSegPtr) {
+	CleanupSplitPoint(endSegPtr, sharedTextPtr);
+    }
+
+    if (nodePtr) {
+	PropagateChangeToLineCount(nodePtr, changeToLogicalLineCount);
+    }
+
+    if (startLinePtr) {
+	unsigned lineNo1 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, startLinePtr, NULL);
+	unsigned lineNo2 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, endLinePtr, NULL);
+
+	if (!endLinePtr->nextPtr) {
+	    assert(lineNo1 < lineNo2);
+	    lineNo2 -= 1; /* don't invalidate very last line */
+	}
+
+	TkTextInvalidateLineMetrics(sharedTextPtr, NULL, startLinePtr,
+		lineNo2 - lineNo1, TK_TEXT_INVALIDATE_ELIDE);
+    }
+
+    if (tagPtr && reason == ELISION_WILL_BE_REMOVED) {
+	/* Re-enable the tag. */
+	tagPtr->textPtr = oldTextPtr;
+    }
+}
+
+void
+TkBTreeUpdateElideInfo(
+    TkText *textPtr,
+    TkTextTag *tagPtr)
+{
+    TkSharedText *sharedTextPtr;
+    TkTextIndex index1, index2;
+    TkTextSearch search;
+
+    assert(textPtr);
+    assert(tagPtr);
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+
+    if (!tagPtr->elide && !TkBTreeHaveElidedSegments(sharedTextPtr)) {
+	return;
+    }
+
+    TkTextIndexSetupToStartOfText(&index1, textPtr, sharedTextPtr->tree);
+    TkTextIndexSetupToEndOfText(&index2, textPtr, sharedTextPtr->tree);
+    TkBTreeStartSearch(&index1, &index2, tagPtr, &search, SEARCH_NEXT_TAGON);
+
+    while (TkBTreeNextTag(&search)) {
+	TkTextSegment *firstSegPtr;
+
+	firstSegPtr = search.segPtr;
+	TkBTreeNextTag(&search);
+	assert(search.segPtr);
+	firstSegPtr->protectionFlag = true;
+	search.segPtr->protectionFlag = true;
+
+	UpdateElideInfo(sharedTextPtr, tagPtr, firstSegPtr, search.segPtr, ELISION_HAS_BEEN_CHANGED);
+
+	CleanupSplitPoint(firstSegPtr, sharedTextPtr);
+	CleanupSplitPoint(search.segPtr, sharedTextPtr);
+    }
+
+    TkBTreeIncrEpoch(sharedTextPtr->tree);
+    TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeTag --
+ *
+ *	Turn a given tag on or off for a given range of characters in a B-tree
+ *	of text.
+ *
+ * Results:
+ *	True if the tags on any characters in the range were changed, and false
+ *	otherwise (i.e. if the tag was already absent (add = false) or present
+ *	(add = true) on the index range in question).
+ *
+ * Side effects:
+ *	The given tag is added to the given range of characters in the tree or
+ *	removed from all those characters, depending on the "add" argument.
+ *	Furthermore some branches and links may be inserted, or removed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+enum {
+    HAS_TAGON  = (1 << 0),
+    HAS_TAGOFF = (1 << 1),
+    DID_SKIP   = (1 << 2)
+};
+
+enum {
+    UNDO_NEEDED,
+    UNDO_MERGED,
+    UNDO_ANNIHILATED,
+};
+
+typedef struct {
+    TkText *textPtr;
+    unsigned lineNo1;
+    unsigned lineNo2;
+    TkTextTag *tagPtr;
+    bool add;
+    TkTextUndoInfo *undoInfo;
+    TkTextTagChangedProc *changedProc;
+    const TkTextTagSet *tagonPtr;
+    const TkTextTagSet *addTagoffPtr;
+    const TkTextTagSet *eraseTagoffPtr;
+    const TkTextTagSet *tagInfoPtr;
+    TkTextTagSet *newTagonPtr;
+    TkTextTagSet *newAddTagoffPtr;
+    TkTextTagSet *newEraseTagoffPtr;
+    TkTextTagSet *newTagInfoPtr;
+    TkTextSegment *firstSegPtr;
+    TkTextSegment *lastSegPtr;
+    int32_t firstOffset;
+    int32_t lastOffset;
+    int32_t lengthsBuf[200];
+    int32_t *lengths;
+    unsigned sizeOfLengths;
+    unsigned capacityOfLengths;
+    int32_t currLength;
+} TreeTagData;
+
+static void
+SaveLength(
+    TreeTagData *data)
+{
+    if (++data->sizeOfLengths == data->capacityOfLengths) {
+	unsigned newCapacity = 2*data->capacityOfLengths;
+	data->lengths = realloc(data->lengths == data->lengthsBuf ? NULL : data->lengths, newCapacity);
+	data->capacityOfLengths = newCapacity;
+    }
+
+    data->lengths[data->sizeOfLengths - 1] = data->currLength;
+    data->currLength = 0;
+}
+
+static void
+AddLength(
+    TreeTagData *data,
+    int length)
+{
+    if (data->currLength < 0) {
+	SaveLength(data);
+    }
+    data->currLength += length;
+}
+
+static void
+SubLength(
+    TreeTagData *data,
+    int length)
+{
+    if (data->currLength > 0) {
+	SaveLength(data);
+    }
+    if (data->sizeOfLengths > 0) {
+	data->currLength -= length;
+    }
+}
+
+static int
+CompareIndices(
+    const TkTextIndex *indexPtr1,
+    const TkTextUndoIndex *indexPtr2)
+{
+    int cmp;
+
+    if (indexPtr2->lineIndex == -1) {
+	TkTextIndex index = *indexPtr1;
+	TkTextIndexSetSegment(&index, indexPtr2->u.markPtr);
+	return TkTextIndexCompare(indexPtr1, &index);
+    }
+
+    if ((cmp = TkTextIndexGetLineNumber(indexPtr1, NULL) - indexPtr2->lineIndex) == 0) {
+	cmp = TkTextIndexGetByteIndex(indexPtr1) - indexPtr2->u.byteIndex;
+    }
+
+    return cmp;
+}
+
+static int
+MergeTagUndoToken(
+    TkSharedText *sharedTextPtr,
+    const TkTextIndex *indexPtr1,
+    const TkTextIndex *indexPtr2,
+    const TreeTagData *data)
+{
+    UndoTokenTagChange *prevToken;
+    TkTextTag *tagPtr = data->tagPtr;
+    int cmp1, cmp2;
+    bool remove;
+    bool wholeRange;
+
+    if (!tagPtr->recentTagAddRemoveToken || tagPtr->recentTagAddRemoveTokenIsNull) {
+	return UNDO_NEEDED;
+    }
+
+    prevToken = (UndoTokenTagChange *) tagPtr->recentTagAddRemoveToken;
+
+    assert(prevToken);
+    assert(UNMARKED_INT(((UndoTokenTagChange *) prevToken)->tagPtr) == UNMARKED_INT(tagPtr));
+
+    remove = POINTER_IS_MARKED(prevToken->tagPtr);
+    cmp1 = CompareIndices(indexPtr1, &prevToken->startIndex);
+    cmp2 = CompareIndices(indexPtr2, &prevToken->endIndex);
+    wholeRange = data->sizeOfLengths == 0
+	    && !((UndoTokenTagChange *) tagPtr->recentTagAddRemoveToken)->lengths;
+
+    if (data->add == remove) {
+	if (cmp1 <= 0 && cmp2 >= 0) {
+	    if (!data->add || wholeRange) {
+		free(prevToken->lengths);
+		prevToken->lengths = NULL;
+		return UNDO_ANNIHILATED;
+	    }
+	    return UNDO_NEEDED;
+	}
+	if (!wholeRange) {
+	    return UNDO_NEEDED;
+	}
+	if (cmp1 < 0 && cmp2 <= 0 && CompareIndices(indexPtr2, &prevToken->startIndex) >= 0) {
+	    MakeUndoIndex(sharedTextPtr, indexPtr1, &prevToken->startIndex, GRAVITY_LEFT);
+	    if (cmp2 > 0) {
+		MakeUndoIndex(sharedTextPtr, indexPtr2, &prevToken->endIndex, GRAVITY_RIGHT);
+	    }
+	    if (data->add) {
+		UNMARK_POINTER(prevToken->tagPtr);
+	    } else {
+		MARK_POINTER(prevToken->tagPtr);
+	    }
+	    return UNDO_MERGED;
+	}
+	if (cmp2 > 0 && cmp1 >= 0 && CompareIndices(indexPtr1, &prevToken->endIndex) <= 0) {
+	    if (cmp1 > 0) {
+		MakeUndoIndex(sharedTextPtr, indexPtr1, &prevToken->startIndex, GRAVITY_LEFT);
+	    }
+	    MakeUndoIndex(sharedTextPtr, indexPtr2, &prevToken->endIndex, GRAVITY_RIGHT);
+	    if (data->add) {
+		UNMARK_POINTER(prevToken->tagPtr);
+	    } else {
+		MARK_POINTER(prevToken->tagPtr);
+	    }
+	    return UNDO_MERGED;
+	}
+    } else if (wholeRange) {
+	int cmp3 = CompareIndices(indexPtr2, &prevToken->startIndex);
+	int cmp4 = CompareIndices(indexPtr1, &prevToken->endIndex);
+
+	if (cmp3 == 0 || cmp4 == 0 || (cmp1 <= 0 && cmp2 >= 0) || (cmp1 >= 0 && cmp2 <= 0)) {
+	    if (cmp1 < 0) {
+		MakeUndoIndex(sharedTextPtr, indexPtr1, &prevToken->startIndex, GRAVITY_LEFT);
+	    }
+	    if (cmp2 > 0) {
+		MakeUndoIndex(sharedTextPtr, indexPtr2, &prevToken->endIndex, GRAVITY_RIGHT);
+	    }
+	    return UNDO_MERGED;
+	}
+    }
+
+    return UNDO_NEEDED;
+}
+
+static unsigned
+AddRemoveTag(
+    TreeTagData *data,
+    TkTextLine *linePtr,
+    TkTextSegment *firstPtr,
+    TkTextSegment *lastPtr,
+    TkTextTagSet *(*addRemoveFunc)(TkTextTagSet *, const TkTextTag *))
+{
+    const TkTextTag *tagPtr = data->tagPtr;
+    const TkSharedText *sharedTextPtr = tagPtr->sharedTextPtr;
+    TkTextSegment *segPtr = firstPtr ? firstPtr : linePtr->segPtr;
+    TkTextSegment *prevPtr = NULL;
+    unsigned flags = 0;
+
+    assert(tagPtr);
+
+    while (segPtr != lastPtr) {
+	TkTextSegment *nextPtr = segPtr->nextPtr;
+
+	if (segPtr->tagInfoPtr) {
+	    if (data->undoInfo) {
+		if (TkTextTagSetTest(segPtr->tagInfoPtr, tagPtr->index) != data->add) {
+		    AddLength(data, segPtr->size);
+		    if (!data->firstSegPtr) {
+			data->firstSegPtr = segPtr;
+		    }
+		    data->lastSegPtr = segPtr;
+		    data->lastOffset = segPtr->size;
+		} else {
+		    SubLength(data, segPtr->size);
+		}
+	    } else if (!data->firstSegPtr) {
+		if (TkTextTagSetTest(segPtr->tagInfoPtr, tagPtr->index) != data->add) {
+		    /* needed for test whether modifications have been done */
+		    data->firstSegPtr = segPtr;
+		}
+	    }
+	    if (segPtr->tagInfoPtr == data->tagInfoPtr) {
+		assert(TkTextTagSetRefCount(data->newTagInfoPtr) > 0);
+		TagSetAssign(&segPtr->tagInfoPtr, data->newTagInfoPtr);
+	    } else {
+		data->tagInfoPtr = segPtr->tagInfoPtr;
+		segPtr->tagInfoPtr = addRemoveFunc(segPtr->tagInfoPtr, tagPtr);
+		data->newTagInfoPtr = segPtr->tagInfoPtr;
+	    }
+	    if (segPtr->typePtr == &tkTextCharType && !segPtr->protectionFlag) {
+		if (prevPtr && TkTextTagSetIsEqual(segPtr->tagInfoPtr, prevPtr->tagInfoPtr)) {
+		    TkTextSegment *pPtr = prevPtr;
+
+		    prevPtr = JoinCharSegments(sharedTextPtr, prevPtr);
+		    if (data->firstSegPtr == segPtr) {
+			data->firstOffset += prevPtr->size - segPtr->size;
+			data->firstSegPtr = prevPtr;
+		    } else if (data->firstSegPtr == pPtr) {
+			data->firstSegPtr = prevPtr;
+		    }
+		    if (data->lastSegPtr == segPtr) {
+			data->lastOffset += prevPtr->size - segPtr->size;
+			data->lastSegPtr = prevPtr;
+		    } else if (data->lastSegPtr == pPtr) {
+			data->lastSegPtr = prevPtr;
+		    }
+		    if (data->newTagInfoPtr == segPtr->tagInfoPtr
+			    || data->newTagInfoPtr == pPtr->tagInfoPtr) {
+			data->newTagInfoPtr = prevPtr->tagInfoPtr;
+		    }
+		} else {
+		    prevPtr = segPtr;
+		}
+	    } else {
+		prevPtr = NULL;
+	    }
+	} else {
+	    prevPtr = NULL;
+	}
+
+	segPtr = nextPtr;
+    }
+
+    return flags;
+}
+
+static unsigned
+TreeTagLine(
+    TreeTagData *data,
+    TkTextLine *linePtr,
+    TkTextSegment *segPtr1,
+    TkTextSegment *segPtr2)
+{
+    unsigned flags = 0;
+    const TkTextTag *tagPtr = data->tagPtr;
+    unsigned tagIndex = tagPtr->index;
+    TkTextSegment *segPtr = segPtr1 ? segPtr1 : linePtr->segPtr;
+    bool add = data->add;
+
+    while (segPtr->size == 0 && segPtr1 != segPtr2) {
+	segPtr = segPtr->nextPtr;
+    }
+    while (segPtr2 && segPtr2->prevPtr && segPtr2->prevPtr->size == 0 && segPtr2 != segPtr1) {
+	segPtr2 = segPtr2->prevPtr;
+    }
+    if (segPtr == segPtr2) {
+	flags = DID_SKIP;
+    } else if (add) {
+	if (linePtr->tagonPtr == data->tagonPtr) {
+	    assert(TkTextTagSetRefCount(data->newTagInfoPtr) > 0);
+	    TagSetAssign(&linePtr->tagonPtr, data->newTagonPtr);
+	} else {
+	    data->tagonPtr = linePtr->tagonPtr;
+	    linePtr->tagonPtr = TagSetAdd(linePtr->tagonPtr, tagPtr);
+	    data->newTagonPtr = linePtr->tagonPtr;
+	}
+	flags |= HAS_TAGON;
+	if (LineTestIfAnyIsUntagged(linePtr->segPtr, segPtr, tagIndex)
+		|| (segPtr2 && LineTestIfAnyIsUntagged(segPtr2, NULL, tagIndex))) {
+	    if (linePtr->tagoffPtr == data->addTagoffPtr) {
+		assert(TkTextTagSetRefCount(data->newAddTagoffPtr) > 0);
+		TagSetAssign(&linePtr->tagoffPtr, data->newAddTagoffPtr);
+	    } else {
+		data->addTagoffPtr = linePtr->tagoffPtr;
+		linePtr->tagoffPtr = TagSetAdd(linePtr->tagoffPtr, tagPtr);
+		data->newAddTagoffPtr = linePtr->tagoffPtr;
+	    }
+	    flags |= HAS_TAGOFF;
+	} else {
+	    linePtr->tagoffPtr = TagSetErase(linePtr->tagoffPtr, tagPtr);
+	}
+	flags |= AddRemoveTag(data, linePtr, segPtr1, segPtr2, TagSetAdd);
+    } else {
+	if (LineTestIfAnyIsTagged(linePtr->segPtr, segPtr, tagIndex)
+		|| (segPtr2 && LineTestIfAnyIsTagged(segPtr2, NULL, tagIndex))) {
+	    linePtr->tagoffPtr = TagSetAdd(linePtr->tagoffPtr, tagPtr);
+	    flags |= HAS_TAGON | HAS_TAGOFF;
+	} else {
+	    if (linePtr->tagonPtr == data->tagonPtr) {
+		assert(TkTextTagSetRefCount(data->newTagonPtr) > 0);
+		TagSetAssign(&linePtr->tagonPtr, data->newTagonPtr);
+	    } else {
+		data->tagonPtr = linePtr->tagonPtr;
+		linePtr->tagonPtr = TagSetErase(linePtr->tagonPtr, tagPtr);
+		data->newTagonPtr = linePtr->tagonPtr;
+	    }
+	    if (linePtr->tagoffPtr == data->eraseTagoffPtr) {
+		assert(TkTextTagSetRefCount(data->newEraseTagoffPtr) > 0);
+		TagSetAssign(&linePtr->tagoffPtr, data->newEraseTagoffPtr);
+	    } else {
+		data->eraseTagoffPtr = linePtr->tagoffPtr;
+		linePtr->tagoffPtr = TagSetErase(linePtr->tagoffPtr, tagPtr);
+		data->newEraseTagoffPtr = linePtr->tagoffPtr;
+	    }
+	}
+	flags |= AddRemoveTag(data, linePtr, segPtr1, segPtr2, TagSetErase);
+    }
+
+    return flags;
+}
+
+static unsigned
+TreeTagNode(
+    Node *nodePtr,
+    TreeTagData *data,
+    unsigned firstLineNo,
+    TkTextSegment *segPtr1,
+    TkTextSegment *segPtr2,
+    bool redraw)
+{
+    TkTextTag *tagPtr;
+    bool add;
+    unsigned flags;
+    unsigned nchilds;
+    unsigned endLineNo = firstLineNo + nodePtr->numLines - 1;
+
+    if (endLineNo < data->lineNo1 || data->lineNo2 < firstLineNo) {
+	return DID_SKIP;
+    }
+
+    tagPtr = data->tagPtr;
+    add = data->add;
+
+    assert(tagPtr);
+
+    if (NodeTestAllSegments(nodePtr, tagPtr->index, add)) {
+	if (!data->firstSegPtr) {
+	    data->firstSegPtr = nodePtr->linePtr->segPtr;
+	}
+	data->lastSegPtr = nodePtr->lastPtr->prevPtr->lastPtr;
+	data->lastOffset = data->lastSegPtr->size;
+	return add ? HAS_TAGON : 0;
+    }
+
+    flags = nchilds = 0;
+
+    if ((segPtr1 ? data->lineNo1 < firstLineNo : data->lineNo1 <= firstLineNo)
+	    && (segPtr2 ? endLineNo < data->lineNo2 : endLineNo <= data->lineNo2)) {
+	const TkSharedText *sharedTextPtr = tagPtr->sharedTextPtr;
+	bool delegateRedraw = redraw && NodeTestAnySegment(nodePtr, tagPtr->index, add);
+	TkTextIndex index1, index2;
+
+	if (delegateRedraw) {
+	    redraw = false;
+	}
+
+	TkTextIndexClear2(&index1, NULL, sharedTextPtr->tree);
+	TkTextIndexClear2(&index2, NULL, sharedTextPtr->tree);
+
+	/*
+	 * Whole node is affected.
+	 */
+
+	if (nodePtr->level > 0) {
+	    Node *childPtr;
+
+	    for (childPtr = nodePtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+		flags |= TreeTagNode(childPtr, data, firstLineNo, NULL, NULL, delegateRedraw);
+		firstLineNo += childPtr->numLines;
+	    }
+	} else {
+	    TkTextLine *linePtr = nodePtr->linePtr;
+	    TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+
+	    for ( ; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+		if (!LineTestAllSegments(linePtr, tagPtr, add)) {
+		    if (add) {
+			flags |= AddRemoveTag(data, linePtr, NULL, NULL, TagSetAdd);
+			if (linePtr->tagonPtr == data->tagonPtr) {
+			    assert(TkTextTagSetRefCount(data->newTagonPtr) > 0);
+			    TagSetAssign(&linePtr->tagonPtr, data->newTagonPtr);
+			} else {
+			    data->tagonPtr = linePtr->tagonPtr;
+			    linePtr->tagonPtr = TagSetAdd(linePtr->tagonPtr, tagPtr);
+			    data->newTagonPtr = linePtr->tagonPtr;
+			}
+		    } else {
+			flags |= AddRemoveTag(data, linePtr, NULL, NULL, TagSetErase);
+			if (linePtr->tagonPtr == data->tagonPtr) {
+			    assert(TkTextTagSetRefCount(data->newTagonPtr) > 0);
+			    TagSetAssign(&linePtr->tagonPtr, data->newTagonPtr);
+			} else {
+			    data->tagonPtr = linePtr->tagonPtr;
+			    linePtr->tagonPtr = TagSetErase(linePtr->tagonPtr, tagPtr);
+			    data->newTagonPtr = linePtr->tagonPtr;
+			}
+		    }
+		    if (linePtr->tagoffPtr == data->eraseTagoffPtr) {
+			assert(TkTextTagSetRefCount(data->newEraseTagoffPtr) > 0);
+			TagSetAssign(&linePtr->tagoffPtr, data->newEraseTagoffPtr);
+		    } else {
+			data->eraseTagoffPtr = linePtr->tagoffPtr;
+			linePtr->tagoffPtr = TagSetErase(linePtr->tagoffPtr, tagPtr);
+			data->newEraseTagoffPtr = linePtr->tagoffPtr;
+		    }
+		    if (delegateRedraw) {
+			TkTextIndexSetToStartOfLine2(&index1, linePtr);
+			TkTextIndexSetToEndOfLine2(&index2, linePtr);
+			data->changedProc(sharedTextPtr, data->textPtr, &index1, &index2,
+				tagPtr, false);
+		    }
+		    if (!data->firstSegPtr) {
+			data->firstSegPtr = linePtr->segPtr;
+		    }
+		    data->lastSegPtr = linePtr->lastPtr;
+		    data->lastOffset = linePtr->lastPtr->size;
+		} else if (data->undoInfo) {
+		    SubLength(data, linePtr->size);
+		}
+	    }
+	}
+
+	if (redraw) {
+	    TkTextIndexSetToStartOfLine2(&index1, nodePtr->linePtr);
+	    TkTextIndexSetToEndOfLine2(&index2, nodePtr->lastPtr);
+	    data->changedProc(sharedTextPtr, data->textPtr, &index1, &index2, tagPtr, false);
+	}
+
+	if (add) {
+	    flags = HAS_TAGON;
+	    nchilds = nodePtr->numChildren;
+	}
+    } else {
+	unsigned tagIndex = tagPtr->index;
+	unsigned myFlags;
+
+	if (nodePtr->level > 0) {
+	    Node *childPtr;
+
+	    for (childPtr = nodePtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+		myFlags = TreeTagNode(childPtr, data, firstLineNo, segPtr1, segPtr2, redraw);
+		if (myFlags == DID_SKIP) {
+		    if (TkTextTagSetTest(childPtr->tagonPtr, tagIndex)) {
+			if (!tagPtr->rootPtr) {
+			    tagPtr->rootPtr = childPtr;
+			}
+			myFlags |= HAS_TAGON;
+		    }
+		    if (TkTextTagSetTest(childPtr->tagoffPtr, tagIndex)) {
+			myFlags |= HAS_TAGOFF;
+		    }
+		}
+		if (myFlags & HAS_TAGON) { nchilds += 1; }
+		flags |= myFlags;
+		firstLineNo += childPtr->numLines;
+	    }
+	} else {
+	    const TkSharedText *sharedTextPtr = tagPtr->sharedTextPtr;
+	    TkTextLine *linePtr = nodePtr->linePtr;
+	    TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+	    TkTextIndex index1, index2;
+
+	    if (redraw) {
+		TkTextIndexClear2(&index1, NULL, sharedTextPtr->tree);
+		TkTextIndexClear2(&index2, NULL, sharedTextPtr->tree);
+	    }
+
+	    for ( ; firstLineNo < data->lineNo1; ++firstLineNo, linePtr = linePtr->nextPtr) {
+		assert(linePtr);
+		myFlags = 0;
+		if (TkTextTagSetTest(linePtr->tagonPtr, tagIndex)) { myFlags |= HAS_TAGON; }
+		if (TkTextTagSetTest(linePtr->tagoffPtr, tagIndex)) { myFlags |= HAS_TAGOFF; }
+		if (myFlags & HAS_TAGON) { nchilds += 1; }
+		flags |= myFlags;
+		if (data->undoInfo) {
+		    SubLength(data, linePtr->size);
+		}
+	    }
+	    for ( ; firstLineNo <= data->lineNo2 && linePtr != lastPtr;
+		    linePtr = linePtr->nextPtr, ++firstLineNo) {
+		if (!LineTestAllSegments(linePtr, tagPtr, add)) {
+		    TkTextSegment *startSegPtr, *stopSegPtr;
+
+		    startSegPtr = (firstLineNo == data->lineNo1) ? segPtr1 : NULL;
+		    stopSegPtr = (firstLineNo == data->lineNo2) ? segPtr2 : NULL;
+		    myFlags = TreeTagLine(data, linePtr, startSegPtr, stopSegPtr);
+
+		    if (myFlags == DID_SKIP) {
+			if (TkTextTagSetTest(linePtr->tagonPtr, tagIndex)) { myFlags |= HAS_TAGON; }
+			if (TkTextTagSetTest(linePtr->tagoffPtr, tagIndex)) { myFlags |= HAS_TAGOFF; }
+		    }
+		    if (myFlags & HAS_TAGON) { nchilds += 1; }
+		    flags |= myFlags;
+
+		    if (redraw) {
+			TkTextIndexSetToStartOfLine2(&index1, linePtr);
+			TkTextIndexSetToEndOfLine2(&index2, linePtr);
+			data->changedProc(sharedTextPtr, data->textPtr, &index1, &index2, tagPtr, false);
+		    }
+		} else {
+		    if (add) {
+			flags |= HAS_TAGON;
+			nchilds += 1;
+		    }
+		    if (data->undoInfo) {
+			SubLength(data, linePtr->size);
+		    }
+		}
+	    }
+	    for ( ; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+		assert(linePtr);
+		myFlags = 0;
+		if (TkTextTagSetTest(linePtr->tagonPtr, tagIndex)) { myFlags |= HAS_TAGON; }
+		if (TkTextTagSetTest(linePtr->tagoffPtr, tagIndex)) { myFlags |= HAS_TAGOFF; }
+		if (myFlags & HAS_TAGON) { nchilds += 1; }
+		flags |= myFlags;
+		if (data->undoInfo) {
+		    SubLength(data, linePtr->size);
+		}
+	    }
+	}
+    }
+
+    if (!(flags & HAS_TAGON)) {
+	flags &= ~HAS_TAGOFF;
+    } else if (nchilds < nodePtr->numChildren) {
+	flags |= HAS_TAGOFF;
+    }
+    if (nchilds > (nodePtr->level > 0 ? 1 : 0)) {
+	tagPtr->rootPtr = nodePtr;
+    }
+
+    nodePtr->tagonPtr = TagSetAddOrErase(nodePtr->tagonPtr, tagPtr, !!(flags & HAS_TAGON));
+    nodePtr->tagoffPtr = TagSetAddOrErase(nodePtr->tagoffPtr, tagPtr, !!(flags & HAS_TAGOFF));
+
+    return flags;
+}
+
+static bool
+FindSplitPoints(
+    TkSharedText *sharedTextPtr,
+    const TkTextIndex *indexPtr1,
+    const TkTextIndex *indexPtr2,
+    const TkTextTag *tagPtr,	/* can be NULL */
+    bool add,
+    TkTextSegment **segPtr1,
+    TkTextSegment **segPtr2)
+{
+    TkTextLine *linePtr1 = TkTextIndexGetLine(indexPtr1);
+    TkTextLine *linePtr2 = TkTextIndexGetLine(indexPtr2);
+    TkTextIndex end;
+    bool needSplit1;
+    bool needSplit2;
+
+    assert(tagPtr || !add);
+
+    TkTextIndexBackChars(NULL, indexPtr2, 1, &end, COUNT_INDICES);
+
+    needSplit1 = (TkBTreeCharTagged(indexPtr1, tagPtr) != add);
+    needSplit2 = (TkBTreeCharTagged(&end, tagPtr) != add);
+
+    if (!needSplit1 && !needSplit2) {
+	if (tagPtr) {
+	    TkTextSearch search;
+
+	    TkBTreeStartSearch(indexPtr1, indexPtr2, tagPtr, &search, SEARCH_EITHER_TAGON_TAGOFF);
+	    if (!TkBTreeNextTag(&search)) {
+		return false; /* whole range is already tagged/untagged */
+	    }
+	} else {
+	    if (!TkBTreeFindNextTagged(indexPtr1, indexPtr2, NULL)) {
+		return false; /* whole range is already untagged */
+	    }
+	}
+    }
+
+    if (needSplit1) {
+	if ((*segPtr1 = SplitSeg(indexPtr1, NULL))) {
+	    SplitSection((*segPtr1)->sectionPtr);
+	}
+	TkTextIndexToByteIndex((TkTextIndex *) indexPtr2); /* mutable due to concept */
+    } else {
+	*segPtr1 = NULL;
+    }
+    if (!*segPtr1) {
+	*segPtr1 = TkTextIndexGetContentSegment(indexPtr1, NULL);
+    } else if (!(*segPtr1 = (*segPtr1)->nextPtr)) {
+	assert((*segPtr1)->sectionPtr->linePtr->nextPtr);
+	linePtr1 = (*segPtr1)->sectionPtr->linePtr->nextPtr;
+	*segPtr1 = linePtr1->segPtr;
+    }
+
+    /*
+     * The next split may invalidate '*segPtr1', so we are inserting temporarily
+     * a protection mark, this avoids the invalidation.
+     */
+
+    assert(!sharedTextPtr->protectionMark[0]->sectionPtr); /* this protection mark is unused? */
+    LinkSegment(linePtr1, (*segPtr1)->prevPtr, sharedTextPtr->protectionMark[0]);
+
+    if (!needSplit2) {
+	*segPtr2 = NULL;
+    } else if ((*segPtr2 = SplitSeg(indexPtr2, NULL))) {
+	SplitSection((*segPtr2)->sectionPtr);
+    }
+    if (!*segPtr2) {
+	*segPtr2 = TkTextIndexGetContentSegment(indexPtr2, NULL);
+    } else if (!(*segPtr2 = (*segPtr2)->nextPtr)) {
+	assert((*segPtr2)->sectionPtr->linePtr->nextPtr);
+	linePtr2 = (*segPtr2)->sectionPtr->linePtr->nextPtr;
+	*segPtr2 = linePtr2->segPtr;
+    }
+
+    *segPtr1 = sharedTextPtr->protectionMark[0]->nextPtr;
+    UnlinkSegment(sharedTextPtr->protectionMark[0]);
+
+    return true;
+}
+
+bool
+TkBTreeTag(
+    TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    TkText *textPtr,			/* Information about text widget, can be NULL. */
+    const TkTextIndex *indexPtr1,	/* Indicates first character in range. */
+    const TkTextIndex *indexPtr2,	/* Indicates character just after the last one in range. */
+    TkTextTag *tagPtr,			/* Tag to add or remove. */
+    bool add,				/* 'true' means add tag to the given range of characters;
+					 * 'false' means remove the tag from the range. */
+    TkTextUndoInfo *undoInfo,		/* Store undo information, can be NULL. */
+    TkTextTagChangedProc changedProc)	/* Trigger this callback when any tag will be added/removed. */
+{
+    TkTextLine *linePtr1;
+    TkTextLine *linePtr2;
+    TkTextSegment *segPtr1, *segPtr2;
+    TkTextSegment *firstPtr, *lastPtr;
+    TreeTagData data;
+    Node *rootPtr;
+
+    assert(tagPtr);
+    assert(indexPtr1);
+    assert(indexPtr2);
+    assert(TkTextIndexCompare(indexPtr1, indexPtr2) <= 0);
+    assert(changedProc);
+
+    if (!add && !tagPtr->rootPtr) {
+	return false;
+    }
+    if (TkTextIndexIsEqual(indexPtr1, indexPtr2)) {
+	return false;
+    }
+    if (!add) {
+	if (!tagPtr->rootPtr) {
+	    return false;
+	}
+	if (TkBTreeGetRoot(sharedTextPtr->tree)->tagonPtr == sharedTextPtr->emptyTagInfoPtr) {
+	    return false;
+	}
+    }
+    if (!FindSplitPoints(sharedTextPtr, indexPtr1, indexPtr2, tagPtr, add, &segPtr1, &segPtr2)) {
+	return false;
+    }
+
+    segPtr1->protectionFlag = true;
+    segPtr2->protectionFlag = true;
+
+    if (!add && tagPtr->elideString) {
+	/*
+	 * In case of elision we have to inspect each segment, because a
+	 * Branch or a Link segment has to be inserted/removed if required.
+	 *
+	 * NOTE: Currently, when using elision (tag option -elide), TkBTreeTag
+	 * can be considerably slower than without. In return the lookup, whether
+	 * a segment is elided, is super-fast now, and this has more importance -
+	 * in general inserting/removing an elided range will be done only once,
+	 * but the lookup for the elision option is a frequent use case.
+	 *
+	 * Note that UpdateElideInfo needs the old state when removing the tag,
+	 * so we are doing this before eliminating the tag.
+	 */
+
+	UpdateElideInfo(sharedTextPtr, tagPtr, segPtr1, segPtr2, ELISION_WILL_BE_REMOVED);
+    }
+
+    if (undoInfo) {
+	memset(undoInfo, 0, sizeof(*undoInfo));
+    }
+
+    firstPtr = TkTextIndexIsStartOfLine(indexPtr1) ? NULL : segPtr1;
+    lastPtr = TkTextIndexIsStartOfLine(indexPtr2) ? NULL : segPtr2;
+    linePtr1 = segPtr1->sectionPtr->linePtr;
+    linePtr2 = segPtr2->sectionPtr->linePtr;
+    rootPtr = TkBTreeGetRoot(sharedTextPtr->tree); /* we must start at top level */
+    tagPtr->rootPtr = NULL; /* will be recomputed */
+
+    memset(&data, 0, sizeof(data));
+    data.tagPtr = tagPtr;
+    data.add = add;
+    data.changedProc = changedProc;
+    data.undoInfo = tagPtr->undo ? undoInfo : NULL;
+    data.firstSegPtr = NULL;
+    data.lastSegPtr = NULL;
+    data.textPtr = textPtr;
+    data.lineNo1 = TkTextIndexGetLineNumber(indexPtr1, NULL);
+    data.lineNo2 = linePtr1 == linePtr2 ?
+	    data.lineNo1 : TkTextIndexGetLineNumber(indexPtr2, NULL) - (lastPtr ? 0 : 1);
+    data.lengths = data.lengthsBuf;
+    data.capacityOfLengths = sizeof(data.lengthsBuf)/sizeof(data.lengthsBuf[0]);
+
+    TreeTagNode(rootPtr, &data, 0, firstPtr, lastPtr, tagPtr->affectsDisplay);
+
+    if (add && tagPtr->elideString) {
+	/*
+	 * In case of elision we have to inspect each segment, because a
+	 * Branch or a Link segment has to be inserted/removed if required.
+	 *
+	 * NOTE: Currently, when using elision (tag option -elide), TkBTreeTag
+	 * can be considerably slower than without. In return the lookup, whether
+	 * a segment is elided, is super-fast now, and this has more importance -
+	 * in general inserting/removing an elided range will be done only once,
+	 * but the lookup for the elision option is a frequent use case.
+	 *
+	 * Note that UpdateElideInfo needs the new state when adding the tag,
+	 * so we are doing this after the tag has been added.
+	 */
+
+	UpdateElideInfo(sharedTextPtr, tagPtr, segPtr1, segPtr2, ELISION_HAS_BEEN_ADDED);
+    }
+
+    if (undoInfo && (data.sizeOfLengths > 0 || data.currLength > 0)) {
+	TkTextIndex index1 = *indexPtr1;
+	TkTextIndex index2 = *indexPtr2;
+
+	assert(data.firstSegPtr);
+	assert(data.lastSegPtr);
+
+	/*
+	 * Setup the undo information.
+	 */
+
+	assert(data.lastSegPtr->size >= data.lastOffset);
+	data.lastOffset = data.lastSegPtr->size - data.lastOffset;
+
+	if (data.lastSegPtr->nextPtr) {
+	    data.lastSegPtr = data.lastSegPtr->nextPtr;
+	} else if (data.lastSegPtr->sectionPtr->linePtr->nextPtr) {
+	    data.lastSegPtr = data.lastSegPtr->sectionPtr->linePtr->nextPtr->segPtr;
+	}
+	if (data.lastSegPtr->sectionPtr->linePtr == GetLastLine(sharedTextPtr, textPtr)) {
+	    data.lastSegPtr = textPtr->endMarker;
+	}
+	TkTextIndexSetSegment(&index1, data.firstSegPtr);
+	TkTextIndexSetSegment(&index2, data.lastSegPtr);
+	TkTextIndexForwBytes(textPtr, &index1, data.firstOffset, &index1);
+	TkTextIndexBackBytes(textPtr, &index2, data.lastOffset, &index2);
+	assert(TkTextIndexCompare(&index1, &index2) < 0);
+
+	if (data.sizeOfLengths > 0) {
+	    assert(data.currLength != 0);
+	    if (data.currLength > 0 && data.sizeOfLengths > 1) {
+		SaveLength(&data);
+	    }
+	    if (data.sizeOfLengths == 1) {
+		data.sizeOfLengths = 0;
+	    } else if (data.lengths[data.sizeOfLengths - 1] > 0) {
+		data.lengths[data.sizeOfLengths - 1] = 0;
+	    } else {
+		data.currLength = 0;
+		SaveLength(&data);
+	    }
+	}
+
+	switch (MergeTagUndoToken(sharedTextPtr, &index1, &index2, &data)) {
+	case UNDO_NEEDED: {
+	    UndoTokenTagChange *undoToken;
+
+	    if (tagPtr->recentTagAddRemoveToken && !tagPtr->recentTagAddRemoveTokenIsNull) {
+		undoInfo->token = (TkTextUndoToken *) tagPtr->recentTagAddRemoveToken;
+		undoInfo->byteSize = 0;
+		tagPtr->recentTagAddRemoveToken = NULL;
+	    }
+	    if (!tagPtr->recentTagAddRemoveToken) {
+		tagPtr->recentTagAddRemoveToken = malloc(sizeof(UndoTokenTagChange));
+		DEBUG_ALLOC(tkTextCountNewUndoToken++);
+	    }
+
+	    tagPtr->recentTagAddRemoveTokenIsNull = false;
+	    undoToken = (UndoTokenTagChange *) tagPtr->recentTagAddRemoveToken;
+	    undoToken->undoType = &undoTokenTagType;
+	    undoToken->tagPtr = tagPtr;
+	    if (!add) {
+		MARK_POINTER(undoToken->tagPtr);
+	    }
+	    MakeUndoIndex(sharedTextPtr, &index1, &undoToken->startIndex, GRAVITY_LEFT);
+	    MakeUndoIndex(sharedTextPtr, &index2, &undoToken->endIndex, GRAVITY_RIGHT);
+	    if (data.sizeOfLengths > 0) {
+		if (data.lengths == data.lengthsBuf) {
+		    data.lengths = malloc(data.sizeOfLengths * sizeof(data.lengths[0]));
+		    memcpy(data.lengths, data.lengthsBuf, data.sizeOfLengths * sizeof(data.lengths[0]));
+		} else {
+		    data.lengths = realloc(data.lengths, data.sizeOfLengths * sizeof(data.lengths[0]));
+		}
+		undoToken->lengths = data.lengths;
+		data.lengths = data.lengthsBuf;
+	    } else {
+		undoToken->lengths = NULL;
+	    }
+	    TkTextTagAddRetainedUndo(sharedTextPtr, tagPtr);
+	    break;
+	}
+	case UNDO_MERGED:
+	    /* no action required */
+	    break;
+	case UNDO_ANNIHILATED:
+	    tagPtr->recentTagAddRemoveTokenIsNull = true;
+	    break;
+	}
+
+	if (data.lengths != data.lengthsBuf) {
+	    free(data.lengths);
+	}
+    }
+
+    assert(data.lengths == data.lengthsBuf);
+
+    CleanupSplitPoint(segPtr1, sharedTextPtr);
+    CleanupSplitPoint(segPtr2, sharedTextPtr);
+    TkBTreeIncrEpoch(sharedTextPtr->tree);
+
+    TK_BTREE_DEBUG(TkBTreeCheck(indexPtr1->tree));
+
+    return !!data.firstSegPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeClearTags --
+ *
+ *	Turn all tags off inside a given range. Note that the special
+ *	selection tag is an exception, and may not be removed if not
+ *	wanted.
+ *
+ * Results:
+ *	True if the tags on any characters were changed, and false otherwise.
+ *
+ * Side effects:
+ *	Some branches and links may be removed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+typedef struct ClearTagsData {
+    unsigned skip;
+    unsigned capacity;
+    TkTextTagSet *tagonPtr;
+    TkTextTagSet *tagoffPtr;
+    TkTextTagSet *newTagonPtr;
+    TkTextTagSet *newTagoffPtr;
+    UndoTagChange *tagChangePtr;
+    TkTextSegment *firstSegPtr;
+    TkTextSegment *lastSegPtr;
+} ClearTagsData;
+
+static Node *
+FindCommonParent(
+    Node *nodePtr1,
+    Node *nodePtr2)
+{
+    while (nodePtr1->level > nodePtr2->level) {
+	nodePtr1 = nodePtr1->parentPtr;
+    }
+    while (nodePtr2->level > nodePtr1->level) {
+	nodePtr2 = nodePtr2->parentPtr;
+    }
+    return nodePtr2;
+}
+
+static bool
+TestIfAnySegmentIsAffected(
+    TkSharedText *sharedTextPtr,
+    const TkTextTagSet *tagInfoPtr,
+    bool discardSelection)
+{
+    if (discardSelection) {
+	return !TkTextTagBitContainsSet(sharedTextPtr->selectionTags, tagInfoPtr);
+    }
+    return tagInfoPtr != sharedTextPtr->emptyTagInfoPtr;
+}
+
+static bool
+TestIfDisplayGeometryIsAffected(
+    TkSharedText *sharedTextPtr,
+    const TkTextTagSet *tagInfoPtr,
+    bool discardSelection)
+{
+    unsigned i;
+
+    i = TkTextTagSetFindFirstInIntersection(
+	    tagInfoPtr, discardSelection ? sharedTextPtr->affectGeometryNonSelTags
+	    : sharedTextPtr->affectGeometryTags);
+    return i != TK_TEXT_TAG_SET_NPOS && sharedTextPtr->tagLookup[i]->affectsDisplayGeometry;
+}
+
+static TkTextTagSet *
+ClearTagsFromLine(
+    TkSharedText *sharedTextPtr,
+    TkTextLine *linePtr,
+    TkTextSegment *firstPtr,
+    TkTextSegment *lastPtr,
+    TkTextTagSet *affectedTagInfoPtr,
+    UndoTokenTagClear *undoToken,
+    ClearTagsData *data,
+    bool discardSelection,
+    bool redraw,
+    TkTextTagChangedProc changedProc,
+    TkText *textPtr)
+{
+    TkTextTagSet *emptyTagInfoPtr = sharedTextPtr->emptyTagInfoPtr;
+    TkTextTagSet *myAffectedTagInfoPtr;
+    TkTextSegment *segPtr;
+    TkTextSegment *prevPtr;
+    bool anyChanges;
+
+    if (linePtr->tagonPtr == emptyTagInfoPtr) {
+	/*
+	 * Nothing to do.
+	 */
+	if (undoToken) {
+	    data->skip += linePtr->size;
+	}
+	return affectedTagInfoPtr;
+    }
+
+    if (discardSelection || redraw) {
+	TkTextTagSetIncrRefCount(myAffectedTagInfoPtr = emptyTagInfoPtr);
+    } else {
+	myAffectedTagInfoPtr = affectedTagInfoPtr;
+    }
+
+    segPtr = firstPtr ? firstPtr : linePtr->segPtr;
+    prevPtr = NULL;
+    anyChanges = false;
+
+    if (undoToken && firstPtr) {
+	TkTextIndex index;
+	TkTextIndexClear2(&index, NULL, sharedTextPtr->tree);
+	TkTextIndexSetSegment(&index, firstPtr);
+	data->skip = TkTextSegToIndex(firstPtr);
+    }
+
+    while (segPtr != lastPtr) {
+	TkTextSegment *nextPtr = segPtr->nextPtr;
+
+	if (segPtr->tagInfoPtr) {
+	    if (segPtr->tagInfoPtr != emptyTagInfoPtr
+		    && (!discardSelection
+			|| !TkTextTagBitContainsSet(sharedTextPtr->selectionTags, segPtr->tagInfoPtr))) {
+		if (!data->firstSegPtr) {
+		    data->firstSegPtr = segPtr;
+		}
+		data->lastSegPtr = segPtr;
+
+		if (myAffectedTagInfoPtr) {
+		    myAffectedTagInfoPtr = TkTextTagSetJoin(myAffectedTagInfoPtr, segPtr->tagInfoPtr);
+		}
+
+		if (undoToken) {
+		    TkTextTagSet *tagInfoPtr;
+
+		    TkTextTagSetIncrRefCount(tagInfoPtr = segPtr->tagInfoPtr);
+		    tagInfoPtr = TagSetRemoveBits(segPtr->tagInfoPtr,
+			    sharedTextPtr->dontUndoTags, sharedTextPtr);
+
+		    if (tagInfoPtr == sharedTextPtr->emptyTagInfoPtr) {
+			TkTextTagSetDecrRefCount(tagInfoPtr);
+			data->skip += segPtr->size;
+			if (data->firstSegPtr == segPtr) {
+			    data->firstSegPtr = data->lastSegPtr = NULL;
+			}
+		    } else {
+			UndoTagChange *tagChangePtr;
+
+			if (data->skip == 0
+				&& data->tagChangePtr
+				&& TkTextTagSetIsEqual(data->tagChangePtr->tagInfoPtr, tagInfoPtr)) {
+			    data->tagChangePtr->size += segPtr->size;
+			    TkTextTagSetDecrRefCount(tagInfoPtr);
+			} else {
+			    if (undoToken->changeListSize == data->capacity) {
+				data->capacity = MAX(2*data->capacity, 50);
+				undoToken->changeList = realloc(undoToken->changeList,
+					data->capacity * sizeof(undoToken->changeList[0]));
+			    }
+			    tagChangePtr = undoToken->changeList + undoToken->changeListSize++;
+			    tagChangePtr->tagInfoPtr = tagInfoPtr;
+			    tagChangePtr->size = segPtr->size;
+			    tagChangePtr->skip = data->skip;
+			    data->tagChangePtr = tagChangePtr;
+			    data->skip = 0;
+			}
+		    }
+		}
+
+		if (discardSelection) {
+		    segPtr->tagInfoPtr = TagSetIntersectBits(segPtr->tagInfoPtr,
+			    sharedTextPtr->selectionTags, sharedTextPtr);
+		} else {
+		    TagSetAssign(&segPtr->tagInfoPtr, sharedTextPtr->emptyTagInfoPtr);
+		}
+		anyChanges = true;
+	    } else if (undoToken) {
+		data->skip += segPtr->size;
+	    }
+	    if (segPtr->typePtr == &tkTextCharType && !segPtr->protectionFlag) {
+		if (prevPtr && TkTextTagSetIsEqual(segPtr->tagInfoPtr, prevPtr->tagInfoPtr)) {
+		    TkTextSegment *pPtr = prevPtr;
+
+		    prevPtr = JoinCharSegments(sharedTextPtr, prevPtr);
+		    if (data->firstSegPtr == pPtr || data->firstSegPtr == segPtr) {
+			data->firstSegPtr = prevPtr;
+		    }
+		    if (data->lastSegPtr == pPtr || data->lastSegPtr == segPtr) {
+			data->lastSegPtr = prevPtr;
+		    }
+		} else {
+		    prevPtr = segPtr;
+		}
+	    } else {
+		prevPtr = NULL;
+	    }
+	} else {
+	    prevPtr = NULL;
+	}
+
+	segPtr = nextPtr;
+    }
+
+    if (anyChanges) {
+	if (redraw
+		&& TkTextTagSetIntersectsBits(myAffectedTagInfoPtr,
+			discardSelection
+			    ? sharedTextPtr->affectDisplayNonSelTags
+			    : sharedTextPtr->affectDisplayTags)) {
+	    bool affectsDisplayGeometry = TestIfDisplayGeometryIsAffected(
+		    sharedTextPtr, myAffectedTagInfoPtr, discardSelection);
+	    TkTextIndex index1, index2;
+
+	    TkTextIndexClear2(&index1, NULL, sharedTextPtr->tree);
+	    TkTextIndexClear2(&index2, NULL, sharedTextPtr->tree);
+	    TkTextIndexSetToStartOfLine2(&index1, linePtr);
+	    TkTextIndexSetToEndOfLine2(&index2, linePtr);
+	    changedProc(sharedTextPtr, textPtr, &index1, &index2, NULL, affectsDisplayGeometry);
+	}
+
+	if (discardSelection) {
+	    myAffectedTagInfoPtr = TagSetRemoveBits(myAffectedTagInfoPtr,
+		    sharedTextPtr->selectionTags, sharedTextPtr);
+	}
+
+	if (firstPtr || lastPtr) {
+	    TkTextTagSet *tagonPtr, *tagoffPtr;
+
+	    if (linePtr->tagonPtr == data->tagonPtr && linePtr->tagoffPtr == data->tagoffPtr) {
+		TagSetReplace(&linePtr->tagonPtr, data->newTagonPtr);
+		TagSetReplace(&linePtr->tagoffPtr, data->newTagoffPtr);
+	    } else {
+		data->tagonPtr = linePtr->tagonPtr;
+		data->tagoffPtr = linePtr->tagoffPtr;
+
+		TkTextTagSetIncrRefCount(tagonPtr = sharedTextPtr->emptyTagInfoPtr);
+		tagoffPtr = NULL;
+
+		for (segPtr = linePtr->segPtr; segPtr; segPtr = segPtr->nextPtr) {
+		    if (segPtr->tagInfoPtr) {
+			tagonPtr = TkTextTagSetJoin(tagonPtr, segPtr->tagInfoPtr);
+			tagoffPtr = TagSetIntersect(tagoffPtr, segPtr->tagInfoPtr, sharedTextPtr);
+		    }
+		}
+
+		TagSetReplace(&linePtr->tagonPtr, tagonPtr);
+
+		if (tagoffPtr) {
+		    tagoffPtr = TagSetComplementTo(tagoffPtr, linePtr->tagonPtr, sharedTextPtr);
+		    TagSetReplace(&linePtr->tagoffPtr, tagoffPtr);
+		} else {
+		    TagSetAssign(&linePtr->tagoffPtr, linePtr->tagonPtr);
+		}
+
+		data->newTagonPtr = linePtr->tagonPtr;
+		data->newTagoffPtr = linePtr->tagoffPtr;
+	    }
+	} else if (discardSelection) {
+	    linePtr->tagonPtr = TagSetRemove(linePtr->tagonPtr, myAffectedTagInfoPtr, sharedTextPtr);
+	    linePtr->tagoffPtr = TagSetRemove(linePtr->tagoffPtr, myAffectedTagInfoPtr, sharedTextPtr);
+	} else {
+	    TagSetAssign(&linePtr->tagonPtr, sharedTextPtr->emptyTagInfoPtr);
+	    TagSetAssign(&linePtr->tagoffPtr, sharedTextPtr->emptyTagInfoPtr);
+	}
+
+	if (discardSelection) {
+	    if (affectedTagInfoPtr) {
+		affectedTagInfoPtr = TkTextTagSetJoin(affectedTagInfoPtr, myAffectedTagInfoPtr);
+	    }
+	    TkTextTagSetDecrRefCount(myAffectedTagInfoPtr);
+	} else if (redraw && affectedTagInfoPtr) {
+	    affectedTagInfoPtr = TkTextTagSetJoin(affectedTagInfoPtr, myAffectedTagInfoPtr);
+	    TkTextTagSetDecrRefCount(myAffectedTagInfoPtr);
+	}
+    }
+
+    return affectedTagInfoPtr;
+}
+
+static void
+ClearTagRoots(
+    const TkSharedText *sharedTextPtr,
+    const TkTextTagSet *affectedTags)
+{
+    unsigned i;
+
+    for (i = TkTextTagSetFindFirst(affectedTags);
+	    i != TK_TEXT_TAG_SET_NPOS;
+	    i = TkTextTagSetFindNext(affectedTags, i)) {
+	TkTextTag *tagPtr = sharedTextPtr->tagLookup[i];
+
+	assert(tagPtr);
+	tagPtr->rootPtr = NULL;
+    }
+}
+
+static void
+ClearTagsFromAllNodes(
+    TkSharedText *sharedTextPtr,
+    Node *nodePtr,
+    ClearTagsData *data,
+    bool discardSelection,
+    TkTextTagChangedProc changedProc,
+    TkText *textPtr)
+{
+    /*
+     * This is a very fast way to clear all tags, but this function only works
+     * if all the tags in the widget will be cleared.
+     */
+
+    if (!TestIfAnySegmentIsAffected(sharedTextPtr, nodePtr->tagonPtr, discardSelection)) {
+	return; /* nothing to do */
+    }
+
+    if (nodePtr->level > 0) {
+	Node *childPtr;
+
+	for (childPtr = nodePtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+	    ClearTagsFromAllNodes(sharedTextPtr, childPtr, data, discardSelection, changedProc, textPtr);
+	}
+    } else {
+	TkTextLine *linePtr = nodePtr->linePtr;
+	TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+
+	for ( ; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+	    if (TestIfAnySegmentIsAffected(sharedTextPtr, linePtr->tagonPtr, discardSelection)) {
+		ClearTagsFromLine(sharedTextPtr, linePtr, NULL, NULL, NULL, NULL, data,
+			discardSelection, false, changedProc, textPtr);
+	    } else if (data->firstSegPtr) {
+		data->skip += linePtr->size;
+	    }
+	}
+    }
+
+    if (discardSelection) {
+	nodePtr->tagonPtr = TagSetIntersectBits(nodePtr->tagonPtr,
+		sharedTextPtr->selectionTags, sharedTextPtr);
+	nodePtr->tagoffPtr = TagSetIntersectBits(nodePtr->tagoffPtr,
+		sharedTextPtr->selectionTags, sharedTextPtr);
+    } else {
+	TagSetAssign(&nodePtr->tagonPtr, sharedTextPtr->emptyTagInfoPtr);
+	TagSetAssign(&nodePtr->tagoffPtr, sharedTextPtr->emptyTagInfoPtr);
+    }
+}
+
+static TkTextTagSet *
+ClearTagsFromNode(
+    TkSharedText *sharedTextPtr,
+    Node *nodePtr,
+    unsigned firstLineNo,
+    unsigned lineNo1,
+    unsigned lineNo2,
+    TkTextSegment *segPtr1,	/* will not be free'd! */
+    TkTextSegment *segPtr2,	/* will not be free'd! */
+    TkTextTagSet *affectedTagInfoPtr,
+    UndoTokenTagClear *undoToken,
+    ClearTagsData *data,
+    bool discardSelection,
+    bool redraw,
+    TkTextTagChangedProc changedProc,
+    TkText *textPtr)
+{
+    TkTextTagSet *emptyTagInfoPtr = sharedTextPtr->emptyTagInfoPtr;
+    unsigned endLineNo = firstLineNo + nodePtr->numLines - 1;
+    TkTextTagSet *additionalTagoffPtr, *tagInfoPtr, *tagRootInfoPtr;
+    unsigned i;
+
+    if (endLineNo < lineNo1
+	    || lineNo2 < firstLineNo
+	    || !TestIfAnySegmentIsAffected(sharedTextPtr, nodePtr->tagonPtr, discardSelection)) {
+	/*
+	 * Nothing to do for this node.
+	 */
+
+	if (undoToken) {
+	    data->skip += nodePtr->size;
+	}
+	return affectedTagInfoPtr;
+    }
+
+    additionalTagoffPtr = NULL;
+    tagRootInfoPtr = NULL;
+    TkTextTagSetIncrRefCount(tagInfoPtr = nodePtr->tagonPtr);
+
+    if ((segPtr1 ? lineNo1 < firstLineNo : lineNo1 <= firstLineNo)
+	    && (segPtr2 ? endLineNo < lineNo2 : endLineNo <= lineNo2)) {
+	bool delegateRedraw = redraw
+		&& (discardSelection
+			? TkTextTagSetIntersectionIsEqual(nodePtr->tagonPtr, nodePtr->tagoffPtr,
+				sharedTextPtr->selectionTags)
+			: !TkTextTagSetIsEqual(nodePtr->tagonPtr, nodePtr->tagoffPtr));
+	TkTextIndex index1, index2;
+
+	TkTextIndexClear2(&index1, NULL, sharedTextPtr->tree);
+	TkTextIndexClear2(&index2, NULL, sharedTextPtr->tree);
+
+	if (delegateRedraw) {
+	    redraw = false;
+	}
+
+	/*
+	 * Whole node is affected.
+	 */
+
+	if (affectedTagInfoPtr) {
+	    affectedTagInfoPtr = TkTextTagSetJoin(affectedTagInfoPtr, nodePtr->tagonPtr);
+	    affectedTagInfoPtr = TagSetRemoveBits(affectedTagInfoPtr,
+		    sharedTextPtr->selectionTags, sharedTextPtr);
+	}
+
+	if (discardSelection) {
+	    nodePtr->tagonPtr = TagSetIntersectBits(
+		    nodePtr->tagonPtr, sharedTextPtr->selectionTags, sharedTextPtr);
+	    nodePtr->tagoffPtr = TagSetIntersectBits(
+		    nodePtr->tagoffPtr, sharedTextPtr->selectionTags, sharedTextPtr);
+	} else {
+	    TagSetAssign(&nodePtr->tagonPtr, emptyTagInfoPtr);
+	    TagSetAssign(&nodePtr->tagoffPtr, emptyTagInfoPtr);
+	}
+
+	if (nodePtr->level > 0) {
+	    Node *childPtr;
+
+	    for (childPtr = nodePtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+		ClearTagsFromNode(sharedTextPtr, childPtr, firstLineNo, lineNo1, lineNo2,
+			NULL, NULL, NULL, undoToken, data, discardSelection, delegateRedraw,
+			changedProc, textPtr);
+		firstLineNo += childPtr->numLines;
+	    }
+	} else {
+	    TkTextLine *linePtr = nodePtr->linePtr;
+	    TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+
+	    for ( ; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+		if (TestIfAnySegmentIsAffected(sharedTextPtr, linePtr->tagonPtr, discardSelection)) {
+		    ClearTagsFromLine(sharedTextPtr, linePtr, NULL, NULL, NULL, undoToken, data,
+			    discardSelection, delegateRedraw, changedProc, textPtr);
+		} else if (data->firstSegPtr) {
+		    data->skip += linePtr->size;
+		}
+	    }
+	}
+
+	if (redraw) {
+	    bool affectsDisplayGeometry = TestIfDisplayGeometryIsAffected(sharedTextPtr,
+		    nodePtr->tagonPtr, discardSelection);
+	    TkTextIndexSetToStartOfLine2(&index1, nodePtr->linePtr);
+	    TkTextIndexSetToEndOfLine2(&index2,
+		    nodePtr->lastPtr->nextPtr ? nodePtr->lastPtr: nodePtr->lastPtr->prevPtr);
+	    changedProc(sharedTextPtr, textPtr, &index1, &index2, NULL, affectsDisplayGeometry);
+	}
+    } else {
+	TagSetAssign(&nodePtr->tagonPtr, emptyTagInfoPtr);
+	TagSetAssign(&nodePtr->tagoffPtr, emptyTagInfoPtr);
+
+	if (nodePtr->level > 0) {
+	    Node *childPtr;
+
+	    TkTextTagSetIncrRefCount(tagRootInfoPtr = emptyTagInfoPtr);
+
+	    for (childPtr = nodePtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+		affectedTagInfoPtr = ClearTagsFromNode(sharedTextPtr, childPtr, firstLineNo,
+			lineNo1, lineNo2, segPtr1, segPtr2, affectedTagInfoPtr, undoToken, data,
+			discardSelection, redraw, changedProc, textPtr);
+		tagRootInfoPtr = TagSetJoinOfDifferences(
+			tagRootInfoPtr, childPtr->tagonPtr, nodePtr->tagonPtr, sharedTextPtr);
+		nodePtr->tagonPtr = TkTextTagSetJoin(nodePtr->tagonPtr, childPtr->tagonPtr);
+		nodePtr->tagoffPtr = TkTextTagSetJoin(nodePtr->tagoffPtr, childPtr->tagoffPtr);
+		additionalTagoffPtr = TagSetIntersect(additionalTagoffPtr,
+			childPtr->tagonPtr, sharedTextPtr);
+		firstLineNo += childPtr->numLines;
+	    }
+
+	    tagRootInfoPtr = TkTextTagSetComplementTo(tagRootInfoPtr, nodePtr->tagonPtr);
+	} else {
+	    TkTextLine *linePtr = nodePtr->linePtr;
+	    TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+	    TkTextIndex index1, index2;
+
+	    TkTextIndexClear2(&index1, NULL, sharedTextPtr->tree);
+	    TkTextIndexClear2(&index2, NULL, sharedTextPtr->tree);
+
+	    for ( ; linePtr != lastPtr; linePtr = linePtr->nextPtr, ++firstLineNo) {
+		if (firstLineNo >= lineNo1 && firstLineNo <= lineNo2) {
+		    if (TestIfAnySegmentIsAffected(sharedTextPtr, linePtr->tagonPtr,
+				discardSelection)) {
+			TkTextSegment *startSegPtr = (firstLineNo == lineNo1) ? segPtr1 : NULL;
+			TkTextSegment *stopSegPtr = (firstLineNo == lineNo2) ? segPtr2 : NULL;
+
+			affectedTagInfoPtr = ClearTagsFromLine(sharedTextPtr, linePtr, startSegPtr,
+				stopSegPtr, affectedTagInfoPtr, undoToken, data, discardSelection,
+				redraw, changedProc, textPtr);
+		    } else if (data->firstSegPtr) {
+			data->skip += linePtr->size;
+		    }
+		}
+
+		nodePtr->tagonPtr = TkTextTagSetJoin(nodePtr->tagonPtr, linePtr->tagonPtr);
+		nodePtr->tagoffPtr = TkTextTagSetJoin(nodePtr->tagoffPtr, linePtr->tagoffPtr);
+		additionalTagoffPtr = TagSetIntersect(additionalTagoffPtr,
+			linePtr->tagonPtr, sharedTextPtr);
+	    }
+	}
+    }
+
+    if (additionalTagoffPtr) {
+	nodePtr->tagoffPtr = TagSetJoinComplementTo(
+		nodePtr->tagoffPtr, additionalTagoffPtr, nodePtr->tagonPtr, sharedTextPtr);
+	TkTextTagSetDecrRefCount(additionalTagoffPtr);
+    } else {
+	TagSetAssign(&nodePtr->tagoffPtr, nodePtr->tagonPtr);
+    }
+
+    /*
+     * Update tag roots.
+     */
+
+    if (tagRootInfoPtr) {
+	for (i = TkTextTagSetFindFirst(tagInfoPtr);
+		i != TK_TEXT_TAG_SET_NPOS;
+		i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	    TkTextTag *tagPtr = sharedTextPtr->tagLookup[i];
+
+	    assert(tagPtr);
+	    assert(!tagPtr->isDisabled);
+
+	    if (TkTextTagSetTest(tagRootInfoPtr, i)) {
+		tagPtr->rootPtr = nodePtr;
+	    } else if (tagPtr->rootPtr == nodePtr) {
+		tagPtr->rootPtr = NULL;
+	    }
+	}
+
+	TkTextTagSetDecrRefCount(tagRootInfoPtr);
+    } else {
+	tagInfoPtr = TkTextTagSetRemove(tagInfoPtr, nodePtr->tagonPtr);
+
+	for (i = TkTextTagSetFindFirst(tagInfoPtr);
+		i != TK_TEXT_TAG_SET_NPOS;
+		i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	    TkTextTag *tagPtr = sharedTextPtr->tagLookup[i];
+
+	    assert(tagPtr);
+	    assert(!tagPtr->isDisabled);
+	    tagPtr->rootPtr = NULL;
+	}
+    }
+
+    TkTextTagSetDecrRefCount(tagInfoPtr);
+    return affectedTagInfoPtr;
+}
+
+static bool
+CheckIfAnyTagIsAffected(
+    TkSharedText *sharedTextPtr,
+    const TkTextTagSet *tagInfoPtr,
+    bool discardSelection)
+{
+    unsigned i;
+
+    for (i = TkTextTagSetFindFirst(tagInfoPtr);
+	    i != TK_TEXT_TAG_SET_NPOS;
+	    i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	TkTextTag *tagPtr = sharedTextPtr->tagLookup[i];
+
+	assert(tagPtr);
+	assert(!tagPtr->isDisabled);
+
+	if (!discardSelection || !TkBitTest(sharedTextPtr->selectionTags, tagPtr->index)) {
+	    return true;
+	}
+    }
+
+    return false;
+}
+
+TkTextTag *
+TkBTreeClearTags(
+    TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    TkText *textPtr,			/* Information about text widget, can be NULL. */
+    const TkTextIndex *indexPtr1,	/* Start clearing tags here. */
+    const TkTextIndex *indexPtr2,	/* Stop clearing tags here. */
+    TkTextUndoInfo *undoInfo,		/* Store undo information, can be NULL. */
+    bool discardSelection,		/* Discard the special selection tag (do not delete)? */
+    TkTextTagChangedProc changedProc)	/* Trigger this callback when any tag will be added/removed. */
+{
+    TkTextTag *chainPtr;
+    UndoTokenTagClear *undoToken;
+    TkTextSegment *segPtr1, *segPtr2;
+    TkTextTagSet *affectedTagInfoPtr;
+    TkTextLine *linePtr1, *linePtr2;
+    TkTextIndex startIndex, endIndex;
+    Node *rootPtr;
+    bool wholeText;
+    unsigned i;
+
+    assert(TkTextIndexCompare(indexPtr1, indexPtr2) <= 0);
+    assert(changedProc);
+
+    if (TkTextIndexIsEqual(indexPtr1, indexPtr2)) {
+	return NULL;
+    }
+
+    linePtr1 = TkTextIndexGetLine(indexPtr1);
+    linePtr2 = TkTextIndexGetLine(indexPtr2);
+    rootPtr = FindCommonParent(linePtr1->parentPtr, linePtr2->parentPtr);
+
+    if (discardSelection
+	    ? TkTextTagBitContainsSet(sharedTextPtr->selectionTags, rootPtr->tagonPtr)
+	    : rootPtr->tagonPtr == sharedTextPtr->emptyTagInfoPtr) {
+	return NULL; /* there is nothing to do */
+    }
+
+    /*
+     * Try to restrict the range, because in general we have to process all the segments
+     * inside the range, and this is a bit expensive. The search for smaller bounds is
+     * quite fast because it uses the B-Tree. But if the range is small, then it's not
+     * worth to search for smaller bounds.
+     */
+
+    if (linePtr1->parentPtr != linePtr2->parentPtr) {
+	const TkTextSegment *segPtr;
+	TkTextIndex oneBack;
+
+	segPtr = TkBTreeFindNextTagged(indexPtr1, indexPtr2,
+		discardSelection ? sharedTextPtr->selectionTags : NULL);
+	if (!segPtr) {
+	    return NULL;
+	}
+	TkTextIndexClear2(&startIndex, NULL, sharedTextPtr->tree);
+	TkTextIndexSetSegment(&startIndex, (TkTextSegment *) segPtr);
+	TkTextIndexBackChars(textPtr, indexPtr1, 1, &oneBack, COUNT_DISPLAY_INDICES);
+	segPtr = TkBTreeFindPrevTagged(&oneBack, indexPtr1, discardSelection);
+	assert(segPtr);
+	TkTextIndexClear2(&endIndex, NULL, sharedTextPtr->tree);
+	TkTextIndexSetSegment(&endIndex, (TkTextSegment *) segPtr);
+	assert(TkTextIndexCompare(&startIndex, &endIndex) <= 0);
+    } else {
+	startIndex = *indexPtr1;
+	endIndex = *indexPtr2;
+    }
+
+    if (!FindSplitPoints(sharedTextPtr, &startIndex, &endIndex, NULL, false, &segPtr1, &segPtr2)) {
+	return NULL;
+    }
+
+    linePtr1 = TkTextIndexGetLine(&startIndex);
+    linePtr2 = TkTextIndexGetLine(&endIndex);
+    segPtr1->protectionFlag = true;
+    segPtr2->protectionFlag = true;
+    undoToken = NULL;
+    chainPtr = NULL;
+    wholeText = false;
+
+    /*
+     * Now we will test whether we can accelerate a frequent case: all tagged segments
+     * will be cleared. But if the range is small, then it's not worth to test for this
+     * case.
+     */
+
+    if (!undoInfo) {
+	if (TkTextIndexIsStartOfText(indexPtr1) && TkTextIndexIsEndOfText(indexPtr2)) {
+	    wholeText = true;
+	} else if (linePtr1->parentPtr != linePtr2->parentPtr) {
+	    TkTextIndex index1, index2;
+
+	    wholeText = true;
+
+	    if (TkTextIndexBackChars(textPtr, indexPtr1, 1, &index1, COUNT_DISPLAY_INDICES)) {
+		TkTextIndexSetupToStartOfText(&index2, textPtr, sharedTextPtr->tree);
+		if (TkBTreeFindPrevTagged(&index1, &index2, discardSelection)) {
+		    wholeText = false;
+		}
+	    }
+
+	    if (wholeText && !TkTextIndexIsEndOfText(indexPtr2)) {
+		TkTextIndexSetupToEndOfText(&index2, textPtr, sharedTextPtr->tree);
+		if (TkBTreeFindNextTagged(indexPtr2, &index2,
+			discardSelection ? sharedTextPtr->selectionTags : NULL)) {
+		    wholeText = false;
+		}
+	    }
+	}
+    }
+
+    TkTextTagSetIncrRefCount(affectedTagInfoPtr = sharedTextPtr->emptyTagInfoPtr);
+
+    if (!wholeText || CheckIfAnyTagIsAffected(sharedTextPtr, rootPtr->tagonPtr, discardSelection)) {
+	bool anyChanges = wholeText; /* already checked for this case */
+	ClearTagsData data;
+
+	memset(&data, 0, sizeof(data));
+	rootPtr = TkBTreeGetRoot(sharedTextPtr->tree); /* we must start at top level */
+
+	if (TkBTreeHaveElidedSegments(sharedTextPtr)) {
+	    UpdateElideInfo(sharedTextPtr, NULL, segPtr1, segPtr2, ELISION_WILL_BE_REMOVED);
+	}
+
+	if (wholeText) {
+	    assert(!undoInfo);
+	    TagSetAssign(&affectedTagInfoPtr, rootPtr->tagonPtr);
+	    ClearTagsFromAllNodes(sharedTextPtr, rootPtr, &data, discardSelection, changedProc, textPtr);
+	    ClearTagRoots(sharedTextPtr, affectedTagInfoPtr);
+	    if (TkTextTagSetIntersectsBits(affectedTagInfoPtr, sharedTextPtr->affectDisplayTags)) {
+		/* TODO: probably it's better to search for all affected ranges. */
+		/* TODO: probably it's better to delegate the redraw to ClearTagsFromAllNodes,
+		 *       especially because of 'affectsDisplayGeometry'. */
+		bool affectsDisplayGeometry = TestIfDisplayGeometryIsAffected(sharedTextPtr,
+			affectedTagInfoPtr, discardSelection);
+		changedProc(sharedTextPtr, textPtr, &startIndex, &endIndex,
+			NULL, affectsDisplayGeometry);
+	    }
+	} else {
+	    TkTextSegment *firstPtr, *lastPtr;
+	    int lineNo1, lineNo2;
+
+	    if (undoInfo) {
+		undoToken = malloc(sizeof(UndoTokenTagClear));
+		undoInfo->token = (TkTextUndoToken *) undoToken;
+		undoInfo->byteSize = 0;
+		undoToken->undoType = &undoTokenClearTagsType;
+		undoToken->changeList = NULL;
+		undoToken->changeListSize = 0;
+		DEBUG_ALLOC(tkTextCountNewUndoToken++);
+	    }
+
+	    firstPtr = segPtr1;
+	    if (TkTextIndexIsStartOfLine(&endIndex)) {
+		lastPtr = NULL;
+		linePtr2 = linePtr2->prevPtr;
+	    } else {
+		lastPtr = segPtr2;
+	    }
+	    lineNo1 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, linePtr1, NULL);
+	    lineNo2 = (linePtr1 == linePtr2) ?
+		    lineNo1 : TkBTreeLinesTo(sharedTextPtr->tree, NULL, linePtr2, NULL);
+
+	    affectedTagInfoPtr = ClearTagsFromNode(sharedTextPtr, rootPtr, 0, lineNo1, lineNo2,
+	    		firstPtr, lastPtr, affectedTagInfoPtr, undoToken, &data, discardSelection,
+			true, changedProc, textPtr);
+	    anyChanges = CheckIfAnyTagIsAffected(sharedTextPtr, affectedTagInfoPtr, discardSelection);
+
+	    if (undoToken) {
+		if (anyChanges
+			&& !TkTextTagBitContainsSet(sharedTextPtr->selectionTags, affectedTagInfoPtr)) {
+		    TkTextIndex index1 = startIndex;
+		    TkTextIndex index2 = endIndex;
+
+		    assert(data.lastSegPtr);
+		    TkTextIndexSetSegment(&index1, data.firstSegPtr);
+		    if (data.lastSegPtr->nextPtr) {
+			data.lastSegPtr = data.lastSegPtr->nextPtr;
+		    } else if (data.lastSegPtr->sectionPtr->linePtr->nextPtr) {
+			data.lastSegPtr = data.lastSegPtr->sectionPtr->linePtr->nextPtr->segPtr;
+		    }
+		    if (data.lastSegPtr->sectionPtr->linePtr == GetLastLine(sharedTextPtr, textPtr)) {
+			data.lastSegPtr = textPtr->endMarker;
+		    }
+		    MakeUndoIndex(sharedTextPtr, &index1, &undoToken->startIndex, GRAVITY_LEFT);
+		    MakeUndoIndex(sharedTextPtr, &index2, &undoToken->endIndex, GRAVITY_RIGHT);
+		} else {
+		    undoToken->changeListSize = 0;
+		}
+	    }
+	}
+
+	if (anyChanges) {
+	    if (!wholeText) {
+		if (!TkTextIndexIsStartOfLine(&startIndex)) {
+		    RecomputeLineTagInfo(linePtr1, NULL, sharedTextPtr);
+		    if (linePtr1 == linePtr2) {
+			linePtr2 = NULL;
+		    }
+		}
+		if (linePtr2 && !TkTextIndexIsStartOfLine(&endIndex)) {
+		    RecomputeLineTagInfo(linePtr2, NULL, sharedTextPtr);
+		}
+	    }
+
+	    /*
+	     * Build a chain of all affected tags.
+	     */
+
+	    for (i = TkTextTagSetFindFirst(affectedTagInfoPtr);
+		    i != TK_TEXT_TAG_SET_NPOS;
+		    i = TkTextTagSetFindNext(affectedTagInfoPtr, i)) {
+		TkTextTag *tagPtr = sharedTextPtr->tagLookup[i];
+
+		assert(tagPtr);
+		assert(!tagPtr->isDisabled);
+
+		tagPtr->nextPtr = chainPtr;
+		tagPtr->epoch = 0;
+		chainPtr = tagPtr;
+	    }
+	    TkTextTagSetDecrRefCount(affectedTagInfoPtr);
+	    TkBTreeIncrEpoch(sharedTextPtr->tree);
+	}
+    }
+
+    if (undoToken) {
+	if (undoToken->changeListSize == 0) {
+	    free(undoToken->changeList);
+	    free(undoToken);
+	    undoInfo->token = NULL;
+	    DEBUG_ALLOC(tkTextCountNewUndoToken--);
+	} else {
+	    undoToken->changeList = realloc(undoToken->changeList,
+		    undoToken->changeListSize * sizeof(undoToken->changeList[0]));
+	}
+    }
+
+    CleanupSplitPoint(segPtr1, sharedTextPtr);
+    CleanupSplitPoint(segPtr2, sharedTextPtr);
+
+    TK_BTREE_DEBUG(TkBTreeCheck(indexPtr1->tree));
+    return chainPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FindTagStart --
+ *
+ *	Find the start of the first range of a tag.
+ *
+ * Results:
+ *	The return value is a pointer to the first tag toggle segment for the
+ *	tag. This can be either a tagon or tagoff segment. Sets *indexPtr to be
+ *	the index of the tag toggle.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextSegment *
+FindTagStartInLine(
+    TkTextSearch *searchPtr,
+    TkTextLine *linePtr,
+    TkTextSegment *segPtr,
+    bool testTagon)
+{
+    TkTextIndex *indexPtr = &searchPtr->curIndex;
+    const TkTextTag *tagPtr = searchPtr->tagPtr;
+    const TkTextSegment *lastPtr;
+    int byteOffset;
+
+    assert(tagPtr);
+
+    if (LineTestAllSegments(linePtr, tagPtr, testTagon)) {
+	if (!segPtr) {
+	    TkTextIndexSetToStartOfLine2(indexPtr, linePtr);
+	} else {
+	    TkTextIndexSetSegment(indexPtr, segPtr);
+	}
+	segPtr = TkTextIndexGetContentSegment(indexPtr, NULL);
+	return segPtr;
+    }
+
+    if (segPtr) {
+	byteOffset = TkTextIndexGetByteIndex(indexPtr);
+    } else {
+	assert(!searchPtr->textPtr || linePtr != searchPtr->textPtr->startMarker->sectionPtr->linePtr);
+	segPtr = linePtr->segPtr;
+	byteOffset = 0;
+    }
+    lastPtr = (linePtr == searchPtr->lastLinePtr) ? searchPtr->lastPtr : NULL;
+
+    while (segPtr != lastPtr) {
+	if (segPtr->tagInfoPtr) {
+	    if (TkTextTagSetTest(segPtr->tagInfoPtr, tagPtr->index) == testTagon) {
+		TkTextIndexSetByteIndex2(indexPtr, linePtr, byteOffset);
+		return segPtr;
+	    }
+	    byteOffset += segPtr->size;
+	}
+	segPtr = segPtr->nextPtr;
+    }
+
+    return NULL;
+}
+
+static const Node *
+FindTagStartInSubtree(
+    const Node *nodePtr,
+    unsigned startLineNo,
+    unsigned endLineNo,
+    unsigned lineNumber,
+    const Node *excludePtr,	/* we don't want this result */
+    unsigned tagIndex)
+{
+    assert(nodePtr->level > 0);
+
+    for (nodePtr = nodePtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+	if (nodePtr != excludePtr && startLineNo < lineNumber + nodePtr->numLines) {
+	    bool testTagon = !LineTestIfToggleIsOpen(nodePtr->linePtr->prevPtr, tagIndex);
+
+	    if (NodeTestToggleFwd(nodePtr, tagIndex, testTagon)) {
+		const Node *nPtr;
+
+		if (nodePtr->level == 0) {
+		    return nodePtr;
+		}
+		nPtr = FindTagStartInSubtree(
+			nodePtr, startLineNo, endLineNo, lineNumber, excludePtr, tagIndex);
+		if (nPtr) {
+		    return nPtr;
+		}
+	    }
+	}
+	if ((lineNumber += nodePtr->numLines) > endLineNo) {
+	    return NULL;
+	}
+    }
+
+    return NULL;
+}
+
+static TkTextSegment *
+FindTagStart(
+    TkTextSearch *searchPtr,
+    const TkTextIndex *stopIndex)
+{
+    TkTextIndex *indexPtr = &searchPtr->curIndex;
+    const TkTextTag *tagPtr = searchPtr->tagPtr;
+    TkTextLine *linePtr;
+    const TkTextLine *lastLinePtr;
+    const TkTextLine *lastPtr;
+    TkTextSegment *segPtr;
+    bool testTagon;
+    const Node *nodePtr;
+    const Node *rootPtr;
+    unsigned startLineNumber;
+    unsigned endLineNumber;
+    unsigned lineNumber;
+    unsigned tagIndex;
+
+    assert(tagPtr);
+
+    if (!tagPtr->rootPtr) {
+	return NULL;
+    }
+
+    tagIndex = tagPtr->index;
+    linePtr = TkTextIndexGetLine(indexPtr);
+    lastLinePtr = searchPtr->lastLinePtr;
+    testTagon = !LineTestIfToggleIsOpen(linePtr->prevPtr, tagIndex);
+
+    if (LineTestToggleFwd(linePtr, tagIndex, testTagon)) {
+	TkTextSegment *sPtr;
+
+	segPtr = TkTextIndexGetContentSegment(&searchPtr->curIndex, NULL);
+
+	if (!TkTextTagSetTest(testTagon ? linePtr->tagoffPtr : linePtr->tagonPtr, tagIndex)) {
+	    return segPtr;
+	}
+	if (searchPtr->mode == SEARCH_EITHER_TAGON_TAGOFF) {
+	    sPtr = GetFirstTagInfoSegment(searchPtr->textPtr, linePtr);
+	    for ( ; sPtr != segPtr; sPtr = sPtr->nextPtr) {
+		if (sPtr->tagInfoPtr && TkTextTagSetTest(sPtr->tagInfoPtr, tagIndex) == testTagon) {
+		    testTagon = !testTagon;
+		}
+	    }
+	}
+	if ((segPtr = FindTagStartInLine(searchPtr, linePtr, segPtr, testTagon))) {
+	    return segPtr;
+	}
+	if (linePtr == lastLinePtr) {
+	    return NULL;
+	}
+	testTagon = !LineTestIfToggleIsOpen(linePtr, tagIndex);
+    } else if (linePtr == lastLinePtr) {
+	return NULL;
+    }
+
+    nodePtr = linePtr->parentPtr;
+    if (TkTextTagSetTest(testTagon ? nodePtr->tagonPtr : nodePtr->tagoffPtr, tagIndex)) {
+	lastPtr = nodePtr->lastPtr->nextPtr;
+
+	while ((linePtr = linePtr->nextPtr) != lastPtr) {
+	    if (LineTestToggleFwd(linePtr, tagIndex, testTagon)) {
+		return FindTagStartInLine(searchPtr, linePtr, NULL, testTagon);
+	    }
+	    if (linePtr == lastLinePtr) {
+		return NULL;
+	    }
+	}
+    }
+
+    rootPtr = tagPtr->rootPtr;
+    if (rootPtr == nodePtr) {
+	if (!nodePtr->nextPtr) {
+	    Node *parentPtr = nodePtr->parentPtr;
+
+	    while (parentPtr && !parentPtr->nextPtr) {
+		parentPtr = parentPtr->parentPtr;
+	    }
+	    if (!parentPtr) {
+		return NULL;
+	    }
+	    nodePtr = parentPtr->nextPtr;
+	}
+	linePtr = nodePtr->nextPtr->linePtr;
+	lineNumber = TkBTreeLinesTo(indexPtr->tree, NULL, linePtr, NULL);
+	if (lineNumber > TkTextIndexGetLineNumber(stopIndex, NULL)) {
+	    return NULL;
+	}
+	segPtr = linePtr->segPtr;
+	while (!segPtr->tagInfoPtr && segPtr != searchPtr->lastPtr) {
+	    segPtr = segPtr->nextPtr;
+	}
+	return segPtr == searchPtr->lastPtr ? NULL : segPtr;
+    }
+
+    startLineNumber = TkTextIndexGetLineNumber(indexPtr, NULL);
+    endLineNumber = TkTextIndexGetLineNumber(stopIndex, NULL);
+    lineNumber = TkBTreeLinesTo(indexPtr->tree, NULL, rootPtr->linePtr, NULL);
+
+    if (lineNumber > endLineNumber || startLineNumber >= lineNumber + rootPtr->numLines) {
+	return NULL;
+    }
+
+    if (rootPtr->level == 0) {
+	nodePtr = rootPtr;
+    } else {
+	nodePtr = FindTagStartInSubtree(
+		rootPtr, startLineNumber, endLineNumber, lineNumber, nodePtr, tagPtr->index);
+	if (!nodePtr) {
+	    return NULL;
+	}
+	lineNumber = TkBTreeLinesTo(indexPtr->tree, NULL, nodePtr->linePtr, NULL);
+    }
+
+    assert(nodePtr->level == 0);
+    assert(lineNumber >= startLineNumber);
+
+    lastPtr = nodePtr->lastPtr->nextPtr;
+    testTagon = !LineTestIfToggleIsOpen(linePtr->prevPtr, tagIndex);
+
+    for (linePtr = nodePtr->linePtr; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+	if (LineTestToggleFwd(linePtr, tagIndex, testTagon)) {
+	    return FindTagStartInLine(searchPtr, linePtr, NULL, testTagon);
+	}
+	if (linePtr == lastLinePtr) {
+	    return NULL;
+	}
+    }
+
+    return NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FindTagEnd --
+ *
+ *	Find the end of the last range of a tag.
+ *
+ * Results:
+ *	The return value is a pointer to the last tag toggle segment for the
+ *	tag. This can be either a tagon or tagoff segment. Sets *indexPtr to be
+ *	the index of the tag toggle.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+HasLeftNode(
+    const Node *nodePtr)
+{
+    assert(nodePtr);
+    return nodePtr->parentPtr && nodePtr->parentPtr->childPtr != nodePtr;
+}
+
+static TkTextSegment *
+FindTagEndInLine(
+    TkTextSearch *searchPtr,
+    TkTextLine *linePtr,
+    TkTextSegment *segPtr,
+    bool testTagon)
+{
+    TkTextIndex *indexPtr = &searchPtr->curIndex;
+    const TkTextTag *tagPtr = searchPtr->tagPtr;
+    TkTextSegment *lastPtr;
+    TkTextSegment *firstPtr;
+    TkTextSegment *prevPtr;
+    int byteOffset, offset = 0;
+
+    assert(tagPtr);
+
+    if (LineTestAllSegments(linePtr, tagPtr, testTagon)) {
+	if (!segPtr || linePtr != searchPtr->lastLinePtr) {
+	    TkTextIndexSetToStartOfLine2(indexPtr, linePtr);
+	} else {
+	    lastPtr = searchPtr->lastPtr;
+	    while (segPtr && segPtr != lastPtr) {
+		segPtr = segPtr->prevPtr;
+	    }
+	    TkTextIndexSetSegment(indexPtr, segPtr);
+	}
+	segPtr = TkTextIndexGetContentSegment(indexPtr, NULL);
+	return segPtr;
+    }
+
+    if (segPtr) {
+	byteOffset = TkTextIndexGetByteIndex(indexPtr);
+    } else if (searchPtr->textPtr && linePtr == searchPtr->textPtr->endMarker->sectionPtr->linePtr) {
+	segPtr = searchPtr->textPtr->endMarker;
+        byteOffset = TkTextSegToIndex(segPtr);
+    } else {
+	segPtr = linePtr->lastPtr;
+	byteOffset = linePtr->size - segPtr->size;
+    }
+    lastPtr = (linePtr == searchPtr->lastLinePtr) ? searchPtr->lastPtr : NULL;
+    firstPtr = prevPtr = NULL;
+
+    while (segPtr) {
+	if (segPtr->tagInfoPtr) {
+	    if (TkTextTagSetTest(segPtr->tagInfoPtr, tagPtr->index)) {
+		if (prevPtr) {
+		    TkTextIndexSetByteIndex2(indexPtr, linePtr, offset);
+		    return prevPtr;
+		}
+		if (testTagon) {
+		    prevPtr = segPtr;
+		}
+		firstPtr = segPtr;
+	    } else if (firstPtr) {
+		TkTextIndexSetByteIndex2(indexPtr, linePtr, offset);
+		return firstPtr;
+	    } else if (!testTagon) {
+		prevPtr = segPtr;
+	    }
+	    offset = byteOffset;
+	}
+	if (segPtr == lastPtr) {
+	    break;
+	}
+	if ((segPtr = segPtr->prevPtr)) {
+	    byteOffset -= segPtr->size;
+	}
+    }
+
+    if (firstPtr
+	    && firstPtr == GetFirstTagInfoSegment(searchPtr->textPtr, linePtr)
+	    && !LineTestIfToggleIsOpen(linePtr->prevPtr, tagPtr->index)) {
+	TkTextIndexSetByteIndex2(&searchPtr->curIndex, linePtr, offset);
+	return firstPtr;
+    }
+
+    return NULL;
+}
+
+static const Node *
+FindTagEndInSubtree(
+    const Node *nodePtr,
+    unsigned startLineNo,	/* start of search interval */
+    unsigned endLineNo,		/* end of search interval */
+    unsigned lineNumber,	/* line number of last line in this node */
+    const Node *excludePtr,	/* we don't want this result */
+    unsigned tagIndex)
+{
+    const Node *stack[MAX_CHILDREN];
+    unsigned count = 0;
+
+    assert(nodePtr->level > 0);
+
+    lineNumber -= nodePtr->numLines - 1; /* now it's the line number of first line in this node */
+
+    for (nodePtr = nodePtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+	stack[count++] = nodePtr;
+	lineNumber += nodePtr->numLines;
+	if (startLineNo < lineNumber) {
+	    break;
+	}
+    }
+
+    lineNumber -= 1; /* now it's the line number of the last line in last node */
+
+    while (count > 0) {
+	nodePtr = stack[--count];
+	if (nodePtr != excludePtr && startLineNo >= lineNumber - nodePtr->numLines + 1) {
+	    bool testTagon = !LineTestIfToggleIsClosed(nodePtr->lastPtr->nextPtr, tagIndex);
+
+	    if (NodeTestToggleBack(nodePtr, tagIndex, testTagon)) {
+		const Node *nPtr;
+
+		if (nodePtr->level == 0) {
+		    return nodePtr;
+		}
+		nPtr = FindTagEndInSubtree(
+			nodePtr, startLineNo, endLineNo, lineNumber, excludePtr, tagIndex);
+		if (nPtr) {
+		    return nPtr;
+		}
+	    }
+	}
+	if ((lineNumber -= nodePtr->numLines) + 1 <= endLineNo) {
+	    return NULL;
+	}
+    }
+
+    return NULL;
+}
+
+static TkTextSegment *
+FindTagEnd(
+    TkTextSearch *searchPtr,
+    const TkTextIndex *stopIndex)
+{
+    TkTextIndex *indexPtr = &searchPtr->curIndex;
+    const TkTextTag *tagPtr = searchPtr->tagPtr;
+    TkTextLine *linePtr;
+    const TkTextLine *lastLinePtr, *lastPtr;
+    TkTextSegment *segPtr;
+    bool testTagon;
+    const Node *nodePtr;
+    const Node *rootPtr;
+    unsigned startLineNumber;
+    unsigned endLineNumber;
+    unsigned lineNumber;
+    unsigned tagIndex;
+
+    assert(tagPtr);
+
+    if (!tagPtr->rootPtr) {
+	return NULL;
+    }
+
+    tagIndex = tagPtr->index;
+    linePtr = TkTextIndexGetLine(indexPtr);
+    lastLinePtr = searchPtr->lastLinePtr;
+    testTagon = !LineTestIfToggleIsClosed(linePtr->nextPtr, tagIndex);
+
+    /*
+     * Here testTagon == true means: test for the segment which starts the tagged region.
+     */
+
+    if (LineTestToggleBack(linePtr, tagIndex, testTagon)) {
+	TkTextSegment *sPtr;
+
+	segPtr = TkTextIndexGetContentSegment(&searchPtr->curIndex, NULL);
+
+	for (sPtr = linePtr->lastPtr; sPtr != segPtr; sPtr = sPtr->prevPtr) {
+	    if (sPtr->tagInfoPtr && TkTextTagSetTest(sPtr->tagInfoPtr, tagIndex) != testTagon) {
+		testTagon = !testTagon;
+	    }
+	}
+	if ((segPtr = FindTagEndInLine(searchPtr, linePtr, segPtr, testTagon))) {
+	    return segPtr;
+	}
+	if (linePtr == lastLinePtr) {
+	    return NULL;
+	}
+	testTagon = !LineTestIfToggleIsClosed(linePtr, tagIndex);
+    } else if (linePtr == lastLinePtr) {
+	return NULL;
+    }
+
+    nodePtr = linePtr->parentPtr;
+    if (TkTextTagSetTest(testTagon ? nodePtr->tagonPtr : nodePtr->tagoffPtr, tagIndex)) {
+	lastPtr = nodePtr->linePtr->prevPtr;
+
+	while ((linePtr = linePtr->prevPtr) != lastPtr) {
+	    if (LineTestToggleBack(linePtr, tagIndex, testTagon)) {
+		return FindTagEndInLine(searchPtr, linePtr, NULL, testTagon);
+	    }
+	    if (linePtr == lastLinePtr) {
+		return NULL;
+	    }
+	}
+    }
+
+    rootPtr = tagPtr->rootPtr;
+    if (rootPtr == nodePtr) {
+	const Node *nPtr, *prevPtr = NULL;
+
+	if (!HasLeftNode(nodePtr)) {
+	    Node *parentPtr = nodePtr->parentPtr;
+
+	    while (parentPtr && !HasLeftNode(parentPtr)) {
+		parentPtr = parentPtr->parentPtr;
+	    }
+	    if (!parentPtr) {
+		return NULL;
+	    }
+	    nodePtr = parentPtr;
+	}
+	for (nPtr = nodePtr->parentPtr->childPtr; nPtr != nodePtr; nPtr = nPtr->nextPtr) {
+	    prevPtr = nPtr;
+	}
+	if (!prevPtr || !(linePtr = prevPtr->lastPtr->prevPtr)) {
+	    return NULL;
+	}
+	lineNumber = TkBTreeLinesTo(indexPtr->tree, NULL, linePtr, NULL);
+	if (lineNumber < TkTextIndexGetLineNumber(stopIndex, NULL)) {
+	    return NULL;
+	}
+	return linePtr->lastPtr == searchPtr->lastPtr ? NULL : linePtr->lastPtr;
+    }
+
+    startLineNumber = TkTextIndexGetLineNumber(indexPtr, NULL);
+    endLineNumber = TkTextIndexGetLineNumber(stopIndex, NULL);
+    lineNumber = TkBTreeLinesTo(indexPtr->tree, NULL, rootPtr->lastPtr, NULL);
+
+    if (endLineNumber > lineNumber || lineNumber >= startLineNumber + rootPtr->numLines) {
+	return NULL;
+    }
+
+    if (rootPtr->level == 0) {
+	nodePtr = rootPtr;
+    } else {
+	nodePtr = FindTagEndInSubtree(rootPtr, startLineNumber, endLineNumber,
+		lineNumber, nodePtr, tagPtr->index);
+	if (!nodePtr) {
+	    return NULL;
+	}
+	lineNumber = TkBTreeLinesTo(indexPtr->tree, NULL, nodePtr->lastPtr, NULL);
+    }
+
+    assert(nodePtr->level == 0);
+    assert(lineNumber <= startLineNumber);
+
+    if (!testTagon && NodeTestAllSegments(nodePtr, tagIndex, true)) {
+	linePtr = nodePtr->lastPtr;
+	if (linePtr->nextPtr) { linePtr = linePtr->nextPtr; }
+	TkTextIndexSetToStartOfLine2(&searchPtr->curIndex, linePtr);
+	return linePtr->segPtr;
+    }
+
+    lastPtr = nodePtr->linePtr->prevPtr;
+    testTagon = !LineTestIfToggleIsClosed(linePtr, tagIndex);
+
+    for (linePtr = nodePtr->lastPtr; linePtr != lastPtr; linePtr = linePtr->prevPtr) {
+	if (LineTestToggleBack(linePtr, tagIndex, testTagon)) {
+	    return FindTagEndInLine(searchPtr, linePtr, NULL, testTagon);
+	}
+	if (linePtr == lastLinePtr) {
+	    return NULL;
+	}
+    }
+
+    return NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeStartSearch --
+ *
+ *	This function sets up a search for tag transitions involving a given
+ *	tag in a given range of the text.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The information at *searchPtr is set up so that subsequent calls to
+ *	TkBTreeNextTag or TkBTreePrevTag will return information about the
+ *	locations of tag transitions. Note that TkBTreeNextTag or
+ *	TkBTreePrevTag must be called to get the first transition. Note:
+ *	unlike TkBTreeNextTag and TkBTreePrevTag, this routine does not
+ *	guarantee that searchPtr->curIndex is equal to *indexPtr1. It may be
+ *	greater than that if *indexPtr1 is less than the first tag transition.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+TestPrevSegmentIsTagged(
+    const TkTextIndex *indexPtr,
+    const TkTextTag *tagPtr)
+{
+    const TkTextLine *linePtr = TkTextIndexGetLine(indexPtr);
+    const TkTextLine *startLinePtr = indexPtr->textPtr ? TkBTreeGetStartLine(indexPtr->textPtr) : NULL;
+    const TkTextSegment *segPtr = NULL; /* avoid compiler warning */
+
+    if (linePtr == startLinePtr) {
+	if (!(segPtr = GetPrevTagInfoSegment(indexPtr->textPtr->startMarker))) {
+	    return false;
+	}
+    } else if (linePtr->prevPtr) {
+	const TkTextLine *endLinePtr = indexPtr->textPtr ? TkBTreeGetStartLine(indexPtr->textPtr) : NULL;
+
+	if (linePtr->prevPtr == endLinePtr) {
+	    if (TkTextIsDeadPeer(indexPtr->textPtr)) {
+		return false;
+	    }
+	    segPtr = GetPrevTagInfoSegment(indexPtr->textPtr->endMarker);
+	} else {
+	    segPtr = linePtr->prevPtr->lastPtr;
+	}
+    }
+
+    return TkTextTagSetTest(segPtr->tagInfoPtr, tagPtr->index);
+}
+
+void
+TkBTreeStartSearch(
+    const TkTextIndex *indexPtr1,
+    				/* Search starts here. Tag toggles at this position will be returned. */
+    const TkTextIndex *indexPtr2,
+    				/* Search stops here. Tag toggles at this position *will* not be
+				 * returned. */
+    const TkTextTag *tagPtr,	/* Tag to search for. */
+    TkTextSearch *searchPtr,	/* Where to store information about search's progress. */
+    TkTextSearchMode mode)	/* The search mode, see definition of TkTextSearchMode. */
+{
+    TkTextSegment *segPtr;
+    int offset, nlines, lineNo;
+
+    assert(tagPtr);
+
+    /*
+     * Find the segment that contains the first toggle for the tag. This may
+     * become the starting point in the search.
+     */
+
+    searchPtr->textPtr = indexPtr1->textPtr;
+    searchPtr->curIndex = *indexPtr1;
+    searchPtr->tagPtr = tagPtr;
+    searchPtr->segPtr = NULL;
+    searchPtr->tagon = true;
+    searchPtr->endOfText = false;
+    searchPtr->linesLeft = 0;
+    searchPtr->resultPtr = NULL;
+    searchPtr->mode = mode;
+
+    if (TkTextIndexCompare(indexPtr1, indexPtr2) >= 0) {
+	return;
+    }
+
+    segPtr = TkTextIndexGetContentSegment(indexPtr1, &offset);
+    if (offset > 0) {
+	if (segPtr->nextPtr) {
+	    int byteOffset = TkTextIndexGetByteIndex(indexPtr1);
+
+	    TkTextIndexSetPosition(&searchPtr->curIndex,
+		    byteOffset + segPtr->size - offset, segPtr->nextPtr);
+	    segPtr = segPtr->nextPtr;
+	} else {
+	    TkTextLine *linePtr = segPtr->sectionPtr->linePtr;
+
+	    if (linePtr == TkTextIndexGetLine(indexPtr2)
+		    || (linePtr = linePtr->nextPtr) == TkTextIndexGetLine(indexPtr2)) {
+		return;
+	    }
+	    TkTextIndexSetToStartOfLine2(&searchPtr->curIndex, linePtr);
+	    segPtr = GetFirstTagInfoSegment(NULL, linePtr);
+	}
+    }
+
+    if (indexPtr2->textPtr && TkTextIndexIsEndOfText(indexPtr2)) {
+	/* In this case indexPtr2 points to start of last line, but we need end marker. */
+	searchPtr->lastPtr = indexPtr2->textPtr->endMarker;
+	offset = 0;
+    } else {
+	searchPtr->lastPtr = TkTextIndexGetContentSegment(indexPtr2, &offset);
+    }
+    searchPtr->lastLinePtr = searchPtr->lastPtr->sectionPtr->linePtr;
+    if (offset > 0) {
+	searchPtr->lastPtr = searchPtr->lastPtr->nextPtr;
+    }
+    if (segPtr == searchPtr->lastPtr) {
+	return;
+    }
+    if (TkTextIndexIsEndOfText(indexPtr2)) {
+	searchPtr->endOfText = true;
+    }
+
+    if (mode == SEARCH_NEXT_TAGON
+	    && TkTextIndexIsStartOfText(indexPtr1)
+	    && TkTextTagSetTest(segPtr->tagInfoPtr, tagPtr->index)) {
+	/*
+	 * We must find start of text.
+	 */
+	searchPtr->segPtr = segPtr;
+	searchPtr->resultPtr = segPtr;
+    } else if (!(searchPtr->resultPtr = FindTagStart(searchPtr, indexPtr2))) {
+	if (mode == SEARCH_EITHER_TAGON_TAGOFF
+	    	&& searchPtr->endOfText
+		&& TestPrevSegmentIsTagged(indexPtr2, tagPtr)) {
+	    /*
+	     * We must find end of text.
+	     */
+	    searchPtr->resultPtr = TkTextIndexGetContentSegment(indexPtr2, NULL);
+	    searchPtr->curIndex = *indexPtr2;
+	    searchPtr->segPtr = NULL;
+	    searchPtr->linesLeft = 0;
+	    searchPtr->tagon = false;
+	}
+	return;
+    } else if (!TkTextTagSetTest(searchPtr->resultPtr->tagInfoPtr, tagPtr->index)) {
+	searchPtr->tagon = false;
+	if (mode == SEARCH_NEXT_TAGON) {
+	    /*
+	     * We have found tagoff, but we are searching tagon, so we have no
+	     * result yet: force TkBTreeNextTag to continue the search.
+	     */
+	    searchPtr->segPtr = searchPtr->resultPtr;
+	    TkTextIndexSetSegment(&searchPtr->curIndex, searchPtr->segPtr);
+	    searchPtr->resultPtr = NULL;
+	}
+    }
+
+    indexPtr1 = &searchPtr->curIndex;
+    lineNo = TkTextIndexGetLineNumber(indexPtr2, indexPtr1->textPtr);
+    searchPtr->linesLeft = lineNo - TkTextIndexGetLineNumber(indexPtr1, indexPtr1->textPtr) + 1;
+    nlines = TkBTreeNumLines(indexPtr1->tree, indexPtr1->textPtr);
+    searchPtr->linesToEndOfText = nlines - lineNo + 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeStartSearchBack --
+ *
+ *	This function sets up a search backwards for tag transitions involving
+ *	a given tag (or all tags) in a given range of the text. In the normal
+ *	case the first index (*indexPtr1) is beyond the second index
+ *	(*indexPtr2).
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The information at *searchPtr is set up so that subsequent calls to
+ *	TkBTreePrevTag will return information about the locations of tag
+ *	transitions. Note that TkBTreePrevTag must be called to get the first
+ *	transition. Note: unlike TkBTreeNextTag and TkBTreePrevTag, this
+ *	routine does not guarantee that searchPtr->curIndex is equal to
+ *	*indexPtr1. It may be less than that if *indexPtr1 is greater than the
+ *	last tag transition.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeStartSearchBack(
+    const TkTextIndex *indexPtr1,
+				/* Search starts here. Tag toggles at this position will not be
+				 * returned iff mode is SEARCH_NEXT_TAGON. */
+    const TkTextIndex *indexPtr2,
+    				/* Search stops here. Tag toggles at this position *will* be returned. */
+    const TkTextTag *tagPtr,	/* Tag to search for. */
+    TkTextSearch *searchPtr,	/* Where to store information about search's progress. */
+    TkTextSearchMode mode)	/* The search mode, see definition of TkTextSearchMode. */
+{
+    TkTextSegment *segPtr;
+    TkTextSegment *lastPtr;
+    int offset;
+    int lineNo;
+
+    assert(tagPtr);
+
+    /*
+     * Find the segment that contains the last toggle for the tag. This may
+     * become the starting point in the search.
+     */
+
+    searchPtr->textPtr = indexPtr1->textPtr;
+    searchPtr->curIndex = *indexPtr1;
+    searchPtr->tagPtr = tagPtr;
+    searchPtr->segPtr = NULL;
+    searchPtr->tagon = true;
+    searchPtr->endOfText = false;
+    searchPtr->linesLeft = 0;
+    searchPtr->resultPtr = NULL;
+    searchPtr->mode = mode;
+
+    if (TkTextIndexCompare(indexPtr1, indexPtr2) <= 0) {
+	return;
+    }
+
+    if (indexPtr1->textPtr && TkTextIndexIsEndOfText(indexPtr1)) {
+	/*
+	 * In this case indexPtr2 points to start of last line, but we need
+	 * next content segment after end marker.
+	 */
+	segPtr = GetNextTagInfoSegment(indexPtr1->textPtr->endMarker);
+	offset = 0;
+    } else {
+	segPtr = TkTextIndexGetContentSegment(indexPtr1, &offset);
+    }
+
+    if (offset == 0) {
+	segPtr = GetPrevTagInfoSegment(segPtr);
+	TkTextIndexSetSegment(&searchPtr->curIndex, segPtr);
+    } else {
+	TkTextIndexAddToByteIndex(&searchPtr->curIndex, -offset);
+    }
+
+    lastPtr = searchPtr->lastPtr = TkTextIndexGetContentSegment(indexPtr2, &offset);
+    if (offset == 0) {
+	if (searchPtr->lastPtr->prevPtr) {
+	    searchPtr->lastPtr = searchPtr->lastPtr->prevPtr;
+	} else {
+	    assert(searchPtr->lastPtr->sectionPtr->linePtr->prevPtr);
+	    searchPtr->lastPtr = searchPtr->lastPtr->sectionPtr->linePtr->prevPtr->lastPtr;
+	}
+    } else if (segPtr == searchPtr->lastPtr) {
+	return;
+    }
+    searchPtr->lastLinePtr = searchPtr->lastPtr->sectionPtr->linePtr;
+    if (TkTextIndexIsStartOfText(indexPtr2)) {
+	searchPtr->endOfText = true;
+    }
+
+    if (mode == SEARCH_EITHER_TAGON_TAGOFF
+	    && TkTextIndexIsEndOfText(indexPtr1)
+	    && TestPrevSegmentIsTagged(indexPtr1, tagPtr)) {
+	/*
+	 * We must find end of text.
+	 */
+	searchPtr->curIndex = *indexPtr1;
+	searchPtr->segPtr = TkTextIndexGetContentSegment(indexPtr1, NULL);
+	searchPtr->resultPtr = segPtr;
+	searchPtr->tagon = false;
+    } else if (!(searchPtr->resultPtr = FindTagEnd(searchPtr, indexPtr2))) {
+	if (searchPtr->endOfText
+		&& TkTextTagSetTest(lastPtr->tagInfoPtr, tagPtr->index)
+		&& TestPrevSegmentIsTagged(indexPtr2, tagPtr)) {
+	    /*
+	     * We must find start of text.
+	     */
+	    searchPtr->resultPtr = TkTextIndexGetContentSegment(indexPtr2, NULL);
+	    searchPtr->curIndex = *indexPtr2;
+	    searchPtr->segPtr = NULL;
+	    searchPtr->linesLeft = 0;
+	    searchPtr->tagon = true;
+	}
+	return;
+    } else if (!TkTextTagSetTest(searchPtr->resultPtr->tagInfoPtr, tagPtr->index)) {
+	searchPtr->tagon = false;
+	if (mode == SEARCH_NEXT_TAGON) {
+	    /*
+	     * We have found tagoff, but we are searching tagon, so we have no
+	     * result yet: force TkBTreePrevTag to continue the search.
+	     */
+	    searchPtr->segPtr = searchPtr->resultPtr;
+	    TkTextIndexSetSegment(&searchPtr->curIndex, searchPtr->segPtr);
+	    searchPtr->resultPtr = NULL;
+	}
+    }
+
+    indexPtr1 = &searchPtr->curIndex;
+    searchPtr->linesToEndOfText = TkTextIndexGetLineNumber(indexPtr2, indexPtr1->textPtr);
+    lineNo = TkTextIndexGetLineNumber(indexPtr1, indexPtr1->textPtr);
+    searchPtr->linesLeft = lineNo - searchPtr->linesToEndOfText + 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeLiftSearch --
+ *
+ *	This function "lifts" the search, next TkBTreeNextTag (or TkBTreePrevTag)
+ *	will search without a limitation of the range, this is especially required
+ *	if we search for tagoff of a corresponding tagon.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The information at *searchPtr is set up so that subsequent calls to
+ *	TkBTreeNextTag/TkBTreePrevTag will search outside of the specified
+ *	range.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeLiftSearch(
+    TkTextSearch *searchPtr)
+{
+    TkText *textPtr = searchPtr->curIndex.textPtr;
+
+    searchPtr->lastPtr = textPtr ?
+	    textPtr->endMarker : TkTextIndexGetShared(&searchPtr->curIndex)->endMarker;
+    searchPtr->linesLeft += searchPtr->linesToEndOfText;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeNextTag --
+ *
+ *	Once a tag search has begun, successive calls to this function return
+ *	successive tag toggles. Note: it is NOT SAFE to call this function if
+ *	characters have been inserted into or deleted from the B-tree since
+ *	the call to TkBTreeStartSearch.
+ *
+ * Results:
+ *	The return value is 'true' if another toggle was found that met the
+ *	criteria specified in the call to TkBTreeStartSearch; in this case
+ *	searchPtr->curIndex gives the toggle's position and
+ *	searchPtr->segPtr points to its segment. 'false' is returned if no
+ *	more matching tag transitions were found; in this case
+ *	searchPtr->curIndex is the same as searchPtr->stopIndex.
+ *
+ * Side effects:
+ *	Information in *searchPtr is modified to update the state of the
+ *	search and indicate where the next tag toggle is located.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static const Node *
+NextTagFindNextNode(
+    const Node *nodePtr,
+    TkTextSearch *searchPtr,
+    bool tagon)
+{
+    const Node *parentPtr;
+    const TkTextTag *tagPtr = searchPtr->tagPtr;
+
+    assert(tagPtr);
+
+    /*
+     * Search forward across and up through the B-tree's node hierarchy looking for the
+     * next node that has a relevant tag transition somewhere in its subtree. Be sure to
+     * update linesLeft as we skip over large chunks of lines.
+     */
+
+    parentPtr = nodePtr->parentPtr;
+
+    while (true) {
+	if (!parentPtr || nodePtr == tagPtr->rootPtr) {
+	    if (tagon) {
+		return NULL;
+	    }
+	    searchPtr->linesLeft = 0;
+	    return nodePtr;
+	}
+	if (!(nodePtr = nodePtr->nextPtr)) {
+	    nodePtr = parentPtr;
+	    parentPtr = nodePtr->parentPtr;
+	} else if (NodeTestToggleFwd(nodePtr, tagPtr->index, tagon)) {
+	    return nodePtr;
+	} else if ((searchPtr->linesLeft -= nodePtr->numLines) <= 0) {
+	    return NULL;
+	}
+    }
+
+    return NULL; /* never reached */
+}
+
+static bool
+NextTag(
+    TkTextSearch *searchPtr)	/* Information about search in progress; must
+				 * have been set up by call to TkBTreeStartSearch. */
+{
+    TkTextSegment *segPtr;
+    const TkTextTag *tagPtr;
+    const Node *nodePtr;
+    TkTextLine *linePtr;
+    bool tagon;
+
+    assert(searchPtr->tagPtr);
+    assert(searchPtr->segPtr);
+
+    TkTextIndexAddToByteIndex(&searchPtr->curIndex, searchPtr->segPtr->size);
+    linePtr = searchPtr->segPtr->sectionPtr->linePtr;
+    tagPtr = searchPtr->tagPtr;
+    segPtr = searchPtr->segPtr->nextPtr;
+    searchPtr->segPtr = NULL;
+    tagon = !searchPtr->tagon;
+
+    /*
+     * The outermost loop iterates over lines that may potentially contain a relevant
+     * tag transition, starting from the current segment in the current line.
+     */
+
+    while (true) {
+	const TkTextLine *lastPtr;
+
+	if (segPtr) {
+	    bool wholeLine;
+
+	    /*
+	     * Check for more tags on the current line.
+	     */
+
+	    wholeLine = LineTestAllSegments(linePtr, tagPtr, tagon);
+
+	    while (segPtr) {
+		if (segPtr == searchPtr->lastPtr) {
+		    searchPtr->linesLeft = 0;
+		    return false;
+		}
+		if (segPtr->tagInfoPtr) {
+		    if (wholeLine || TkTextTagSetTest(segPtr->tagInfoPtr, tagPtr->index) == tagon) {
+			searchPtr->segPtr = segPtr;
+			searchPtr->tagon = tagon;
+			return true;
+		    }
+		    if (!TkTextIndexAddToByteIndex(&searchPtr->curIndex, segPtr->size)) {
+			segPtr = TkTextIndexGetFirstSegment(&searchPtr->curIndex, NULL);
+		    } else {
+			segPtr = segPtr->nextPtr;
+		    }
+		} else {
+		    segPtr = segPtr->nextPtr;
+		}
+	    }
+	}
+
+	/*
+	 * See if there are more lines associated with the current parent
+	 * node. If so, go back to the top of the loop to search the next one.
+	 */
+
+	nodePtr = linePtr->parentPtr;
+	lastPtr = nodePtr->lastPtr->nextPtr;
+
+	do {
+	    if (--searchPtr->linesLeft == 0) {
+		return false;
+	    }
+	    linePtr = linePtr->nextPtr;
+	} while (linePtr != lastPtr && !LineTestToggleFwd(linePtr, tagPtr->index, tagon));
+
+	if (linePtr != lastPtr) {
+	    segPtr = linePtr->segPtr;
+	    TkTextIndexSetToStartOfLine2(&searchPtr->curIndex, linePtr);
+	    continue; /* go back to outer loop */
+	}
+
+	if (!(nodePtr = NextTagFindNextNode(nodePtr, searchPtr, tagon))) {
+	    searchPtr->linesLeft = 0;
+	    return false;
+	}
+
+	if (searchPtr->linesLeft == 0) {
+	    assert(nodePtr->lastPtr->nextPtr);
+	    TkTextIndexSetToStartOfLine2(&searchPtr->curIndex, nodePtr->lastPtr->nextPtr);
+	    searchPtr->segPtr = TkTextIndexGetContentSegment(&searchPtr->curIndex, NULL);
+	    searchPtr->tagon = tagon;
+	    return true;
+	}
+
+	/*
+	 * At this point we've found a subtree that has a relevant tag
+	 * transition. Now search down (and across) through that subtree to
+	 * find the first level-0 node that has a relevant tag transition.
+	 */
+
+	while (nodePtr->level > 0) {
+	    nodePtr = nodePtr->childPtr;
+	    while (!NodeTestToggleFwd(nodePtr, tagPtr->index, tagon)) {
+		if ((searchPtr->linesLeft -= nodePtr->numLines) <= 0) {
+		    return false;
+		}
+		nodePtr = nodePtr->nextPtr;
+		assert(nodePtr);
+	    }
+	}
+
+	/*
+	 * Now we're down to a level-0 node that contains a line that contains
+	 * a relevant tag transition.
+	 */
+
+	linePtr = nodePtr->linePtr;
+	DEBUG(lastPtr = nodePtr->lastPtr->nextPtr);
+
+	/*
+	 * Now search through the lines.
+	 */
+
+	while (!LineTestToggleFwd(linePtr, tagPtr->index, tagon)) {
+	    if (--searchPtr->linesLeft == 0) {
+		return false;
+	    }
+	    linePtr = linePtr->nextPtr;
+	    assert(linePtr != lastPtr);
+	}
+
+	TkTextIndexSetToStartOfLine2(&searchPtr->curIndex, linePtr);
+	segPtr = linePtr->segPtr;
+    }
+
+    return false; /* never reached */
+}
+
+bool
+TkBTreeNextTag(
+    TkTextSearch *searchPtr)	/* Information about search in progress; must
+				 * have been set up by call to TkBTreeStartSearch. */
+{
+    if (searchPtr->resultPtr) {
+	searchPtr->segPtr = searchPtr->resultPtr;
+	searchPtr->resultPtr = NULL;
+	return true;
+    }
+
+    if (searchPtr->linesLeft <= 0) {
+	searchPtr->segPtr = NULL;
+	return false;
+    }
+
+    if (NextTag(searchPtr)) {
+	return true;
+    }
+
+    if (searchPtr->endOfText && searchPtr->tagon) {
+	/* we must find end of text in this case */
+	TkTextIndexSetupToEndOfText(&searchPtr->curIndex,
+		searchPtr->curIndex.textPtr, searchPtr->curIndex.tree);
+	searchPtr->segPtr = TkTextIndexGetContentSegment(&searchPtr->curIndex, NULL);
+	searchPtr->tagon = false;
+	return true;
+    }
+
+    return false;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreePrevTag --
+ *
+ *	Once a tag search has begun, successive calls to this function return
+ *	successive tag toggles in the reverse direction. Note: it is NOT SAFE
+ *	to call this function if characters have been inserted into or deleted
+ *	from the B-tree since the call to TkBTreeStartSearch.
+ *
+ * Results:
+ *	The return value is 'true' if another toggle was found that met the
+ *	criteria specified in the call to TkBTreeStartSearch; in this case
+ *	searchPtr->curIndex gives the toggle's position and
+ *	searchPtr->segPtr points to its segment. 'false' is returned if no
+ *	more matching tag transitions were found; in this case
+ *	'searchPtr->curIndex' is the same as 'searchPtr->stopIndex'.
+ *
+ * Side effects:
+ *	Information in *searchPtr is modified to update the state of the
+ *	search and indicate where the next tag toggle is located.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static const Node *
+PrevTagFindPrevNode(
+    const Node *nodePtr,
+    TkTextSearch *searchPtr,
+    bool tagon)
+{
+    const TkTextTag *tagPtr = searchPtr->tagPtr;
+    const Node *parentPtr;
+    const Node *rootPtr;
+
+    assert(tagPtr);
+
+    /*
+     * Search backward across and up through the B-tree's node hierarchy looking for the
+     * next node that has a relevant tag transition somewhere in its subtree. Be sure to
+     * update linesLeft as we skip over large chunks of lines.
+     */
+
+    if (nodePtr == tagPtr->rootPtr) {
+	return NULL;
+    }
+
+    parentPtr = nodePtr->parentPtr;
+    rootPtr = tagPtr->rootPtr;
+
+    do {
+	const Node *nodeStack[MAX_CHILDREN];
+	const Node *lastPtr = nodePtr;
+	int idx = 0;
+
+	for (nodePtr = parentPtr->childPtr; nodePtr != lastPtr; nodePtr = nodePtr->nextPtr) {
+	    if (nodePtr == rootPtr) {
+		if (!tagon) {
+		    return NULL;
+		}
+		return nodePtr;
+	    }
+	    nodeStack[idx++] = nodePtr;
+	}
+	for (--idx; idx >= 0; --idx) {
+	    if (NodeTestToggleBack(nodePtr = nodeStack[idx], tagPtr->index, tagon)) {
+		return nodePtr;
+	    }
+	    if ((searchPtr->linesLeft -= nodePtr->numLines) <= 0) {
+		return NULL;
+	    }
+	}
+	nodePtr = parentPtr;
+	parentPtr = parentPtr->parentPtr;
+    } while (parentPtr);
+
+    searchPtr->linesLeft = 0;
+    return NULL;
+}
+
+static bool
+PrevTag(
+    TkTextSearch *searchPtr)	/* Information about search in progress; must
+				 * have been set up by call to TkBTreeStartSearch. */
+{
+    TkTextSegment *segPtr;
+    const TkTextTag *tagPtr;
+    const Node *nodePtr;
+    bool tagon;
+
+    assert(searchPtr->tagPtr);
+    assert(searchPtr->segPtr);
+
+    tagPtr = searchPtr->tagPtr;
+    segPtr = searchPtr->segPtr->prevPtr;
+    searchPtr->segPtr = NULL;
+    tagon = !searchPtr->tagon;
+
+    if (segPtr) {
+	TkTextIndexAddToByteIndex(&searchPtr->curIndex, -segPtr->size);
+    }
+
+    /*
+     * The outermost loop iterates over lines that may potentially contain a relevant
+     * tag transition, starting from the current segment in the current line.
+     */
+
+    while (true) {
+	TkTextLine *linePtr;
+	const TkTextLine *lastPtr;
+
+	if (segPtr) {
+	    TkTextSegment *prevPtr;
+	    TkTextSegment *firstPtr;
+	    int byteOffset, offset = 0;
+
+	    /*
+	     * Check for more tags in the current line.
+	     */
+
+	    linePtr = segPtr->sectionPtr->linePtr;
+
+	    if (LineTestAllSegments(linePtr, tagPtr, tagon)) {
+		if (searchPtr->lastPtr->sectionPtr->linePtr == linePtr) {
+		    TkTextIndexSetSegment(&searchPtr->curIndex, searchPtr->lastPtr);
+		    searchPtr->segPtr = searchPtr->lastPtr;
+		} else {
+		    TkTextIndexSetToStartOfLine2(&searchPtr->curIndex, linePtr);
+		    searchPtr->segPtr = linePtr->segPtr;
+		}
+		searchPtr->tagon = tagon;
+		return true;
+	    }
+
+	    prevPtr = firstPtr = NULL;
+	    byteOffset = TkTextIndexGetByteIndex(&searchPtr->curIndex);
+
+	    while (true) {
+		if (segPtr->tagInfoPtr) {
+		    if (TkTextTagSetTest(segPtr->tagInfoPtr, tagPtr->index)) {
+			if (prevPtr) {
+			    TkTextIndexSetByteIndex(&searchPtr->curIndex, offset);
+			    searchPtr->tagon = tagon;
+			    return true;
+			}
+			firstPtr = segPtr;
+		    } else if (firstPtr) {
+			TkTextIndexSetByteIndex(&searchPtr->curIndex, offset);
+			searchPtr->segPtr = firstPtr;
+			searchPtr->tagon = tagon;
+			return true;
+		    } else if (!tagon) {
+			prevPtr = segPtr;
+		    }
+		    offset = byteOffset;
+		}
+		if (segPtr == searchPtr->lastPtr) {
+		    if (firstPtr
+			    && firstPtr == GetFirstTagInfoSegment(searchPtr->textPtr, linePtr)
+			    && !LineTestIfToggleIsOpen(linePtr->prevPtr, tagPtr->index)) {
+			TkTextIndexSetByteIndex(&searchPtr->curIndex, offset);
+			searchPtr->segPtr = firstPtr;
+			searchPtr->tagon = tagon;
+			return true;
+		    }
+		    searchPtr->linesLeft = 0;
+		    return false;
+		}
+		if (!(segPtr = segPtr->prevPtr)) {
+		    break;
+		}
+		byteOffset -= segPtr->size;
+	    }
+	    if (firstPtr && !LineTestIfToggleIsOpen(linePtr->prevPtr, tagPtr->index)) {
+		TkTextIndexSetByteIndex(&searchPtr->curIndex, offset);
+		searchPtr->segPtr = firstPtr;
+		searchPtr->tagon = tagon;
+		return true;
+	    }
+	} else {
+	    linePtr = TkTextIndexGetLine(&searchPtr->curIndex);
+	}
+
+	/*
+	 * See if there are more lines associated with the current parent
+	 * node. If so, go back to the top of the loop to search the previous one.
+	 */
+
+	nodePtr = linePtr->parentPtr;
+	lastPtr = nodePtr->linePtr->prevPtr;
+
+	do {
+	    if (--searchPtr->linesLeft == 0) {
+		return false;
+	    }
+	    linePtr = linePtr->prevPtr;
+	} while (linePtr != lastPtr && !LineTestToggleBack(linePtr, tagPtr->index, tagon));
+
+	if (linePtr != lastPtr) {
+	    TkTextIndexSetSegment(&searchPtr->curIndex, segPtr = linePtr->lastPtr);
+	    continue; /* go back to outer loop */
+	}
+
+	if (!(nodePtr = PrevTagFindPrevNode(nodePtr, searchPtr, tagon))) {
+	    searchPtr->linesLeft = 0;
+	    return false;
+	}
+
+	/*
+	 * At this point we've found a subtree that has a relevant tag
+	 * transition. Now search down (and across) through that subtree to
+	 * find the first level-0 node that has a relevant tag transition.
+	 */
+
+	while (nodePtr->level > 0) {
+	    const Node *nodeStack[MAX_CHILDREN];
+	    int idx = 0;
+
+	    for (nodePtr = nodePtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+		nodeStack[idx++] = nodePtr;
+	    }
+	    assert(idx > 0);
+	    nodePtr = nodeStack[--idx];
+	    while (!NodeTestToggleBack(nodePtr, tagPtr->index, tagon)) {
+		if ((searchPtr->linesLeft -= nodePtr->numLines) <= 0) {
+		    return false;
+		}
+		assert(idx > 0);
+		nodePtr = nodeStack[--idx];
+	    }
+	}
+
+	/*
+	 * We're down to a level-0 node that contains a line that has a relevant tag transition.
+	 */
+
+	linePtr = nodePtr->lastPtr;
+	DEBUG(lastPtr = nodePtr->linePtr->prevPtr);
+
+	/*
+	 * Now search through the lines.
+	 */
+
+	while (!LineTestToggleBack(linePtr, tagPtr->index, tagon)) {
+	    if (--searchPtr->linesLeft == 0) {
+		return false;
+	    }
+	    linePtr = linePtr->prevPtr;
+	    assert(linePtr != lastPtr);
+	}
+
+	TkTextIndexSetSegment(&searchPtr->curIndex, segPtr = linePtr->lastPtr);
+    }
+
+    return false; /* never reached */
+}
+
+bool
+TkBTreePrevTag(
+    TkTextSearch *searchPtr)	/* Information about search in progress; must
+				 * have been set up by call to TkBTreeStartSearch. */
+{
+    if (searchPtr->resultPtr) {
+	searchPtr->segPtr = searchPtr->resultPtr;
+	searchPtr->resultPtr = NULL;
+	return true;
+    }
+
+    if (searchPtr->linesLeft <= 0) {
+	searchPtr->segPtr = NULL;
+	return false;
+    }
+
+    if (PrevTag(searchPtr)) {
+	return true;
+    }
+
+    if (searchPtr->endOfText && !searchPtr->tagon) {
+	/* we must find start of text in this case */
+	TkTextIndexSetupToStartOfText(&searchPtr->curIndex,
+		searchPtr->curIndex.textPtr, searchPtr->curIndex.tree);
+	searchPtr->segPtr = TkTextIndexGetContentSegment(&searchPtr->curIndex, NULL);
+	searchPtr->tagon = true;
+	return true;
+    }
+
+    return false;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeFindNextTagged --
+ *
+ *	Find next segment which contains any tag inside given range.
+ *
+ * Results:
+ *	The return value is the next segment containing any tag.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextSegment *
+FindNextTaggedSegInLine(
+    TkTextSegment *segPtr,
+    const TkTextSegment *lastPtr,
+    const TkBitField *discardTags)
+{
+    if (lastPtr->sectionPtr->linePtr != segPtr->sectionPtr->linePtr) {
+	lastPtr = NULL;
+    }
+
+    for ( ; segPtr != lastPtr; segPtr = segPtr->nextPtr) {
+	const TkTextTagSet *tagInfoPtr = segPtr->tagInfoPtr;
+
+	if (tagInfoPtr) {
+	    if (TagSetTestBits(tagInfoPtr, discardTags)) {
+		return segPtr;
+	    }
+	}
+    }
+
+    return NULL;
+}
+
+TkTextSegment *
+FindNextTaggedSegInNode(
+    const TkTextSegment *lastPtr,
+    const TkTextLine *linePtr,
+    const TkBitField *discardTags)	/* can be NULL */
+{
+    const TkTextLine *lastLinePtr = lastPtr->sectionPtr->linePtr;
+    const TkTextLine *endLinePtr = linePtr->parentPtr->lastPtr;
+
+    while (linePtr) {
+	if (TagSetTestBits(linePtr->tagonPtr, discardTags)) {
+	    return FindNextTaggedSegInLine(linePtr->segPtr, lastPtr, discardTags);
+	}
+	if (linePtr == lastLinePtr || linePtr == endLinePtr) {
+	    return NULL;
+	}
+	linePtr = linePtr->nextPtr;
+    }
+
+    return NULL;
+}
+
+static const Node *
+FindNextTaggedNode(
+    const Node *nodePtr,
+    const TkBitField *discardTags)	/* can be NULL */
+{
+    while (nodePtr) {
+	const Node *startNodePtr = nodePtr;
+
+	for (nodePtr = nodePtr->nextPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+	    if (TagSetTestBits(nodePtr->tagonPtr, discardTags)) {
+		while (nodePtr->level > 0) {
+		    for (nodePtr = nodePtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+			if (TagSetTestBits(nodePtr->tagonPtr, discardTags)) {
+			    return nodePtr;
+			}
+		    }
+		}
+		return nodePtr;
+	    }
+	}
+
+	nodePtr = startNodePtr->parentPtr;
+    }
+
+    return NULL;
+}
+
+TkTextSegment *
+TkBTreeFindNextTagged(
+    const TkTextIndex *indexPtr1,
+    				/* Search starts here. Tag toggles at this position will be returned. */
+    const TkTextIndex *indexPtr2,
+    				/* Search stops here. Tag toggles at this position will not be
+				 * returned. */
+    const struct TkBitField *discardTags)
+				/* Discard these tags when searching, can be NULL. */
+{
+    const TkSharedText *sharedTextPtr = TkTextIndexGetShared(indexPtr1);
+    const TkTextLine *linePtr = TkTextIndexGetLine(indexPtr1);
+    const TkTextSegment *lastPtr = TkTextIndexGetFirstSegment(indexPtr2, NULL);
+    const TkText *textPtr;
+    const Node *nodePtr;
+
+    /*
+     * At first, search for next segment in first line.
+     */
+
+    if (TagSetTestBits(linePtr->tagonPtr, discardTags)) {
+	TkTextSegment *segPtr = TkTextIndexGetContentSegment(indexPtr1, NULL);
+
+	if ((segPtr = FindNextTaggedSegInLine(segPtr, lastPtr, discardTags))) {
+	    return segPtr;
+	}
+    }
+
+    /*
+     * At second, search for line containing any tag in current node.
+     */
+
+    textPtr = indexPtr1->textPtr;
+    nodePtr = linePtr->parentPtr;
+
+    if (linePtr != nodePtr->lastPtr && TagSetTestBits(nodePtr->tagonPtr, discardTags)) {
+	TkTextSegment *segPtr = FindNextTaggedSegInNode(lastPtr, linePtr->nextPtr, discardTags);
+
+	if (segPtr) {
+	    return segPtr;
+	}
+    }
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for next level-0
+     * node which contains any tag.
+     */
+
+    if (!(nodePtr = FindNextTaggedNode(nodePtr, discardTags))) {
+	return NULL;
+    }
+
+    if (textPtr && textPtr->startMarker != textPtr->sharedTextPtr->startMarker) {
+	int lineNo1 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, nodePtr->linePtr, NULL);
+	int lineNo2 = TkTextIndexGetLineNumber(indexPtr2, NULL);
+
+	if (lineNo1 > lineNo2) {
+	    /* We've found a node after text end, so return NULL. */
+	    return NULL;
+	}
+    }
+
+    /*
+     * Final search of segment containing any tag.
+     */
+
+    return FindNextTaggedSegInNode(lastPtr, nodePtr->linePtr, discardTags);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeFindNextUntagged --
+ *
+ *	Find next segment which does not contain any tag.
+ *
+ * Results:
+ *	The return value is the next segment not containing any tag.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextSegment *
+FindNextUntaggedSegInLine(
+    TkTextSegment *segPtr,
+    const TkTextSegment *lastPtr,
+    const TkBitField *discardTags)
+{
+    if (lastPtr->sectionPtr->linePtr != segPtr->sectionPtr->linePtr) {
+	lastPtr = NULL;
+    }
+
+    for ( ; segPtr != lastPtr; segPtr = segPtr->nextPtr) {
+	const TkTextTagSet *tagInfoPtr = segPtr->tagInfoPtr;
+
+	if (tagInfoPtr) {
+	    if (!TagSetTestDisjunctiveBits(tagInfoPtr, discardTags)) {
+		return segPtr;
+	    }
+	}
+    }
+
+    return NULL;
+}
+
+TkTextSegment *
+FindNextUntaggedSegInNode(
+    const TkTextSegment *lastPtr,
+    const TkTextLine *linePtr,
+    const TkBitField *discardTags)	/* can be NULL */
+{
+    const TkTextLine *lastLinePtr = lastPtr->sectionPtr->linePtr;
+    const TkTextLine *endLinePtr = linePtr->parentPtr->lastPtr;
+
+    while (linePtr) {
+	if (TagSetTestDontContainsAny(linePtr->tagonPtr, linePtr->tagoffPtr, discardTags)) {
+	    return FindNextUntaggedSegInLine(linePtr->segPtr, lastPtr, discardTags);
+	}
+	if (linePtr == lastLinePtr || linePtr == endLinePtr) {
+	    return NULL;
+	}
+	linePtr = linePtr->nextPtr;
+    }
+
+    return NULL;
+}
+
+static const Node *
+FindNextUntaggedNode(
+    const Node *nodePtr,
+    const TkBitField *discardTags)	/* can be NULL */
+{
+    while (nodePtr) {
+	const Node *startNodePtr = nodePtr;
+
+	for (nodePtr = nodePtr->nextPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+	    if (TagSetTestDontContainsAny(nodePtr->tagonPtr, nodePtr->tagoffPtr, discardTags)) {
+		while (nodePtr->level > 0) {
+		    for (nodePtr = nodePtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+			if (TagSetTestDontContainsAny(nodePtr->tagonPtr, nodePtr->tagoffPtr,
+				discardTags)) {
+			    return nodePtr;
+			}
+		    }
+		}
+		return nodePtr;
+	    }
+	}
+
+	nodePtr = startNodePtr->parentPtr;
+    }
+
+    return NULL;
+}
+
+TkTextSegment *
+TkBTreeFindNextUntagged(
+    const TkTextIndex *indexPtr1,
+    				/* Search starts here. Tag toggles at this position will be
+				 * returned. */
+    const TkTextIndex *indexPtr2,
+    				/* Search stops here. Tag toggles at this position will not be
+				 * returned. */
+    const struct TkBitField *discardTags)
+				/* Discard these tags when searching, can be NULL. */
+{
+    const TkSharedText *sharedTextPtr = TkTextIndexGetShared(indexPtr1);
+    const TkTextLine *linePtr = TkTextIndexGetLine(indexPtr1);
+    const TkTextSegment *lastPtr = TkTextIndexGetFirstSegment(indexPtr2, NULL);
+    const TkText *textPtr;
+    const Node *nodePtr;
+
+    /*
+     * At first, search for next segment in first line.
+     */
+
+    if (TagSetTestDontContainsAny(linePtr->tagonPtr, linePtr->tagoffPtr, discardTags)) {
+	TkTextSegment *segPtr = TkTextIndexGetContentSegment(indexPtr1, NULL);
+
+	if ((segPtr = FindNextUntaggedSegInLine(segPtr, lastPtr, discardTags))) {
+	    return segPtr;
+	}
+    }
+
+    /*
+     * At second, search for line containing any tag in current node.
+     */
+
+    textPtr = indexPtr1->textPtr;
+    nodePtr = linePtr->parentPtr;
+
+    if (linePtr != nodePtr->lastPtr
+	    && (TagSetTestDontContainsAny(nodePtr->tagonPtr, nodePtr->tagoffPtr, discardTags))) {
+	TkTextSegment *segPtr = FindNextUntaggedSegInNode(lastPtr, linePtr->nextPtr, discardTags);
+
+	if (segPtr) {
+	    return segPtr;
+	}
+    }
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for next level-0
+     * node which don't contains any tag.
+     */
+
+    if (!(nodePtr = FindNextUntaggedNode(nodePtr, discardTags))) {
+	return NULL;
+    }
+
+    if (textPtr && textPtr->startMarker != textPtr->sharedTextPtr->startMarker) {
+	int lineNo1 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, nodePtr->linePtr, NULL);
+	int lineNo2 = TkTextIndexGetLineNumber(indexPtr2, NULL);
+
+	if (lineNo1 > lineNo2) {
+	    /* We've found a node after text end, so return NULL. */
+	    return NULL;
+	}
+    }
+
+    /*
+     * Final search of segment not containing any tag.
+     */
+
+    return FindNextUntaggedSegInNode(lastPtr, nodePtr->linePtr, discardTags);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeFindPrevTagged --
+ *
+ *	Starting at given index, find previous segment which contains any tag.
+ *
+ * Results:
+ *	The return value is the previous segment containing any tag.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextSegment *
+FindPrevTaggedSegInLine(
+    TkTextSegment *segPtr,
+    const TkTextSegment *firstPtr,
+    const TkBitField *selTags)
+{
+    const TkTextLine *linePtr = segPtr->sectionPtr->linePtr;
+
+    firstPtr = (linePtr == firstPtr->sectionPtr->linePtr) ? firstPtr->prevPtr : NULL;
+
+    for ( ; segPtr != firstPtr; segPtr = segPtr->prevPtr) {
+	const TkTextTagSet *tagInfoPtr = segPtr->tagInfoPtr;
+
+	if (tagInfoPtr) {
+	    if (TagSetTestBits(tagInfoPtr, selTags)) {
+		return segPtr;
+	    }
+	}
+    }
+
+    return NULL;
+}
+
+TkTextSegment *
+FindPrevTaggedSegInNode(
+    TkTextSegment *firstPtr,
+    const TkTextLine *linePtr,
+    const TkBitField *selTags)		/* can be NULL */
+{
+    const TkTextLine *firstLinePtr = firstPtr->sectionPtr->linePtr;
+    const TkTextLine *startLinePtr = linePtr->parentPtr->linePtr;
+
+    while (true) {
+	if (TagSetTestBits(linePtr->tagonPtr, selTags)) {
+	    return FindPrevTaggedSegInLine(linePtr->lastPtr, firstPtr, selTags);
+	}
+	if (linePtr == startLinePtr || linePtr == firstLinePtr) {
+	    return NULL;
+	}
+	linePtr = linePtr->prevPtr;
+    };
+
+    return NULL;
+}
+
+static const Node *
+FindPrevTaggedNode(
+    const Node *nodePtr,
+    const TkBitField *selTags)	/* can be NULL */
+{
+    assert(nodePtr);
+
+    while (nodePtr->parentPtr) {
+	const Node *startNodePtr = nodePtr;
+	const Node *lastNodePtr = NULL;
+
+	nodePtr = nodePtr->parentPtr->childPtr;
+
+	for ( ; nodePtr != startNodePtr; nodePtr = nodePtr->nextPtr) {
+	    if (TagSetTestBits(nodePtr->tagonPtr, selTags)) {
+		lastNodePtr = nodePtr;
+	    }
+	}
+	if (lastNodePtr) {
+	    nodePtr = lastNodePtr;
+
+	    while (nodePtr->level > 0) {
+		DEBUG(lastNodePtr = NULL);
+
+		for (nodePtr = nodePtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+		    if (TagSetTestBits(nodePtr->tagonPtr, selTags)) {
+			lastNodePtr = nodePtr;
+		    }
+		}
+
+		assert(lastNodePtr);
+		nodePtr = lastNodePtr;
+	    }
+
+	    return lastNodePtr;
+	}
+
+	nodePtr = startNodePtr->parentPtr;
+    }
+
+    return NULL;
+}
+
+TkTextSegment *
+TkBTreeFindPrevTagged(
+    const TkTextIndex *indexPtr1,
+    				/* Search starts here. Tag toggles at this position will be returned. */
+    const TkTextIndex *indexPtr2,
+    				/* Search stops here. Tag toggles at this position will be returned. */
+    bool discardSelection)	/* Discard selection tags? */
+{
+    const TkSharedText *sharedTextPtr = TkTextIndexGetShared(indexPtr1);
+    const TkBitField *selTags = discardSelection ? sharedTextPtr->selectionTags : NULL;
+    const TkTextLine *linePtr = TkTextIndexGetLine(indexPtr1);
+    TkTextSegment *firstPtr = TkTextIndexGetFirstSegment(indexPtr2, NULL);
+    const TkText *textPtr;
+    const Node *nodePtr;
+
+    /*
+     * At first, search for previous segment in first line.
+     */
+
+    if (TagSetTestBits(linePtr->tagonPtr, selTags)) {
+	TkTextSegment *segPtr = TkTextIndexGetContentSegment(indexPtr1, NULL);
+
+	if ((segPtr = FindPrevTaggedSegInLine(segPtr, firstPtr, selTags))) {
+	    return segPtr;
+	}
+    }
+
+    /*
+     * At second, search for line containing any tag in current node.
+     */
+
+    textPtr = indexPtr1->textPtr;
+    nodePtr = linePtr->parentPtr;
+
+    if (linePtr != nodePtr->linePtr && TagSetTestBits(nodePtr->tagonPtr, selTags)) {
+	TkTextSegment *segPtr = FindPrevTaggedSegInNode(firstPtr, linePtr->prevPtr, selTags);
+
+	if (segPtr) {
+	    return segPtr;
+	}
+    }
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for previous level-0
+     * node which contains any tag.
+     */
+
+    if (!(nodePtr = FindPrevTaggedNode(nodePtr, selTags))) {
+	return NULL;
+    }
+
+    if (textPtr && textPtr->startMarker != textPtr->sharedTextPtr->startMarker) {
+	int lineNo1 = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, NULL, nodePtr->lastPtr, NULL);
+	int lineNo2 = TkTextIndexGetLineNumber(indexPtr2, NULL);
+
+	if (lineNo1 < lineNo2) {
+	    /* We've found a node before text start, so return NULL. */
+	    return NULL;
+	}
+    }
+
+    /*
+     * Final search of segment containing any tag.
+     */
+
+    return FindPrevTaggedSegInNode(firstPtr, nodePtr->lastPtr, selTags);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeCharTagged --
+ *
+ *	Determine whether a particular character has a particular tag.
+ *
+ * Results:
+ *	The return value is 1 if the given tag is in effect at the character
+ *	given by linePtr and ch, and 0 otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkBTreeCharTagged(
+    const TkTextIndex *indexPtr,/* Indicates a character position at which to check for a tag. */
+    const TkTextTag *tagPtr)	/* Tag of interest, can be NULL. */
+{
+    const TkTextTagSet *tagInfoPtr = TkTextIndexGetContentSegment(indexPtr, NULL)->tagInfoPtr;
+    return tagPtr ? TkTextTagSetTest(tagInfoPtr, tagPtr->index) : !TkTextTagSetIsEmpty(tagInfoPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeGetSegmentTags --
+ *
+ *	Return information about all of the tags that are associated with a
+ *	particular char segment in a B-tree of text.
+ *
+ * Results:
+ *      The return value is the root of the tag chain, containing all tags
+ *	associated with the given char segment. If there are no tags in this
+ *	segment, then a NULL pointer is returned.
+ *
+ * Side effects:
+ *	The attribute nextPtr of TkTextTag will be modified for any tag.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextTag *
+TkBTreeGetSegmentTags(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextSegment *segPtr,	/* Get tags from this segment. */
+    const TkText *textPtr)		/* If non-NULL, then only return tags for this text widget
+    					 * (when there are peer widgets). */
+{
+    const TkTextTagSet *tagInfoPtr;
+    TkTextTag *chainPtr = NULL;
+
+    assert(segPtr->tagInfoPtr);
+
+    tagInfoPtr = segPtr->tagInfoPtr;
+
+    if (tagInfoPtr != sharedTextPtr->emptyTagInfoPtr) {
+	unsigned i = TkTextTagSetFindFirst(tagInfoPtr);
+
+	for ( ; i != TK_TEXT_TAG_SET_NPOS; i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	    TkTextTag *tagPtr = sharedTextPtr->tagLookup[i];
+
+	    assert(tagPtr);
+	    assert(!tagPtr->isDisabled);
+
+	    if (!textPtr || !tagPtr->textPtr || tagPtr->textPtr == textPtr) {
+		tagPtr->nextPtr = chainPtr;
+		tagPtr->epoch = 0;
+		chainPtr = tagPtr;
+	    }
+	}
+    }
+
+    return chainPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeGetLang --
+ *
+ *	Return the language information of given segment.
+ *
+ * Results:
+ *      The return value is the language string belonging to given segment.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+const char *
+TkBTreeGetLang(
+    const TkText *textPtr,		/* Relative to this client of the B-tree. */
+    const TkTextSegment *segPtr)	/* Get tags from this segment. */
+{
+    const TkTextTagSet *tagInfoPtr;
+    const TkSharedText *sharedTextPtr;
+    const char *langPtr;
+
+    assert(textPtr);
+    assert(segPtr->tagInfoPtr);
+    assert(segPtr->sectionPtr->linePtr->nextPtr);
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+    tagInfoPtr = segPtr->tagInfoPtr;
+    langPtr = textPtr->lang;
+
+    if (tagInfoPtr != sharedTextPtr->emptyTagInfoPtr) {
+	unsigned i = TkTextTagSetFindFirst(tagInfoPtr);
+	int highestPriority = -1;
+
+	for ( ; i != TK_TEXT_TAG_SET_NPOS; i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	    const TkTextTag *tagPtr = sharedTextPtr->tagLookup[i];
+
+	    assert(tagPtr);
+	    assert(!tagPtr->isDisabled);
+
+	    if (tagPtr->lang[0] && tagPtr->priority > highestPriority) {
+		langPtr = tagPtr->lang;
+		highestPriority = tagPtr->priority;
+	    }
+	}
+    }
+
+    return langPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeCheck --
+ *
+ *	This function runs a set of consistency checks over a B-tree and
+ *	panics if any inconsistencies are found.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If a structural defect is found, the function panics with an error
+ *	message.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkBTreeCheck(
+    TkTextBTree tree)		/* Tree to check. */
+{
+    BTree *treePtr = (BTree *) tree;
+    const Node *nodePtr;
+    const TkTextLine *linePtr, *prevLinePtr;
+    const TkTextSegment *segPtr;
+    const TkText *peer;
+    unsigned numBranches = 0;
+    unsigned numLinks = 0;
+    Tcl_HashEntry *entryPtr;
+    Tcl_HashSearch search;
+    const char *s;
+
+    if (treePtr->sharedTextPtr->refCount == 0) {
+	Tcl_Panic("TkBTreeCheck: tree is destroyed");
+    }
+
+    nodePtr = treePtr->rootPtr;
+    while (nodePtr->level > 0) {
+	nodePtr = nodePtr->childPtr;
+	if (!nodePtr) {
+	    Tcl_Panic("TkBTreeCheck: no level 0 node in tree");
+	}
+    }
+
+    /*
+     * Check line pointers.
+     */
+
+    prevLinePtr = NULL;
+    for (linePtr = nodePtr->linePtr;
+	    linePtr;
+	    prevLinePtr = linePtr, linePtr = linePtr->nextPtr) {
+	if (!linePtr->segPtr) {
+	    Tcl_Panic("TkBTreeCheck: line has no segments");
+	}
+	if (linePtr->size == 0) {
+	    Tcl_Panic("TkBTreeCheck: line has size zero");
+	}
+	if (!linePtr->lastPtr) {
+	    Tcl_Panic("TkBTreeCheck: line has no last pointer");
+	}
+	if (linePtr->prevPtr != prevLinePtr) {
+	    Tcl_Panic("TkBTreeCheck: line has wrong predecessor");
+	}
+	if (!linePtr->tagoffPtr || !linePtr->tagonPtr) {
+	    Tcl_Panic("TkBTreeCheck: line tag information is incomplete");
+	}
+	if (TkTextTagSetRefCount(linePtr->tagonPtr) == 0) {
+	    Tcl_Panic("TkBTreeCheck: unreferenced tag info (tagon)");
+	}
+	if (TkTextTagSetRefCount(linePtr->tagonPtr) > 0x3fffffff) {
+	    Tcl_Panic("TkBTreeCheck: negative reference count in tagon info");
+	}
+	if (TkTextTagSetRefCount(linePtr->tagoffPtr) == 0) {
+	    Tcl_Panic("TkBTreeCheck: unreferenced tag info (tagoff)");
+	}
+	if (TkTextTagSetRefCount(linePtr->tagoffPtr) > 0x3fffffff) {
+	    Tcl_Panic("TkBTreeCheck: negative reference count in tagoff info");
+	}
+	if (!TkTextTagSetContains(linePtr->tagonPtr, linePtr->tagoffPtr)) {
+	    Tcl_Panic("TkBTreeCheck: line tagoff not included in tagon");
+	}
+	if (TkTextTagSetIsEmpty(linePtr->tagonPtr)
+		&& linePtr->tagonPtr != treePtr->sharedTextPtr->emptyTagInfoPtr) {
+	    Tcl_Panic("TkBTreeCheck: should use shared resource if tag info is empty");
+	}
+	if (TkTextTagSetIsEmpty(linePtr->tagoffPtr)
+		&& linePtr->tagoffPtr != treePtr->sharedTextPtr->emptyTagInfoPtr) {
+	    Tcl_Panic("TkBTreeCheck: should use shared resource if tag info is empty");
+	}
+	if (TkTextTagSetRefCount(linePtr->tagonPtr) == 0) {
+	    Tcl_Panic("TkBTreeCheck: reference count of line tagon is zero");
+	}
+	if (TkTextTagSetRefCount(linePtr->tagoffPtr) == 0) {
+	    Tcl_Panic("TkBTreeCheck: reference count of line tagoff is zero");
+	}
+	if (linePtr->logicalLine ==
+		(linePtr->prevPtr && HasElidedNewline(treePtr->sharedTextPtr, linePtr->prevPtr))) {
+	    Tcl_Panic("TkBTreeCheck: wrong logicalLine flag");
+	}
+	numBranches += linePtr->numBranches;
+	numLinks += linePtr->numLinks;
+    }
+
+    if (numBranches != treePtr->rootPtr->numBranches) {
+	Tcl_Panic("TkBTreeCheck: wrong branch count %u (expected is %u)",
+		numBranches, treePtr->rootPtr->numBranches);
+    }
+    if (numLinks != numBranches) {
+	Tcl_Panic("TkBTreeCheck: mismatch in number of links (%d) and branches (%d)",
+		numLinks, numBranches);
+    }
+
+    /*
+     * Check the special markers.
+     */
+
+    if (!treePtr->sharedTextPtr->startMarker->sectionPtr) {
+	Tcl_Panic("TkBTreeCheck: start marker of shared resource is not linked");
+    }
+    if (!treePtr->sharedTextPtr->endMarker->sectionPtr) {
+	Tcl_Panic("TkBTreeCheck: end marker of shared resource is not linked");
+    }
+    if (treePtr->sharedTextPtr->startMarker->sectionPtr->linePtr->prevPtr) {
+	Tcl_Panic("TkBTreeCheck: start marker of shared resource is not in first line");
+    }
+    if (treePtr->sharedTextPtr->endMarker->sectionPtr->linePtr->nextPtr) {
+	Tcl_Panic("TkBTreeCheck: end marker of shared resource is not in last line");
+    }
+    if (!SegIsAtStartOfLine(treePtr->sharedTextPtr->startMarker)) {
+	Tcl_Panic("TkBTreeCheck: start marker of shared resource is not at start of line");
+    }
+    if (!SegIsAtStartOfLine(treePtr->sharedTextPtr->endMarker)) {
+	Tcl_Panic("TkBTreeCheck: end marker of shared resource is not at start of line");
+    }
+
+    for (peer = treePtr->sharedTextPtr->peers; peer; peer = peer->next) {
+	if (peer->currentMarkPtr && peer->currentMarkPtr->sectionPtr) {
+	    if ((peer->currentMarkPtr->prevPtr && !peer->currentMarkPtr->prevPtr->typePtr)
+		|| (peer->currentMarkPtr->nextPtr && !peer->currentMarkPtr->nextPtr->typePtr)
+		|| (peer->currentMarkPtr->sectionPtr
+		    && (!peer->currentMarkPtr->sectionPtr->linePtr
+			|| !peer->currentMarkPtr->sectionPtr->linePtr->parentPtr))) {
+		Tcl_Panic("TkBTreeCheck: current mark is expired");
+	    }
+	}
+	if (peer->insertMarkPtr && peer->insertMarkPtr->sectionPtr) {
+	    if ((peer->insertMarkPtr->prevPtr && !peer->insertMarkPtr->prevPtr->typePtr)
+		|| (peer->insertMarkPtr->nextPtr && !peer->insertMarkPtr->nextPtr->typePtr)
+		|| (peer->insertMarkPtr->sectionPtr
+		    && (!peer->insertMarkPtr->sectionPtr->linePtr
+			|| !peer->insertMarkPtr->sectionPtr->linePtr->parentPtr))) {
+		Tcl_Panic("TkBTreeCheck: insert mark is expired");
+	    }
+	}
+#if 0 /* cannot be used, because also TkBTreeUnlinkSegment is calling TreeCheck */
+	if (peer->startMarker != treePtr->sharedTextPtr->startMarker) {
+	    if (!peer->startMarker->sectionPtr) {
+		Tcl_Panic("TkBTreeCheck: start marker is not linked");
+	    }
+	    if (!peer->endMarker->sectionPtr) {
+		Tcl_Panic("TkBTreeCheck: end marker is not linked");
+	    }
+	}
+#endif
+	if (!peer->startMarker->sectionPtr) {
+	    Tcl_Panic("TkBTreeCheck: start marker of is not linked");
+	}
+	if (!peer->endMarker->sectionPtr) {
+	    Tcl_Panic("TkBTreeCheck: end marker of is not linked");
+	}
+	if (!peer->startMarker->sectionPtr->linePtr->nextPtr) {
+	    Tcl_Panic("TkBTreeCheck: start marker is on very last line");
+	}
+	if (peer->startMarker->sectionPtr->linePtr == peer->endMarker->sectionPtr->linePtr) {
+	    const TkTextSegment *segPtr = peer->startMarker;
+	    while (segPtr && segPtr != peer->endMarker) {
+		segPtr = segPtr->prevPtr;
+	    }
+	    if (segPtr == peer->endMarker) {
+		Tcl_Panic("TkBTreeCheck: end marker segment is before start marker segment");
+	    }
+	} else {
+	    int startLineNo = TkBTreeLinesTo(tree, NULL, peer->startMarker->sectionPtr->linePtr, NULL);
+	    int endLineNo = TkBTreeLinesTo(tree, NULL, peer->endMarker->sectionPtr->linePtr, NULL);
+
+	    if (startLineNo > endLineNo) {
+		Tcl_Panic("TkBTreeCheck: end marker line is before start marker line");
+	    }
+	}
+    }
+
+    /*
+     * Call a recursive function to do the main body of checks.
+     */
+
+    CheckNodeConsistency(treePtr->sharedTextPtr, treePtr->rootPtr,
+	    treePtr->rootPtr, treePtr->numPixelReferences);
+
+    /*
+     * Make sure that there are at least two lines in the text and that the
+     * last line has no characters except a newline.
+     */
+
+    nodePtr = treePtr->rootPtr;
+    if (nodePtr->numLines < 2) {
+	Tcl_Panic("TkBTreeCheck: less than 2 lines in tree");
+    }
+    if (!nodePtr->linePtr->logicalLine) {
+	Tcl_Panic("TkBTreeCheck: first line must be a logical line");
+    }
+#if 0 /* TODO: is it really allowed that the last line is not a logical line? */
+    if (!nodePtr->lastPtr->logicalLine) {
+	Tcl_Panic("TkBTreeCheck: last line must be a logical line");
+    }
+#endif
+    while (nodePtr->level > 0) {
+	nodePtr = nodePtr->childPtr;
+	while (nodePtr->nextPtr) {
+	    nodePtr = nodePtr->nextPtr;
+	}
+    }
+    linePtr = nodePtr->lastPtr;
+    segPtr = linePtr->segPtr;
+    if (segPtr->typePtr == &tkTextLinkType) {
+	/* It's OK to have one link in the last line. */
+	segPtr = segPtr->nextPtr;
+    }
+    while (segPtr->typePtr->group == SEG_GROUP_MARK) {
+	/* It's OK to have marks or breaks in the last line. */
+	segPtr = segPtr->nextPtr;
+    }
+    if (segPtr->typePtr != &tkTextCharType) {
+	Tcl_Panic("TkBTreeCheck: last line has bogus segment type");
+    }
+    if (segPtr->nextPtr) {
+	Tcl_Panic("TkBTreeCheck: last line has too many segments");
+    }
+    if (segPtr->size != 1) {
+	Tcl_Panic("TkBTreeCheck: last line has wrong # characters: %d", segPtr->size);
+    }
+
+    s = segPtr->body.chars; /* this avoids warnings */
+    if (s[0] != '\n' || s[1] != '\0') {
+	Tcl_Panic("TkBTreeCheck: last line had bad value: %s", segPtr->body.chars);
+    }
+
+    for (entryPtr = Tcl_FirstHashEntry(&treePtr->sharedTextPtr->tagTable, &search);
+	    entryPtr;
+	    entryPtr = Tcl_NextHashEntry(&search)) {
+	const TkTextTag *tagPtr = Tcl_GetHashValue(entryPtr);
+
+	assert(tagPtr->index < treePtr->sharedTextPtr->tagInfoSize);
+
+	if (TkBitTest(treePtr->sharedTextPtr->selectionTags, tagPtr->index) && tagPtr->elideString) {
+	    Tcl_Panic("TkBTreeCheck: the selection tag '%s' is not allowed to elide (or un-elide)",
+		    tagPtr->name);
+	}
+
+	if ((nodePtr = tagPtr->rootPtr)) {
+	    assert(nodePtr->linePtr); /* still unfree'd? */
+
+	    if (!TkTextTagSetTest(nodePtr->tagonPtr, tagPtr->index)) {
+		if (nodePtr->level == 0) {
+		    Tcl_Panic("TkBTreeCheck: level zero node is not root for tag '%s'",
+			    tagPtr->name);
+		} else {
+		    Tcl_Panic("TkBTreeCheck: node is not root for tag '%s'", tagPtr->name);
+		}
+	    }
+
+	    if (nodePtr->level > 0 && CountChildsWithTag(nodePtr, tagPtr->index) < 2) {
+		Tcl_Panic("TkBTreeCheck: node is not root for tag '%s', it has less "
+			"than two childs containing this tag", tagPtr->name);
+	    }
+
+	    while ((nodePtr = nodePtr->parentPtr)) {
+		if (CountChildsWithTag(nodePtr, tagPtr->index) > 1) {
+		    Tcl_Panic("TkBTreeCheck: found higher node as root for tag '%s'", tagPtr->name);
+		}
+	    }
+	} else if (TkTextTagSetTest(treePtr->rootPtr->tagonPtr, tagPtr->index)) {
+	    Tcl_Panic("TkBTreeCheck: tag '%s' is used, but has no root", tagPtr->name);
+	}
+    }
+
+    if (tkTextDebug) {
+	for (peer = treePtr->sharedTextPtr->peers; peer; peer = peer->next) {
+	    /*
+	     * Check display stuff.
+	     */
+	    TkTextCheckDisplayLineConsistency(peer);
+	    TkTextCheckLineMetricUpdate(peer);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * CheckNodeConsistency --
+ *
+ *	This function is called as part of consistency checking for B-trees:
+ *	it checks several aspects of a node and also runs checks recursively
+ *	on the node's children.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If anything suspicious is found in the tree structure, the function
+ *	panics.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+CheckNodeConsistency(
+    const TkSharedText *sharedTextPtr,/* Handle to shared text resource. */
+    const Node *rootPtr,	/* The root node. */
+    const Node *nodePtr,	/* Node whose subtree should be checked. */
+    unsigned references)	/* Number of referring widgets which have pixel counts. */
+{
+    const Node *childNodePtr;
+    const TkTextLine *linePtr;
+    const TkTextLine *prevLinePtr;
+    int numChildren, numLines, numLogicalLines, numBranches;
+    int minChildren, size, i;
+    NodePixelInfo *pixelInfo = NULL;
+    NodePixelInfo pixelInfoBuf[PIXEL_CLIENTS];
+    TkTextTagSet *tagonPtr = NULL;
+    TkTextTagSet *tagoffPtr = NULL;
+    TkTextTagSet *additionalTagoffPtr = NULL;
+    unsigned memsize;
+
+    if (nodePtr->level == 0 && !nodePtr->linePtr) {
+	Tcl_Panic("CheckNodeConsistency: this node is freed");
+    }
+
+    minChildren = nodePtr->parentPtr ? MIN_CHILDREN : (nodePtr->level > 0 ? 2 : 1);
+    if (nodePtr->numChildren < minChildren || nodePtr->numChildren > MAX_CHILDREN) {
+	Tcl_Panic("CheckNodeConsistency: bad child count (%d)", nodePtr->numChildren);
+    }
+
+    if (!nodePtr->linePtr) {
+	Tcl_Panic("CheckNodeConsistency: first pointer is NULL");
+    }
+    if (!nodePtr->lastPtr) {
+	Tcl_Panic("CheckNodeConsistency: last pointer is NULL");
+    }
+    if (!nodePtr->tagonPtr || !nodePtr->tagoffPtr) {
+	Tcl_Panic("CheckNodeConsistency: tag information is NULL");
+    }
+    if (TkTextTagSetRefCount(nodePtr->tagonPtr) == 0) {
+	Tcl_Panic("CheckNodeConsistency: unreferenced tag info (tagon)");
+    }
+    if (TkTextTagSetRefCount(nodePtr->tagonPtr) > 0x3fffffff) {
+	Tcl_Panic("CheckNodeConsistency: negative reference count in tagon info");
+    }
+    if (TkTextTagSetRefCount(nodePtr->tagoffPtr) == 0) {
+	Tcl_Panic("CheckNodeConsistency: unreferenced tag info (tagoff)");
+    }
+    if (TkTextTagSetRefCount(nodePtr->tagoffPtr) > 0x3fffffff) {
+	Tcl_Panic("CheckNodeConsistency: negative reference count in tagoff info");
+    }
+    if (TkTextTagSetIsEmpty(nodePtr->tagonPtr)
+	    && nodePtr->tagonPtr != sharedTextPtr->emptyTagInfoPtr) {
+	Tcl_Panic("CheckNodeConsistency: should use shared resource if tag info is empty");
+    }
+    if (TkTextTagSetIsEmpty(nodePtr->tagoffPtr)
+	    && nodePtr->tagoffPtr != sharedTextPtr->emptyTagInfoPtr) {
+	Tcl_Panic("CheckNodeConsistency: should use shared resource if tag info is empty");
+    }
+    if (!TkTextTagSetContains(nodePtr->tagonPtr, nodePtr->tagoffPtr)) {
+	Tcl_Panic("CheckNodeConsistency: node tagoff not included in tagon");
+    }
+    if (!TkTextTagSetContains(rootPtr->tagonPtr, nodePtr->tagonPtr)) {
+	Tcl_Panic("CheckNodeConsistency: tagon not propagated to root");
+    }
+    if (!TkTextTagSetContains(rootPtr->tagoffPtr, nodePtr->tagoffPtr)) {
+	Tcl_Panic("CheckNodeConsistency: tagoff not propagated to root");
+    }
+
+    numChildren = numLines = numLogicalLines = numBranches = size = 0;
+
+    memsize = sizeof(pixelInfo[0])*references;
+    pixelInfo = (references > PIXEL_CLIENTS) ? (NodePixelInfo *) malloc(memsize) : pixelInfoBuf;
+    memset(pixelInfo, 0, memsize);
+
+    TkTextTagSetIncrRefCount(tagonPtr = sharedTextPtr->emptyTagInfoPtr);
+    TkTextTagSetIncrRefCount(tagoffPtr = sharedTextPtr->emptyTagInfoPtr);
+    additionalTagoffPtr = NULL;
+
+    if (nodePtr->level == 0) {
+	prevLinePtr = NULL;
+	linePtr = nodePtr->linePtr;
+	for (linePtr = nodePtr->linePtr;
+		numChildren < nodePtr->numChildren;
+		++numChildren, ++numLines, linePtr = linePtr->nextPtr) {
+	    if (!linePtr) {
+		Tcl_Panic("CheckNodeConsistency: unexpected end of line chain");
+	    }
+	    if (linePtr->parentPtr != nodePtr) {
+		Tcl_Panic("CheckNodeConsistency: line has wrong parent pointer");
+	    }
+	    CheckSegments(sharedTextPtr, linePtr);
+	    CheckSegmentItems(sharedTextPtr, linePtr);
+	    CheckSections(linePtr);
+	    for (i = 0; i < references; ++i) {
+		pixelInfo[i].pixels += linePtr->pixelInfo[i].height;
+		pixelInfo[i].numDispLines += GetDisplayLines(linePtr, i);
+	    }
+	    if (tagonPtr) {
+		tagonPtr = TkTextTagSetJoin(tagonPtr, linePtr->tagonPtr);
+		tagoffPtr = TkTextTagSetJoin(tagoffPtr, linePtr->tagoffPtr);
+		if (additionalTagoffPtr) {
+		    additionalTagoffPtr = TkTextTagSetIntersect(additionalTagoffPtr, linePtr->tagonPtr);
+		} else {
+		    TkTextTagSetIncrRefCount(additionalTagoffPtr = linePtr->tagonPtr);
+		}
+	    }
+	    prevLinePtr = linePtr;
+	    numLogicalLines += linePtr->logicalLine;
+	    numBranches += linePtr->numBranches;
+	    size += linePtr->size;
+	}
+	if (prevLinePtr != nodePtr->lastPtr) {
+	    Tcl_Panic("CheckNodeConsistency: wrong pointer to last line");
+	}
+    } else {
+	TkTextLine *startLinePtr = nodePtr->linePtr;
+
+	for (childNodePtr = nodePtr->childPtr; childNodePtr; childNodePtr = childNodePtr->nextPtr) {
+	    if (childNodePtr->parentPtr != nodePtr) {
+		Tcl_Panic("CheckNodeConsistency: node doesn't point to parent");
+	    }
+	    if (childNodePtr->level != nodePtr->level - 1) {
+		Tcl_Panic("CheckNodeConsistency: level mismatch (%d %d)",
+			nodePtr->level, childNodePtr->level);
+	    }
+	    if (childNodePtr->linePtr != startLinePtr) {
+		const Node *nodePtr = childNodePtr;
+		while (nodePtr->level > 0) {
+		    nodePtr = nodePtr->childPtr;
+		}
+		if (nodePtr->linePtr != startLinePtr) {
+		    Tcl_Panic("CheckNodeConsistency: pointer to first line is wrong");
+		} else {
+		    Tcl_Panic("CheckNodeConsistency: pointer to last line is wrong");
+		}
+	    }
+	    startLinePtr = childNodePtr->lastPtr->nextPtr;
+	    CheckNodeConsistency(sharedTextPtr, rootPtr, childNodePtr, references);
+	    numChildren += 1;
+	    numLines += childNodePtr->numLines;
+	    numLogicalLines += childNodePtr->numLogicalLines;
+	    numBranches += childNodePtr->numBranches;
+	    size += childNodePtr->size;
+	    if (tagonPtr) {
+		tagonPtr = TkTextTagSetJoin(tagonPtr, nodePtr->tagonPtr);
+		tagoffPtr = TkTextTagSetJoin(tagoffPtr, nodePtr->tagoffPtr);
+		if (additionalTagoffPtr) {
+		    additionalTagoffPtr = TkTextTagSetIntersect(additionalTagoffPtr, nodePtr->tagonPtr);
+		} else {
+		    TkTextTagSetIncrRefCount(additionalTagoffPtr = nodePtr->tagonPtr);
+		}
+	    }
+	    for (i = 0; i < references; i++) {
+		pixelInfo[i].pixels += childNodePtr->pixelInfo[i].pixels;
+		pixelInfo[i].numDispLines += childNodePtr->pixelInfo[i].numDispLines;
+	    }
+	}
+    }
+    if (size != nodePtr->size) {
+	Tcl_Panic("CheckNodeConsistency: sum of size (%d) at level %d is wrong (%d is expected)",
+		nodePtr->size, nodePtr->level, size);
+    }
+    if (numChildren != nodePtr->numChildren) {
+	Tcl_Panic("CheckNodeConsistency: mismatch in numChildren (expected: %d, counted: %d)",
+		numChildren, nodePtr->numChildren);
+    }
+    if (numLines != nodePtr->numLines) {
+	Tcl_Panic("CheckNodeConsistency: mismatch in numLines (expected: %d, counted: %d)",
+		numLines, nodePtr->numLines);
+    }
+    if (numLogicalLines != nodePtr->numLogicalLines) {
+	Tcl_Panic("CheckNodeConsistency: mismatch in numLogicalLines (expected: %d, counted: %d)",
+		numLogicalLines, nodePtr->numLogicalLines);
+    }
+    if (numBranches != nodePtr->numBranches) {
+	Tcl_Panic("CheckNodeConsistency: mismatch in numBranches (expected: %d, counted: %d)",
+		numLogicalLines, nodePtr->numLogicalLines);
+    }
+    if (tagonPtr) {
+	if (!TkTextTagSetIsEqual(tagonPtr, nodePtr->tagonPtr)) {
+	    Tcl_Panic("CheckNodeConsistency: sum of node tag information is wrong (tagon)");
+	}
+	assert(additionalTagoffPtr);
+	additionalTagoffPtr = TkTextTagSetComplementTo(additionalTagoffPtr, tagonPtr);
+	tagoffPtr = TkTextTagSetJoin(tagoffPtr, additionalTagoffPtr);
+	if (!TkTextTagSetIsEqual(tagoffPtr, nodePtr->tagoffPtr)) {
+	    Tcl_Panic("CheckNodeConsistency: sum of node tag information is wrong (tagoff)");
+	}
+	for (i = TkTextTagSetFindFirst(tagonPtr);
+		i != TK_TEXT_TAG_SET_NPOS;
+		i = TkTextTagSetFindNext(tagonPtr, i)) {
+	    if (!sharedTextPtr->tagLookup[i]) {
+		Tcl_Panic("CheckNodeConsistency: node tagon contains deleted tag %d", i);
+	    }
+	    if (sharedTextPtr->tagLookup[i]->isDisabled) {
+		Tcl_Panic("CheckNodeConsistency: node tagon contains disabled tag %d", i);
+	    }
+	}
+
+	TkTextTagSetDecrRefCount(tagonPtr);
+	TkTextTagSetDecrRefCount(tagoffPtr);
+	TkTextTagSetDecrRefCount(additionalTagoffPtr);
+    }
+    for (i = 0; i < references; i++) {
+	if (pixelInfo[i].pixels != nodePtr->pixelInfo[i].pixels) {
+	    Tcl_Panic("CheckNodeConsistency: mismatch in pixel count "
+		    "(expected: %d, counted: %d) for widget (%d) at level %d",
+		    pixelInfo[i].pixels, nodePtr->pixelInfo[i].pixels, i, nodePtr->level);
+	}
+	if (pixelInfo[i].numDispLines != nodePtr->pixelInfo[i].numDispLines) {
+	    Tcl_Panic("CheckNodeConsistency: mismatch in number of display lines "
+		    "(expected: %d, counted: %d) for widget (%d) at level %d",
+		    pixelInfo[i].numDispLines, nodePtr->pixelInfo[i].numDispLines,
+		    i, nodePtr->level);
+	}
+    }
+    if (pixelInfo != pixelInfoBuf) {
+	free(pixelInfo);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DeleteEmptyNode --
+ *
+ *	This function is deleting a level-0 node from the B-tree.
+ *	It is also deleting the parents recursively upwards until
+ *	a non-empty node is found.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The internal structure of treePtr will change. The pixel counts
+ *	will be updated.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+DeleteEmptyNode(
+    BTree *treePtr,	/* B-tree that is being modified. */
+    Node *nodePtr)	/* Level-0 node that will be deleted. */
+{
+    TkTextLine *linePtr, *lastPtr, *nextPtr, *prevPtr;
+    Node *parentPtr;
+    NodePixelInfo *changeToPixelInfo;
+    unsigned ref;
+
+    assert(nodePtr->level == 0);
+    assert(nodePtr->numChildren == 0);
+    assert(nodePtr->linePtr);
+
+    changeToPixelInfo = treePtr->pixelInfoBuffer;
+    memset(changeToPixelInfo, 0, treePtr->numPixelReferences * sizeof(changeToPixelInfo[0]));
+
+    /*
+     * The pixel count of this node is going to zero.
+     */
+
+    for (linePtr = nodePtr->linePtr, lastPtr = nodePtr->lastPtr->nextPtr;
+	    linePtr != lastPtr;
+	    linePtr = linePtr->nextPtr) {
+	NodePixelInfo *dst = changeToPixelInfo;
+
+	for (ref = 0; ref < treePtr->numPixelReferences; ++ref, ++dst) {
+	    dst->pixels += linePtr->pixelInfo[ref].height;
+	    dst->numDispLines += GetDisplayLines(linePtr, ref);
+	}
+    }
+    SubtractPixelCount2(treePtr, nodePtr->parentPtr, nodePtr->numLines, nodePtr->numLogicalLines,
+	    nodePtr->numBranches, nodePtr->size, changeToPixelInfo);
+
+    lastPtr = nodePtr->lastPtr;
+    prevPtr = nodePtr->linePtr->prevPtr;
+    parentPtr = nodePtr->parentPtr;
+    for ( ; parentPtr && parentPtr->lastPtr == lastPtr; parentPtr = parentPtr->parentPtr) {
+	parentPtr->lastPtr = prevPtr;
+    }
+
+    linePtr = nodePtr->linePtr;
+    nextPtr = nodePtr->lastPtr->nextPtr;
+    parentPtr = nodePtr->parentPtr;
+    for ( ; parentPtr && parentPtr->linePtr == linePtr; parentPtr = parentPtr->parentPtr) {
+	parentPtr->linePtr = nextPtr;
+    }
+
+    do {
+	TkTextTagSet *tagonPtr;
+	unsigned i;
+
+	parentPtr = nodePtr->parentPtr;
+
+	if (parentPtr->childPtr == nodePtr) {
+	    parentPtr->childPtr = nodePtr->nextPtr;
+	} else {
+	    Node *prevNodePtr = parentPtr->childPtr;
+
+	    while (prevNodePtr->nextPtr != nodePtr) {
+		prevNodePtr = prevNodePtr->nextPtr;
+	    }
+	    prevNodePtr->nextPtr = nodePtr->nextPtr;
+	}
+	parentPtr->numChildren -= 1;
+
+	/*
+	 * Remove all tags from this node.
+	 */
+
+	tagonPtr = nodePtr->tagonPtr;
+	TkTextTagSetIncrRefCount(tagonPtr);
+	for (i = TkTextTagSetFindFirst(tagonPtr);
+		i != TK_TEXT_TAG_SET_NPOS;
+		i = TkTextTagSetFindNext(tagonPtr, i)) {
+	    RemoveTagFromNode(nodePtr, treePtr->sharedTextPtr->tagLookup[i]);
+	}
+	TkTextTagSetDecrRefCount(tagonPtr);
+
+	FreeNode(nodePtr);
+	nodePtr = parentPtr;
+    } while (nodePtr->numChildren == 0);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Rebalance --
+ *
+ *	This function is called when a node of a B-tree appears to be out of
+ *	balance (too many children, or too few). It rebalances that node and
+ *	all of its ancestors in the tree.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The internal structure of treePtr may change.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+RebalanceAssignNewParentToChildren(
+    Node *nodePtr)
+{
+    if (nodePtr->level == 0) {
+	TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+	TkTextLine *linePtr;
+
+	for (linePtr = nodePtr->linePtr; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+	    linePtr->parentPtr = nodePtr;
+	}
+    } else {
+	Node *childPtr = nodePtr->childPtr;
+
+	for (childPtr = nodePtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+	    childPtr->parentPtr = nodePtr;
+	}
+    }
+}
+
+static void
+RebalanceAddLinePixels(
+    NodePixelInfo *dstPixels,
+    const TkTextLine *linePtr,
+    unsigned numRefs)
+{
+    const TkTextPixelInfo *srcPixelInfo = linePtr->pixelInfo;
+    const TkTextPixelInfo *e = srcPixelInfo + numRefs;
+
+    for ( ; srcPixelInfo < e; ++srcPixelInfo, ++dstPixels) {
+	dstPixels->pixels += srcPixelInfo->height;
+	dstPixels->numDispLines += TkBTreeGetNumberOfDisplayLines(srcPixelInfo);
+    }
+}
+
+static void
+RebalanceAddNodePixels(
+    NodePixelInfo *dstPixels,
+    const NodePixelInfo *srcPixels,
+    unsigned numRefs)
+{
+    const NodePixelInfo *e = srcPixels + numRefs;
+
+    for ( ; srcPixels < e; ++srcPixels, ++dstPixels) {
+	dstPixels->pixels += srcPixels->pixels;
+	dstPixels->numDispLines += srcPixels->numDispLines;
+    }
+}
+
+static void
+RebalanceSubtractNodePixels(
+    NodePixelInfo *dstPixels,
+    const NodePixelInfo *srcPixels,
+    unsigned numRefs)
+{
+    const NodePixelInfo *e = srcPixels + numRefs;
+
+    for ( ; srcPixels < e; ++srcPixels, ++dstPixels) {
+	dstPixels->pixels -= srcPixels->pixels;
+	dstPixels->numDispLines -= srcPixels->numDispLines;
+    }
+}
+
+static void
+RebalanceRecomputeNodeTagInfo(
+    Node *nodePtr,
+    TkSharedText *sharedTextPtr)
+{
+    TkTextTagSet *additionalTagoffPtr = NULL;
+
+    assert(TkTextTagSetIsEmpty(nodePtr->tagonPtr));
+    assert(TkTextTagSetIsEmpty(nodePtr->tagoffPtr));
+
+    if (nodePtr->level == 0) {
+	TkTextLine *linePtr = nodePtr->linePtr;
+	TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+
+	for ( ; linePtr != lastPtr; linePtr = linePtr->nextPtr) {
+	    nodePtr->tagonPtr = TkTextTagSetJoin(nodePtr->tagonPtr, linePtr->tagonPtr);
+	    nodePtr->tagoffPtr = TkTextTagSetJoin(nodePtr->tagoffPtr, linePtr->tagoffPtr);
+	    if (additionalTagoffPtr) {
+		additionalTagoffPtr = TkTextTagSetIntersect(additionalTagoffPtr, linePtr->tagonPtr);
+	    } else {
+		TkTextTagSetIncrRefCount(additionalTagoffPtr = linePtr->tagonPtr);
+	    }
+	}
+    } else {
+	Node *childPtr = nodePtr->childPtr;
+
+	for ( ; childPtr; childPtr = childPtr->nextPtr) {
+	    nodePtr->tagonPtr = TkTextTagSetJoin(nodePtr->tagonPtr, childPtr->tagonPtr);
+	    nodePtr->tagoffPtr = TkTextTagSetJoin(nodePtr->tagoffPtr, childPtr->tagoffPtr);
+	    if (additionalTagoffPtr) {
+		additionalTagoffPtr = TkTextTagSetIntersect(additionalTagoffPtr, nodePtr->tagonPtr);
+	    } else {
+		TkTextTagSetIncrRefCount(additionalTagoffPtr = nodePtr->tagonPtr);
+	    }
+	}
+    }
+
+    assert(additionalTagoffPtr);
+
+    /*
+     * Finally add any tag to tagoff, if it is contained in at least one child, but not in all.
+     */
+
+    nodePtr->tagoffPtr = TagSetJoinComplementTo(
+	    nodePtr->tagoffPtr, additionalTagoffPtr, nodePtr->tagonPtr, sharedTextPtr);
+    TkTextTagSetDecrRefCount(additionalTagoffPtr);
+}
+
+static Node *
+RebalanceFindSiblingForTag(
+    Node *parentPtr,
+    unsigned tagIndex)
+{
+    Node *childPtr;
+    Node *nodePtr = NULL;
+
+    for (childPtr = parentPtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+	if (TkTextTagSetTest(childPtr->tagonPtr, tagIndex)) {
+	    if (nodePtr) {
+		return NULL;
+	    }
+	    nodePtr = childPtr;
+	}
+    }
+
+    return nodePtr;
+}
+
+static void
+RebalanceRecomputeTagRootsAfterSplit(
+    Node *parentPtr,
+    TkSharedText *sharedTextPtr)
+{
+    const TkTextTagSet *tagInfoPtr = parentPtr->tagonPtr;
+    unsigned childLevel = parentPtr->level - 1;
+    unsigned i;
+
+    for (i = TkTextTagSetFindFirst(tagInfoPtr);
+	    i != TK_TEXT_TAG_SET_NPOS;
+	    i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	TkTextTag *tagPtr = sharedTextPtr->tagLookup[i];
+	const Node *rootPtr;
+
+	assert(tagPtr);
+	assert(!tagPtr->isDisabled);
+
+	rootPtr = tagPtr->rootPtr;
+
+	if (rootPtr == parentPtr || rootPtr->level == childLevel) {
+	    Node *nodePtr;
+
+	    /*
+	     * Either we have a sibling which has collected all occurrences, so move
+	     * the root to this node, or more than one sibling contains this tag,
+	     * so the parent is the root.
+	     */
+
+	    nodePtr = RebalanceFindSiblingForTag(parentPtr, i);
+	    tagPtr->rootPtr = nodePtr ? nodePtr : parentPtr;
+	}
+    }
+}
+
+static bool
+RebalanceHasCollectedAll(
+    const Node *nodePtr,
+    const Node *excludePtr,	/* don't test this node */
+    unsigned tagIndex)
+{
+    for ( ; nodePtr; nodePtr = nodePtr->nextPtr) {
+	if (nodePtr != excludePtr && TkTextTagSetTest(nodePtr->tagonPtr, tagIndex)) {
+	    return false;
+	}
+    }
+    return true;
+}
+
+static void
+RebalanceRecomputeTagRootsAfterMerge(
+    Node *resultPtr,		/* The node as the result of the merge. */
+    const Node *mergePtr,	/* The node which has been merged into resultPtr. */
+    TkSharedText *sharedTextPtr)
+{
+    unsigned i;
+
+    assert(resultPtr->parentPtr);
+
+    for (i = TkTextTagSetFindFirst(resultPtr->tagonPtr);
+	    i != TK_TEXT_TAG_SET_NPOS;
+	    i = TkTextTagSetFindNext(resultPtr->tagonPtr, i)) {
+	TkTextTag *tagPtr = sharedTextPtr->tagLookup[i];
+	const Node *tagRootPtr;
+
+	assert(tagPtr);
+	assert(!tagPtr->isDisabled);
+
+	tagRootPtr = tagPtr->rootPtr;
+
+	/*
+	 * We have three cases:
+	 *
+	 * 1. mergePtr is the root of this tag; simply move the root to resultPtr.
+	 *
+	 * 2. The parent of these nodes is root of this tag, and resultPtr now has
+	 *    collected all occurrences of this tag; simply move the root one level
+	 *    down to resultPtr.
+	 *
+	 * 3. Otherwise, simply do nothing.
+	 */
+
+	if (tagRootPtr == mergePtr) {
+	    tagPtr->rootPtr = resultPtr;
+	} else if (tagRootPtr == resultPtr->parentPtr) {
+	    if (RebalanceHasCollectedAll(resultPtr->parentPtr->childPtr, resultPtr, i)) {
+		tagPtr->rootPtr = resultPtr;
+	    }
+	}
+    }
+}
+
+static Node *
+RebalanceDivideChildren(
+    Node *nodePtr,
+    Node *otherPtr,		/* can be NULL */
+    unsigned minChildren,	/* split after this number of children */
+    unsigned numRefs)
+{
+    Node *childPtr = nodePtr->childPtr;
+    Node *divideChildPtr = NULL;
+
+    assert(nodePtr->level > 0);
+    assert(minChildren > 0);
+
+    nodePtr->numLines = 0;
+    nodePtr->numLogicalLines = 0;
+    nodePtr->numBranches = 0;
+    nodePtr->size = 0;
+
+    for ( ; childPtr->nextPtr; childPtr = childPtr->nextPtr) {
+	if (!divideChildPtr) {
+	    nodePtr->numLines += childPtr->numLines;
+	    nodePtr->numLogicalLines += childPtr->numLogicalLines;
+	    nodePtr->numBranches += childPtr->numBranches;
+	    nodePtr->size += childPtr->size;
+	    RebalanceAddNodePixels(nodePtr->pixelInfo, childPtr->pixelInfo, numRefs);
+	}
+	if (--minChildren == 0) {
+	    if (!otherPtr) {
+		return childPtr;
+	    }
+	    divideChildPtr = childPtr;
+	}
+    }
+
+    assert(otherPtr);
+
+    childPtr->nextPtr = otherPtr->childPtr;
+
+    if (!divideChildPtr) {
+	assert(minChildren > 1);
+	nodePtr->numLines += childPtr->numLines;
+	nodePtr->numLogicalLines += childPtr->numLogicalLines;
+	nodePtr->size += childPtr->size;
+	RebalanceAddNodePixels(nodePtr->pixelInfo, childPtr->pixelInfo, numRefs);
+	for ( ; minChildren > 1; --minChildren) {
+	    childPtr = childPtr->nextPtr;
+	    nodePtr->numLines += childPtr->numLines;
+	    nodePtr->numLogicalLines += childPtr->numLogicalLines;
+	    nodePtr->numBranches += childPtr->numBranches;
+	    nodePtr->size += childPtr->size;
+	    RebalanceAddNodePixels(nodePtr->pixelInfo, childPtr->pixelInfo, numRefs);
+	}
+	assert(childPtr);
+	divideChildPtr = childPtr;
+    }
+
+    return divideChildPtr;
+}
+
+static TkTextLine *
+RebalanceDivideLines(
+    Node *nodePtr,
+    unsigned minLines,
+    unsigned numRefs)
+{
+    TkTextLine *divideLinePtr = nodePtr->linePtr;
+
+    assert(nodePtr->level == 0);
+    assert(minLines > 0);
+
+    RebalanceAddLinePixels(nodePtr->pixelInfo, divideLinePtr, numRefs);
+    nodePtr->size = divideLinePtr->size;
+    nodePtr->numLogicalLines = divideLinePtr->logicalLine;
+    nodePtr->numBranches = divideLinePtr->numBranches;
+
+    for ( ; minLines > 1; --minLines) {
+	divideLinePtr = divideLinePtr->nextPtr;
+	nodePtr->size += divideLinePtr->size;
+	nodePtr->numLogicalLines += divideLinePtr->logicalLine;
+	nodePtr->numBranches += divideLinePtr->numBranches;
+	RebalanceAddLinePixels(nodePtr->pixelInfo, divideLinePtr, numRefs);
+    }
+
+    return divideLinePtr;
+}
+
+static void
+RebalanceFinalizeNodeSplits(
+    Node **firstNodePtr,
+    Node *lastNodePtr,			/* inclusive this node */
+    TkSharedText *sharedTextPtr)
+{
+    Node *nodePtr;
+
+    if (!*firstNodePtr) {
+	return;
+    }
+
+    lastNodePtr = lastNodePtr->nextPtr;
+
+    for (nodePtr = *firstNodePtr; nodePtr != lastNodePtr; nodePtr = nodePtr->nextPtr) {
+	TagSetAssign(&nodePtr->tagonPtr, sharedTextPtr->emptyTagInfoPtr);
+	TagSetAssign(&nodePtr->tagoffPtr, sharedTextPtr->emptyTagInfoPtr);
+	RebalanceAssignNewParentToChildren(nodePtr);
+	RebalanceRecomputeNodeTagInfo(nodePtr, sharedTextPtr);
+    }
+
+    RebalanceRecomputeTagRootsAfterSplit((*firstNodePtr)->parentPtr, sharedTextPtr);
+    *firstNodePtr = NULL;
+}
+
+static void
+RebalanceNodeJoinTagInfo(
+    Node *dstPtr,
+    Node *srcPtr,
+    const TkSharedText *sharedTextPtr)
+{
+    assert(dstPtr);
+    assert(srcPtr);
+    assert(sharedTextPtr);
+
+    if (srcPtr->tagonPtr == dstPtr->tagonPtr && srcPtr->tagoffPtr == dstPtr->tagoffPtr) {
+	return;
+    }
+
+    if (dstPtr->tagonPtr == sharedTextPtr->emptyTagInfoPtr) {
+	dstPtr->tagoffPtr = TkTextTagSetJoin2(dstPtr->tagoffPtr, srcPtr->tagoffPtr, srcPtr->tagonPtr);
+    } else if (srcPtr->tagonPtr == sharedTextPtr->emptyTagInfoPtr) {
+	dstPtr->tagoffPtr = TkTextTagSetJoin2(dstPtr->tagoffPtr, srcPtr->tagoffPtr, dstPtr->tagonPtr);
+    } else {
+#if !TK_TEXT_DONT_USE_BITFIELDS
+	unsigned size1 = TkTextTagSetSize(dstPtr->tagonPtr);
+	unsigned size2 = TkTextTagSetSize(srcPtr->tagonPtr);
+	unsigned minSize = MAX(TkTextTagSetSize(srcPtr->tagoffPtr), MAX(size1, size2));
+
+	if (TkTextTagSetSize(dstPtr->tagoffPtr) < minSize) {
+	    dstPtr->tagoffPtr = TkTextTagSetResize(dstPtr->tagoffPtr, sharedTextPtr->tagInfoSize);
+	}
+	if (size1 < size2) {
+	    dstPtr->tagonPtr = TkTextTagSetResize(dstPtr->tagonPtr, size2);
+	} else if (size2 < size1) {
+	    srcPtr->tagonPtr = TkTextTagSetResize(srcPtr->tagonPtr, size1);
+	}
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+	dstPtr->tagoffPtr = TkTextTagSetJoin2ComplementToIntersection(
+		dstPtr->tagoffPtr, srcPtr->tagoffPtr, dstPtr->tagonPtr, srcPtr->tagonPtr);
+    }
+    if (TkTextTagSetIsEmpty(dstPtr->tagoffPtr)) {
+	TagSetAssign(&dstPtr->tagoffPtr, sharedTextPtr->emptyTagInfoPtr);
+    }
+    dstPtr->tagonPtr = TkTextTagSetJoin(dstPtr->tagonPtr, srcPtr->tagonPtr);
+}
+
+static void
+Rebalance(
+    BTree *treePtr,	/* Tree that is being rebalanced. */
+    Node *nodePtr)	/* Node that may be out of balance. */
+{
+    unsigned numRefs = treePtr->numPixelReferences;
+    unsigned pixelSize = sizeof(nodePtr->pixelInfo[0])*numRefs;
+
+    /*
+     * Loop over the entire ancestral chain of the node, working up through
+     * the tree one node at a time until the root node has been processed.
+     */
+
+    for ( ; nodePtr; nodePtr = nodePtr->parentPtr) {
+	Node *firstNodePtr = NULL;
+	Node *lastNodePtr = NULL;
+
+	/*
+	 * Check to see if the node has too many children. If it does, then split off
+	 * all but the first MIN_CHILDREN into a separate node following the original
+	 * one. Then repeat until the node has a decent size.
+	 */
+
+	if (nodePtr->numChildren > MAX_CHILDREN) {
+	    firstNodePtr = nodePtr;
+
+	    do {
+		Node *newPtr;
+
+		/*
+		 * If the node being split is the root node, then make a new root node above it first.
+		 */
+
+		if (!nodePtr->parentPtr) {
+		    Node *newRootPtr = malloc(sizeof(Node));
+		    newRootPtr->parentPtr = NULL;
+		    newRootPtr->nextPtr = NULL;
+		    newRootPtr->childPtr = nodePtr;
+		    newRootPtr->linePtr = nodePtr->linePtr;
+		    newRootPtr->lastPtr = nodePtr->lastPtr;
+		    TkTextTagSetIncrRefCount(newRootPtr->tagonPtr = nodePtr->tagonPtr);
+		    TkTextTagSetIncrRefCount(newRootPtr->tagoffPtr = nodePtr->tagoffPtr);
+		    newRootPtr->numChildren = 1;
+		    newRootPtr->numLines = nodePtr->numLines;
+		    newRootPtr->numLogicalLines = nodePtr->numLogicalLines;
+		    newRootPtr->numBranches = nodePtr->numBranches;
+		    newRootPtr->level = nodePtr->level + 1;
+		    newRootPtr->size = nodePtr->size;
+		    newRootPtr->pixelInfo = memcpy(malloc(pixelSize), nodePtr->pixelInfo, pixelSize);
+		    nodePtr->parentPtr = newRootPtr;
+		    treePtr->rootPtr = newRootPtr;
+		    DEBUG_ALLOC(tkTextCountNewNode++);
+		    DEBUG_ALLOC(tkTextCountNewPixelInfo++);
+		}
+
+		newPtr = malloc(sizeof(Node));
+		newPtr->parentPtr = nodePtr->parentPtr;
+		newPtr->nextPtr = nodePtr->nextPtr;
+		newPtr->lastPtr = nodePtr->lastPtr;
+		newPtr->tagonPtr = treePtr->sharedTextPtr->emptyTagInfoPtr;
+		newPtr->tagoffPtr = treePtr->sharedTextPtr->emptyTagInfoPtr;
+		TkTextTagSetIncrRefCount(newPtr->tagonPtr);
+		TkTextTagSetIncrRefCount(newPtr->tagoffPtr);
+		newPtr->numChildren = nodePtr->numChildren - MIN_CHILDREN;
+		newPtr->level = nodePtr->level;
+		newPtr->size = nodePtr->size;
+		newPtr->pixelInfo = nodePtr->pixelInfo;
+		newPtr->numLines = nodePtr->numLines;
+		newPtr->numLogicalLines = nodePtr->numLogicalLines;
+		newPtr->numBranches = nodePtr->numBranches;
+		nodePtr->nextPtr = newPtr;
+		nodePtr->numChildren = MIN_CHILDREN;
+		nodePtr->pixelInfo = memset(malloc(pixelSize), 0, pixelSize);
+		TagSetAssign(&nodePtr->tagonPtr, treePtr->sharedTextPtr->emptyTagInfoPtr);
+		TagSetAssign(&nodePtr->tagoffPtr, treePtr->sharedTextPtr->emptyTagInfoPtr);
+		DEBUG_ALLOC(tkTextCountNewNode++);
+		DEBUG_ALLOC(tkTextCountNewPixelInfo++);
+		if (nodePtr->level == 0) {
+		    TkTextLine *linePtr = RebalanceDivideLines(nodePtr, MIN_CHILDREN, numRefs);
+		    assert(linePtr->nextPtr);
+		    newPtr->childPtr = NULL;
+		    newPtr->linePtr = linePtr->nextPtr;
+		    newPtr->numLines = newPtr->numChildren;
+		    nodePtr->lastPtr = linePtr;
+		    nodePtr->numLines = MIN_CHILDREN;
+		} else {
+		    Node *childPtr = RebalanceDivideChildren(nodePtr, NULL, MIN_CHILDREN, numRefs);
+		    newPtr->childPtr = childPtr->nextPtr;
+		    newPtr->linePtr = childPtr->nextPtr->linePtr;
+		    newPtr->numLines -= nodePtr->numLines;
+		    nodePtr->lastPtr = childPtr->lastPtr;
+		    childPtr->nextPtr = NULL;
+		}
+		RebalanceSubtractNodePixels(newPtr->pixelInfo, nodePtr->pixelInfo, numRefs);
+		newPtr->size -= nodePtr->size;
+		newPtr->numLogicalLines -= nodePtr->numLogicalLines;
+		newPtr->numBranches -= nodePtr->numBranches;
+		nodePtr->parentPtr->numChildren += 1;
+		lastNodePtr = nodePtr = newPtr;
+	    } while (nodePtr->numChildren > MAX_CHILDREN);
+	}
+
+	while (nodePtr->numChildren < MIN_CHILDREN) {
+	    Node *otherPtr;
+	    unsigned totalChildren;
+
+	    /*
+	     * Too few children for this node. If this is the root then, it's OK
+	     * for it to have less than MIN_CHILDREN children as long as it's got
+	     * at least two. If it has only one (and isn't at level 0), then chop
+	     * the root node out of the tree and use its child as the new root.
+	     */
+
+	    if (!nodePtr->parentPtr) {
+		if (nodePtr->numChildren == 1 && nodePtr->level > 0) {
+		    treePtr->rootPtr = nodePtr->childPtr;
+		    treePtr->rootPtr->parentPtr = NULL;
+		    FreeNode(nodePtr);
+		}
+		return;
+	    }
+
+	    /*
+	     * Not the root. Make sure that there are siblings to balance with.
+	     */
+
+	    if (nodePtr->parentPtr->numChildren < 2) {
+		/* Do the finalization of previous splits. */
+		RebalanceFinalizeNodeSplits(&firstNodePtr, lastNodePtr, treePtr->sharedTextPtr);
+		Rebalance(treePtr, nodePtr->parentPtr);
+		continue;
+	    }
+
+	    /*
+	     * Find a sibling neighbor to borrow from, and arrange for nodePtr
+	     * to be the earlier of the pair.
+	     */
+
+	    if (!nodePtr->nextPtr) {
+		for (otherPtr = nodePtr->parentPtr->childPtr;
+			otherPtr->nextPtr != nodePtr;
+			otherPtr = otherPtr->nextPtr) {
+		    /* Empty loop body. */
+		}
+		nodePtr = otherPtr;
+	    }
+	    otherPtr = nodePtr->nextPtr;
+
+	    /*
+	     * We're going to either merge the two siblings together into one
+	     * node or redivide the children among them to balance their loads.
+	     */
+
+	    totalChildren = nodePtr->numChildren + otherPtr->numChildren;
+
+	    /*
+	     * The successor node will contain the sum of both pixel counts.
+	     */
+
+	    RebalanceAddNodePixels(otherPtr->pixelInfo, nodePtr->pixelInfo, numRefs);
+
+	    if (!nodePtr->childPtr) {
+		nodePtr->childPtr = otherPtr->childPtr;
+		otherPtr->childPtr = NULL;
+	    }
+
+	    if (totalChildren <= MAX_CHILDREN) {
+		NodePixelInfo *pixelInfo;
+		Node *childPtr;
+
+		/*
+		 * Do the finalization of previous splits.
+		 */
+
+		RebalanceFinalizeNodeSplits(&firstNodePtr, lastNodePtr, treePtr->sharedTextPtr);
+
+		/*
+		 * Simply merge the two siblings. At first join their two child
+		 * lists into a single list.
+		 */
+
+		if (nodePtr->level > 0) {
+		    for (childPtr = nodePtr->childPtr; childPtr->nextPtr; childPtr = childPtr->nextPtr) {
+			/* empty loop body */
+		    }
+		    childPtr->nextPtr = otherPtr->childPtr;
+		}
+
+		nodePtr->lastPtr = otherPtr->lastPtr;
+		nodePtr->nextPtr = otherPtr->nextPtr;
+		nodePtr->numChildren = totalChildren;
+		nodePtr->numLines += otherPtr->numLines;
+		nodePtr->numLogicalLines += otherPtr->numLogicalLines;
+		nodePtr->numBranches += otherPtr->numBranches;
+		nodePtr->parentPtr->numChildren -= 1;
+		nodePtr->size += otherPtr->size;
+		/* swap pixel count */
+		pixelInfo = nodePtr->pixelInfo;
+		nodePtr->pixelInfo = otherPtr->pixelInfo;
+		otherPtr->pixelInfo = pixelInfo;
+
+		RebalanceAssignNewParentToChildren(nodePtr);
+		RebalanceNodeJoinTagInfo(nodePtr, otherPtr, treePtr->sharedTextPtr);
+		RebalanceRecomputeTagRootsAfterMerge(nodePtr, otherPtr, treePtr->sharedTextPtr);
+		FreeNode(otherPtr);
+	    } else {
+		/*
+		 * The siblings can't be merged, so just divide their children evenly between them.
+		 */
+
+		unsigned firstChildren = totalChildren/2;
+
+		/*
+		 * Remember this node for finalization.
+		 */
+
+		if (!firstNodePtr) {
+		    firstNodePtr = nodePtr;
+		}
+		lastNodePtr = otherPtr;
+
+		otherPtr->size += nodePtr->size;
+		otherPtr->numLogicalLines += nodePtr->numLogicalLines;
+		otherPtr->numBranches += nodePtr->numBranches;
+
+		/* Prepare pixel count in nodePtr, DivideLines/DivideChildren will do the count. */
+		memset(nodePtr->pixelInfo, 0, pixelSize);
+
+		nodePtr->numChildren = firstChildren;
+		otherPtr->numChildren = totalChildren - firstChildren;
+
+		if (nodePtr->level == 0) {
+		    TkTextLine *halfwayLinePtr = RebalanceDivideLines(nodePtr, firstChildren, numRefs);
+
+		    nodePtr->numLines = nodePtr->numChildren;
+		    nodePtr->lastPtr = halfwayLinePtr;
+		    otherPtr->linePtr = halfwayLinePtr->nextPtr;
+		    otherPtr->numLines = otherPtr->numChildren;
+		} else {
+		    unsigned totalLines = nodePtr->numLines + otherPtr->numLines;
+		    Node *halfwayNodePtr;
+
+		    halfwayNodePtr = RebalanceDivideChildren(nodePtr, otherPtr, firstChildren, numRefs);
+		    nodePtr->lastPtr = halfwayNodePtr->lastPtr;
+		    otherPtr->numLines = totalLines - nodePtr->numLines;
+		    otherPtr->linePtr = halfwayNodePtr->nextPtr->linePtr;
+		    otherPtr->childPtr = halfwayNodePtr->nextPtr;
+		    halfwayNodePtr->nextPtr = NULL;
+		}
+
+		otherPtr->size -= nodePtr->size;
+		otherPtr->numLogicalLines -= nodePtr->numLogicalLines;
+		otherPtr->numBranches -= nodePtr->numBranches;
+		RebalanceSubtractNodePixels(otherPtr->pixelInfo, nodePtr->pixelInfo, numRefs);
+	    }
+	}
+
+	/*
+	 * Do the finalization of previous splits.
+	 */
+
+	RebalanceFinalizeNodeSplits(&firstNodePtr, lastNodePtr, treePtr->sharedTextPtr);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeGetLogicalLine --
+ *
+ *	Given a line, this function is searching in B-Tree for the first
+ *	line which belongs logically to given line due to elided newlines.
+ *
+ * Results:
+ *	The return value is the first logical line belonging to given
+ *	line, in most cases this will be the given line itself.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static const Node *
+PrevLogicalNode(
+    const Node *nodePtr)
+{
+    assert(nodePtr);
+
+    while (nodePtr->parentPtr) {
+	const Node *startNodePtr = nodePtr;
+	const Node *lastNodePtr = NULL;
+
+	nodePtr = nodePtr->parentPtr->childPtr;
+
+	for ( ; nodePtr != startNodePtr; nodePtr = nodePtr->nextPtr) {
+	    if (nodePtr->numLogicalLines > 0) {
+		lastNodePtr = nodePtr;
+	    }
+	}
+	if (lastNodePtr) {
+	    nodePtr = lastNodePtr;
+
+	    while (nodePtr->level > 0) {
+		DEBUG(lastNodePtr = NULL);
+
+		for (nodePtr = nodePtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+		    if (nodePtr->numLogicalLines > 0) {
+			lastNodePtr = nodePtr;
+		    }
+		}
+
+		assert(lastNodePtr);
+		nodePtr = lastNodePtr;
+	    }
+
+	    return lastNodePtr;
+	}
+
+	nodePtr = startNodePtr->parentPtr;
+    }
+
+    return NULL;
+}
+
+TkTextLine *
+TkBTreeGetLogicalLine(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr,		/* can be NULL */
+    TkTextLine *linePtr)
+{
+    const Node *nodePtr;
+    TkTextLine *startLinePtr;
+
+    assert(linePtr);
+
+    if (linePtr->logicalLine || linePtr == GetStartLine(sharedTextPtr, textPtr)) {
+	return linePtr;
+    }
+
+    nodePtr = linePtr->parentPtr;
+    startLinePtr = GetStartLine(sharedTextPtr, textPtr);
+
+    /*
+     * At first, search for logical line in current node.
+     */
+
+    while (linePtr->parentPtr == nodePtr) {
+	if (linePtr->logicalLine || linePtr == startLinePtr) {
+	    return linePtr;
+	}
+	linePtr = linePtr->prevPtr;
+    }
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for next level-0
+     * node which contains the logical line.
+     */
+
+    if (!(nodePtr = PrevLogicalNode(nodePtr))) {
+	return startLinePtr;
+    }
+
+    if (textPtr && textPtr->startMarker != textPtr->sharedTextPtr->startMarker) {
+	int lineNo1 = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, NULL, nodePtr->lastPtr, NULL);
+	int lineNo2 = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, NULL, startLinePtr, NULL);
+
+	if (lineNo1 <= lineNo2) {
+	    /*
+	     * We've found a node before text start, so return text start.
+	     */
+	    return startLinePtr;
+	}
+    }
+
+    /*
+     * Final search of logical line.
+     */
+
+    linePtr = nodePtr->lastPtr;
+    while (!linePtr->logicalLine && linePtr != startLinePtr) {
+	linePtr = linePtr->prevPtr;
+    }
+    return linePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeNextLogicalLine --
+ *
+ *	Given a line, this function is searching in the B-Tree for the
+ *	next logical line, which don't has a predecessing line with
+ *	elided newline. If the search reaches the end of the text, then
+ *	the last line will be returned, even if it's not a logical line
+ *	(the latter can only happen in peers with restricted ranges).
+ *
+ * Results:
+ *	The return value is the next logical line, in most cases this
+ *	will be simply the next line.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static const Node *
+NextLogicalNode(
+    const Node *nodePtr)
+{
+    while (nodePtr) {
+	const Node *startNodePtr = nodePtr;
+
+	for (nodePtr = nodePtr->nextPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+	    if (nodePtr->numLogicalLines > 0) {
+		while (nodePtr->level > 0) {
+		    for (nodePtr = nodePtr->childPtr; nodePtr; nodePtr = nodePtr->nextPtr) {
+			if (nodePtr->numLogicalLines > 0) {
+			    return nodePtr;
+			}
+		    }
+		}
+		return nodePtr;
+	    }
+	}
+
+	nodePtr = startNodePtr->parentPtr;
+    }
+
+    return NULL;
+}
+
+TkTextLine *
+TkBTreeNextLogicalLine(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr,	/* can be NULL */
+    TkTextLine *linePtr)
+{
+    const Node *nodePtr;
+    TkTextLine *endLinePtr;
+
+    assert(linePtr);
+    assert(linePtr->nextPtr);
+    assert(linePtr != GetLastLine(sharedTextPtr, textPtr));
+
+    if (linePtr->nextPtr->logicalLine) {
+	return linePtr->nextPtr;
+    }
+
+    /*
+     * At first, search for logical line in current node.
+     */
+
+    nodePtr = linePtr->parentPtr;
+    linePtr = linePtr->nextPtr;
+    endLinePtr = GetLastLine(sharedTextPtr, textPtr);
+
+    while (linePtr && linePtr->parentPtr == nodePtr) {
+	if (linePtr->logicalLine || linePtr == endLinePtr) {
+	    return linePtr;
+	}
+	linePtr = linePtr->nextPtr;
+    }
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for next level-0
+     * node which contains the logical line.
+     */
+
+    if (!(nodePtr = NextLogicalNode(nodePtr))) {
+	return endLinePtr;
+    }
+
+    if (textPtr && textPtr->startMarker != textPtr->sharedTextPtr->startMarker) {
+	int lineNo1 = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, NULL, nodePtr->linePtr, NULL);
+	int lineNo2 = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, NULL, endLinePtr, NULL);
+
+	if (lineNo1 >= lineNo2) {
+	    /*
+	     * We've found a node after text end, so return text end.
+	     */
+	    return endLinePtr;
+	}
+    }
+
+    /*
+     * Final search of logical line.
+     */
+
+    linePtr = nodePtr->linePtr;
+    while (!linePtr->logicalLine && linePtr != endLinePtr) {
+	linePtr = linePtr->nextPtr;
+    }
+    return linePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeNextDisplayLine --
+ *
+ *	Given a logical line, and a display line number belonging to
+ *	this logical line, find next display line 'offset' display lines
+ *	ahead.
+ *
+ * Results:
+ *	Returns the logcial line of the requested display line, and stores
+ *	the display line number in 'dispLineNo'.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextLine *
+GetLastDisplayLine(
+    TkText *textPtr,
+    int *displayLineNo)
+{
+    TkTextLine *linePtr;
+
+    linePtr = textPtr->endMarker->sectionPtr->linePtr;
+    linePtr = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+    *displayLineNo = GetDisplayLines(linePtr, textPtr->pixelReference);
+    return linePtr;
+}
+
+TkTextLine *
+TkBTreeNextDisplayLine(
+    TkText *textPtr,		/* Information about text widget. */
+    TkTextLine *linePtr,	/* Start at this logical line. */
+    int *displayLineNo,		/* IN: Start at this display line number in given logical line.
+    				 * OUT: Store display line number of requested display line. */
+    unsigned offset)		/* Offset to requested display line. */
+{
+    const Node *nodePtr;
+    const Node *parentPtr;
+    int lineNo, numLines;
+    unsigned numDispLines;
+    unsigned ref;
+
+    assert(textPtr);
+    assert(linePtr->logicalLine || linePtr == TkBTreeGetStartLine(textPtr));
+    assert(*displayLineNo >= 0);
+    assert(*displayLineNo < GetDisplayLines(linePtr, textPtr->pixelReference));
+
+    if (offset == 0) {
+	return linePtr;
+    }
+
+    ref = textPtr->pixelReference;
+    nodePtr = linePtr->parentPtr;
+    parentPtr = nodePtr->parentPtr;
+    offset += *displayLineNo;
+
+    if (linePtr != nodePtr->linePtr || !parentPtr || HasLeftNode(nodePtr)) {
+	TkTextLine *lastPtr;
+
+	/*
+	 * At first, search for display line in current node.
+	 */
+
+	lastPtr = nodePtr->lastPtr->nextPtr;
+
+	while (linePtr != lastPtr) {
+	    numDispLines = GetDisplayLines(linePtr, ref);
+	    if (numDispLines > offset) {
+		assert(linePtr->logicalLine);
+		*displayLineNo = offset;
+		return linePtr;
+	    }
+	    offset -= numDispLines;
+	    if (!(linePtr = TkBTreeNextLine(textPtr, linePtr))) {
+		return GetLastDisplayLine(textPtr, displayLineNo);
+	    }
+	}
+
+	nodePtr = nodePtr->nextPtr;
+    }
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for next level-0
+     * node which contains the display line.
+     */
+
+    lineNo = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, NULL, linePtr, NULL);
+    numLines = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, NULL, TkBTreeGetLastLine(textPtr), NULL);
+
+    while (parentPtr) {
+	if (!nodePtr || (!HasLeftNode(nodePtr) && offset >= parentPtr->pixelInfo[ref].numDispLines)) {
+	    offset -= parentPtr->pixelInfo[ref].numDispLines;
+	    nodePtr = parentPtr->nextPtr;
+	    parentPtr = parentPtr->parentPtr;
+	} else {
+	    while (nodePtr) {
+		numDispLines = nodePtr->pixelInfo[ref].numDispLines;
+		if (offset < numDispLines) {
+		    if (nodePtr->level > 0) {
+			nodePtr = nodePtr->childPtr;
+			continue;
+		    }
+		    /*
+		     * We've found the right node, now search for the line.
+		     */
+		    linePtr = nodePtr->linePtr;
+		    while (true) {
+			numDispLines = GetDisplayLines(linePtr, ref);
+			if (offset < numDispLines) {
+			    *displayLineNo = offset;
+			    assert(linePtr->logicalLine);
+			    return linePtr;
+			}
+			offset -= numDispLines;
+			if (!(linePtr = TkBTreeNextLine(textPtr, linePtr))) {
+			    return GetLastDisplayLine(textPtr, displayLineNo);
+			}
+		    }
+		}
+		if ((lineNo += nodePtr->numLines) >= numLines) {
+		    parentPtr = NULL;
+		    break;
+		}
+		offset -= numDispLines;
+		nodePtr = nodePtr->nextPtr;
+	    }
+	}
+    }
+
+    return GetLastDisplayLine(textPtr, displayLineNo);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreePrevDisplayLine --
+ *
+ *	Given a logical line, and a display line number belonging to
+ *	this logical line, find previous display line 'offset' display lines
+ *	back.
+ *
+ * Results:
+ *	Returns the logcial line of the requested display line, and stores
+ *	the display line number in 'dispLineNo'.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextLine *
+GetFirstDisplayLine(
+    TkText *textPtr,
+    int *displayLineNo)
+{
+    *displayLineNo = 0;
+    return textPtr->startMarker->sectionPtr->linePtr;
+}
+
+TkTextLine *
+TkBTreePrevDisplayLine(
+    TkText *textPtr,		/* Information about text widget. */
+    TkTextLine *linePtr,	/* Start at this logical line. */
+    int *displayLineNo,		/* IN: Start at this display line number in given logical line.
+    				 * OUT: Store display line number of requested display line. */
+    unsigned offset)		/* Offset to requested display line. */
+{
+    const Node *nodeStack[MAX_CHILDREN];
+    const Node *nodePtr;
+    const Node *parentPtr;
+    const Node *nPtr;
+    unsigned numDispLines;
+    unsigned ref;
+    unsigned idx;
+    int lineNo;
+
+    assert(textPtr);
+    assert(linePtr->logicalLine || linePtr == TkBTreeGetStartLine(textPtr));
+    assert(*displayLineNo >= 0);
+    assert(*displayLineNo < GetDisplayLines(linePtr, textPtr->pixelReference));
+
+    if (offset == 0) {
+	return linePtr;
+    }
+
+    ref = textPtr->pixelReference;
+    nodePtr = linePtr->parentPtr;
+    parentPtr = nodePtr->parentPtr;
+    numDispLines = GetDisplayLines(linePtr, ref);
+    offset += numDispLines - *displayLineNo - 1;
+
+    if (linePtr != nodePtr->lastPtr || !parentPtr || nodePtr->nextPtr) {
+	TkTextLine *lastPtr;
+
+	/*
+	 * At first, search for display line in current node.
+	 */
+
+	lastPtr = nodePtr->linePtr->prevPtr;
+
+	while (linePtr != lastPtr) {
+	    numDispLines = GetDisplayLines(linePtr, ref);
+	    if (offset < numDispLines) {
+		assert(linePtr->logicalLine);
+		*displayLineNo = numDispLines - offset - 1;
+		return linePtr;
+	    }
+	    offset -= numDispLines;
+	    if (!(linePtr = TkBTreePrevLine(textPtr, linePtr))) {
+		return GetFirstDisplayLine(textPtr, displayLineNo);
+	    }
+	}
+    } else {
+	nodePtr = nodePtr->nextPtr;
+    }
+
+    for (nPtr = parentPtr->childPtr, idx = 0; nPtr != nodePtr; nPtr = nPtr->nextPtr) {
+	nodeStack[idx++] = nPtr;
+    }
+    nodePtr = idx ? nodeStack[--idx] : NULL;
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for next level-0
+     * node which contains the display line.
+     */
+
+    lineNo = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, NULL, linePtr, NULL);
+
+    while (parentPtr) {
+	if (!nodePtr || (!nodePtr->nextPtr && offset >= parentPtr->pixelInfo[ref].numDispLines)) {
+	    nodePtr = parentPtr;
+	    if ((parentPtr = parentPtr->parentPtr)) {
+		for (nPtr = parentPtr->childPtr, idx = 0; nPtr != nodePtr; nPtr = nPtr->nextPtr) {
+		    nodeStack[idx++] = nPtr;
+		}
+		nodePtr = idx ? nodeStack[--idx] : NULL;
+	    }
+	} else {
+	    while (nodePtr) {
+		numDispLines = nodePtr->pixelInfo[ref].numDispLines;
+		if (offset < numDispLines) {
+		    if (nodePtr->level > 0) {
+			parentPtr = nodePtr;
+			idx = 0;
+			for (nPtr = nodePtr->childPtr; nPtr; nPtr = nPtr->nextPtr) {
+			    nodeStack[idx++] = nPtr;
+			}
+			nodePtr = idx ? nodeStack[--idx] : NULL;
+			continue;
+		    }
+		    /*
+		     * We've found the right node, now search for the line.
+		     */
+		    linePtr = nodePtr->lastPtr;
+		    while (true) {
+			numDispLines = GetDisplayLines(linePtr, ref);
+			if (offset < numDispLines) {
+			    assert(linePtr->logicalLine);
+			    *displayLineNo = numDispLines - offset - 1;
+			    return linePtr;
+			}
+			offset -= numDispLines;
+			if (!(linePtr = TkBTreePrevLine(textPtr, linePtr))) {
+			    return GetFirstDisplayLine(textPtr, displayLineNo);
+			}
+		    }
+		}
+		if ((lineNo -= nodePtr->numLines) < 0) {
+		    parentPtr = NULL;
+		    break;
+		}
+		offset -= numDispLines;
+		nodePtr = idx ? nodeStack[--idx] : NULL;
+	    }
+	}
+    }
+
+    return GetFirstDisplayLine(textPtr, displayLineNo);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeFindStartOfElidedRange --
+ *
+ *	Given an elided segment, this function is searching for the
+ *	first segment which is spanning the range containing the
+ *	given segment. Normally this is a branch segment, but in
+ *	case of restricted peers it may be a start marker.
+ *
+ * Results:
+ *	The return value is a corresponding branch segment (or the
+ *	start marker of this peer).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextSegment *
+SearchBranchInLine(
+    TkTextSegment *segPtr,
+    TkTextSegment *startMarker)
+{
+    TkTextSection *sectionPtr = segPtr->sectionPtr;
+    TkTextSection *startSectionPtr;
+
+    /*
+     * Note that a branch is always at the end of a section.
+     */
+
+    while (segPtr->nextPtr && segPtr->size == 0 && segPtr->nextPtr->sectionPtr == sectionPtr) {
+	segPtr = segPtr->nextPtr;
+    }
+
+    if (segPtr->typePtr == &tkTextBranchType) {
+	return segPtr;
+    }
+
+    startSectionPtr = startMarker ? startMarker->sectionPtr : NULL;
+
+    if (sectionPtr == startSectionPtr) {
+	return startMarker;
+    }
+
+    for ( ; sectionPtr->prevPtr; sectionPtr = sectionPtr->prevPtr) {
+	if (sectionPtr->segPtr->prevPtr->typePtr == &tkTextBranchType) {
+	    return sectionPtr->segPtr->prevPtr;
+	}
+	if (sectionPtr == startSectionPtr) {
+	    return startMarker;
+	}
+    }
+
+    return NULL;
+}
+
+static const Node *
+FindNodeWithBranch(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr,		/* can be NULL */
+    const Node *nodePtr)
+{
+    const Node *parentPtr;
+
+    assert(nodePtr);
+
+    for (parentPtr = nodePtr->parentPtr; parentPtr; parentPtr = parentPtr->parentPtr) {
+	const Node *resultPtr = NULL;
+	const Node *childPtr;
+
+	if (parentPtr->numBranches > 0) {
+	    for (childPtr = parentPtr->childPtr; childPtr != nodePtr; childPtr = childPtr->nextPtr) {
+		if (childPtr->numBranches > 0) {
+		    resultPtr = childPtr;
+		}
+	    }
+	    if (resultPtr) {
+		while (resultPtr->level > 0) {
+		    for (childPtr = resultPtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+			if (childPtr->numBranches > 0) {
+			    resultPtr = childPtr;
+			}
+		    }
+		}
+		return resultPtr;
+	    }
+	}
+	nodePtr = parentPtr;
+    }
+
+    return TkBTreeGetRoot(sharedTextPtr->tree)->linePtr->parentPtr;
+}
+
+static TkTextSegment *
+FindBranchSegment(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr,		/* can be NULL */
+    const TkTextSegment *segPtr,
+    TkTextSegment *startMarker)
+{
+    const Node *nodePtr;
+    TkTextLine *firstLinePtr;
+    TkTextLine *linePtr;
+
+    assert(segPtr);
+    assert(segPtr->tagInfoPtr);
+    assert(TkBTreeHaveElidedSegments(sharedTextPtr));
+    assert(SegmentIsElided(sharedTextPtr, segPtr, textPtr));
+
+    linePtr = segPtr->sectionPtr->linePtr;
+    nodePtr = linePtr->parentPtr;
+    firstLinePtr = startMarker ? GetStartLine(sharedTextPtr, textPtr) : NULL;
+
+    /*
+     * At first, search for branch in current line.
+     */
+
+    if (linePtr->numBranches > 0) {
+	TkTextSegment *branchPtr = SearchBranchInLine((TkTextSegment *) segPtr, startMarker);
+
+	if (branchPtr) {
+	    return branchPtr;
+	}
+    }
+
+    /*
+     * At second, search for line with a branch in current node.
+     */
+
+    linePtr = linePtr->prevPtr;
+    while (linePtr && linePtr->parentPtr == nodePtr) {
+	TkTextLine *prevPtr = linePtr->prevPtr;
+
+	if (linePtr->numBranches > 0) {
+	    return SearchBranchInLine(linePtr->lastPtr, startMarker);
+	}
+	if (prevPtr == firstLinePtr) {
+	    return startMarker;
+	}
+	linePtr = prevPtr;
+    }
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for next level-0
+     * node which contains a branch.
+     */
+
+    nodePtr = FindNodeWithBranch(sharedTextPtr, textPtr, nodePtr);
+
+    if (startMarker && startMarker != sharedTextPtr->startMarker) {
+	int lineNo1 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, nodePtr->lastPtr, NULL);
+	int lineNo2 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, startMarker->sectionPtr->linePtr, NULL);
+
+	if (lineNo1 <= lineNo2) {
+	    /*
+	     * We've found a node before text start, so return text start.
+	     */
+	    return startMarker;
+	}
+    }
+
+    /*
+     * Final search of branch segment.
+     */
+
+    linePtr = nodePtr->lastPtr;
+    while (linePtr->numBranches == 0) {
+	if (linePtr == firstLinePtr) {
+	    return startMarker;
+	}
+	linePtr = linePtr->prevPtr;
+	assert(linePtr);
+    }
+
+    return SearchBranchInLine(linePtr->lastPtr, startMarker);
+}
+
+TkTextSegment *
+TkBTreeFindStartOfElidedRange(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr,		/* can be NULL */
+    const TkTextSegment *segPtr)
+{
+    assert(segPtr);
+    assert(TkBTreeHaveElidedSegments(sharedTextPtr));
+    assert(SegmentIsElided(sharedTextPtr, segPtr, textPtr));
+
+    return FindBranchSegment(sharedTextPtr, textPtr, segPtr,
+	    textPtr ? textPtr->startMarker : sharedTextPtr->startMarker);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeFindEndOfElidedRange --
+ *
+ *	Given an elided segment, this function is searching for the
+ *	last segment which is spanning the range containing the
+ *	given segment. Normally this is a link segment, but in
+ *	case of restricted peers it may be an end marker.
+ *
+ * Results:
+ *	The return value is a corresponding link segment (or the end
+ *	marker of this peer).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextSegment *
+SearchLinkInLine(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr,		/* can be NULL */
+    TkTextSegment *segPtr)
+{
+    TkTextSegment *endMarker = textPtr ? textPtr->endMarker : sharedTextPtr->endMarker;
+    TkTextSection *sectionPtr = segPtr->sectionPtr;
+    TkTextSection *endSectionPtr;
+
+    assert(endMarker);
+
+    /*
+     * Note that a link is always at the start of a section.
+     */
+
+    if (segPtr->typePtr == &tkTextLinkType) {
+	return segPtr;
+    }
+
+    endSectionPtr = endMarker->sectionPtr;
+
+    if (sectionPtr == endSectionPtr) {
+	return endMarker;
+    }
+
+    for (sectionPtr = sectionPtr->nextPtr; sectionPtr; sectionPtr = sectionPtr->nextPtr) {
+	if (sectionPtr->segPtr->typePtr == &tkTextLinkType) {
+	    return sectionPtr->segPtr;
+	}
+	if (sectionPtr == endSectionPtr) {
+	    return endMarker;
+	}
+    }
+
+    return NULL;
+}
+
+TkTextSegment *
+TkBTreeFindEndOfElidedRange(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr,		/* can be NULL */
+    const TkTextSegment *segPtr)
+{
+    TkTextSegment *branchPtr;
+    TkTextSegment *linkPtr;
+
+    assert(segPtr);
+    assert(SegmentIsElided(sharedTextPtr, segPtr, textPtr));
+
+    if (segPtr->sectionPtr->linePtr->numLinks > 0) {
+	if ((linkPtr = SearchLinkInLine(sharedTextPtr, textPtr, (TkTextSegment *) segPtr))) {
+	    return linkPtr;
+	}
+    }
+
+    branchPtr = FindBranchSegment(sharedTextPtr, textPtr, segPtr, NULL);
+
+    assert(branchPtr);
+    assert(branchPtr->typePtr == &tkTextBranchType);
+
+    linkPtr = branchPtr->body.branch.nextPtr;
+
+    if (textPtr && textPtr->endMarker != sharedTextPtr->endMarker) {
+	TkTextLine *lastLinePtr = textPtr->endMarker->sectionPtr->linePtr;
+	TkTextLine *linePtr = linkPtr->sectionPtr->linePtr;
+	int lineNo1, lineNo2;
+
+	if (linePtr == lastLinePtr) {
+	    return SearchLinkInLine(sharedTextPtr, textPtr, linePtr->segPtr);
+	}
+
+	lineNo1 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, linkPtr->sectionPtr->linePtr, NULL);
+	lineNo2 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, lastLinePtr, NULL);
+
+	if (lineNo1 > lineNo2) {
+	    /* we've found a node after text end, so return text end */
+	    return textPtr->endMarker;
+	}
+    }
+
+    return linkPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeSize --
+ *
+ *	This function returns the byte size over all lines in given client.
+ *	If the client is NULL then count over all lines in the B-Tree.
+ *
+ * Results:
+ *	The return value is either the total number of bytes in given client,
+ *	or the total number of bytes in the B-Tree if the client is NULL.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkBTreeSize(
+    const TkTextBTree tree,	/* The B-tree. */
+    const TkText *textPtr)	/* Relative to this client of the B-tree, can be NULL. */
+{
+    assert(tree);
+
+    if (!textPtr) {
+	return TkBTreeGetRoot(tree)->size - 1;
+    }
+    return TkBTreeCountSize(tree, textPtr, TkBTreeGetStartLine(textPtr), TkBTreeGetLastLine(textPtr));
+
+}
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeCountSize --
+ *
+ *	This function returns the byte size over all lines in given range.
+ *
+ * Results:
+ *	The return value is the total number of bytes in given line range.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static unsigned
+CountSize(
+    const Node *nodePtr,
+    unsigned lineNo,
+    unsigned firstLineNo,
+    unsigned lastLineNo)
+{
+    unsigned endLineNo = lineNo + nodePtr->numLines - 1;
+    unsigned size;
+
+    if (firstLineNo <= lineNo && endLineNo <= lastLineNo) {
+	return nodePtr->size;
+    }
+
+    if (endLineNo < firstLineNo || lastLineNo < lineNo) {
+	return 0;
+    }
+
+    size = 0;
+
+    if (nodePtr->level == 0) {
+	const TkTextLine *linePtr = nodePtr->linePtr;
+	const TkTextLine *lastPtr = nodePtr->lastPtr->nextPtr;
+
+	endLineNo = MIN(endLineNo, lastLineNo);
+
+	for ( ; lineNo < firstLineNo; ++lineNo, linePtr = linePtr->nextPtr) {
+	    assert(linePtr);
+	}
+	for ( ; lineNo <= endLineNo && linePtr != lastPtr; ++lineNo, linePtr = linePtr->nextPtr) {
+	    size += linePtr->size;
+	}
+    } else {
+	const Node *childPtr;
+
+	for (childPtr = nodePtr->childPtr; childPtr; childPtr = childPtr->nextPtr) {
+	    size += CountSize(childPtr, lineNo, firstLineNo, lastLineNo);
+	    lineNo += childPtr->numLines;
+	}
+    }
+
+    return size;
+}
+
+unsigned
+TkBTreeCountSize(
+    const TkTextBTree tree,
+    const TkText *textPtr,	/* Relative to this client, can be NULL. */
+    const TkTextLine *linePtr1,	/* Start counting at this line. */
+    const TkTextLine *linePtr2)	/* Stop counting at this line (don't count this line). */
+{
+    const BTree *treePtr = (const BTree *) tree;
+    unsigned numBytes;
+
+    if (linePtr1 == linePtr2) {
+	return 0;
+    }
+
+    assert(tree);
+    assert(linePtr1);
+    assert(linePtr2);
+    assert(TkBTreeLinesTo(tree, NULL, linePtr1, NULL) <= TkBTreeLinesTo(tree, NULL, linePtr2, NULL));
+
+    if (linePtr1 == treePtr->rootPtr->linePtr && linePtr2 == treePtr->rootPtr->lastPtr) {
+	numBytes = treePtr->rootPtr->size - 1;
+    } else {
+	unsigned firstLineNo = TkBTreeLinesTo(tree, NULL, linePtr1, NULL);
+	unsigned lastLineNo = TkBTreeLinesTo(tree, NULL, linePtr2, NULL) - 1;
+
+	numBytes = CountSize(treePtr->rootPtr, 0, firstLineNo, lastLineNo);
+    }
+
+    if (textPtr) {
+	const TkSharedText *sharedTextPtr = treePtr->sharedTextPtr;
+
+	if (textPtr->startMarker != sharedTextPtr->startMarker) {
+	    if (linePtr1 == textPtr->startMarker->sectionPtr->linePtr) {
+		assert(TkTextSegToIndex(textPtr->startMarker) <= numBytes);
+		numBytes -= TkTextSegToIndex(textPtr->startMarker);
+	    }
+	}
+	if (textPtr->endMarker != sharedTextPtr->endMarker) {
+	    if (!SegIsAtStartOfLine(textPtr->endMarker)) {
+		const TkTextLine *linePtr = textPtr->endMarker->sectionPtr->linePtr;
+		assert(linePtr->size - TkTextSegToIndex(textPtr->endMarker) - 1 <= numBytes);
+		numBytes -= linePtr->size - TkTextSegToIndex(textPtr->endMarker) - 1;
+	    }
+	}
+    }
+
+    return numBytes;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeMoveForward --
+ *
+ *	Given an index for a text widget, this function creates a new index
+ *	that points 'byteCount' bytes ahead of the source index.
+ *
+ * Results:
+ *	'dstPtr' is modified to refer to the character 'byteCount' bytes after
+ *	'srcPtr', or to the last character in the TkText if there aren't 'byteCount'
+ *	bytes left.
+ *
+ *	In this latter case, the function returns 'false' to indicate that not all
+ *	of 'byteCount' could be used.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkBTreeMoveForward(
+    TkTextIndex *indexPtr,
+    unsigned byteCount)
+{
+    TkTextLine *linePtr;
+    const Node *nodePtr;
+    const Node *parentPtr;
+    int byteIndex;
+
+    if (byteCount == 0) {
+	return true;
+    }
+
+    byteIndex = byteCount + TkTextIndexGetByteIndex(indexPtr);
+    linePtr = TkTextIndexGetLine(indexPtr);
+    nodePtr = linePtr->parentPtr;
+    parentPtr = nodePtr->parentPtr;
+
+    if (linePtr != nodePtr->linePtr || !parentPtr || HasLeftNode(nodePtr)) {
+	TkTextLine *lastPtr;
+
+	/*
+	 * At first, search for byte offset in current node.
+	 */
+
+	lastPtr = nodePtr->lastPtr->nextPtr;
+
+	while (linePtr != lastPtr) {
+	    if (byteIndex < linePtr->size) {
+		TkTextIndexSetByteIndex2(indexPtr, linePtr, byteIndex);
+		return TkTextIndexRestrictToEndRange(indexPtr) <= 0;
+	    }
+	    byteIndex -= linePtr->size;
+	    if (!(linePtr = TkBTreeNextLine(indexPtr->textPtr, linePtr))) {
+		TkTextIndexSetupToEndOfText(indexPtr, indexPtr->textPtr, indexPtr->tree);
+		return false;
+	    }
+	}
+
+	nodePtr = nodePtr->nextPtr;
+    }
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for next level-0
+     * node which contains the byte offset.
+     */
+
+    while (parentPtr) {
+	if (!nodePtr || (!HasLeftNode(nodePtr) && byteIndex >= parentPtr->size)) {
+	    nodePtr = parentPtr->nextPtr;
+	    parentPtr = parentPtr->parentPtr;
+	} else {
+	    while (nodePtr) {
+		if (byteIndex < nodePtr->size) {
+		    if (nodePtr->level > 0) {
+			nodePtr = nodePtr->childPtr;
+			continue;
+		    }
+		    /*
+		     * We've found the right node, now search for the line.
+		     */
+		    linePtr = nodePtr->linePtr;
+		    while (true) {
+			if (byteIndex < linePtr->size) {
+			    TkTextIndexSetByteIndex2(indexPtr, linePtr, byteIndex);
+			    return TkTextIndexRestrictToEndRange(indexPtr) <= 0;
+			}
+			byteIndex -= linePtr->size;
+			if (!(linePtr = TkBTreeNextLine(indexPtr->textPtr, linePtr))) {
+			    TkTextIndexSetupToEndOfText(indexPtr, indexPtr->textPtr, indexPtr->tree);
+			    return false;
+			}
+		    }
+		}
+		byteIndex -= nodePtr->size;
+		nodePtr = nodePtr->nextPtr;
+	    }
+	}
+    }
+
+    TkTextIndexSetupToEndOfText(indexPtr, indexPtr->textPtr, indexPtr->tree);
+    return false;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeMoveBackward --
+ *
+ *	Given an index for a text widget, this function creates a new index
+ *	that points 'byteCount' bytes earlier of the source index.
+ *
+ * Results:
+ *	'dstPtr' is modified to refer to the character 'byteCount' bytes before
+ *	'srcPtr', or to the first character in the TkText if there aren't 'byteCount'
+ *	bytes earlier.
+ *
+ *	In this latter case, the function returns true to indicate that not all
+ *	of 'byteCount' could be used.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkBTreeMoveBackward(
+    TkTextIndex *indexPtr,
+    unsigned byteCount)
+{
+    const Node *nodeStack[MAX_CHILDREN];
+    const Node *nodePtr;
+    const Node *parentPtr;
+    const Node *nPtr;
+    TkTextLine *linePtr;
+    unsigned idx;
+    int byteIndex;
+
+    if (byteCount == 0) {
+	return true;
+    }
+
+    linePtr = TkTextIndexGetLine(indexPtr);
+    nodePtr = linePtr->parentPtr;
+    parentPtr = nodePtr->parentPtr;
+    byteIndex = byteCount + (linePtr->size - TkTextIndexGetByteIndex(indexPtr));
+
+    if (linePtr != nodePtr->lastPtr || !parentPtr || nodePtr->nextPtr) {
+	TkTextLine *lastPtr;
+
+	/*
+	 * At first, search for byte offset in current node.
+	 */
+
+	lastPtr = nodePtr->linePtr->prevPtr;
+
+	while (linePtr != lastPtr) {
+	    if ((byteIndex -= linePtr->size) <= 0) {
+		TkTextIndexSetByteIndex2(indexPtr, linePtr, -byteIndex);
+		return TkTextIndexRestrictToStartRange(indexPtr) >= 0;
+	    }
+	    if (!(linePtr = TkBTreePrevLine(indexPtr->textPtr, linePtr))) {
+		TkTextIndexSetupToStartOfText(indexPtr, indexPtr->textPtr, indexPtr->tree);
+		return false;
+	    }
+	}
+    } else {
+	nodePtr = NULL;
+    }
+
+    /*
+     * We couldn't find a line, so search inside B-Tree for next level-0
+     * node which contains the byte offset.
+     */
+
+    for (nPtr = parentPtr->childPtr, idx = 0; nPtr != nodePtr; nPtr = nPtr->nextPtr) {
+	nodeStack[idx++] = nPtr;
+    }
+    nodePtr = idx ? nodeStack[--idx] : NULL;
+
+    while (parentPtr) {
+	if (!nodePtr || (!nodePtr->nextPtr && byteIndex >= parentPtr->size)) {
+	    nodePtr = parentPtr;
+	    if ((parentPtr = parentPtr->parentPtr)) {
+		for (nPtr = parentPtr->childPtr, idx = 0; nPtr != nodePtr; nPtr = nPtr->nextPtr) {
+		    nodeStack[idx++] = nPtr;
+		}
+		nodePtr = idx ? nodeStack[--idx] : NULL;
+	    }
+	} else {
+	    while (nodePtr) {
+		if (byteIndex < nodePtr->size) {
+		    if (nodePtr->level > 0) {
+			parentPtr = nodePtr;
+			idx = 0;
+			for (nPtr = nodePtr->childPtr; nPtr; nPtr = nPtr->nextPtr) {
+			    nodeStack[idx++] = nPtr;
+			}
+			nodePtr = idx ? nodeStack[--idx] : NULL;
+			continue;
+		    }
+		    /*
+		     * We've found the right node, now search for the line.
+		     */
+		    linePtr = nodePtr->lastPtr;
+		    while (true) {
+			if ((byteIndex -= linePtr->size) <= 0) {
+			    TkTextIndexSetByteIndex2(indexPtr, linePtr, -byteIndex);
+			    return TkTextIndexRestrictToStartRange(indexPtr) >= 0;
+			}
+			if (!(linePtr = TkBTreePrevLine(indexPtr->textPtr, linePtr))) {
+			    TkTextIndexSetupToStartOfText(indexPtr, indexPtr->textPtr, indexPtr->tree);
+			    return false;
+			}
+		    }
+		}
+		byteIndex -= nodePtr->size;
+		nodePtr = idx ? nodeStack[--idx] : NULL;
+	    }
+	}
+    }
+
+    TkTextIndexSetupToStartOfText(indexPtr, indexPtr->textPtr, indexPtr->tree);
+    return false;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeRootTagInfo --
+ *
+ *	This function returns the tag information of root node.
+ *
+ * Results:
+ *	The tag information of root node.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+const TkTextTagSet *
+TkBTreeRootTagInfo(
+    const TkTextBTree tree)
+{
+    return ((BTree *) tree)->rootPtr->tagonPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeLinesPerNode --
+ *
+ *	This function returns the minimal number of lines per node.
+ *
+ * Results:
+ *	The minimal number of lines per node.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkBTreeLinesPerNode(
+    const TkTextBTree tree)
+{
+    return MIN_CHILDREN;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeChildNumber --
+ *
+ *	This function returns the number of level-0 node which contains the
+ *	given line. If 'depth' is given then also the depth of this node
+ *	will be returned (in 'depth').
+ *
+ * Results:
+ *	The number of the child for given line, and also the depth of this
+ *	child if 'depth' is given.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkBTreeChildNumber(
+    const TkTextBTree tree,
+    const TkTextLine *linePtr,
+    unsigned *depth)
+{
+    const Node *childPtr;
+    const Node *nodePtr;
+    unsigned number = 0;
+
+    assert(linePtr);
+
+    nodePtr = linePtr->parentPtr;
+    childPtr = nodePtr->parentPtr->childPtr;
+
+    for ( ; childPtr != nodePtr; childPtr = childPtr->nextPtr) {
+	number += 1;
+    }
+
+    if (depth) {
+	*depth = 0;
+
+	while (nodePtr) {
+	    nodePtr = nodePtr->parentPtr;
+	    *depth += 1;
+	}
+    }
+
+    return number;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeNumPixels --
+ *
+ *	This function returns a count of the number of pixels of text present
+ *	in a given widget's B-tree representation.
+ *
+ * Results:
+ *	The return value is a count of the number of usable pixels in tree
+ *	(since the dummy line used to mark the end of the B-tree is maintained
+ *	with zero height, as are any lines that are before or after the
+ *	'-startindex -endindex' range of the text widget in question, the number
+ *	stored at the root is the number we want).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkBTreeNumPixels(
+    const TkText *textPtr)	/* Relative to this client of the B-tree. */
+{
+    assert(textPtr);
+    assert(textPtr->pixelReference != -1);
+
+    return TkBTreeGetRoot(textPtr->sharedTextPtr->tree)->pixelInfo[textPtr->pixelReference].pixels;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CleanupSplitPoint --
+ *
+ *	This function merges adjacent character segments into a single
+ *	character segment, if possible, and removes the protection flag.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Storage for the segments may be allocated and freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+CleanupSplitPoint(
+    TkTextSegment *segPtr,
+    TkSharedText *sharedTextPtr)
+{
+    if (!segPtr || !segPtr->protectionFlag) {
+	return;
+    }
+
+    segPtr->protectionFlag = false;
+
+    if (segPtr->typePtr == &tkTextCharType) {
+	if (segPtr->prevPtr && segPtr->prevPtr->typePtr == &tkTextCharType) {
+	    TkTextSegment *prevPtr = segPtr->prevPtr;
+	    if ((segPtr = CleanupCharSegments(sharedTextPtr, prevPtr)) == prevPtr) {
+		segPtr = segPtr->nextPtr;
+	    }
+	}
+	if (segPtr->nextPtr && segPtr->nextPtr->typePtr == &tkTextCharType) {
+	    CleanupCharSegments(sharedTextPtr, segPtr);
+	}
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * JoinCharSegments --
+ *
+ *	This function merges adjacent character segments into a single
+ *	character segment.
+ *
+ *	This functions assumes that the successor of given segment is
+ *	a joinable char segment.
+ *
+ * Results:
+ *	The return value is a pointer to the first segment in the (new) list
+ *	of segments that used to start with segPtr.
+ *
+ * Side effects:
+ *	Storage for the segments may be allocated and freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextSegment *
+JoinCharSegments(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    TkTextSegment *segPtr)		/* Pointer to first of two adjacent segments to join. */
+{
+    TkTextSegment *nextPtr, *newPtr;
+
+    assert(segPtr);
+    assert(segPtr->typePtr == &tkTextCharType);
+    assert(!segPtr->protectionFlag);
+    assert(segPtr->nextPtr);
+    assert(!segPtr->nextPtr->protectionFlag);
+    assert(segPtr->nextPtr->typePtr == &tkTextCharType);
+    assert(TkTextTagSetIsEqual(segPtr->tagInfoPtr, segPtr->nextPtr->tagInfoPtr));
+
+    nextPtr = segPtr->nextPtr;
+    newPtr = CopyCharSeg(segPtr, 0, segPtr->size, segPtr->size + nextPtr->size);
+    memcpy(newPtr->body.chars + segPtr->size, nextPtr->body.chars, nextPtr->size);
+    newPtr->nextPtr = nextPtr->nextPtr;
+    newPtr->prevPtr = segPtr->prevPtr;
+
+    if (segPtr->prevPtr) {
+	segPtr->prevPtr->nextPtr = newPtr;
+    } else {
+	segPtr->sectionPtr->linePtr->segPtr = newPtr;
+    }
+    if (nextPtr->nextPtr) {
+	nextPtr->nextPtr->prevPtr = newPtr;
+    }
+    if (segPtr->sectionPtr->segPtr == segPtr) {
+	segPtr->sectionPtr->segPtr = newPtr;
+    }
+    if (nextPtr->sectionPtr->segPtr == nextPtr) {
+	nextPtr->sectionPtr->segPtr = nextPtr->nextPtr;
+    }
+    if (newPtr->sectionPtr->linePtr->lastPtr == nextPtr) {
+	newPtr->sectionPtr->linePtr->lastPtr = newPtr;
+    }
+    nextPtr->sectionPtr->length -= 1;
+    if (segPtr->sectionPtr != nextPtr->sectionPtr) {
+	segPtr->sectionPtr->size += nextPtr->size;
+	nextPtr->sectionPtr->size -= nextPtr->size;
+	JoinSections(nextPtr->sectionPtr);
+    }
+    JoinSections(segPtr->sectionPtr);
+    TkBTreeFreeSegment(segPtr);
+    TkBTreeFreeSegment(nextPtr);
+
+    return newPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CleanupCharSegments --
+ *
+ *	This function merges adjacent character segments into a single
+ *	character segment, if possible.
+ *
+ * Results:
+ *	The return value is a pointer to the first segment in the (new) list
+ *	of segments that used to start with segPtr.
+ *
+ * Side effects:
+ *	Storage for the segments may be allocated and freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextSegment *
+CleanupCharSegments(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    TkTextSegment *segPtr)		/* Pointer to first of two adjacent segments to join. */
+{
+    TkTextSegment *nextPtr;
+
+    assert(segPtr);
+    assert(segPtr->typePtr == &tkTextCharType);
+
+    if (segPtr->protectionFlag) {
+	return segPtr;
+    }
+    nextPtr = segPtr->nextPtr;
+    if (!nextPtr
+	    || nextPtr->protectionFlag
+	    || nextPtr->typePtr != &tkTextCharType
+	    || !TkTextTagSetIsEqual(segPtr->tagInfoPtr, nextPtr->tagInfoPtr)) {
+	return segPtr;
+    }
+    return JoinCharSegments(sharedTextPtr, segPtr);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CharDeleteProc --
+ *
+ *	This function is invoked to delete a character segment.
+ *
+ * Results:
+ *	Always returns true to indicate that the segment was
+ *	(virtually) deleted.
+ *
+ * Side effects:
+ *	Storage for the segment is freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+CharDeleteProc(
+    TkTextBTree tree,
+    TkTextSegment *segPtr,	/* Segment to delete. */
+    int flags)			/* Flags controlling the deletion. */
+{
+    TkBTreeFreeSegment(segPtr);
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CharInspectProc --
+ *
+ *	This function is invoked to build the information for
+ *	"inspect".
+ *
+ * Results:
+ *	Return a TCL object containing the information for
+ *	"inspect".
+ *
+ * Side effects:
+ *	Storage is allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+CharInspectProc(
+    const TkSharedText *sharedTextPtr,
+    const TkTextSegment *segPtr)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(segPtr->typePtr->name, -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(segPtr->body.chars, segPtr->size));
+    Tcl_ListObjAppendElement(NULL, objPtr, MakeTagInfoObj(sharedTextPtr, segPtr->tagInfoPtr));
+    return objPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CharCheckProc --
+ *
+ *	This function is invoked to perform consistency checks on character
+ *	segments.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If the segment isn't inconsistent then the function panics.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+CharCheckProc(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextSegment *segPtr)	/* Segment to check. */
+{
+    /*
+     * Make sure that the segment contains the number of characters indicated
+     * by its header, and that the last segment in a line ends in a newline.
+     * Also make sure that there aren't ever two character segments with same
+     * tagging adjacent to each other: they should be merged together.
+     */
+
+    if (segPtr->size <= 0) {
+	Tcl_Panic("CharCheckProc: segment has size <= 0");
+    }
+    if (strlen(segPtr->body.chars) != (size_t) segPtr->size) {
+	Tcl_Panic("CharCheckProc: segment has wrong size");
+    }
+    if (!segPtr->nextPtr) {
+	if (segPtr->body.chars[segPtr->size - 1] != '\n') {
+	    Tcl_Panic("CharCheckProc: line doesn't end with newline");
+	}
+    } else if (segPtr->nextPtr->typePtr == &tkTextCharType
+	    && TkTextTagSetIsEqual(segPtr->tagInfoPtr, segPtr->nextPtr->tagInfoPtr)) {
+	Tcl_Panic("CharCheckProc: adjacent character segments weren't merged");
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * HyphenDeleteProc --
+ *
+ *	This function is invoked to delete hyphen segments.
+ *
+ * Results:
+ *	Returns always true to indicate that the segment has been
+ *	deleted (virtually).
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+HyphenDeleteProc(
+    TkTextBTree tree,
+    TkTextSegment *segPtr,	/* Segment to check. */
+    int flags)			/* Flags controlling the deletion. */
+{
+    TkBTreeFreeSegment(segPtr);
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * HyphenInspectProc --
+ *
+ *	This function is invoked to build the information for
+ *	"inspect".
+ *
+ * Results:
+ *	Return a TCL object containing the information for
+ *	"inspect".
+ *
+ * Side effects:
+ *	Storage is allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+HyphenInspectProc(
+    const TkSharedText *sharedTextPtr,
+    const TkTextSegment *segPtr)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(segPtr->typePtr->name, -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, MakeTagInfoObj(sharedTextPtr, segPtr->tagInfoPtr));
+    return objPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * HyphenCheckProc --
+ *
+ *	This function is invoked to perform consistency checks on hyphen
+ *	segments.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If a consistency problem is found the function panics.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+HyphenCheckProc(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextSegment *segPtr)	/* Segment to check. */
+{
+    if (segPtr->size != 1) {
+	Tcl_Panic("HyphenCheckProc: hyphen has size %d", segPtr->size);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * BranchDeleteProc --
+ *
+ *	This function is invoked to delete branch segments.
+ *
+ * Results:
+ *	Returns always true to indicate that the segment has been
+ *	deleted (virtually).
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+BranchDeleteProc(
+    TkTextBTree tree,
+    TkTextSegment *segPtr,	/* Segment to check. */
+    int flags)			/* Flags controlling the deletion. */
+{
+    if (flags & TREE_GONE) {
+	FREE_SEGMENT(segPtr);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+	return true;
+    }
+
+    if (flags & DELETE_BRANCHES) {
+	TkBTreeFreeSegment(segPtr);
+	return true;
+    }
+
+    /* Save old relationships for undo (we misuse an unused pointer). */
+    segPtr->tagInfoPtr = (TkTextTagSet *) segPtr->body.branch.nextPtr;
+    return false;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * BranchRestoreProc --
+ *
+ *	This function is called when a branch will be restored from the
+ *	undo chain.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+BranchRestoreProc(
+    TkTextSegment *segPtr)	/* Segment to reuse. */
+{
+    /* Restore old relationship. */
+    segPtr->body.branch.nextPtr = (TkTextSegment *) segPtr->tagInfoPtr;
+    assert(segPtr->body.branch.nextPtr->typePtr == &tkTextLinkType);
+    segPtr->tagInfoPtr = NULL;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * BranchInspectProc --
+ *
+ *	This function is invoked to build the information for
+ *	"inspect".
+ *
+ * Results:
+ *	Return a TCL object containing the information for
+ *	"inspect".
+ *
+ * Side effects:
+ *	Storage is allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+BranchInspectProc(
+    const TkSharedText *sharedTextPtr,
+    const TkTextSegment *segPtr)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(segPtr->typePtr->name, -1));
+    return objPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * BranchCheckProc --
+ *
+ *	This function is invoked to perform consistency checks on branch
+ *	segments.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If a consistency problem is found the function panics.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+BranchCheckProc(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextSegment *segPtr)	/* Segment to check. */
+{
+    const TkTextSegment *prevPtr, *nextPtr;
+    const TkTextLine *linePtr;
+
+    if (segPtr->size != 0) {
+	Tcl_Panic("BranchCheckProc: branch has size %d", segPtr->size);
+    }
+    if (!segPtr->nextPtr) {
+	Tcl_Panic("BranchCheckProc: branch cannot be at end of line");
+    }
+    if (segPtr->sectionPtr->nextPtr
+	    ? segPtr->sectionPtr->nextPtr->segPtr->prevPtr != segPtr
+	    : !!segPtr->nextPtr) {
+	Tcl_Panic("BranchCheckProc: branch is not at end of section");
+    }
+    if (!segPtr->body.branch.nextPtr) {
+	Tcl_Panic("BranchCheckProc: missing fork");
+    }
+    if (segPtr->nextPtr == segPtr->body.branch.nextPtr) {
+	Tcl_Panic("BranchCheckProc: bad fork");
+    }
+    if (!segPtr->body.branch.nextPtr->sectionPtr) {
+	Tcl_Panic("BranchCheckProc: connection is not linked");
+    }
+    if (segPtr->nextPtr->typePtr->group == SEG_GROUP_MARK) {
+	Tcl_Panic("BranchCheckProc: branch shouldn't be followed by marks");
+    }
+
+    assert(segPtr->body.branch.nextPtr);
+    assert(segPtr->body.branch.nextPtr->typePtr);
+
+    if (segPtr->body.branch.nextPtr->typePtr != &tkTextLinkType) {
+	Tcl_Panic("BranchCheckProc: branch is not pointing to a link");
+    }
+    if (segPtr->body.branch.nextPtr->body.link.prevPtr != segPtr) {
+	Tcl_Panic("BranchCheckProc: related link is not pointing to this branch");
+    }
+    if (segPtr->nextPtr->typePtr == &tkTextLinkType) {
+	Tcl_Panic("BranchCheckProc: elided section is empty");
+    }
+
+    linePtr = segPtr->sectionPtr->linePtr;
+    if (!(prevPtr = segPtr->prevPtr) && linePtr->prevPtr) {
+	prevPtr = linePtr->prevPtr->lastPtr;
+    }
+    while (prevPtr && !prevPtr->tagInfoPtr) {
+	if (prevPtr->typePtr->group == SEG_GROUP_BRANCH) {
+	    Tcl_Panic("BranchCheckProc: invalid branch/link structure (%s before branch)",
+		    prevPtr->typePtr->name);
+	}
+	if (!(prevPtr = prevPtr->prevPtr) && linePtr->prevPtr) {
+	    prevPtr = linePtr->prevPtr->lastPtr;
+	}
+    }
+    nextPtr = segPtr->nextPtr;
+    while (nextPtr && !nextPtr->tagInfoPtr) {
+	if (nextPtr->typePtr->group == SEG_GROUP_BRANCH) {
+	    Tcl_Panic("BranchCheckProc: invalid branch/link structure (%s after branch)",
+		    nextPtr->typePtr->name);
+	}
+	nextPtr = nextPtr->nextPtr;
+    }
+
+    if (prevPtr && SegmentIsElided(sharedTextPtr, prevPtr, NULL)) {
+	Tcl_Panic("BranchCheckProc: branch not at start of elided range");
+    }
+    if (nextPtr && !SegmentIsElided(sharedTextPtr, nextPtr, NULL)) {
+	Tcl_Panic("BranchCheckProc: misplaced branch");
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * LinkDeleteProc --
+ *
+ *	This function is invoked to delete link segments.
+ *
+ * Results:
+ *	Returns always 'true' to indicate that the segment has been
+ *	deleted (virtually).
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+LinkDeleteProc(
+    TkTextBTree tree,
+    TkTextSegment *segPtr,	/* Segment to check. */
+    int flags)			/* Flags controlling the deletion. */
+{
+    if (flags & TREE_GONE) {
+	FREE_SEGMENT(segPtr);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+	return true;
+    }
+
+    if (flags & DELETE_BRANCHES) {
+	TkBTreeFreeSegment(segPtr);
+	return true;
+    }
+
+    /* Save old relationships for undo (we have misused an unused pointer). */
+    segPtr->tagInfoPtr = (TkTextTagSet *) segPtr->body.link.prevPtr;
+    return false;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * LinkRestoreProc --
+ *
+ *	This function is called when a branch will be restored from the
+ *	undo chain.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+LinkRestoreProc(
+    TkTextSegment *segPtr)	/* Segment to reuse. */
+{
+    /* Restore old relationship (misuse of an unused pointer). */
+    segPtr->body.link.prevPtr = (TkTextSegment *) segPtr->tagInfoPtr;
+    assert(segPtr->body.link.prevPtr->typePtr == &tkTextBranchType);
+    segPtr->tagInfoPtr = NULL;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * LinkInspectProc --
+ *
+ *	This function is invoked to build the information for
+ *	"inspect".
+ *
+ * Results:
+ *	Return a TCL object containing the information for
+ *	"inspect".
+ *
+ * Side effects:
+ *	Storage is allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+LinkInspectProc(
+    const TkSharedText *sharedTextPtr,
+    const TkTextSegment *segPtr)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(segPtr->typePtr->name, -1));
+    return objPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * LinkCheckProc --
+ *
+ *	This function is invoked to perform consistency checks on link
+ *	segments.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If a consistency problem is found the function panics.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+LinkCheckProc(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextSegment *segPtr)	/* Segment to check. */
+{
+    const TkTextSegment *prevPtr, *nextPtr;
+    const TkTextLine *linePtr;
+
+    if (segPtr->size != 0) {
+	Tcl_Panic("LinkCheckProc: link has size %d", segPtr->size);
+    }
+    if (segPtr->sectionPtr->segPtr != segPtr) {
+	Tcl_Panic("LinkCheckProc: link is not at start of section");
+    }
+    if (!segPtr->body.link.prevPtr) {
+	Tcl_Panic("LinkCheckProc: missing connection");
+    }
+    if (!segPtr->body.link.prevPtr->sectionPtr) {
+	Tcl_Panic("LinkCheckProc: connection is not linked");
+    }
+    if (segPtr->prevPtr == segPtr->body.link.prevPtr) {
+	Tcl_Panic("LinkCheckProc: bad link");
+    }
+
+    assert(segPtr->body.link.prevPtr);
+    assert(segPtr->body.link.prevPtr->typePtr);
+
+    if (segPtr->body.link.prevPtr->typePtr != &tkTextBranchType) {
+	Tcl_Panic("LinkCheckProc: link is not pointing to a branch");
+    }
+    if (segPtr->body.link.prevPtr->body.branch.nextPtr != segPtr) {
+	Tcl_Panic("LinkCheckProc: related branch is not pointing to this link");
+    }
+    if (segPtr->prevPtr && segPtr->prevPtr->typePtr->group == SEG_GROUP_MARK) {
+	Tcl_Panic("LinkCheckProc: link shouldn't be preceded by marks");
+    }
+
+    linePtr = segPtr->sectionPtr->linePtr;
+    if (!(prevPtr = segPtr->prevPtr) && linePtr->prevPtr) {
+	prevPtr = linePtr->prevPtr->lastPtr;
+    }
+    while (prevPtr && !prevPtr->tagInfoPtr) {
+	if (prevPtr->typePtr->group == SEG_GROUP_BRANCH) {
+	    Tcl_Panic("LinkCheckProc: invalid branch/link structure (%s after link)",
+		    prevPtr->typePtr->name);
+	}
+	if (!(prevPtr = prevPtr->prevPtr) && linePtr->prevPtr) {
+	    prevPtr = linePtr->prevPtr->lastPtr;
+	}
+    }
+    nextPtr = segPtr->nextPtr;
+    while (nextPtr && !nextPtr->tagInfoPtr) {
+	if (nextPtr->typePtr->group == SEG_GROUP_BRANCH) {
+	    Tcl_Panic("LinkCheckProc: invalid branch/link structure (%s after link)",
+		    nextPtr->typePtr->name);
+	}
+	nextPtr = nextPtr->nextPtr;
+    }
+
+    if (prevPtr && !SegmentIsElided(sharedTextPtr, prevPtr, NULL)) {
+	Tcl_Panic("LinkCheckProc: misplaced link");
+    }
+    if (nextPtr && SegmentIsElided(sharedTextPtr, nextPtr, NULL)) {
+	Tcl_Panic("LinkCheckProc: link is not at end of elided range");
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * ProtectionMarkCheckProc --
+ *
+ *	This function is invoked to perform consistency checks on the
+ *	protection mark.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The function panics because the deletion markers are only
+ *	temporary.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+ProtectionMarkCheckProc(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextSegment *segPtr)	/* Segment to check. */
+{
+    Tcl_Panic("ProtectionMarkCheckProc: protection mark detected");
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * ProtectionMarkDeleteProc --
+ *
+ *	This function is invoked to delete the protection markers.
+ *
+ * Results:
+ *	Returns 'true' to indicate that the segment is (virtually) deleted.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+ProtectionMarkDeleteProc(
+    TkTextBTree tree,
+    TkTextSegment *segPtr,	/* Segment to check. */
+    int flags)			/* Flags controlling the deletion. */
+{
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CheckSegmentItems --
+ *
+ *	This function is invoked to perform consistency checks on the
+ *	segment items.
+ *
+ * Results:
+ *	Returns always true for successful, because in case of an detected
+ *	error the panic function will be called.
+ *
+ * Side effects:
+ *	If a consistency problem is found the function panics.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+CheckSegmentItems(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextLine *linePtr)	/* Pointer to line in B-tree */
+{
+    const TkTextSegment *segPtr;
+
+    for (segPtr = linePtr->segPtr; segPtr; segPtr = segPtr->nextPtr) {
+	if (segPtr->typePtr->checkProc) {
+	    segPtr->typePtr->checkProc(sharedTextPtr, segPtr);
+	}
+    }
+
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CheckSegments --
+ *
+ *	This function is invoked to perform consistency checks on the
+ *	chain of segments.
+ *
+ * Results:
+ *	Returns always true for successful, because in case of an detected
+ *	error the panic function will be called.
+ *
+ * Side effects:
+ *	If a consistency problem is found the function panics.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+CheckSegments(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextLine *linePtr)		/* Pointer to line in B-tree */
+{
+    const TkTextSegment *segPtr;
+    TkTextTagSet *tagonPtr;
+    TkTextTagSet *tagoffPtr;
+    unsigned count = 0;
+    unsigned numBranches = 0;
+    unsigned numLinks = 0;
+    bool startsWithBranch = false;
+    bool startsWithLink = false;
+    bool endsWithBranch = false;
+    bool endsWithLink = false;
+
+    TkTextTagSetIncrRefCount(tagonPtr = sharedTextPtr->emptyTagInfoPtr);
+    TkTextTagSetIncrRefCount(tagoffPtr = linePtr->tagonPtr);
+
+    if (!linePtr->segPtr) {
+	Tcl_Panic("CheckSegments: line has no segments");
+    }
+    if (linePtr->segPtr->prevPtr) {
+	Tcl_Panic("CheckSegments: first segment has predecessor");
+    }
+
+    for (segPtr = linePtr->segPtr; segPtr; segPtr = segPtr->nextPtr) {
+	if (!segPtr->typePtr) {
+	    Tcl_Panic("CheckSegments: segment has null type");
+	}
+	if (segPtr->refCount <= 0) {
+	    Tcl_Panic("CheckSegments: reference count <= 0");
+	}
+	if (segPtr->protectionFlag) {
+	    Tcl_Panic("CheckSegments: segment is protected");
+	}
+	if (segPtr != linePtr->segPtr && !segPtr->prevPtr) {
+	    Tcl_Panic("CheckSegments: missing predecessor in segment");
+	}
+	if (segPtr->nextPtr && segPtr->nextPtr->prevPtr != segPtr) {
+	    Tcl_Panic("CheckSegments: wrong successor in segment");
+	}
+	if (segPtr->prevPtr ? segPtr->prevPtr->nextPtr != segPtr
+		: segPtr != linePtr->segPtr) {
+	    Tcl_Panic("CheckSegments: wrong predecessor in segment");
+	}
+	if (segPtr->typePtr->group != SEG_GROUP_MARK) {
+	    if (segPtr->normalMarkFlag
+		    || segPtr->privateMarkFlag
+		    || segPtr->currentMarkFlag
+		    || segPtr->insertMarkFlag
+		    || segPtr->startEndMarkFlag) {
+		Tcl_Panic("CheckSegments: wrong mark flag in segment");
+	    }
+	}
+	if (!sharedTextPtr->steadyMarks
+	    	&& segPtr->typePtr->gravity == GRAVITY_RIGHT
+		&& segPtr->nextPtr
+		&& segPtr->nextPtr->typePtr->gravity == GRAVITY_LEFT) {
+	    if (segPtr->typePtr == &tkTextBranchType && segPtr->nextPtr->typePtr == &tkTextLinkType) {
+		Tcl_Panic("CheckSegments: empty branch");
+	    } else {
+		Tcl_Panic("CheckSegments: wrong segment order for gravity");
+	    }
+	}
+	if (!segPtr->nextPtr && segPtr->typePtr != &tkTextCharType) {
+	    Tcl_Panic("CheckSegments: line ended with wrong type");
+	}
+	if (!segPtr->sectionPtr) {
+	    Tcl_Panic("CheckSegments: segment has no section");
+	}
+	if (segPtr->size > 0) {
+	    if (!segPtr->tagInfoPtr) {
+		Tcl_Panic("CheckSegments: segment '%s' has no tag information", segPtr->typePtr->name);
+	    }
+	    if (TkTextTagSetIsEmpty(segPtr->tagInfoPtr)
+		    && segPtr->tagInfoPtr != sharedTextPtr->emptyTagInfoPtr) {
+		Tcl_Panic("CheckSegments: should use shared resource if tag info is empty");
+	    }
+	    if (TkTextTagSetRefCount(segPtr->tagInfoPtr) == 0) {
+		Tcl_Panic("CheckSegments: unreferenced tag info");
+	    }
+	    if (TkTextTagSetRefCount(segPtr->tagInfoPtr) > 0x3fffffff) {
+		Tcl_Panic("CheckSegments: negative reference count in tag info");
+	    }
+	    tagonPtr = TkTextTagSetJoin(tagonPtr, segPtr->tagInfoPtr);
+	    tagoffPtr = TkTextTagSetIntersect(tagoffPtr, segPtr->tagInfoPtr);
+	} else if (segPtr->tagInfoPtr) {
+	    Tcl_Panic("CheckSegments: segment '%s' should not have tag information",
+		    segPtr->typePtr->name);
+	}
+	if (segPtr->sectionPtr->linePtr != linePtr) {
+	    Tcl_Panic("CheckSegments: segment has wrong line pointer");
+	}
+	if (!segPtr->nextPtr && linePtr->lastPtr != segPtr) {
+	    Tcl_Panic("CheckSegments: wrong pointer to last segment");
+	}
+	if (segPtr->typePtr == &tkTextBranchType) {
+	    numBranches += 1;
+	    if (numLinks == 0) {
+		startsWithBranch = true;
+	    }
+	    endsWithBranch = true;
+	    endsWithLink = false;
+	} else if (segPtr->typePtr == &tkTextLinkType) {
+	    numLinks += 1;
+	    if (numBranches == 0) {
+		startsWithLink = true;
+	    }
+	    endsWithBranch = false;
+	    endsWithLink = true;
+	}
+	if (++count > 100000) {
+	   Tcl_Panic("CheckSegments: infinite chain of segments");
+	}
+    }
+
+    tagoffPtr = TagSetComplementTo(tagoffPtr, tagonPtr, sharedTextPtr);
+
+    if (!TkTextTagSetIsEqual(linePtr->tagonPtr, tagonPtr)) {
+	Tcl_Panic("CheckSegments: line tagon information is wrong");
+    }
+    if (!TkTextTagSetIsEqual(linePtr->tagoffPtr, tagoffPtr)) {
+	Tcl_Panic("CheckSegments: line tagoff information is wrong");
+    }
+    if (numBranches != linePtr->numBranches) {
+	Tcl_Panic("CheckSegments: wrong branch count %u (expected is %u)",
+		numBranches, linePtr->numBranches);
+    }
+    if (numLinks != linePtr->numLinks) {
+	Tcl_Panic("CheckSegments: wrong link count %u (expected is %u)",
+		numLinks, linePtr->numLinks);
+    }
+    if (startsWithLink && linePtr->logicalLine) {
+	Tcl_Panic("CheckSegments: this line cannot be a logical line");
+    }
+    if (startsWithBranch && !linePtr->logicalLine) {
+	Tcl_Panic("CheckSegments: this line must be a logical line");
+    }
+    if (linePtr->nextPtr) {
+	if (endsWithBranch && linePtr->nextPtr->logicalLine) {
+	    Tcl_Panic("CheckSegments: next line cannot be a logical line");
+	}
+	if (linePtr->logicalLine
+		&& !linePtr->nextPtr->logicalLine
+		&& (numBranches == 0 || endsWithLink)) {
+	    Tcl_Panic("CheckSegments: next line must be a logical line");
+	}
+    }
+
+    TkTextTagSetDecrRefCount(tagonPtr);
+    TkTextTagSetDecrRefCount(tagoffPtr);
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CheckSections --
+ *
+ *	This function is invoked to perform consistency checks on the
+ *	chain of sections.
+ *
+ * Results:
+ *	Returns always true for successful, because in case of an detected
+ *	error the panic function will be called.
+ *
+ * Side effects:
+ *	If a consistency problem is found the function panics.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+CheckSections(
+    const TkTextLine *linePtr)	/* Pointer to line with sections. */
+{
+    const TkTextSection *sectionPtr = linePtr->segPtr->sectionPtr;
+    const TkTextSegment *segPtr;
+    unsigned numSegs, size, length, count, lineSize = 0;
+
+    if (!sectionPtr) {
+	Tcl_Panic("CheckSections: segment has no section");
+    }
+    if (linePtr->segPtr->sectionPtr->segPtr != linePtr->segPtr) {
+	Tcl_Panic("CheckSections: first segment has wrong section pointer");
+    }
+    if (linePtr->segPtr->sectionPtr->prevPtr) {
+	Tcl_Panic("CheckSections: first section has predecessor");
+    }
+
+    for ( ; sectionPtr; sectionPtr = sectionPtr->nextPtr) {
+	segPtr = sectionPtr->segPtr;
+	if (!sectionPtr->linePtr) {
+	    Tcl_Panic("CheckSections: section has no line pointer");
+	}
+	if (sectionPtr->prevPtr
+		? sectionPtr->prevPtr->nextPtr != sectionPtr
+		: sectionPtr->prevPtr != NULL) {
+	    Tcl_Panic("CheckSections: wrong predecessor in section");
+	}
+	if (sectionPtr->nextPtr && sectionPtr->nextPtr->prevPtr != sectionPtr) {
+	    Tcl_Panic("CheckSegments: wrong successor in segment");
+	}
+	numSegs = 0;
+	size = 0;
+	length = 0;
+	count = 0;
+	for ( ; segPtr && segPtr->sectionPtr == sectionPtr; segPtr = segPtr->nextPtr, numSegs++) {
+	    size += segPtr->size;
+	    length += 1;
+	    if (++count > 4*MAX_TEXT_SEGS) {
+	       Tcl_Panic("CheckSections: infinite chain of segments");
+	    }
+	}
+	if (!sectionPtr->nextPtr && segPtr) {
+	    Tcl_Panic("CheckSections: missing successor in section");
+	}
+	if (sectionPtr->nextPtr && sectionPtr->nextPtr->segPtr != segPtr) {
+	    Tcl_Panic("CheckSections: wrong predecessor in section");
+	}
+	if (sectionPtr->length != length) {
+	    Tcl_Panic("CheckSections: wrong segment count %d in section (expected is %d)",
+		    sectionPtr->length, length);
+	}
+	if (sectionPtr->size != size) {
+	    Tcl_Panic("CheckSections: wrong size %d in section (expected is %d)",
+		    sectionPtr->size, size);
+	}
+	if (sectionPtr->linePtr != linePtr) {
+	    Tcl_Panic("CheckSections: section has wrong line pointer");
+	}
+	if (numSegs < MIN_TEXT_SEGS
+		&& sectionPtr->nextPtr
+		&& (!sectionPtr->nextPtr
+		    || sectionPtr->nextPtr->segPtr->prevPtr->typePtr != &tkTextBranchType
+		    || (sectionPtr->prevPtr && sectionPtr->segPtr->typePtr != &tkTextLinkType))
+		&& (!sectionPtr->nextPtr
+		    || sectionPtr->nextPtr->segPtr->typePtr != &tkTextLinkType
+		    || (sectionPtr->prevPtr
+			&& sectionPtr->segPtr->prevPtr->typePtr != &tkTextBranchType))) {
+	    Tcl_Panic("CheckSections: too few segments in section");
+	}
+	if (numSegs > MAX_TEXT_SEGS) {
+	    Tcl_Panic("CheckSections: too many segments in section");
+	}
+	lineSize += sectionPtr->size;
+    }
+
+    if (linePtr->size != lineSize) {
+	Tcl_Panic("CheckSections: wrong size in line");
+    }
+
+    return true;
+}
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 105
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: src/tktext/tkTextDisp.c
===================================================================
--- src/tktext/tkTextDisp.c	(revision 0)
+++ src/tktext/tkTextDisp.c	(working copy)
@@ -0,0 +1,13604 @@
+/*
+ * tkTextDisp.c --
+ *
+ *	This module provides facilities to display text widgets. It is the
+ *	only place where information is kept about the screen layout of text
+ *	widgets. (Well, strictly, each TkTextLine and B-tree node caches its
+ *	last observed pixel height, but that information originates here).
+ *
+ * Copyright (c) 1992-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkText.h"
+#include "tkTextTagSet.h"
+#include "tkRangeList.h"
+#include "tkInt.h"
+
+#ifdef _WIN32
+#include "tkWinInt.h"
+#elif defined(__CYGWIN__)
+#include "tkUnixInt.h"
+#endif
+
+#ifdef MAC_OSX_TK
+#include "tkMacOSXInt.h"
+#endif
+
+#include <stdlib.h>
+#include <assert.h>
+
+#ifndef MIN
+# define MIN(a,b) (a < b ? a : b)
+#endif
+#ifndef MAX
+# define MAX(a,b) (a < b ? b : a)
+#endif
+
+#if NDEBUG
+# define DEBUG(expr)
+#else
+# define DEBUG(expr) expr
+#endif
+
+/*
+ * "Calculations of line pixel heights and the size of the vertical
+ * scrollbar."
+ *
+ * Given that tag, font and elide changes can happen to large numbers of
+ * diverse chunks in a text widget containing megabytes of text, it is not
+ * possible to recalculate all affected height information immediately any
+ * such change takes place and maintain a responsive user-experience. Yet, for
+ * an accurate vertical scrollbar to be drawn, we must know the total number
+ * of vertical pixels shown on display versus the number available to be
+ * displayed.
+ *
+ * The way the text widget solves this problem is by maintaining cached line
+ * pixel heights (in the BTree for each logical line), and having asynchronous
+ * timer callbacks (i) to iterate through the logical lines recalculating
+ * their heights, and (ii) to recalculate the vertical scrollbar's position
+ * and size.
+ *
+ * Typically this works well but there are some situations where the overall
+ * functional design of this file causes some problems. These problems can
+ * only arise because the calculations used to display lines on screen are not
+ * connected to those in the iterating-line- recalculation-process.
+ *
+ * The reason for this disconnect is that the display calculations operate in
+ * display lines, and the iteration and cache operates in logical lines.
+ * Given that the display calculations both need not contain complete logical
+ * lines (at top or bottom of display), and that they do not actually keep
+ * track of logical lines (for simplicity of code and historical design), this
+ * means a line may be known and drawn with a different pixel height to that
+ * which is cached in the BTree, and this might cause some temporary
+ * undesirable mismatch between display and the vertical scrollbar.
+ *
+ * All such mismatches should be temporary, however, since the asynchronous
+ * height calculations will always catch up eventually.
+ *
+ * For further details see the comments before and within the following
+ * functions below: LayoutDLine, AsyncUpdateLineMetrics, GetYView,
+ * GetYPixelCount, TkTextUpdateOneLine, UpdateLineMetrics.
+ *
+ * For details of the way in which the BTree keeps track of pixel heights, see
+ * tkTextBTree.c. Basically the BTree maintains two pieces of information: the
+ * logical line indices and the pixel height cache.
+ */
+
+/*
+ * TK_LAYOUT_WITH_BASE_CHUNKS:
+ *
+ *	With this macro set, collect all char chunks that have no holes
+ *	between them, that are on the same line and use the same font and font
+ *	size. Allocate the chars of all these chunks, the so-called "stretch",
+ *	in a DString in the first chunk, the so-called "base chunk". Use the
+ *	base chunk string for measuring and drawing, so that these actions are
+ *	always performed with maximum context.
+ *
+ *	This is necessary for text rendering engines that provide ligatures
+ *	and sub-pixel layout, like ATSU on Mac. If we don't do this, the
+ *	measuring will change all the time, leading to an ugly "tremble and
+ *	shiver" effect. This is because of the continuous splitting and
+ *	re-merging of chunks that goes on in a text widget, when the cursor or
+ *	the selection move.
+ *
+ * Side effects:
+ *
+ *	Memory management changes. Instead of attaching the character data to
+ *	the clientData structures of the char chunks, an additional DString is
+ *	used. The collection process will even lead to resizing this DString
+ *	for large stretches (> TCL_DSTRING_STATIC_SIZE == 200). We could
+ *	reduce the overall memory footprint by copying the result to a plain
+ *	char array after the line breaking process, but that would complicate
+ *	the code and make performance even worse speedwise.
+ */
+
+/*
+ * The following macro is used to compare two floating-point numbers to within
+ * a certain degree of scale. Direct comparison fails on processors where the
+ * processor and memory representations of FP numbers of a particular
+ * precision is different (e.g. Intel)
+ */
+
+#define FP_EQUAL_SCALE(double1, double2, scaleFactor) \
+    (fabs((double1) - (double2))*((scaleFactor) + 1.0) < 0.3)
+
+/*
+ * Macro to make debugging/testing logging a little easier.
+ */
+
+#define LOG(toVar,what) \
+    Tcl_SetVar2(textPtr->interp, toVar, NULL, what, TCL_GLOBAL_ONLY|TCL_APPEND_VALUE|TCL_LIST_ELEMENT)
+
+/*
+ * Speed up if the text content only contains monospaced line heights, and line wrapping
+ * is disabled.
+ *
+ * But this speed-up trial seems not to have any effect which is worth the effort,
+ * especially because it can be used only if no line wrapping will be done.
+ */
+
+#define SPEEDUP_MONOSPACED_LINE_HEIGHTS 0
+
+/*
+ * Structure for line break information:
+ */
+
+typedef struct BreakInfo {
+    uint32_t refCount;	/* Reference counter, destroy if this counter is going to zero. */
+    char *brks;		/* Array of break info, has exactly the char length of the logical line,
+    			 * each cell is one of LINEBREAK_NOBREAK, LINEBREAK_ALLOWBREAK,
+			 * LINEBREAK_MUSTBREAK, or LINEBREAK_INSIDEACHAR. */
+    struct BreakInfo *nextPtr;
+    			/* Pointer to break information of successor line. Will only be used
+    			 * when caching the break information while redrawing tags. */
+} BreakInfo;
+
+/*
+ * The following structure describes one line of the display, which may be
+ * either part or all of one line of the text.
+ */
+
+typedef struct DLine {
+    TkTextIndex index;		/* Identifies first character in text that is displayed on this line. */
+    struct DLine *nextPtr;	/* Next in list of all display lines for this window. The list is
+    				 * sorted in order from top to bottom. Note: the next DLine doesn't
+				 * always correspond to the next line of text: (a) can have multiple
+				 * DLines for one text line (wrapping), (b) can have elided newlines,
+				 * and (c) can have gaps where DLine's have been deleted because
+				 * they're out of date. */
+    struct DLine *prevPtr;	/* Previous in list of all display lines for this window. */
+    TkTextDispChunk *chunkPtr;	/* Pointer to first chunk in list of all of those that are displayed
+    				 * on this line of the screen. */
+    TkTextDispChunk *firstCharChunkPtr;
+    				/* Pointer to first chunk in list containing chars, window, or image. */
+    TkTextDispChunk *lastChunkPtr;
+    				/* Pointer to last chunk in list containing chars. */
+    TkTextDispChunk *cursorChunkPtr;
+    				/* Pointer to chunk which displays the insert cursor. */
+    BreakInfo *breakInfo;	/* Line break information of logical line. */
+    uint32_t displayLineNo;	/* The number of this display line relative to the related logical
+    				 * line. */
+    uint32_t hyphenRule;	/* Hyphenation rule applied to last char chunk (only if hyphenation
+    				 * has been applied). */
+    uint32_t byteCount;		/* Number of bytes accounted for by this display line, including a
+    				 * trailing space or newline that isn't actually displayed. */
+    int32_t y;			/* Y-position at which line is supposed to be drawn (topmost pixel
+    				 * of rectangular area occupied by line). */
+    int32_t oldY;		/* Y-position at which line currently appears on display. This is
+    				 * used to move lines by scrolling rather than re-drawing. If 'flags'
+				 * have the OLD_Y_INVALID bit set, then we will never examine this
+				 * field (which means line isn't currently visible on display and
+				 * must be redrawn). */
+    int32_t height;		/* Height of line, in pixels. */
+    int32_t baseline;		/* Offset of text baseline from y, in pixels. */
+    int32_t spaceAbove;		/* How much extra space was added to the top of the line because of
+    				 * spacing options. This is included in height and baseline. */
+    int32_t spaceBelow;		/* How much extra space was added to the bottom of the line because
+    				 * of spacing options. This is included in height. */
+    uint32_t length;		/* Total length of line, in pixels. */
+    uint32_t flags;		/* Various flag bits: see below for values. */
+} DLine;
+
+/*
+ * Flag bits for DLine structures:
+ *
+ * HAS_3D_BORDER -		Non-zero means that at least one of the chunks in this line has
+ *				a 3D border, so itpotentially interacts with 3D borders in
+ *				neighboring lines (see DisplayLineBackground).
+ * NEW_LAYOUT -			Non-zero means that the line has been re-layed out since the last
+ *				time the display was updated.
+ * TOP_LINE -			Non-zero means that this was the top line in in the window the last
+ *				time that the window was laid out. This is important because a line
+ *				may be displayed differently if its at the top or bottom than if
+ *				it's in the middle (e.g. beveled edges aren't displayed for middle
+ *				lines if the adjacent line has a similar background).
+ * BOTTOM_LINE -		Non-zero means that this was the bottom line in the window the last
+ *				time that the window was laid out.
+ * OLD_Y_INVALID -		The value of oldY in the structure is not valid or useful and should
+ *				not be examined. 'oldY' is only useful when the DLine is currently
+ *				displayed at a different position and we wish to re-display it via
+ *				scrolling, so this means the DLine needs redrawing.
+ * PARAGRAPH_START -		We are on the first line of a paragraph (used to choose between
+ *				lmargin1, lmargin2).
+ * CURSOR -			This display line is displaying the cursor.
+ */
+
+#define HAS_3D_BORDER	(1 << 0)
+#define NEW_LAYOUT	(1 << 1)
+#define TOP_LINE	(1 << 2)
+#define BOTTOM_LINE	(1 << 3)
+#define OLD_Y_INVALID	(1 << 4)
+#define PARAGRAPH_START	(1 << 5)
+#define DELETED		(1 << 6) /* for debugging */
+#define LINKED		(1 << 7) /* for debugging */
+#define CACHED		(1 << 8) /* for debugging */
+
+/*
+ * The following structure describes how to display a range of characters.
+ * The information is generated by scanning all of the tags associated with
+ * the characters and combining that with default information for the overall
+ * widget. These structures form the hash keys for dInfoPtr->styleTable.
+ */
+
+typedef struct StyleValues {
+    Tk_3DBorder border;		/* Used for drawing background under text.
+				 * NULL means use widget background. */
+    Pixmap bgStipple;		/* Stipple bitmap for background. None means
+				 * draw solid. */
+    XColor *fgColor;		/* Foreground color for text. */
+    XColor *eolColor;		/* Foreground color for end of line symbol, can be NULL. */
+    XColor *hyphenColor;	/* Foreground color for soft hyphens, can be NULL. */
+    Tk_Font tkfont;		/* Font for displaying text. */
+    Pixmap fgStipple;		/* Stipple bitmap for text and other foreground stuff. None means
+    				 * draw solid.*/
+    TkTextTabArray *tabArrayPtr;/* Locations and types of tab stops (may be NULL). */
+    Tk_3DBorder lMarginColor;	/* Color of left margins (1 and 2). */
+    Tk_3DBorder rMarginColor;	/* Color of right margin. */
+    XColor *overstrikeColor;	/* Foreground color for overstrike through text. */
+    XColor *underlineColor;	/* Foreground color for underline underneath text. */
+    char const *lang;		/* Language support (may be NULL). */
+    int hyphenRules;		/* Hyphenation rules for spelling changes. */
+    int32_t borderWidth;	/* Width of 3-D border for background. */
+    int32_t lMargin1;		/* Left margin, in pixels, for first display line of each text line. */
+    int32_t lMargin2;		/* Left margin, in pixels, for second and later display lines of
+    				 * each text line. */
+    int32_t offset;		/* Offset in pixels of baseline, relative to baseline of line. */
+    int32_t rMargin;		/* Right margin, in pixels. */
+    int32_t spacing1;		/* Spacing above first dline in text line. */
+    int32_t spacing2;		/* Spacing between lines of dline. */
+    int32_t spacing3;		/* Spacing below last dline in text line. */
+    uint32_t wrapMode:3;	/* How to handle wrap-around for this tag. One of TEXT_WRAPMODE_CHAR,
+				 * TEXT_WRAPMODE_NONE, TEXT_WRAPMODE_WORD, or TEXT_WRAPMODE_CODEPOINT.*/
+    uint32_t tabStyle:3;	/* One of TABULAR or WORDPROCESSOR. */
+    uint32_t justify:3;		/* Justification style for text. */
+    uint32_t relief:3;		/* 3-D relief for background. */
+    uint32_t indentBg:1;	/* Background will be indented accordingly to the -lmargin1,
+    				 * and -lmargin2 options. */
+    uint32_t overstrike:1;	/* Non-zero means draw overstrike through text. */
+    uint32_t underline:1;	/* Non-zero means draw underline underneath text. */
+    uint32_t elide:1;		/* Zero means draw text, otherwise not. */
+} StyleValues;
+
+/*
+ * The following structure extends the StyleValues structure above with
+ * graphics contexts used to actually draw the characters. The entries in
+ * dInfoPtr->styleTable point to structures of this type.
+ */
+
+typedef struct TextStyle {
+    StyleValues *sValuePtr;	/* Raw information from which GCs were derived. */
+    Tcl_HashEntry *hPtr;	/* Pointer to entry in styleTable. Used to delete entry. */
+    GC bgGC;			/* Graphics context for background. None means use widget background. */
+    GC fgGC;			/* Graphics context for foreground. */
+    GC ulGC;			/* Graphics context for underline. */
+    GC ovGC;			/* Graphics context for overstrike. */
+    GC eolGC;			/* Graphics context for end of line symbol. */
+    GC hyphenGC;		/* Graphics context for soft hyphen character. */
+    uint32_t refCount;		/* Number of times this structure is referenced in Chunks. */
+} TextStyle;
+
+/*
+ * In TkTextDispChunk structures for character segments, the clientData field
+ * points to one of the following structures:
+ */
+
+typedef struct CharInfo {
+    union {
+	const char *chars;	/* UTF characters to display. Actually points into the baseChars of
+				 * it points points into the baseChars of the base chunk. */
+	struct CharInfo *next;	/* Pointer to next free info struct. */
+    } u;
+    int32_t numBytes;		/* Number of bytes that belong to this chunk. */
+    int32_t baseOffset;		/* Starting offset in baseChars of base chunk; always zero if
+    				 * context drawing is not used. */
+    TkTextSegment *segPtr;	/* Pointer to char segment containing the chars. */
+} CharInfo;
+
+typedef struct PixelPos {
+    int32_t xFirst, xLast; 	/* Horizontal pixel position. */
+    int32_t yFirst, yLast;	/* Vertical pixel position. */
+} PixelPos;
+
+/*
+ * Overall display information for a text widget:
+ */
+
+typedef struct TextDInfo {
+    Tcl_HashTable styleTable;	/* Hash table that maps from StyleValues to TextStyles for this
+    				 * widget. */
+    DLine *dLinePtr;		/* First in list of all display lines for this widget, in order
+    				 * from top to bottom. */
+    DLine *lastDLinePtr;	/* Pointer to last display line in this widget. */
+    TextStyle *defaultStyle;	/* Default style. */
+    GC copyGC;			/* Graphics context for copying from off-screen pixmaps onto screen. */
+    GC scrollGC;		/* Graphics context for copying from one place in the window to
+    				 * another (scrolling): differs from copyGC in that we need to get
+				 * GraphicsExpose events. */
+    GC insertFgGC;		/* Graphics context for drawing text "behind" the insert cursor. */
+    double xScrollFirst, xScrollLast;
+				/* Most recent values reported to horizontal scrollbar; used to
+				 * eliminate unnecessary reports. */
+    double yScrollFirst, yScrollLast;
+				/* Most recent values reported to vertical scrollbar; used to
+				 * eliminate unnecessary reports. */
+    uint32_t firstLineNo;	/* Line number of first line in text widget, needed for re-layout. */
+    uint32_t lastLineNo;	/* Line number of last line in text widget, needed for re-layout. */
+    int32_t topPixelOffset;	/* Identifies first pixel in top display line to display in window. */
+    int32_t newTopPixelOffset;	/* Desired first pixel in top display line to display in window. */
+    int32_t x;			/* First x-coordinate that may be used for actually displaying line
+    				 * information. Leaves space for border, etc. */
+    int32_t y;			/* First y-coordinate that may be used for actually displaying line
+    				 * information. Leaves space for border, etc. */
+    int32_t maxX;		/* First x-coordinate to right of available space for displaying
+    				 * lines. */
+    int32_t maxY;		/* First y-coordinate below available space for displaying lines. */
+    int32_t topOfEof;		/* Top-most pixel (lowest y-value) that has been drawn in the
+    				 * appropriate fashion for the portion of the window after the last
+				 * line of the text. This field is used to figure out when to redraw
+				 * part or all of the eof field. */
+    int32_t curYPixelOffset;	/* Y offset of the current view. */
+    TkTextSegment *endOfLineSegPtr;
+    				/* Holds the end of line symbol (option -showendOfline). */
+
+    /*
+     * Cache for single lines:
+     */
+
+    DLine *cachedDLinePtr;	/* We are caching some computed display lines for speed enhancements. */
+    DLine *lastCachedDLinePtr;	/* Pointer to last cached display line. */
+    unsigned numCachedLines;	/* Number of cached display lines. */
+    DLine *lastMetricDLinePtr;	/* We are caching the last computed display line in metric computation,
+    				 * one reason is speed up, but the main reason is to avoid that some
+				 * cached data (i.e. brks) will be released to early. */
+
+    /*
+     * Storage for saved display lines. These lines has been computed for line metric information,
+     * and will be used for displaying afterwards.
+     */
+
+    DLine *savedDLinePtr;	/* First in list of saved display lines, in order from top to bottom. */
+    DLine *lastSavedDLinePtr;/* Pointer to last saved display line. */
+    int32_t savedDisplayLinesHeight;
+    				/* Sum of saved display line heights. */
+
+    /*
+     * Additional buffers:
+     */
+
+    char *strBuffer;		/* We need a string buffer for the line break algorithm. */
+    unsigned strBufferSize;	/* Size of the line break string buffer. */
+
+    /*
+     * Information used for scrolling:
+     */
+
+    int32_t newXPixelOffset;	/* Desired x scroll position, measured as the number of pixels
+    				 * off-screen to the left for a line with no left margin. */
+    int32_t curXPixelOffset;	/* Actual x scroll position, measured as the number of pixels
+    				 * off-screen to the left. */
+    int32_t maxLength;		/* Length in pixels of longest line that's visible in window
+    				 * (length may exceed window size). If there's no wrapping, this
+				 * will be zero. */
+    PixelPos curPixelPos;	/* Most recent pixel position, used for the "watch" command. */
+    PixelPos prevPixelPos;	/* Previous pixel position, used for the "watch" command. */
+
+    /*
+     * The following information is used to implement scanning:
+     */
+
+    int32_t scanMarkXPixel;	/* Pixel index of left edge of the window when the scan started. */
+    int32_t scanMarkX;		/* X-position of mouse at time scan started. */
+    int32_t scanTotalYScroll;	/* Total scrolling (in screen pixels) that has occurred since
+    				 * scanMarkY was set. */
+    int32_t scanMarkY;		/* Y-position of mouse at time scan started. */
+
+    /*
+     * The following is caching the current chunk information:
+     */
+
+    TkTextIndex currChunkIndex;	/* Index position of current chunk. */
+    TkTextDispChunk *currChunkPtr;
+    				/* This is the chunk currently hovered by mouse. */
+    DLine *currDLinePtr;	/* The DLine which contains the current chunk. */
+
+    /*
+     * Cache current y-view position:
+     */
+
+    int32_t topLineNo;
+    int32_t topByteIndex;
+
+    /*
+     * Pools for lines, chunks, char infos, and break infos:
+     */
+
+    DLine *dLinePoolPtr;	/* Pointer to first free display line. */
+    TkTextDispChunk *chunkPoolPtr;
+    				/* Pointer to first free chunk. */
+    struct TkTextDispChunkSection *sectionPoolPtr;
+    				/* Pointer to first free section. */
+    CharInfo *charInfoPoolPtr;	/* Pointer to first free char info. */
+
+    /*
+     * Miscellaneous information:
+     */
+
+    bool dLinesInvalidated;	/* This value is set to true whenever something happens that
+    				 * invalidates information in DLine structures; if a redisplay
+				 * is in progress, it will see this and abort the redisplay. This
+				 * is needed because, for example, an embedded window could change
+				 * its size when it is first displayed, invalidating the DLine that
+				 * is currently being displayed. If redisplay continues, it will
+				 * use freed memory and could dump core. */
+    bool pendingUpdateLineMetricsFinished;
+    				/* Did we add RunUpdateLineMetricsFinished to the idle loop? */
+    int32_t flags;		/* Various flag values: see below for definitions. */
+    uint32_t countImages;	/* Number of displayed images (currently unused except if
+    				 * SPEEDUP_MONOSPACED_LINE_HEIGHTS is set). */
+    uint32_t countWindows;	/* Number of displayed windows. */
+    bool insideLineMetricUpdate;/* Line metric update is currently in progress. */
+
+    /*
+     * Information used to handle the asynchronous updating of the y-scrollbar
+     * and the vertical height calculations:
+     */
+
+    int lineHeight;		/* TkTextRelayoutWindow is using this value: the line height of
+    				 * monospaced lines, is zero of the line heights are not monospaced
+				 * in last call of TkTextRelayoutWindow. */
+    uint32_t lineMetricUpdateEpoch;
+    				/* Stores a number which is incremented each time the text widget
+				 * changes in a significant way (e.g. resizing or geometry-influencing
+				 * tag changes). */
+    uint32_t lineMetricUpdateCounter;
+    				/* Count updates of line metric information. */
+    TkRangeList *lineMetricUpdateRanges;
+    				/* Stores the range of line numbers which are not yet up-to-date. */
+    TkTextIndex metricIndex;	/* If the current metric update line wraps into very many display
+    				 * lines, then this is used to keep track of what index we've got
+				 * to so far... */
+    Tcl_TimerToken lineUpdateTimer;
+				/* A token pointing to the current line metric update callback. */
+    Tcl_TimerToken scrollbarTimer;
+				/* A token pointing to the current scrollbar update callback. */
+    Tcl_TimerToken repickTimer;
+				/* A token pointing to the current repick callback. */
+} TextDInfo;
+
+typedef struct TkTextDispChunkSection {
+    struct TkTextDispChunkSection *nextPtr;
+    				/* Next section in chain of display sections. */
+    TkTextDispChunk *chunkPtr;	/* First display chunk in this section. */
+    uint32_t numBytes;		/* Number of bytes in this section. */
+} TkTextDispChunkSection;
+
+/*
+ * Flag values for TextDInfo structures:
+ *
+ * DINFO_OUT_OF_DATE:	Means that the DLine structures for this window are partially or
+ *			completely out of date and need to be recomputed.
+ *
+ * REDRAW_PENDING:	Means that a when-idle handler has been scheduled to update the display.
+ *
+ * REDRAW_BORDERS:	Means window border or pad area has potentially been damaged and must
+ *			be redrawn.
+ *
+ * ASYNC_UPDATE:	Means that the asynchronous pixel-height calculation is still working.
+ *
+ * ASYNC_PENDING:	Means that the asynchronous pixel-height calculation is pending until
+ *			the display update (DisplayText) has been finished.
+ *
+ * REPICK_NEEDED:	Means that the widget has been modified in a way that could change
+ *			the current character (a different character might be under the mouse
+ *			cursor now). Need to recompute the current character before the next
+ *			redisplay.
+ */
+
+#define DINFO_OUT_OF_DATE	(1 << 0)
+#define REDRAW_PENDING		(1 << 1)
+#define REDRAW_BORDERS		(1 << 2)
+#define ASYNC_UPDATE		(1 << 3)
+#define ASYNC_PENDING		(1 << 4)
+#define REPICK_NEEDED		(1 << 5)
+
+typedef struct LayoutData {
+    TkText *textPtr;
+    TkTextDispChunk *chunkPtr;	/* Start of chunk chain. */
+    TkTextDispChunk *tabChunkPtr;
+				/* Pointer to the chunk containing the previous tab stop. */
+    TkTextDispChunk *firstChunkPtr;
+				/* Pointer to the first chunk. */
+    TkTextDispChunk *lastChunkPtr;
+				/* Pointer to the current chunk. */
+    TkTextDispChunk *firstCharChunkPtr;
+				/* Pointer to the first char/window/image chunk in chain. */
+    TkTextDispChunk *lastCharChunkPtr;
+				/* Pointer to the last char/window/image chunk in chain. */
+    TkTextDispChunk *breakChunkPtr;
+				/* Chunk containing best word break point, if any. */
+    TkTextDispChunk *cursorChunkPtr;
+				/* Pointer to the insert cursor chunk. */
+    TkTextLine *logicalLinePtr;	/* Pointer to the logical line. */
+    BreakInfo *breakInfo;	/* Line break information of logical line. */
+    const char *brks;		/* Buffer for line break information (for TEXT_WRAPMODE_CODEPOINT). */
+    TkTextIndex index;		/* Current index. */
+    unsigned countChunks;	/* Number of chunks in current display line. */
+    unsigned numBytesSoFar;	/* The number of processed bytes (so far). */
+    unsigned byteOffset;	/* The byte offset to start of logical line. */
+    unsigned dispLineOffset;	/* The byte offset to start of display line. */
+    int increaseNumBytes;	/* Increase number of consumed bytes to realize spelling changes. */
+    int decreaseNumBytes;	/* Decrease number of displayable bytes to realize spelling changes. */
+    int displayLineNo;		/* Current display line number. */
+    int rMargin;		/* Right margin width for line. */
+    int hyphenRule;		/* Hyphenation rule applied to last char chunk (only in hyphenation
+    				 * has been applied). */
+    TkTextTabArray *tabArrayPtr;/* Tab stops for line; taken from style for the first character
+    				 * on line. */
+    int tabStyle;		/* One of TABULAR or WORDPROCESSOR. */
+    int tabSize;		/* Number of pixels consumed by current tab stop. */
+    int tabIndex;		/* Index of the current tab stop. */
+    unsigned tabWidth;		/* Default tab width of this widget. */
+    unsigned numSpaces;		/* Number of expandable space (needed for full justification). */
+    TkTextJustify justify;	/* How to justify line: taken from style for the first character
+    				 * in this display line. */
+    TkWrapMode wrapMode;	/* Wrap mode to use for this chunk. */
+    int maxX;			/* Maximal x coord in current line. */
+    int width;			/* Maximal x coord in widget. */
+    int x;			/* Current x coord. */
+    bool paragraphStart;	/* 'true' means that we are on the first line of a paragraph
+    				 * (used to choose between lmargin1, lmargin2). */
+    bool skipSpaces;		/* 'true' means that we have to gobble spaces at start of next
+    				 * segment. */
+    bool trimSpaces;		/* 'true' iff space mode is TEXT_SPACEMODE_TRIM. */
+
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+    /*
+     * Support for context drawing.
+     */
+
+    TkTextDispChunk *baseChunkPtr;
+    				/* The chunk which contains the actual context data. */
+#endif
+} LayoutData;
+
+typedef struct DisplayInfo {
+    int byteOffset;		/* Byte offset to start of display line (subtract this offset to
+    				 * get the index of display line start). */
+    int nextByteOffset;		/* Byte offset to start of next display line (add this offset to
+    				 * get the index of next display line start). */
+    int displayLineNo;		/* Number of display line. */
+    unsigned numDispLines;	/* Total number of display lines belonging to corresponding logical
+    				 * line (so far). */
+    int pixels;			/* Total height of logical line (so far). */
+    bool isComplete;		/* The display line metric is complete for this logical line? */
+    const TkTextDispLineEntry *entry;
+    				/* Pointer to entry in display pixel info for displayLineNo. Note
+				 * that the predecessing entries can be accessed, but not the successing
+				 * entries. */
+    DLine *dLinePtr;		/* Cached display lines, produced while ComputeDisplayLineInfo is
+    				 * computing the line metrics. */
+    DLine *lastDLinePtr;	/* Pointer to last cached display line. */
+    unsigned numCachedLines;	/* Number of cached lines. */
+    unsigned heightOfCachedLines;
+    				/* Sum of cached display line heights. */
+    TkTextIndex index;		/* Index where the computation has finished. */
+    TkTextLine *linePtr;	/* Logical line, where computation has started. */
+    const TkTextPixelInfo *pixelInfo;
+    				/* Pixel information of logical line. */
+    BreakInfo *lineBreakInfo;	/* We have to cache the line break information (for
+    				 * TEXT_WRAPMODE_CODEPOINT), to avoid repeated computations when
+				 * scrolling. */
+
+    /*
+     * This attribute is private.
+     */
+
+    TkTextDispLineEntry entryBuffer[2];
+    				/* This buffer will be used if the logical line has no entries
+				 * (single display line). */
+} DisplayInfo;
+
+/*
+ * Action values for FreeDLines:
+ *
+ * DLINE_UNLINK:	Free, unlink from current display, and set 'dLinesInvalidated'.
+ *
+ * DLINE_UNLINK_KEEP_BRKS:
+ *			Same as DLINE_UNLINK, but do not destroy break info (except if
+ *			now outside of peer).
+ *
+ * DLINE_FREE_TEMP:	Free, but don't unlink, and also don't set 'dLinesInvalidated'.
+ *
+ * DLINE_CACHE:		Don't free, don't unlink, cache this line, and don't set 'dLinesInvalidated'.
+ *
+ * DLINE_METRIC:	Don't free, don't unlink, cache this line temporarily, and don't set
+ *			'dLinesInvalidated'.
+ *
+ * DLINE_SAVE:		Don't free, unlink, and save this line for displaying later.
+ */
+
+typedef enum {
+    DLINE_UNLINK, DLINE_UNLINK_KEEP_BRKS, DLINE_FREE_TEMP, DLINE_CACHE, DLINE_METRIC, DLINE_SAVE
+} FreeDLineAction;
+
+/*
+ * Maximal number of cached display lines.
+ */
+
+#define MAX_CACHED_DISPLAY_LINES 8
+
+/*
+ * We will also mark logical lines with current line metric epoch even if the computation
+ * has been done only partial. In this case we add a special bit to mark it as partially
+ * computed.
+ */
+
+#define EPOCH_MASK		0x7fffffff
+#define PARTIAL_COMPUTED_BIT	0x80000000
+
+/*
+ * Result values returned by TextGetScrollInfoObj:
+ */
+
+typedef enum {
+    SCROLL_MOVETO,
+    SCROLL_PAGES,
+    SCROLL_UNITS,
+    SCROLL_ERROR,
+    SCROLL_PIXELS
+} ScrollMethod;
+
+/*
+ * Threshold type for ComputeMissingMetric:
+ */
+
+typedef enum {
+    THRESHOLD_BYTE_OFFSET,	/* compute until byte offset has been reached */
+    THRESHOLD_LINE_OFFSET,	/* compute until display line offset has been reached */
+    THRESHOLD_PIXEL_DISTANCE	/* compute until pixel distance has been reached */
+} Threshold;
+
+/*
+ * We don't want less than 10 chunks per display section.
+ */
+#define MIN_CHUNKS_PER_SECTION 10
+
+/*
+ * We don't want more than 20 sections per display line.
+ */
+#define MAX_SECTIONS_PER_LINE 20
+
+/*
+ * Forward declarations for functions defined later in this file:
+ */
+
+static void		AdjustForTab(LayoutData *data);
+static void		ComputeSizeOfTab(LayoutData *data);
+static void		ElideBboxProc(TkText *textPtr, TkTextDispChunk *chunkPtr, int index, int y,
+			    int lineHeight, int baseline, int *xPtr, int *yPtr, int *widthPtr,
+			    int *heightPtr);
+static int		ElideMeasureProc(TkTextDispChunk *chunkPtr, int x);
+static void		DisplayDLine(TkText *textPtr, DLine *dlPtr, DLine *prevPtr, Pixmap pixmap);
+static void		DisplayLineBackground(TkText *textPtr, DLine *dlPtr, DLine *prevPtr,
+			    Pixmap pixmap);
+static void		DisplayText(ClientData clientData);
+static DLine *		FindCachedDLine(TkText *textPtr, const TkTextIndex *indexPtr);
+static DLine *		FindDLine(TkText *textPtr, DLine *dlPtr, const TkTextIndex *indexPtr);
+static DLine *		FreeDLines(TkText *textPtr, DLine *firstPtr, DLine *lastPtr,
+			    FreeDLineAction action);
+static void		FreeStyle(TkText *textPtr, TextStyle *stylePtr);
+static TextStyle *	GetStyle(TkText *textPtr, TkTextSegment *segPtr);
+static void		UpdateDefaultStyle(TkText *textPtr);
+static void		GetXView(Tcl_Interp *interp, TkText *textPtr, bool report);
+static void		GetYView(Tcl_Interp *interp, TkText *textPtr, bool report);
+static unsigned		GetYPixelCount(TkText *textPtr, DLine *dlPtr);
+static DLine *		LayoutDLine(const TkTextIndex *indexPtr, int displayLineNo);
+static bool		MeasureUp(TkText *textPtr, const TkTextIndex *srcPtr, int distance,
+			    TkTextIndex *dstPtr, int32_t *overlap);
+static bool		MeasureDown(TkText *textPtr, TkTextIndex *srcPtr, int distance,
+			    int32_t *overlap, bool saveDisplayLines);
+static int		NextTabStop(unsigned tabWidth, int x, int tabOrigin);
+static void		UpdateDisplayInfo(TkText *textPtr);
+static void		YScrollByLines(TkText *textPtr, int offset);
+static void		YScrollByPixels(TkText *textPtr, int offset);
+static void		TextInvalidateRegion(TkText *textPtr, TkRegion region);
+static void		TextInvalidateLineMetrics(TkText *textPtr, TkTextLine *linePtr,
+			    unsigned lineCount, TkTextInvalidateAction action);
+static int		CalculateDisplayLineHeight(TkText *textPtr, const TkTextIndex *indexPtr,
+			    unsigned *byteCountPtr);
+static TkTextDispChunk * DLineChunkOfX(TkText *textPtr, DLine *dlPtr, int x, TkTextIndex *indexPtr,
+			    bool *nearby);
+static void		DLineIndexOfX(TkText *textPtr, TkTextDispChunk *chunkPtr, int x,
+			    TkTextIndex *indexPtr);
+static int		DLineXOfIndex(TkText *textPtr, DLine *dlPtr, int byteIndex);
+static ScrollMethod	TextGetScrollInfoObj(Tcl_Interp *interp, TkText *textPtr, int objc,
+			    Tcl_Obj *const objv[], double *dblPtr, int *intPtr);
+static void		InvokeAsyncUpdateLineMetrics(TkText *textPtr);
+static void		InvokeAsyncUpdateYScrollbar(TkText *textPtr);
+static void		AsyncUpdateYScrollbar(ClientData clientData);
+static void		AsyncUpdateLineMetrics(ClientData clientData);
+static void		UpdateLineMetrics(TkText *textPtr, unsigned doThisMuch);
+static bool		TestIfLinesUpToDate(const TkTextIndex *indexPtr);
+static void		SaveDisplayLines(TkText *textPtr, DisplayInfo *info, bool append);
+static TkTextLine *	ComputeDisplayLineInfo(TkText *textPtr, const TkTextIndex *indexPtr,
+			    DisplayInfo *info);
+static void		ComputeMissingMetric(TkText *textPtr, DisplayInfo *info,
+			    Threshold threshold, int offset);
+static unsigned		GetPixelsTo(TkText *textPtr, const TkTextIndex *indexPtr,
+			    bool inclusiveLastLine, DisplayInfo *info);
+static unsigned		FindDisplayLineOffset(TkText *textPtr, TkTextLine *linePtr, int32_t *distance);
+static void		FindDisplayLineStartEnd(TkText *textPtr, TkTextIndex *indexPtr, bool end,
+			    int cacheType);
+static void		CheckIfLineMetricIsUpToDate(TkText *textPtr);
+static void		RunUpdateLineMetricsFinished(ClientData clientData);
+static void		CheckLineMetricConsistency(const TkText *textPtr);
+static int		ComputeBreakIndex(TkText *textPtr, const TkTextDispChunk *chunkPtr,
+			    TkTextSegment *segPtr, int byteOffset, TkWrapMode wrapMode,
+			    TkTextSpaceMode spaceMode);
+static int		CharChunkMeasureChars(TkTextDispChunk *chunkPtr, const char *chars, int charsLen,
+			    int start, int end, int startX, int maxX, int flags, int *nextXPtr);
+static void		CharDisplayProc(TkText *textPtr, TkTextDispChunk *chunkPtr, int x, int y,
+			    int height, int baseline, Display *display, Drawable dst, int screenY);
+static void		CharUndisplayProc(TkText *textPtr, TkTextDispChunk *chunkPtr);
+static void		HyphenUndisplayProc(TkText *textPtr, TkTextDispChunk *chunkPtr);
+static void		DisplayChars(TkText *textPtr, TkTextDispChunk *chunkPtr, int x, int y,
+			    int baseline, Display *display, Drawable dst);
+static int		CharMeasureProc(TkTextDispChunk *chunkPtr, int x);
+static void		CharBboxProc(TkText *textPtr, TkTextDispChunk *chunkPtr, int index, int y,
+			    int lineHeight, int baseline, int *xPtr, int *yPtr, int *widthPtr,
+			    int *heightPtr);
+static int		MeasureChars(Tk_Font tkfont, const char *source, int maxBytes, int rangeStart,
+			    int rangeLength, int startX, int maxX, int flags, int *nextXPtr);
+static CharInfo *	AllocCharInfo(TkText *textPtr);
+static void		FreeCharInfo(TkText *textPtr, CharInfo *ciPtr);
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+static bool		IsSameFGStyle(TextStyle *style1, TextStyle *style2);
+#endif /* TK_LAYOUT_WITH_BASE_CHUNKS */
+
+static const TkTextDispChunkProcs layoutCharProcs = {
+    TEXT_DISP_CHAR,		/* type */
+    CharDisplayProc,		/* displayProc */
+    CharUndisplayProc,		/* undisplayProc */
+    CharMeasureProc,		/* measureProc */
+    CharBboxProc,		/* bboxProc */
+};
+
+#define CHAR_CHUNK_GET_SEGMENT(chunkPtr) (((const CharInfo *) chunkPtr->clientData)->segPtr)
+
+static const TkTextDispChunkProcs layoutHyphenProcs = {
+    TEXT_DISP_HYPHEN,		/* type */
+    CharDisplayProc,		/* displayProc */
+    HyphenUndisplayProc,	/* undisplayProc */
+    CharMeasureProc,		/* measureProc */
+    CharBboxProc,		/* bboxProc */
+};
+
+
+/*
+ * Pointer to int, for some portable pointer hacks - it's guaranteed that
+ * 'uintptr_'t and 'void *' are convertible in both directions (C99 7.18.1.4).
+ */
+
+typedef union {
+    void *ptr;
+    uintptr_t flag;
+} __ptr_to_int;
+
+static void * MarkPointer(void *ptr) { __ptr_to_int p; p.ptr = ptr; p.flag |= 1; return p.ptr; }
+
+static const TkTextDispChunkProcs layoutElideProcs = {
+    TEXT_DISP_ELIDED,	/* type */
+    NULL,		/* displayProc */
+    NULL,		/* undisplayProc */
+    ElideMeasureProc,	/* measureProc */
+    ElideBboxProc,	/* bboxProc */
+};
+
+#if !NDEBUG
+/*
+ * The following counters keep statistics about redisplay that can be checked
+ * to see how clever this code is at reducing redisplays.
+ */
+
+typedef struct Statistic {
+    unsigned numRedisplays;	/* Number of calls to DisplayText. */
+    unsigned linesRedrawn;	/* Number of calls to DisplayDLine. */
+    unsigned numLayouted;	/* Number of calls to LayoutDLine. */
+    unsigned numCopies;		/* Number of calls to XCopyArea to copy part of the screen. */
+    unsigned lineHeightsRecalculated;
+				/* Number of line layouts purely for height calculation purposes. */
+    unsigned breakInfo;		/* Number of line break computations. */
+    unsigned numCached;		/* Number of computed cached lines. */
+    unsigned numHits;		/* Number of found cached lines. */
+    unsigned numReused;		/* Number of re-used display lines. */
+
+    bool perfFuncIsHooked;
+} Statistic;
+
+static Statistic stats;
+
+static void
+PerfStatistic()
+{
+    if (!tkBTreeDebug) {
+	return;
+    }
+
+    printf("PERFORMANCE -------------------\n");
+    printf("Calls to DisplayText:    %6u\n", stats.numRedisplays);
+    printf("Calls to DisplayDLine:   %6u\n", stats.linesRedrawn);
+    printf("Calls to LayoutDLine:    %6u\n", stats.numLayouted);
+    printf("Calls to XCopyArea:      %6u\n", stats.numCopies);
+    printf("Re-used display lines:   %6u\n", stats.numReused);
+    printf("Cached display lines:    %6u\n", stats.numCached);
+    printf("Found in cache:          %6u\n", stats.numHits);
+    printf("Line metric calculation: %6u\n", stats.lineHeightsRecalculated);
+    printf("Break info computation:  %6u\n", stats.breakInfo);
+}
+#endif /* NDEBUG */
+
+#if TK_CHECK_ALLOCS
+
+/*
+ * Some stuff for memory checks, and allocation statistic.
+ */
+
+static unsigned tkTextCountNewStyle = 0;
+static unsigned tkTextCountDestroyStyle = 0;
+static unsigned tkTextCountNewChunk = 0;
+static unsigned tkTextCountDestroyChunk = 0;
+static unsigned tkTextCountNewSection = 0;
+static unsigned tkTextCountDestroySection = 0;
+static unsigned tkTextCountNewCharInfo = 0;
+static unsigned tkTextCountDestroyCharInfo = 0;
+static unsigned tkTextCountNewBreakInfo = 0;
+static unsigned tkTextCountDestroyBreakInfo = 0;
+static unsigned tkTextCountNewDLine = 0;
+static unsigned tkTextCountDestroyDLine = 0;
+static unsigned tkTextCountNewDispInfo = 0;
+unsigned tkTextCountDestroyDispInfo = 0; /* referenced in tkTextBTree.c */
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+unsigned tkTextCountNewBaseChars = 0;
+unsigned tkTextCountDestroyBaseChars = 0;
+#endif
+
+extern unsigned tkTextCountDestroySegment;
+extern unsigned tkRangeListCountNew;
+extern unsigned tkRangeListCountDestroy;
+
+static bool hookStatFunc = true;
+
+static void
+AllocStatistic()
+{
+    if (!tkBTreeDebug) {
+	return;
+    }
+
+    printf("--------------------------------\n");
+    printf("ALLOCATION:       new    destroy\n");
+    printf("--------------------------------\n");
+    printf("DLine:       %8u - %8u\n", tkTextCountNewDLine, tkTextCountDestroyDLine);
+    printf("Chunk:       %8u - %8u\n", tkTextCountNewChunk, tkTextCountDestroyChunk);
+    printf("Section:     %8u - %8u\n", tkTextCountNewSection, tkTextCountDestroySection);
+    printf("CharInfo:    %8u - %8u\n", tkTextCountNewCharInfo, tkTextCountDestroyCharInfo);
+    printf("DispInfo:    %8u - %8u\n", tkTextCountNewDispInfo, tkTextCountDestroyDispInfo);
+    printf("BreakInfo:   %8u - %8u\n", tkTextCountNewBreakInfo, tkTextCountDestroyBreakInfo);
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+    printf("BaseChars:   %8u - %8u\n", tkTextCountNewBaseChars, tkTextCountDestroyBaseChars);
+#endif
+    printf("Style:       %8u - %8u\n", tkTextCountNewStyle, tkTextCountDestroyStyle);
+    printf("RangeList:   %8u - %8u\n", tkRangeListCountNew, tkRangeListCountDestroy);
+
+    if (tkTextCountNewDLine != tkTextCountDestroyDLine
+	    || tkTextCountNewChunk != tkTextCountDestroyChunk
+	    || tkTextCountNewSection != tkTextCountDestroySection
+	    || tkTextCountNewCharInfo != tkTextCountDestroyCharInfo
+	    || tkTextCountNewDispInfo != tkTextCountDestroyDispInfo
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+	    || tkTextCountNewBaseChars != tkTextCountDestroyBaseChars
+#endif
+	    || tkTextCountNewStyle != tkTextCountDestroyStyle
+	    || tkRangeListCountNew != tkRangeListCountDestroy) {
+	printf("*** memory leak detected ***\n");
+    }
+}
+#endif /* TK_CHECK_ALLOCS */
+
+/*
+ * Some helpers:
+ */
+
+static const char doNotBreakAtAll[8] = {
+    LINEBREAK_NOBREAK, LINEBREAK_NOBREAK, LINEBREAK_NOBREAK, LINEBREAK_NOBREAK,
+    LINEBREAK_NOBREAK, LINEBREAK_NOBREAK, LINEBREAK_NOBREAK, LINEBREAK_NOBREAK };
+
+static bool IsPowerOf2(unsigned n) { return !(n & (n - 1)); }
+
+static unsigned
+NextPowerOf2(uint32_t n)
+{
+    --n;
+    n |= n >> 1;
+    n |= n >> 2;
+    n |= n >> 4;
+    n |= n >> 8;
+    n |= n >> 16;
+    return ++n;
+}
+
+static bool
+IsExpandableSpace(
+    const char *s)
+{
+    /* Normal space or non-break space? */
+    return UCHAR(s[0]) == 0x20 || (UCHAR(s[0]) == 0xc2 && UCHAR(s[1]) == 0x0a);
+}
+
+static void
+LogTextHeightCalc(
+    TkText *textPtr,
+    const TkTextIndex *indexPtr)
+{
+    char string[TK_POS_CHARS];
+
+    assert(tkTextDebug);
+
+    /*
+     * Debugging is enabled, so keep a log of all the lines whose
+     * height was recalculated. The test suite uses this information.
+     */
+
+    TkTextPrintIndex(textPtr, indexPtr, string);
+    LOG("tk_textHeightCalc", string);
+}
+
+static void
+LogTextRelayout(
+    TkText *textPtr,
+    const TkTextIndex *indexPtr)
+{
+    char string[TK_POS_CHARS];
+
+    assert(tkTextDebug);
+
+    /*
+     * Debugging is enabled, so keep a log of all the lines that
+     * were re-layed out. The test suite uses this information.
+     */
+
+    TkTextPrintIndex(textPtr, indexPtr, string);
+    LOG("tk_textRelayout", string);
+}
+
+static void
+LogTextInvalidateLine(
+    TkText *textPtr,
+    unsigned count)
+{
+    char buffer[4*TCL_INTEGER_SPACE + 3];
+    const TkRangeList *ranges = textPtr->dInfoPtr->lineMetricUpdateRanges;
+    unsigned totalCount = TkRangeListCount(ranges) - count;
+    unsigned totalLines = TkBTreeNumLines(textPtr->sharedTextPtr->tree, textPtr);
+    int lineNum = TkRangeListIsEmpty(ranges) ? -1 : TkRangeListLow(ranges);
+
+    assert(tkTextDebug);
+
+    snprintf(buffer, sizeof(buffer), "%d %u - %u %u", lineNum, totalLines, count, totalCount);
+    LOG("tk_textInvalidateLine", buffer);
+}
+
+static void
+DisplayTextWhenIdle(
+    TkText *textPtr)
+{
+    if (textPtr->sharedTextPtr->allowUpdateLineMetrics && !(textPtr->dInfoPtr->flags & REDRAW_PENDING)) {
+	textPtr->dInfoPtr->flags |= REDRAW_PENDING;
+	Tcl_DoWhenIdle(DisplayText, textPtr);
+    }
+}
+
+static int
+GetLeftLineMargin(
+    const DLine *dlPtr,
+    const StyleValues *sValuePtr)
+{
+    assert(dlPtr);
+    assert(sValuePtr);
+    return (dlPtr->flags & PARAGRAPH_START) ? sValuePtr->lMargin1 : sValuePtr->lMargin2;
+}
+
+#if SPEEDUP_MONOSPACED_LINE_HEIGHTS
+
+static bool
+TestMonospacedLineHeights(
+    const TkText *textPtr)
+{
+    return textPtr->wrapMode == TEXT_WRAPMODE_NONE
+	    && textPtr->dInfoPtr->countImages == 0
+	    && textPtr->dInfoPtr->countWindows == 0
+	    && TkTextTagSetDisjunctiveBits(TkBTreeRootTagInfo(textPtr->sharedTextPtr->tree),
+		textPtr->sharedTextPtr->affectLineHeightTags);
+    return false;
+}
+
+#endif /* SPEEDUP_MONOSPACED_LINE_HEIGHTS */
+
+static bool
+UseMonospacedLineHeights(
+    const TkText *textPtr)
+{
+#if SPEEDUP_MONOSPACED_LINE_HEIGHTS
+    return TestMonospacedLineHeights(textPtr)
+	    && TkRangeListIsEmpty(textPtr->dInfoPtr->lineMetricUpdateRanges);
+#else
+    return false;
+#endif
+}
+
+/*
+ * Some helpers for hyphenation support (Latin-1 only):
+ */
+
+static const unsigned char isVowel[256] = {
+#define _ 0
+/*  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 00 - 0f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 10 - 1f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 20 - 2f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 30 - 3f */
+    _, 1, _, _, _, 1, _, _, _, 1, _, _, _, _, _, 1, /* 40 - 4f */
+    _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, /* 50 - 5f */
+    _, 1, _, _, _, 1, _, _, _, 1, _, _, _, _, _, 1, /* 60 - 6f */
+    _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, /* 70 - 7f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 80 - 8f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 90 - 9f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* a0 - af */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* b0 - bf */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* c0 - cf */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* d0 - df */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* e0 - ef */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* f0 - ff */
+/*  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f */
+#undef _
+};
+
+static const unsigned char isConsonant[256] = {
+#define _ 0
+/*  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 00 - 0f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 10 - 1f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 20 - 2f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 30 - 3f */
+    _, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, /* 40 - 4f */
+    1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, _, _, _, _, _, /* 50 - 5f */
+    _, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, /* 60 - 6f */
+    1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, _, _, _, _, _, /* 70 - 7f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 80 - 8f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 90 - 9f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* a0 - af */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* b0 - bf */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* c0 - cf */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* d0 - df */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* e0 - ef */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* f0 - ff */
+/*  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f */
+#undef _
+};
+
+static const unsigned char isUmlaut[256] = {
+#define _ 0
+/*  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 00 - 0f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 10 - 1f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 20 - 2f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 30 - 3f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 40 - 4f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 50 - 5f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 60 - 6f */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 70 - 7f */
+    _, _, _, _, 1, _, _, _, _, _, _, 1, _, _, _, _, /* 80 - 8f */
+    _, _, _, _, _, _, 1, _, _, _, _, _, 1, _, _, _, /* 90 - 9f */
+    _, _, _, _, 1, _, _, _, _, _, _, 1, _, _, _, _, /* a0 - af */
+    _, _, _, _, _, _, 1, _, _, _, _, _, 1, _, _, _, /* b0 - bf */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* c0 - cf */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* d0 - df */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* e0 - ef */
+    _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* f0 - ff */
+/*  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f */
+#undef _
+};
+
+static const unsigned char umlautToVowel[256] = {
+#define ___ 0
+/*   00   01   02   03   04   05   06   07   08   09   0a   0b   0c   0d   0e   0f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 00 - 0f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 10 - 1f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 20 - 2f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 30 - 3f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 40 - 4f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 50 - 5f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 60 - 6f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 70 - 7f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 80 - 8f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* 90 - 9f */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* a0 - af */
+    ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, ___, /* b0 - bf */
+    ___, ___, ___, ___, 'A', ___, ___, ___, ___, ___, ___, 'E', ___, ___, ___, ___, /* c0 - cf */
+    ___, ___, ___, ___, ___, ___, 'O', ___, ___, ___, ___, ___, 'U', ___, ___, ___, /* d0 - df */
+    ___, ___, ___, ___, 'a', ___, ___, ___, ___, ___, ___, 'e', ___, ___, ___, ___, /* e0 - ef */
+    ___, ___, ___, ___, ___, ___, 'o', ___, ___, ___, ___, ___, 'u', ___, ___, ___, /* f0 - ff */
+/*   00   01   02   03   04   05   06   07   08   09   0a   0b   0c   0d   0e   0f */
+#undef ___
+};
+
+static bool IsVowel(unsigned char c)     { return isVowel[c]; }
+static bool IsUmlaut(unsigned char c)    { return umlautToVowel[c] != 0; }
+static bool IsConsonant(unsigned char c) { return isConsonant[c]; }
+
+static unsigned char UmlautToVowel(unsigned char c) { return umlautToVowel[c]; }
+static unsigned char ConvertC3Next(unsigned char c) { return 0xc0 | (c - 0x80); }
+
+static bool
+IsUmlautOrVowel(const char *s)
+{
+    return UCHAR(s[0]) == 0xc3 ? isUmlaut[UCHAR(s[1])] : UCHAR(s[0]) < 0x80 && isVowel[UCHAR(s[0])];
+}
+
+static void
+SetupHyphenChars(
+    TkTextSegment *segPtr,
+    unsigned offset)
+{
+    assert(offset <= 2); /* don't exceed 5 characters */
+
+    /*
+     * NOTE: U+2010 (HYPHEN) always has a visible rendition, but U+00AD
+     * (SOFT HYPHEN) is an invisible format character (per definition).
+     * And don't use '-' (U+002D = HYPHEN-MINUS), because the meaning of
+     * this character is contextual. So we have to use U+2010.
+     */
+
+    assert(segPtr->typePtr->group == SEG_GROUP_HYPHEN);
+    assert(sizeof(doNotBreakAtAll) >= 6); /* we need this break array for hyphens */
+
+    memcpy(segPtr->body.chars + offset, "\xe2\x80\x90", 4); /* U+2010 */
+    segPtr->body.hyphen.textSize = 3 + offset;
+}
+
+static bool
+IsDoubleDigraph(
+    char c1,
+    char c2)
+{
+    switch (c1) {
+	case 'c': /* fallthru */	/* c-cs -> cs-cs */
+	case 'z': return c2 == 's';	/* z-zs -> zs-zs */
+	case 'g': /* fallthru */	/* g-gy -> gy-gy */
+	case 'l': /* fallthru */	/* l-ly -> ly-ly */
+	case 'n': /* fallthru */	/* n-ny -> ny-ny */
+	case 't': return c2 == 'y';	/* t-ty -> ty-ty */
+	case 's': return c2 == 'z';	/* s-sz -> sz-sz */
+    }
+    return false;
+}
+
+static bool
+IsHyphenChunk(
+    const TkTextDispChunk *chunkPtr)
+{
+    assert(chunkPtr);
+    return chunkPtr->layoutProcs && chunkPtr->layoutProcs->type == TEXT_DISP_HYPHEN;
+}
+
+static bool
+IsCharChunk(
+    const TkTextDispChunk *chunkPtr)
+{
+    assert(chunkPtr);
+    return chunkPtr->layoutProcs && chunkPtr->layoutProcs->type == TEXT_DISP_CHAR;
+}
+
+static char
+GetLastCharInChunk(
+    const TkTextDispChunk *chunkPtr)
+{
+    const CharInfo *ciPtr;
+
+    if (!chunkPtr) {
+	return '\0';
+    }
+
+    assert(chunkPtr->layoutProcs);
+    assert(chunkPtr->clientData);
+
+    if (!IsCharChunk(chunkPtr)) {
+	return '\0';
+    }
+
+    ciPtr = chunkPtr->clientData;
+    assert(ciPtr->numBytes > 0);
+    return ciPtr->u.chars[ciPtr->baseOffset + ciPtr->numBytes - 1];
+}
+
+static char
+GetSecondLastCharInChunk(
+    const TkTextDispChunk *chunkPtr)
+{
+    const CharInfo *ciPtr;
+
+    if (!chunkPtr || !IsCharChunk(chunkPtr)) {
+	return '\0';
+    }
+
+    ciPtr = chunkPtr->clientData;
+    assert(chunkPtr->clientData);
+    assert(ciPtr->numBytes > 0);
+
+    if (ciPtr->numBytes > 1) {
+	return ciPtr->u.chars[ciPtr->baseOffset + ciPtr->numBytes - 2];
+    }
+    if ((chunkPtr = chunkPtr->prevCharChunkPtr) && IsCharChunk(chunkPtr)) {
+	ciPtr = chunkPtr->clientData;
+	assert(ciPtr->numBytes > 0);
+	return ciPtr->u.chars[ciPtr->baseOffset + ciPtr->numBytes - 1];
+    }
+
+    return '\0';
+}
+
+static int
+FilterHyphenRules(
+    int hyphenRules,
+    const char *lang)
+{
+    if (lang && hyphenRules) {
+	enum {
+	    CA_RULES = (1 << TK_TEXT_HYPHEN_GEMINATION),
+	    DE_RULES = (1 << TK_TEXT_HYPHEN_CK)|(1 << TK_TEXT_HYPHEN_TRIPLE_CONSONANT),
+	    HU_RULES = (1 << TK_TEXT_HYPHEN_DOUBLE_DIGRAPH),
+	    NL_RULES = (1 << TK_TEXT_HYPHEN_DOUBLE_VOWEL)|(1 << TK_TEXT_HYPHEN_TREMA),
+	    NO_RULES = (1 << TK_TEXT_HYPHEN_TRIPLE_CONSONANT),
+	    PL_RULES = (1 << TK_TEXT_HYPHEN_REPEAT),
+	    SV_RULES = (1 << TK_TEXT_HYPHEN_TRIPLE_CONSONANT)
+	};
+
+	switch (lang[0]) {
+	case 'c': if (lang[1] == 'a') { hyphenRules &= CA_RULES; }; break;
+	case 'd': if (lang[1] == 'e') { hyphenRules &= DE_RULES; }; break;
+	case 'h': if (lang[1] == 'u') { hyphenRules &= HU_RULES; }; break;
+	case 'p': if (lang[1] == 'l') { hyphenRules &= PL_RULES; }; break;
+	case 's': if (lang[1] == 'v') { hyphenRules &= SV_RULES; }; break;
+	case 'n':
+	    switch (lang[1]) {
+	    case 'b': /* fallthru */
+	    case 'n': /* fallthru */
+	    case 'o': hyphenRules &= NO_RULES; break;
+	    case 'l': hyphenRules &= NL_RULES; break;
+	    }
+	    break;
+	}
+    }
+
+    return hyphenRules;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextPendingSync --
+ *
+ *	This function checks if any line heights are not up-to-date.
+ *
+ * Results:
+ *	Returns boolean 'true' if it is the case, or 'false' if all line
+ *      heights are up-to-date.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+bool
+TkTextPendingSync(
+    const TkText *textPtr)	/* Information about text widget. */
+{
+    /*
+     * NOTE: We cannot use
+     *
+     *    !TkRangeListIsEmpty(textPtr->dInfoPtr->lineMetricUpdateRanges)
+     *
+     * because this statement does not guarantee that TkTextRunAfterSyncCmd has
+     * been triggered, and we need the state after triggering.
+     */
+
+    return !!(textPtr->dInfoPtr->flags & (ASYNC_UPDATE|ASYNC_PENDING));
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TestIfLinesUpToDate --
+ *
+ *	This function checks whether the lines up to given index
+ *	position (inclusive) is up-to-date.
+ *
+ * Results:
+ *	Returns boolean 'true' if it is the case, or 'false' if these
+ *      line heights aren't up-to-date.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+TestIfLinesUpToDate(
+    const TkTextIndex *indexPtr)	/* last line of range (inclusive) */
+{
+    const TkRangeList *ranges;
+
+    assert(indexPtr->textPtr);
+
+    ranges = indexPtr->textPtr->dInfoPtr->lineMetricUpdateRanges;
+
+    if (TkRangeListIsEmpty(ranges)) {
+	return true;
+    }
+
+    return TkTextIndexGetLineNumber(indexPtr, indexPtr->textPtr) < TkRangeListLow(ranges);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * InvokeAsyncUpdateYScrollbar --
+ *
+ *	This function invokes the update of the vertical scrollbar.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+InvokeAsyncUpdateYScrollbar(
+    TkText *textPtr)
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+    assert(!dInfoPtr->scrollbarTimer);
+
+    if (textPtr->syncTime == 0) {
+	AsyncUpdateYScrollbar(textPtr);
+    } else {
+	textPtr->refCount += 1;
+	dInfoPtr->scrollbarTimer = Tcl_CreateTimerHandler(textPtr->syncTime,
+		AsyncUpdateYScrollbar, textPtr);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * InvokeAsyncUpdateLineMetrics --
+ *
+ *	This function invokes the update of the line metric calculation.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+InvokeAsyncUpdateLineMetrics(
+    TkText *textPtr)
+{
+    assert(textPtr->sharedTextPtr->allowUpdateLineMetrics);
+
+    if (textPtr->syncTime > 0) {
+	TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+	if (!dInfoPtr->lineUpdateTimer) {
+	    textPtr->refCount += 1;
+	    dInfoPtr->lineUpdateTimer = Tcl_CreateTimerHandler(1, AsyncUpdateLineMetrics, textPtr);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextCreateDInfo --
+ *
+ *	This function is called when a new text widget is created. Its job is
+ *	to set up display-related information for the widget.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	A TextDInfo data structure is allocated and initialized and attached
+ *	to textPtr.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+SetupEolSegment(
+    TkText *textPtr,
+    TextDInfo *dInfoPtr)
+{
+    char eolChar[10];
+    Tcl_UniChar uc;
+    const char *p = textPtr->eolCharPtr ? Tcl_GetString(textPtr->eolCharPtr) : NULL;
+    int len;
+
+    if (!p || !*p) { p = "\xc2\xb6"; /* U+00B6 = PILCROW SIGN */ }
+    len = Tcl_UtfToUniChar(p, &uc);
+    strcpy(eolChar, p);
+    strcpy(eolChar + len, "\n");
+    if (dInfoPtr->endOfLineSegPtr) {
+	TkBTreeFreeSegment(dInfoPtr->endOfLineSegPtr);
+    }
+    dInfoPtr->endOfLineSegPtr = TkBTreeMakeCharSegment(
+	    eolChar, len + 1, textPtr->sharedTextPtr->emptyTagInfoPtr);
+}
+
+void
+TkTextCreateDInfo(
+    TkText *textPtr)	/* Overall information for text widget. */
+{
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    TkTextBTree tree = sharedTextPtr->tree;
+    TextDInfo *dInfoPtr;
+    XGCValues gcValues;
+    bool isMonospaced;
+
+    dInfoPtr = memset(malloc(sizeof(TextDInfo)), 0, sizeof(TextDInfo));
+    Tcl_InitHashTable(&dInfoPtr->styleTable, sizeof(StyleValues)/sizeof(int));
+    dInfoPtr->copyGC = None;
+    gcValues.graphics_exposures = True;
+    dInfoPtr->scrollGC = Tk_GetGC(textPtr->tkwin, GCGraphicsExposures, &gcValues);
+    dInfoPtr->insertFgGC = None;
+    dInfoPtr->xScrollFirst = -1;
+    dInfoPtr->xScrollLast = -1;
+    dInfoPtr->yScrollFirst = -1;
+    dInfoPtr->yScrollLast = -1;
+    dInfoPtr->topLineNo = -1;
+    dInfoPtr->topByteIndex = -1;
+    dInfoPtr->flags = DINFO_OUT_OF_DATE;
+    dInfoPtr->lineMetricUpdateRanges = TkRangeListCreate(64);
+    dInfoPtr->firstLineNo = TkBTreeLinesTo(tree, NULL, TkBTreeGetStartLine(textPtr), NULL);
+    dInfoPtr->lastLineNo = TkBTreeLinesTo(tree, NULL, TkBTreeGetLastLine(textPtr), NULL);
+    dInfoPtr->lineMetricUpdateEpoch = 1;
+    dInfoPtr->strBufferSize = 512;
+    dInfoPtr->strBuffer = malloc(dInfoPtr->strBufferSize);
+    TkTextIndexClear(&dInfoPtr->metricIndex, textPtr);
+    TkTextIndexClear(&dInfoPtr->currChunkIndex, textPtr);
+    SetupEolSegment(textPtr, dInfoPtr);
+
+    if (textPtr->state == TK_TEXT_STATE_NORMAL
+	    && textPtr->blockCursorType
+	    && textPtr->showInsertFgColor) {
+	XGCValues gcValues;
+	gcValues.foreground = textPtr->insertFgColorPtr->pixel;
+	dInfoPtr->insertFgGC = Tk_GetGC(textPtr->tkwin, GCForeground, &gcValues);
+    }
+
+    /*
+     * Note: Setup of defaultStyle must be postponed.
+     */
+
+    textPtr->dInfoPtr = dInfoPtr;
+    isMonospaced = UseMonospacedLineHeights(textPtr);
+
+    if (isMonospaced) {
+	TkBTreeUpdatePixelHeights(textPtr, TkBTreeGetStartLine(textPtr), 1,
+		dInfoPtr->lineMetricUpdateEpoch);
+    } else {
+	dInfoPtr->lineMetricUpdateRanges = TkRangeListAdd(dInfoPtr->lineMetricUpdateRanges, 0, 0);
+    }
+
+    if (!sharedTextPtr->breakInfoTableIsInitialized) {
+	Tcl_InitHashTable(&sharedTextPtr->breakInfoTable, TCL_ONE_WORD_KEYS);
+	sharedTextPtr->breakInfoTableIsInitialized = true;
+    }
+
+    if (sharedTextPtr->allowUpdateLineMetrics) {
+	if (!isMonospaced) {
+	    InvokeAsyncUpdateLineMetrics(textPtr);
+	}
+	InvokeAsyncUpdateYScrollbar(textPtr);
+    }
+
+#if TK_CHECK_ALLOCS
+    if (hookStatFunc) {
+	atexit(AllocStatistic);
+	hookStatFunc = false;
+    }
+#endif
+#if !NDEBUG
+    if (!stats.perfFuncIsHooked) {
+	atexit(PerfStatistic);
+	stats.perfFuncIsHooked = true;
+    }
+#endif
+}
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextDeleteBreakInfoTableEntries --
+ *
+ *	Delete all cached break information. Normally this table will
+ *	be empty when this function is called, but under some specific
+ *	conditions the given table will not be empty - this will only
+ *	happen if a tag redraw action has been interrupted, and this
+ *	will be seldom the case.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Some resources might be freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextDeleteBreakInfoTableEntries(
+    Tcl_HashTable *breakInfoTable)
+{
+    Tcl_HashSearch search;
+    Tcl_HashEntry *hPtr;
+
+    assert(breakInfoTable);
+
+    for (hPtr = Tcl_FirstHashEntry(breakInfoTable, &search); hPtr; hPtr = Tcl_NextHashEntry(&search)) {
+	BreakInfo *breakInfo = Tcl_GetHashValue(hPtr);
+
+	assert(breakInfo->brks);
+	free(breakInfo->brks);
+	free(breakInfo);
+	DEBUG_ALLOC(tkTextCountDestroyBreakInfo++);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextFreeDInfo --
+ *
+ *	This function is called to free up all of the private display
+ *	information kept by this file for a text widget.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Lots of resources get freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextFreeDInfo(
+    TkText *textPtr)		/* Overall information for text widget. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    TkTextDispChunk *chunkPtr;
+    TkTextDispChunkSection *sectionPtr;
+    DLine *dlPtr;
+    CharInfo *ciPtr;
+
+    /*
+     * Cancel pending events.
+     */
+
+    if (dInfoPtr->pendingUpdateLineMetricsFinished) {
+	Tcl_CancelIdleCall(RunUpdateLineMetricsFinished, (ClientData) textPtr);
+    }
+    if (dInfoPtr->flags & REDRAW_PENDING) {
+	Tcl_CancelIdleCall(DisplayText, textPtr);
+    }
+
+    /*
+     * Be careful to free up styleTable *after* freeing up all the DLines, so
+     * that the hash table is still intact to free up the style-related
+     * information from the lines. Once the lines are all free then styleTable
+     * will be empty.
+     */
+
+    FreeDLines(textPtr, dInfoPtr->dLinePtr, NULL, DLINE_UNLINK);
+    FreeDLines(textPtr, dInfoPtr->savedDLinePtr, NULL, DLINE_FREE_TEMP);
+    FreeDLines(textPtr, NULL, NULL, DLINE_CACHE);  /* release cached lines */
+    FreeDLines(textPtr, NULL, NULL, DLINE_METRIC); /* release cached lines */
+
+    if (dInfoPtr->copyGC != None) {
+	Tk_FreeGC(textPtr->display, dInfoPtr->copyGC);
+    }
+    Tk_FreeGC(textPtr->display, dInfoPtr->scrollGC);
+    if (dInfoPtr->insertFgGC != None) {
+	Tk_FreeGC(textPtr->display, dInfoPtr->insertFgGC);
+    }
+    if (dInfoPtr->lineUpdateTimer) {
+	Tcl_DeleteTimerHandler(dInfoPtr->lineUpdateTimer);
+	textPtr->refCount -= 1;
+	dInfoPtr->lineUpdateTimer = NULL;
+    }
+    if (dInfoPtr->scrollbarTimer) {
+	Tcl_DeleteTimerHandler(dInfoPtr->scrollbarTimer);
+	textPtr->refCount -= 1;
+	dInfoPtr->scrollbarTimer = NULL;
+    }
+    if (dInfoPtr->repickTimer) {
+	Tcl_DeleteTimerHandler(dInfoPtr->repickTimer);
+	textPtr->refCount -= 1;
+	dInfoPtr->repickTimer = NULL;
+    }
+    ciPtr = dInfoPtr->charInfoPoolPtr;
+    while (ciPtr) {
+	CharInfo *nextPtr = ciPtr->u.next;
+	free(ciPtr);
+	DEBUG_ALLOC(tkTextCountDestroyCharInfo++);
+	ciPtr = nextPtr;
+    }
+    sectionPtr = dInfoPtr->sectionPoolPtr;
+    while (sectionPtr) {
+	TkTextDispChunkSection *nextPtr = sectionPtr->nextPtr;
+	free(sectionPtr);
+	DEBUG_ALLOC(tkTextCountDestroySection++);
+	sectionPtr = nextPtr;
+    }
+    chunkPtr = dInfoPtr->chunkPoolPtr;
+    while (chunkPtr) {
+	TkTextDispChunk *nextPtr = chunkPtr->nextPtr;
+	free(chunkPtr);
+	DEBUG_ALLOC(tkTextCountDestroyChunk++);
+	chunkPtr = nextPtr;
+    }
+    dlPtr = dInfoPtr->dLinePoolPtr;
+    while (dlPtr) {
+	DLine *nextPtr = dlPtr->nextPtr;
+	free(dlPtr);
+	DEBUG_ALLOC(tkTextCountDestroyDLine++);
+	dlPtr = nextPtr;
+    }
+    if (dInfoPtr->defaultStyle) {
+#if 0
+	/*
+	 * TODO: The following assertion sometimes fails. Luckily it doesn't matter,
+	 * because it will be freed anyway, but why can it fail (and only sometimes)?
+	 */
+	 DEBUG_ALLOC(assert(dInfoPtr->defaultStyle->refCount == 1));
+#endif
+	FreeStyle(textPtr, dInfoPtr->defaultStyle);
+    }
+    Tcl_DeleteHashTable(&dInfoPtr->styleTable);
+    TkRangeListDestroy(&dInfoPtr->lineMetricUpdateRanges);
+    TkBTreeFreeSegment(dInfoPtr->endOfLineSegPtr);
+    free(dInfoPtr->strBuffer);
+    free(dInfoPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextResetDInfo --
+ *
+ *	This function will be called when the whole text has been deleted.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Line metrics will be updated.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextResetDInfo(
+    TkText *textPtr)	/* Overall information for text widget. */
+{
+    TextDInfo *dInfoPtr;
+    TkSharedText *sharedTextPtr;
+    TkTextIndex index1, index2;
+    unsigned lineNo1, lineNo2;
+
+    if (UseMonospacedLineHeights(textPtr)) {
+	return; /* already synchronized */
+    }
+
+    dInfoPtr = textPtr->dInfoPtr;
+    sharedTextPtr = textPtr->sharedTextPtr;
+
+    TkTextIndexSetupToStartOfText(&index1, textPtr, sharedTextPtr->tree);
+    TkTextIndexSetupToEndOfText(&index2, textPtr, sharedTextPtr->tree);
+    TkTextChanged(sharedTextPtr, NULL, &index1, &index2);
+
+    lineNo1 = TkBTreeLinesTo(sharedTextPtr->tree, textPtr, TkTextIndexGetLine(&index1), NULL);
+    lineNo2 = TkBTreeLinesTo(sharedTextPtr->tree, textPtr, TkTextIndexGetLine(&index2), NULL);
+
+    assert(lineNo1 < lineNo2);
+
+    TkRangeListClear(dInfoPtr->lineMetricUpdateRanges);
+    dInfoPtr->lineMetricUpdateRanges =
+	    TkRangeListAdd(dInfoPtr->lineMetricUpdateRanges, lineNo1, lineNo2 - 1);
+    dInfoPtr->lineMetricUpdateEpoch = 1;
+    dInfoPtr->topLineNo = -1;
+    dInfoPtr->topByteIndex = -1;
+
+    if (textPtr->sharedTextPtr->allowUpdateLineMetrics) {
+	TkTextUpdateLineMetrics(textPtr, lineNo1, lineNo2);
+    }
+
+    FreeDLines(textPtr, NULL, NULL, DLINE_CACHE);  /* release cached lines */
+    FreeDLines(textPtr, NULL, NULL, DLINE_METRIC); /* release cached lines */
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetStyle --
+ *
+ *	This function creates all the information needed to display text at a
+ *	particular location.
+ *
+ * Results:
+ *	The return value is a pointer to a TextStyle structure that
+ *	corresponds to *sValuePtr.
+ *
+ * Side effects:
+ *	A new entry may be created in the style table for the widget.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TextStyle *
+MakeStyle(
+    TkText *textPtr,
+    TkTextTag *tagPtr)
+{
+    StyleValues styleValues;
+    TextStyle *stylePtr;
+    Tcl_HashEntry *hPtr;
+    int isNew;
+    bool isSelected;
+    XGCValues gcValues;
+    unsigned long mask;
+
+    /*
+     * The variables below keep track of the highest-priority specification
+     * that has occurred for each of the various fields of the StyleValues.
+     */
+
+    int borderPrio = -1, borderWidthPrio = -1, reliefPrio = -1;
+    int bgStipplePrio = -1, indentBgPrio = -1;
+    int fgPrio = -1, fontPrio = -1, fgStipplePrio = -1;
+    int underlinePrio = -1, elidePrio = -1, justifyPrio = -1, offsetPrio = -1;
+    int lMargin1Prio = -1, lMargin2Prio = -1, rMarginPrio = -1;
+    int lMarginColorPrio = -1, rMarginColorPrio = -1;
+    int spacing1Prio = -1, spacing2Prio = -1, spacing3Prio = -1;
+    int overstrikePrio = -1, tabPrio = -1, tabStylePrio = -1;
+    int wrapPrio = -1, langPrio = -1, hyphenRulesPrio = -1;
+    int eolColorPrio = -1, hyphenColorPrio = -1;
+
+    /*
+     * Find out what tags are present for the character, then compute a
+     * StyleValues structure corresponding to those tags (scan through all of
+     * the tags, saving information for the highest-priority tag).
+     */
+
+    memset(&styleValues, 0, sizeof(StyleValues));
+    styleValues.relief = TK_RELIEF_FLAT;
+    styleValues.fgColor = textPtr->fgColor;
+    styleValues.eolColor = textPtr->eolColor;
+    styleValues.hyphenColor = textPtr->hyphenColor;
+    styleValues.underlineColor = textPtr->fgColor;
+    styleValues.overstrikeColor = textPtr->fgColor;
+    styleValues.tkfont = textPtr->tkfont;
+    styleValues.justify = textPtr->justify;
+    styleValues.spacing1 = textPtr->spacing1;
+    styleValues.spacing2 = textPtr->spacing2;
+    styleValues.spacing3 = textPtr->spacing3;
+    styleValues.tabArrayPtr = textPtr->tabArrayPtr;
+    styleValues.tabStyle = textPtr->tabStyle;
+    styleValues.wrapMode = textPtr->wrapMode;
+    styleValues.lang = textPtr->lang;
+    styleValues.hyphenRules = textPtr->hyphenRulesPtr ? textPtr->hyphenRules : TK_TEXT_HYPHEN_MASK;
+
+    isSelected = false;
+
+    for ( ; tagPtr; tagPtr = tagPtr->nextPtr) {
+	Tk_3DBorder border;
+        XColor *fgColor;
+
+	border = tagPtr->border;
+        fgColor = tagPtr->fgColor;
+
+	/*
+	 * If this is the selection tag, and inactiveSelBorder is NULL (the
+	 * default on Windows), then we need to skip it if we don't have the
+	 * focus.
+	 */
+
+	if (tagPtr == textPtr->selTagPtr && !(textPtr->flags & HAVE_FOCUS)) {
+	    if (!textPtr->inactiveSelBorder) {
+		continue;
+	    }
+#ifdef MAC_OSX_TK
+	    /* Don't show inactive selection in disabled widgets. */
+	    if (textPtr->state == TK_TEXT_STATE_DISABLED) {
+		continue;
+	    }
+#endif
+	    border = textPtr->inactiveSelBorder;
+	}
+
+        if (tagPtr->selBorder && isSelected) {
+            border = tagPtr->selBorder;
+        }
+        if (tagPtr->selFgColor != None && isSelected) {
+            fgColor = tagPtr->selFgColor;
+        }
+	if (border && tagPtr->priority > borderPrio) {
+	    styleValues.border = border;
+	    borderPrio = tagPtr->priority;
+	}
+	if (tagPtr->borderWidthPtr
+		&& Tcl_GetString(tagPtr->borderWidthPtr)[0] != '\0'
+		&& tagPtr->priority > borderWidthPrio) {
+	    styleValues.borderWidth = tagPtr->borderWidth;
+	    borderWidthPrio = tagPtr->priority;
+	}
+	if (tagPtr->reliefString && tagPtr->priority > reliefPrio) {
+	    if (!styleValues.border) {
+		styleValues.border = textPtr->border;
+	    }
+	    assert(tagPtr->relief < 8);
+	    styleValues.relief = tagPtr->relief;
+	    reliefPrio = tagPtr->priority;
+	}
+	if (tagPtr->bgStipple != None && tagPtr->priority > bgStipplePrio) {
+	    styleValues.bgStipple = tagPtr->bgStipple;
+	    bgStipplePrio = tagPtr->priority;
+	}
+	if (tagPtr->indentBgString != None && tagPtr->priority > indentBgPrio) {
+	    assert(tagPtr->indentBg <= 1);
+	    styleValues.indentBg = tagPtr->indentBg;
+	    indentBgPrio = tagPtr->priority;
+	}
+	if (fgColor != None && tagPtr->priority > fgPrio) {
+	    styleValues.fgColor = fgColor;
+	    fgPrio = tagPtr->priority;
+	}
+	if (tagPtr->tkfont != None && tagPtr->priority > fontPrio) {
+	    styleValues.tkfont = tagPtr->tkfont;
+	    fontPrio = tagPtr->priority;
+	}
+	if (tagPtr->fgStipple != None && tagPtr->priority > fgStipplePrio) {
+	    styleValues.fgStipple = tagPtr->fgStipple;
+	    fgStipplePrio = tagPtr->priority;
+	}
+	if (tagPtr->justifyString && tagPtr->priority > justifyPrio) {
+	    /* assert(tagPtr->justify < 8); always true due to range */
+	    styleValues.justify = tagPtr->justify;
+	    justifyPrio = tagPtr->priority;
+	}
+	if (tagPtr->lMargin1String && tagPtr->priority > lMargin1Prio) {
+	    styleValues.lMargin1 = tagPtr->lMargin1;
+	    lMargin1Prio = tagPtr->priority;
+	}
+	if (tagPtr->lMargin2String && tagPtr->priority > lMargin2Prio) {
+	    styleValues.lMargin2 = tagPtr->lMargin2;
+	    lMargin2Prio = tagPtr->priority;
+	}
+	if (tagPtr->lMarginColor && tagPtr->priority > lMarginColorPrio) {
+	    styleValues.lMarginColor = tagPtr->lMarginColor;
+	    lMarginColorPrio = tagPtr->priority;
+	}
+	if (tagPtr->offsetString && tagPtr->priority > offsetPrio) {
+	    styleValues.offset = tagPtr->offset;
+	    offsetPrio = tagPtr->priority;
+	}
+	if (tagPtr->overstrikeString && tagPtr->priority > overstrikePrio) {
+	    assert(tagPtr->overstrike <= 1);
+	    styleValues.overstrike = tagPtr->overstrike;
+	    overstrikePrio = tagPtr->priority;
+            if (tagPtr->overstrikeColor != None) {
+                 styleValues.overstrikeColor = tagPtr->overstrikeColor;
+            } else if (fgColor != None) {
+                 styleValues.overstrikeColor = fgColor;
+            }
+	}
+	if (tagPtr->rMarginString && tagPtr->priority > rMarginPrio) {
+	    styleValues.rMargin = tagPtr->rMargin;
+	    rMarginPrio = tagPtr->priority;
+	}
+	if (tagPtr->rMarginColor && tagPtr->priority > rMarginColorPrio) {
+	    styleValues.rMarginColor = tagPtr->rMarginColor;
+	    rMarginColorPrio = tagPtr->priority;
+	}
+	if (tagPtr->spacing1String && tagPtr->priority > spacing1Prio) {
+	    styleValues.spacing1 = tagPtr->spacing1;
+	    spacing1Prio = tagPtr->priority;
+	}
+	if (tagPtr->spacing2String && tagPtr->priority > spacing2Prio) {
+	    styleValues.spacing2 = tagPtr->spacing2;
+	    spacing2Prio = tagPtr->priority;
+	}
+	if (tagPtr->spacing3String && tagPtr->priority > spacing3Prio) {
+	    styleValues.spacing3 = tagPtr->spacing3;
+	    spacing3Prio = tagPtr->priority;
+	}
+	if (tagPtr->tabStringPtr && tagPtr->priority > tabPrio) {
+	    styleValues.tabArrayPtr = tagPtr->tabArrayPtr;
+	    tabPrio = tagPtr->priority;
+	}
+	if (tagPtr->tabStyle != TK_TEXT_TABSTYLE_NONE && tagPtr->priority > tabStylePrio) {
+	    assert(tagPtr->tabStyle < 8);
+	    styleValues.tabStyle = tagPtr->tabStyle;
+	    tabStylePrio = tagPtr->priority;
+	}
+	if (tagPtr->eolColor && tagPtr->priority > eolColorPrio) {
+	    styleValues.eolColor = tagPtr->eolColor;
+	    eolColorPrio = tagPtr->priority;
+	}
+	if (tagPtr->hyphenColor && tagPtr->priority > hyphenColorPrio) {
+	    styleValues.hyphenColor = tagPtr->hyphenColor;
+	    hyphenColorPrio = tagPtr->priority;
+	}
+	if (tagPtr->underlineString && tagPtr->priority > underlinePrio) {
+	    assert(tagPtr->underline <= 1);
+	    styleValues.underline = tagPtr->underline;
+	    underlinePrio = tagPtr->priority;
+            if (tagPtr->underlineColor != None) {
+		styleValues.underlineColor = tagPtr->underlineColor;
+            } else if (fgColor != None) {
+		styleValues.underlineColor = fgColor;
+            }
+	}
+	if (tagPtr->elideString && tagPtr->priority > elidePrio) {
+	    assert(tagPtr->elide <= 1);
+	    styleValues.elide = tagPtr->elide;
+	    elidePrio = tagPtr->priority;
+	}
+	if (tagPtr->langPtr && tagPtr->priority > langPrio) {
+	    styleValues.lang = tagPtr->lang;
+	    langPrio = tagPtr->priority;
+	}
+	if (tagPtr->hyphenRulesPtr && tagPtr->priority > hyphenRulesPrio) {
+	    styleValues.hyphenRules = tagPtr->hyphenRules;
+	    hyphenRulesPrio = tagPtr->priority;
+	}
+	if (tagPtr->wrapMode != TEXT_WRAPMODE_NULL && tagPtr->priority > wrapPrio) {
+	    /* assert(tagPtr->wrapMode < 8); always true due to range */
+	    styleValues.wrapMode = tagPtr->wrapMode;
+	    wrapPrio = tagPtr->priority;
+	}
+    }
+
+    /*
+     * Use an existing style if there's one around that matches.
+     */
+
+    hPtr = Tcl_CreateHashEntry(&textPtr->dInfoPtr->styleTable, (char *) &styleValues, &isNew);
+    if (!isNew) {
+	return Tcl_GetHashValue(hPtr);
+    }
+
+    /*
+     * No existing style matched. Make a new one.
+     */
+
+    stylePtr = malloc(sizeof(TextStyle));
+    stylePtr->refCount = 0;
+    if (styleValues.border) {
+	gcValues.foreground = Tk_3DBorderColor(styleValues.border)->pixel;
+	mask = GCForeground;
+	if (styleValues.bgStipple != None) {
+	    gcValues.stipple = styleValues.bgStipple;
+	    gcValues.fill_style = FillStippled;
+	    mask |= GCStipple|GCFillStyle;
+	}
+	stylePtr->bgGC = Tk_GetGC(textPtr->tkwin, mask, &gcValues);
+    } else {
+	stylePtr->bgGC = None;
+    }
+    mask = GCFont;
+    gcValues.font = Tk_FontId(styleValues.tkfont);
+    mask |= GCForeground;
+    if (styleValues.eolColor) {
+	gcValues.foreground = styleValues.eolColor->pixel;
+	stylePtr->eolGC = Tk_GetGC(textPtr->tkwin, mask, &gcValues);
+    } else {
+	stylePtr->eolGC = None;
+    }
+    if (styleValues.hyphenColor) {
+	gcValues.foreground = styleValues.hyphenColor->pixel;
+	stylePtr->hyphenGC = Tk_GetGC(textPtr->tkwin, mask, &gcValues);
+    } else {
+	stylePtr->hyphenGC = None;
+    }
+    gcValues.foreground = styleValues.fgColor->pixel;
+    if (styleValues.fgStipple != None) {
+	gcValues.stipple = styleValues.fgStipple;
+	gcValues.fill_style = FillStippled;
+	mask |= GCStipple|GCFillStyle;
+    }
+    stylePtr->fgGC = Tk_GetGC(textPtr->tkwin, mask, &gcValues);
+    mask = GCForeground;
+    gcValues.foreground = styleValues.underlineColor->pixel;
+    stylePtr->ulGC = Tk_GetGC(textPtr->tkwin, mask, &gcValues);
+    gcValues.foreground = styleValues.overstrikeColor->pixel;
+    stylePtr->ovGC = Tk_GetGC(textPtr->tkwin, mask, &gcValues);
+    stylePtr->sValuePtr = (StyleValues *) Tcl_GetHashKey(&textPtr->dInfoPtr->styleTable, hPtr);
+    stylePtr->hPtr = hPtr;
+    Tcl_SetHashValue(hPtr, stylePtr);
+    DEBUG_ALLOC(tkTextCountNewStyle++);
+    return stylePtr;
+}
+
+static TextStyle *
+GetStyle(
+    TkText *textPtr,		/* Overall information about text widget. */
+    TkTextSegment *segPtr)	/* The text for which display information is wanted. */
+{
+    TextStyle *stylePtr;
+    TkTextTag *tagPtr;
+
+    if (segPtr && (tagPtr = TkBTreeGetSegmentTags(textPtr->sharedTextPtr, segPtr, textPtr))) {
+	stylePtr = MakeStyle(textPtr, tagPtr);
+    } else {
+	/*
+	 * Take into account that this function can be called before UpdateDefaultStyle
+	 * has been called for the first time.
+	 */
+	if (!textPtr->dInfoPtr->defaultStyle) {
+	    UpdateDefaultStyle(textPtr);
+	}
+	stylePtr = textPtr->dInfoPtr->defaultStyle;
+    }
+
+    stylePtr->refCount += 1;
+    return stylePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UpdateDefaultStyle --
+ *
+ *	This function is called if something has changed, and some DLines
+ *	have to be updated.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+UpdateDefaultStyle(
+    TkText *textPtr)
+{
+    TextStyle *stylePtr = MakeStyle(textPtr, NULL);
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+    if (stylePtr != dInfoPtr->defaultStyle) {
+	if (dInfoPtr->defaultStyle) {
+	    FreeStyle(textPtr, dInfoPtr->defaultStyle);
+	}
+	dInfoPtr->defaultStyle = stylePtr;
+	stylePtr->refCount += 1;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FreeStyle --
+ *
+ *	This function is called when a TextStyle structure is no longer
+ *	needed. It decrements the reference count and frees up the space for
+ *	the style structure if the reference count is 0.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The storage and other resources associated with the style are freed up
+ *	if no-one's still using it.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+FreeStyle(
+    TkText *textPtr,		/* Information about overall widget. */
+    TextStyle *stylePtr)	/* Information about style to free. */
+{
+    assert(stylePtr);
+    assert(stylePtr->refCount > 0);
+
+    if (--stylePtr->refCount == 0) {
+	if (stylePtr->bgGC != None) {
+	    Tk_FreeGC(textPtr->display, stylePtr->bgGC);
+	}
+	if (stylePtr->fgGC != None) {
+	    Tk_FreeGC(textPtr->display, stylePtr->fgGC);
+	}
+	if (stylePtr->ulGC != None) {
+	    Tk_FreeGC(textPtr->display, stylePtr->ulGC);
+	}
+	if (stylePtr->ovGC != None) {
+	    Tk_FreeGC(textPtr->display, stylePtr->ovGC);
+	}
+	if (stylePtr->eolGC != None) {
+	    Tk_FreeGC(textPtr->display, stylePtr->eolGC);
+	}
+	if (stylePtr->hyphenGC != None) {
+	    Tk_FreeGC(textPtr->display, stylePtr->hyphenGC);
+	}
+	Tcl_DeleteHashEntry(stylePtr->hPtr);
+	free(stylePtr);
+	DEBUG_ALLOC(tkTextCountDestroyStyle++);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * IsStartOfNotMergedLine --
+ *
+ *	This function checks whether the given index is the start of a
+ *      logical line that is not merged with the previous logical line
+ *      (due to elision of the eol of the previous line).
+ *
+ * Results:
+ *	Returns whether the given index denotes the first index of a
+ *      logical line not merged with its previous line.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+IsStartOfNotMergedLine(
+      const TkTextIndex *indexPtr)  /* Index to check. */
+{
+    return TkTextIndexGetLine(indexPtr)->logicalLine
+	    ? TkTextIndexIsStartOfLine(indexPtr)
+	    : TkTextIndexIsStartOfText(indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * IsSameFGStyle --
+ *
+ *	Compare the foreground attributes of two styles. Specifically must
+ *	consider: foreground color, font, font style and font decorations,
+ *	elide, "offset" and foreground stipple. Do *not* consider: background
+ *	color, border, relief or background stipple.
+ *
+ *	If we use TkpDrawCharsInContext, we also don't need to check
+ *	foreground color, font decorations, elide, offset and foreground
+ *	stipple, so all that is left is font (including font size and font
+ *	style) and "offset".
+ *
+ * Results:
+ *	'true' if the two styles match, 'false' otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+
+static bool
+IsSameFGStyle(
+    TextStyle *style1,
+    TextStyle *style2)
+{
+    StyleValues *sv1;
+    StyleValues *sv2;
+
+    if (style1 == style2) {
+	return true;
+    }
+
+    sv1 = style1->sValuePtr;
+    sv2 = style2->sValuePtr;
+
+    return sv1->tkfont == sv2->tkfont && sv1->offset == sv2->offset;
+}
+
+#endif /* TK_LAYOUT_WITH_BASE_CHUNKS */
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * LayoutDLine --
+ *
+ *	This function generates a single DLine structure for a display line
+ *	whose leftmost character is given by indexPtr.
+ *
+ * Results:
+ *	The return value is a pointer to a DLine structure describing the
+ *	display line. All fields are filled in and correct except for y and
+ *	nextPtr.
+ *
+ * Side effects:
+ *	Storage is allocated for the new DLine.
+ *
+ *	See the comments in 'GetYView' for some thoughts on what the side-
+ *	effects of this call (or its callers) should be; the synchronisation
+ *	of TkTextLine->pixelHeight with the sum of the results of this
+ *	function operating on all display lines within each logical line.
+ *	Ideally the code should be refactored to ensure the cached pixel
+ *	height is never behind what is known when this function is called
+ *	elsewhere.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextSegment *
+LayoutGetNextSegment(
+    TkTextSegment *segPtr)
+{
+    while ((segPtr = segPtr->nextPtr)) {
+	if (segPtr->typePtr == &tkTextCharType) {
+	    return segPtr;
+	}
+	if (segPtr->typePtr == &tkTextBranchType) {
+	    segPtr = segPtr->body.branch.nextPtr;
+	}
+    }
+    return NULL;
+}
+
+static TkTextDispChunk *
+LayoutGetNextCharChunk(
+    TkTextDispChunk *chunkPtr)
+{
+    while ((chunkPtr = chunkPtr->nextPtr)) {
+	switch (chunkPtr->layoutProcs->type) {
+	case TEXT_DISP_CHAR:	return chunkPtr;
+	case TEXT_DISP_WINDOW:	/* fallthru */
+	case TEXT_DISP_IMAGE:	return NULL;
+	case TEXT_DISP_HYPHEN:	/* fallthru */
+	case TEXT_DISP_ELIDED:	/* fallthru */
+	case TEXT_DISP_CURSOR:	break;
+	}
+    }
+    return NULL;
+}
+
+static void
+LayoutSetupDispLineInfo(
+    TkTextPixelInfo *pixelInfo)
+{
+    TkTextDispLineInfo *dispLineInfo = pixelInfo->dispLineInfo;
+    unsigned oldNumDispLines = TkBTreeGetNumberOfDisplayLines(pixelInfo);
+
+    if (!dispLineInfo) {
+	dispLineInfo = malloc(TEXT_DISPLINEINFO_SIZE(2));
+	DEBUG(memset(dispLineInfo, 0xff, TEXT_DISPLINEINFO_SIZE(2)));
+	DEBUG_ALLOC(tkTextCountNewDispInfo++);
+	pixelInfo->dispLineInfo = dispLineInfo;
+    }
+
+    dispLineInfo->numDispLines = 1;
+    /* remember old display line count, see TkBTreeGetNumberOfDisplayLines */
+    dispLineInfo->entry[1].pixels = oldNumDispLines;
+}
+
+static void
+LayoutUpdateLineHeightInformation(
+    const LayoutData *data,
+    DLine *dlPtr,
+    TkTextLine *linePtr,	/* The corresponding logical line. */
+    bool finished,		/* Did we finish the layout of a complete logical line? */
+    int hyphenRule)		/* Applied hyphen rule; zero if no rule has been applied. */
+{
+    TkText *textPtr = data->textPtr;
+    unsigned epoch = textPtr->dInfoPtr->lineMetricUpdateEpoch;
+    TkTextPixelInfo *pixelInfo = TkBTreeLinePixelInfo(textPtr, linePtr);
+    unsigned oldNumDispLines = TkBTreeGetNumberOfDisplayLines(pixelInfo);
+    TkTextDispLineInfo *dispLineInfo;
+    TkTextLine *nextLogicalLinePtr;
+
+    assert(dlPtr->byteCount > 0);
+    assert(dlPtr->displayLineNo >= 0);
+    assert(linePtr->logicalLine);
+    assert(linePtr == TkBTreeGetLogicalLine(
+	    textPtr->sharedTextPtr, textPtr, TkTextIndexGetLine(&dlPtr->index)));
+
+    if (pixelInfo->epoch == epoch) {
+	int lineNo = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, linePtr, NULL);
+
+	if (TkRangeListContains(textPtr->dInfoPtr->lineMetricUpdateRanges, lineNo)) {
+	    int mergedLines = 1;
+
+	    nextLogicalLinePtr = TkBTreeNextLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+	    if (linePtr->nextPtr != nextLogicalLinePtr) {
+		mergedLines = TkBTreeCountLines(textPtr->sharedTextPtr->tree, linePtr,
+			nextLogicalLinePtr) - 1;
+	    }
+	    TkRangeListRemove(textPtr->dInfoPtr->lineMetricUpdateRanges, lineNo, lineNo + mergedLines);
+	}
+
+	return; /* already up-to-date */
+    }
+
+    TK_TEXT_DEBUG(LogTextHeightCalc(textPtr, &dlPtr->index));
+    dispLineInfo = pixelInfo->dispLineInfo;
+    dlPtr->hyphenRule = hyphenRule;
+
+    if (dlPtr->displayLineNo > 0) {
+	TkTextDispLineEntry *dispLineEntry;
+
+	assert(dispLineInfo);
+	assert(data->byteOffset == dispLineInfo->entry[dlPtr->displayLineNo].byteOffset);
+
+	if (dlPtr->displayLineNo >= dispLineInfo->numDispLines
+		&& !IsPowerOf2(dlPtr->displayLineNo + 2)) {
+	    unsigned size = NextPowerOf2(dlPtr->displayLineNo + 2);
+	    dispLineInfo = realloc(dispLineInfo, TEXT_DISPLINEINFO_SIZE(size));
+	    DEBUG(memset(dispLineInfo->entry + dlPtr->displayLineNo + 1, 0xff,
+		    (size - dlPtr->displayLineNo - 1)*sizeof(dispLineInfo->entry[0])));
+	    pixelInfo->dispLineInfo = dispLineInfo;
+	}
+	dispLineInfo->numDispLines = dlPtr->displayLineNo + 1;
+	dispLineEntry = dispLineInfo->entry + dlPtr->displayLineNo;
+	(dispLineEntry + 1)->byteOffset = data->byteOffset + dlPtr->byteCount;
+	(dispLineEntry + 1)->pixels = oldNumDispLines;
+	dispLineEntry->height = dlPtr->height;
+	dispLineEntry->pixels = (dispLineEntry - 1)->pixels + dlPtr->height;
+	dispLineEntry->byteOffset = data->byteOffset;
+	dispLineEntry->hyphenRule = hyphenRule;
+    } else if (!finished) {
+	LayoutSetupDispLineInfo(pixelInfo);
+	dispLineInfo = pixelInfo->dispLineInfo;
+	dispLineInfo->entry[0].height = dlPtr->height;
+	dispLineInfo->entry[0].pixels = dlPtr->height;
+	dispLineInfo->entry[0].byteOffset = data->byteOffset;
+	dispLineInfo->entry[0].hyphenRule = hyphenRule;
+	dispLineInfo->entry[1].byteOffset = data->byteOffset + dlPtr->byteCount;
+    }
+
+    assert(finished || dispLineInfo);
+
+    if (finished) {
+	TkTextLine *nextLogicalLinePtr;
+	unsigned lineHeight, mergedLines, lineNo, numDispLines, i;
+
+	if (dlPtr->displayLineNo > 0) {
+	    lineHeight = dispLineInfo->entry[dispLineInfo->numDispLines - 1].pixels;
+	    numDispLines = dispLineInfo->numDispLines;
+	} else {
+	    lineHeight = dlPtr->height;
+	    numDispLines = lineHeight > 0;
+	}
+	nextLogicalLinePtr = TkBTreeNextLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+	mergedLines = TkBTreeCountLines(textPtr->sharedTextPtr->tree, linePtr, nextLogicalLinePtr);
+	if (mergedLines > 0) {
+	    mergedLines -= 1; /* subtract first line */
+	}
+	if (pixelInfo->height != lineHeight || mergedLines > 0 || numDispLines != oldNumDispLines) {
+	    /*
+	     * Do this B-Tree update before updating the epoch, because this action
+	     * needs the old values.
+	     */
+	    TkBTreeAdjustPixelHeight(textPtr, linePtr, lineHeight, mergedLines, numDispLines);
+	}
+	if (dispLineInfo && dlPtr->displayLineNo == 0) {
+	    /*
+	     * This is the right place to destroy the superfluous dispLineInfo. Don't do
+	     * this before TkBTreeAdjustPixelHeight has been called, because the latter
+	     * function needs the old display line count.
+	     */
+	    free(dispLineInfo);
+	    DEBUG_ALLOC(tkTextCountDestroyDispInfo++);
+	    pixelInfo->dispLineInfo = NULL;
+	}
+	textPtr->dInfoPtr->lineMetricUpdateCounter += 1;
+	pixelInfo->epoch = epoch;
+	lineNo = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, linePtr, NULL);
+	for (i = 0; i < mergedLines; ++i) {
+	    pixelInfo = TkBTreeLinePixelInfo(textPtr, linePtr = linePtr->nextPtr);
+	    pixelInfo->epoch = epoch;
+	    if (pixelInfo->dispLineInfo) {
+		free(pixelInfo->dispLineInfo);
+		DEBUG_ALLOC(tkTextCountDestroyDispInfo++);
+		pixelInfo->dispLineInfo = NULL;
+	    }
+	}
+	TkRangeListRemove(textPtr->dInfoPtr->lineMetricUpdateRanges, lineNo, lineNo + mergedLines);
+    } else {
+	/*
+	 * This line is wrapping into several display lines. We mark it as already
+	 * up-to-date, even with a partial computation. This is the right way to
+	 * handle very long lines efficiently, because with very long lines the chance
+	 * will be high that the lookup into the cache succeeds even with a partial
+	 * computation. (If the lookup fails, because the cache for this line is not
+	 * yet complete, then the required remaining lines will be computed, and the
+	 * result will also be stored in the cache, because all metric computation
+	 * will be done with LayoutDLine, and this function is caching any computation.)
+	 */
+
+	pixelInfo->epoch = epoch | PARTIAL_COMPUTED_BIT;
+    }
+}
+
+static unsigned
+LayoutComputeBreakLocations(
+    LayoutData *data)
+{
+    unsigned totalSize = 0;
+    TkText *textPtr = data->textPtr;
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    TkTextSegment *segPtr = data->logicalLinePtr->segPtr;
+    bool useUniBreak = data->textPtr->useUniBreak;
+    char const *lang = useUniBreak ? textPtr->lang : NULL;
+    char const *nextLang = NULL;
+    unsigned capacity = dInfoPtr->strBufferSize;
+    char *str = dInfoPtr->strBuffer;
+    char *brks = textPtr->brksBuffer;
+
+    /*
+     * The codepoint line break computation requires the whole logical line (due to a
+     * poor design of libunibreak), but separated by languages, because this line break
+     * algorithm is in general language dependent.
+     */
+
+    while (segPtr) {
+	unsigned size = 0;
+	unsigned newTotalSize;
+
+	for ( ; segPtr; segPtr = segPtr->nextPtr) {
+	    switch ((int) segPtr->typePtr->group) {
+	    case SEG_GROUP_CHAR: {
+		unsigned newSize;
+
+		if (useUniBreak) {
+		    const char *myLang = TkBTreeGetLang(textPtr, segPtr);
+
+		    if (myLang[0] != lang[0] || myLang[1] != lang[1]) {
+			nextLang = myLang;
+			break;
+		    }
+		}
+		if ((newSize = size + segPtr->size) >= capacity) {
+		    capacity = MAX(2*capacity, newSize + 1);
+		    str = realloc(str, newSize);
+		}
+		memcpy(str + size, segPtr->body.chars, segPtr->size);
+		size = newSize;
+		break;
+	    }
+	    case SEG_GROUP_HYPHEN:
+		if (useUniBreak) {
+		    const char *myLang = TkBTreeGetLang(textPtr, segPtr);
+
+		    if (myLang[0] != lang[0] || myLang[1] != lang[1]) {
+			nextLang = myLang;
+			break;
+		    }
+		}
+		if (size + 1 >= capacity) {
+		    assert(2*capacity > size + 1);
+		    str = realloc(str, capacity *= 2);
+		}
+
+		/*
+		 * Use TAB (U+0009) instead of SHY (U+00AD), because SHY needs two bytes,
+		 * but TAB needs only one byte, and this corresponds to the byte size of
+		 * a hyphen segment. The TAB character has the same character class as
+		 * the SHY character, so it's a proper substitution.
+		 *
+		 * NOTE: Do not use '-' (U+002D) for substitution, because the meaning
+		 * of this character is contextual.
+		 */
+
+		str[size++] = '\t';
+		break;
+	    case SEG_GROUP_IMAGE:
+	    case SEG_GROUP_WINDOW:
+		/* The language variable doesn't matter here. */
+		if (size + 1 >= capacity) {
+		    assert(2*capacity > size + 1);
+		    str = realloc(str, capacity *= 2);
+		}
+		/* Substitute with a TAB, so we can break at this point. */
+		str[size++] = '\t';
+		break;
+	    case SEG_GROUP_BRANCH:
+		segPtr = segPtr->body.branch.nextPtr;
+	    	break;
+	    }
+	}
+	if (size > 0) {
+	    newTotalSize = totalSize + size;
+
+	    if (newTotalSize > textPtr->brksBufferSize) {
+		/*
+		 * Take into account that the buffer must be a bit larger, because we need
+		 * one additional byte for trailing NUL (see below).
+		 */
+		textPtr->brksBufferSize = MAX(newTotalSize, textPtr->brksBufferSize + 512);
+		textPtr->brksBuffer = realloc(textPtr->brksBuffer, textPtr->brksBufferSize + 1);
+		brks = textPtr->brksBuffer;
+	    }
+
+	    str[size] = '\0'; /* TkTextComputeBreakLocations expects traling nul */
+	    TkTextComputeBreakLocations(data->textPtr->interp, str, size,
+		    lang ? (*lang ? lang : "en") : NULL, brks + totalSize);
+	    totalSize = newTotalSize;
+	}
+	lang = nextLang;
+    }
+
+    dInfoPtr->strBuffer = str;
+    dInfoPtr->strBufferSize = capacity;
+
+    return totalSize;
+}
+
+static void
+LayoutLookAheadChars(
+    TkTextDispChunk *chunkPtr,
+    const char *str,
+    unsigned numChars,
+    char *buf)
+{
+    TkTextSegment *segPtr = ((CharInfo *) chunkPtr->clientData)->segPtr;
+
+    for ( ; numChars > 0; --numChars) {
+	if (!*str) {
+	    segPtr = LayoutGetNextSegment(segPtr);
+	    if (!segPtr) {
+		memset(buf, '\0', numChars);
+		return;
+	    }
+	    str = segPtr->body.chars;
+	}
+	*buf++ = *str++;
+    }
+}
+
+static void
+LayoutApplyHyphenRules(
+    LayoutData *data,
+    TkTextDispChunk *prevCharChunkPtr,
+    TkTextDispChunk *hyphenChunkPtr,
+    TkTextDispChunk *nextCharChunkPtr)
+{
+    TkTextSegment *hyphenPtr = hyphenChunkPtr->clientData;
+    const StyleValues *sValPtr = hyphenChunkPtr->stylePtr->sValuePtr;
+    int hyphenRules = sValPtr->hyphenRules & hyphenChunkPtr->hyphenRules;
+
+    data->increaseNumBytes = 0;
+    data->decreaseNumBytes = 0;
+    SetupHyphenChars(hyphenPtr, 0);
+    hyphenRules = FilterHyphenRules(hyphenRules, sValPtr->lang);
+
+    if (hyphenRules) {
+	const CharInfo *prevCiPtr;
+	const CharInfo *nextCiPtr;
+	const char *prevCharPtr;
+	const char *nextCharPtr;
+	unsigned char prevChar;
+	unsigned char nextChar;
+	char lookAhead[3];
+
+	if (hyphenRules & (1 << TK_TEXT_HYPHEN_REPEAT)) {
+	    data->increaseNumBytes = -1;
+	    data->hyphenRule = TK_TEXT_HYPHEN_REPEAT;
+	    return;
+	}
+
+	if (!IsCharChunk(prevCharChunkPtr)) {
+	    return;
+	}
+
+	while ((prevCiPtr = prevCharChunkPtr->clientData)->numBytes == 0) {
+	    if (!(prevCharChunkPtr = prevCharChunkPtr->prevCharChunkPtr)
+		    || !IsCharChunk(prevCharChunkPtr)) {
+		return;
+	    }
+	}
+	prevCharPtr = prevCiPtr->u.chars + prevCiPtr->baseOffset + prevCiPtr->numBytes - 1;
+
+	/*
+	 * We know that we have to inspect only Latin-1 characters, either
+	 * from ASCII code page (< 0x80), or starting with 0xc3.
+	 */
+
+	if (UCHAR(prevCharPtr[0]) < 0x80) {
+	    prevChar = UCHAR(prevCharPtr[0]);
+	} else if (prevCiPtr->numBytes > 1 && UCHAR(prevCharPtr[-1]) == 0xc3) {
+	    prevChar = ConvertC3Next(prevCharPtr[1]);
+	} else {
+	    return;
+	}
+
+	if (hyphenRules & (1 << TK_TEXT_HYPHEN_DOUBLE_VOWEL)) {
+	    /* op(aa-)tje  -> op(a-)tje */
+	    /* caf(ee-)tje -> caf(-)tje */
+	    if (IsVowel(prevChar)) {
+		char secondPrevChar = '\0';
+
+		if (prevCiPtr->numBytes > 1) {
+		    secondPrevChar = prevCharPtr[-1];
+		} else {
+		    const TkTextDispChunk *chunkPtr = prevCharChunkPtr->prevCharChunkPtr;
+		    if (chunkPtr && IsCharChunk(chunkPtr)) {
+			const TkTextSegment *segPtr = CHAR_CHUNK_GET_SEGMENT(chunkPtr);
+			secondPrevChar = segPtr->body.chars[segPtr->size - 1];
+		    }
+		}
+		if (prevChar == secondPrevChar) {
+		    if (prevChar == 'e') {
+			char *s = hyphenPtr->body.chars; /* this avoids warnings */
+			data->decreaseNumBytes = 2;
+			s[0] = 0xc3; s[1] = 0xa9; /* '' = U+00E9 */
+			SetupHyphenChars(hyphenPtr, 2);
+		    } else {
+			data->decreaseNumBytes = 1;
+		    }
+		    data->hyphenRule = TK_TEXT_HYPHEN_DOUBLE_VOWEL;
+		    return;
+		}
+	    }
+	}
+
+	if (!IsCharChunk(nextCharChunkPtr)) {
+	    return;
+	}
+	if ((nextCiPtr = nextCharChunkPtr->clientData)->numBytes == 0) {
+	    TkTextSegment *segPtr = LayoutGetNextSegment(nextCharChunkPtr->clientData);
+	    if (!segPtr) {
+		return;
+	    }
+	    nextCharPtr = segPtr->body.chars;
+	} else {
+	    nextCharPtr = nextCiPtr->u.chars + nextCiPtr->baseOffset;
+	}
+	if (UCHAR(nextCharPtr[0]) < 0x80) {
+	    nextChar = UCHAR(nextCharPtr[0]);
+	} else if (UCHAR(nextCharPtr[0]) == 0xc3) {
+	    nextChar = ConvertC3Next(nextCharPtr[1]);
+	} else {
+	    return;
+	}
+
+	if (hyphenRules & (1 << TK_TEXT_HYPHEN_CK)) {
+	    /* Dru(c-k)er -> Dru(k-k)er */
+	    if (prevChar == UCHAR('c') && nextChar == UCHAR('k')) {
+		data->decreaseNumBytes = 1;
+		hyphenPtr->body.chars[0] = 'k';
+		SetupHyphenChars(hyphenPtr, 1);
+		data->hyphenRule = TK_TEXT_HYPHEN_CK;
+		return;
+	    }
+	}
+	if (hyphenRules & (1 << TK_TEXT_HYPHEN_DOUBLE_DIGRAPH)) {
+	    /* vi(s-sz)a -> vi(sz-sz)a */
+	    if (prevChar == nextChar) {
+		LayoutLookAheadChars(nextCharChunkPtr, nextCharPtr + 1, 1, lookAhead);
+		if (lookAhead[0] && IsDoubleDigraph(prevChar, lookAhead[0])) {
+		    hyphenPtr->body.chars[0] = lookAhead[0];
+		    SetupHyphenChars(hyphenPtr, 1);
+		    data->hyphenRule = TK_TEXT_HYPHEN_DOUBLE_DIGRAPH;
+		    return;
+		}
+	    }
+	}
+	if (hyphenRules & (1 << TK_TEXT_HYPHEN_TREMA)) {
+	    /* r(e-e)l -> r(e-ee)l */
+	    if (IsVowel(prevChar) && IsUmlaut(nextChar)) {
+		data->hyphenRule = TK_TEXT_HYPHEN_TREMA;
+		return;
+	    }
+	}
+	if (hyphenRules & (1 << TK_TEXT_HYPHEN_GEMINATION)) {
+	    /* para(-ll)el -> para(l-l)el */
+	    if (tolower(nextChar) == 'l') {
+		LayoutLookAheadChars(nextCharChunkPtr, nextCharPtr + 1, 3, lookAhead);
+		/* test for U+00B7 = MIDDOT */
+		if (UCHAR(lookAhead[0]) == 0xc2
+			&& UCHAR(lookAhead[1]) == 0xb7
+			&& lookAhead[2] == nextChar) {
+		    data->increaseNumBytes = 3;
+		    hyphenPtr->body.chars[0] = nextChar;
+		    SetupHyphenChars(hyphenPtr, 1);
+		    data->hyphenRule = TK_TEXT_HYPHEN_GEMINATION;
+		    return;
+		}
+	    }
+	}
+    }
+}
+
+static unsigned
+LayoutMakeCharInfo(
+    LayoutData *data,
+    TkTextSegment *segPtr,
+    int byteOffset,
+    int maxBytes)
+{
+    char const *p = segPtr->body.chars + byteOffset;
+    CharInfo *ciPtr = AllocCharInfo(data->textPtr);
+
+    assert(data->chunkPtr);
+    assert(!data->chunkPtr->clientData);
+
+    /*
+     * Take into account that maxBytes == 0 is possible.
+     */
+
+    if (data->trimSpaces && maxBytes > 0 && p[maxBytes - 1] == ' ') {
+	while (maxBytes > 1 && p[maxBytes - 2] == ' ') {
+	    maxBytes -= 1;
+	}
+    }
+
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+
+    if (data->baseChunkPtr
+	    && (!IsSameFGStyle(data->baseChunkPtr->stylePtr, data->chunkPtr->stylePtr)
+	    	|| (data->lastCharChunkPtr && data->lastCharChunkPtr->numSpaces > 0))) {
+	data->baseChunkPtr = NULL;
+    }
+
+    if (!data->baseChunkPtr) {
+	data->baseChunkPtr = data->chunkPtr;
+	Tcl_DStringInit(&data->chunkPtr->baseChars);
+	DEBUG_ALLOC(tkTextCountNewBaseChars++);
+    }
+
+    data->chunkPtr->baseChunkPtr = data->baseChunkPtr;
+    ciPtr->baseOffset = Tcl_DStringLength(&data->baseChunkPtr->baseChars);
+    ciPtr->u.chars = Tcl_DStringAppend(&data->baseChunkPtr->baseChars, p, maxBytes);
+
+#else
+
+    ciPtr->baseOffset = 0;
+    ciPtr->u.chars = p;
+
+#endif
+
+    /*
+     * Keep the char segment, otherwise a split may invalidate our string. This segment
+     * is also used for hyphenation support.
+     */
+
+    segPtr->refCount += 1;
+    ciPtr->segPtr = segPtr;
+    ciPtr->numBytes = maxBytes;
+    data->chunkPtr->clientData = ciPtr;
+
+    return maxBytes;
+}
+
+static void
+LayoutFinalizeCharInfo(
+    LayoutData *data,
+    bool gotTab)
+{
+    CharInfo *ciPtr = data->chunkPtr->clientData;
+
+    assert(data->trimSpaces ?
+	    data->chunkPtr->numBytes >= ciPtr->numBytes :
+	    data->chunkPtr->numBytes == ciPtr->numBytes);
+
+    /*
+     * Update the character information. Take into account that we don't want
+     * to display the newline character.
+     */
+
+    if (ciPtr->u.chars[ciPtr->baseOffset + ciPtr->numBytes - 1] == '\n') {
+	ciPtr->numBytes -= 1;
+    }
+
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+
+    assert(data->chunkPtr->baseChunkPtr);
+
+    /*
+     * Final update for the current base chunk data.
+     */
+
+    Tcl_DStringSetLength(&data->baseChunkPtr->baseChars, ciPtr->baseOffset + ciPtr->numBytes);
+    data->baseChunkPtr->baseWidth =
+	    data->chunkPtr->width + (data->chunkPtr->x - data->baseChunkPtr->x);
+
+    /*
+     * Finalize the base chunk if this chunk ends in a tab, which definitly breaks the context.
+     */
+
+    if (gotTab) {
+	data->baseChunkPtr = NULL;
+    }
+
+#endif
+}
+
+static void
+LayoutUndisplay(
+    LayoutData *data,
+    TkTextDispChunk *chunkPtr)
+{
+    assert(chunkPtr->layoutProcs);
+
+    if (chunkPtr->layoutProcs->undisplayProc) {
+	chunkPtr->layoutProcs->undisplayProc(data->textPtr, chunkPtr);
+    }
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+    if (chunkPtr == data->baseChunkPtr) {
+	data->baseChunkPtr = NULL;
+    }
+#endif
+}
+
+static void
+LayoutReleaseChunk(
+    TkText *textPtr,
+    TkTextDispChunk *chunkPtr)
+{
+    if (chunkPtr->layoutProcs) {
+	if (chunkPtr->layoutProcs->type == TEXT_DISP_IMAGE) {
+	    textPtr->dInfoPtr->countImages -= 1;
+	} else if (chunkPtr->layoutProcs->type == TEXT_DISP_WINDOW) {
+	    textPtr->dInfoPtr->countWindows -= 1;
+	}
+    }
+    FreeStyle(textPtr, chunkPtr->stylePtr);
+}
+
+static void
+LayoutFreeChunk(
+    LayoutData *data)
+{
+    TextDInfo *dInfoPtr = data->textPtr->dInfoPtr;
+    TkTextDispChunk *chunkPtr = data->chunkPtr;
+
+    assert(chunkPtr);
+    assert(data->lastChunkPtr != chunkPtr);
+    assert(data->lastCharChunkPtr != chunkPtr);
+    assert(!chunkPtr->sectionPtr);
+
+    if (chunkPtr->layoutProcs) {
+	LayoutUndisplay(data, chunkPtr);
+    }
+
+    LayoutReleaseChunk(data->textPtr, chunkPtr);
+    DEBUG(chunkPtr->stylePtr = NULL);
+    assert(!chunkPtr->clientData);
+    data->numBytesSoFar -= chunkPtr->numBytes;
+    chunkPtr->nextPtr = dInfoPtr->chunkPoolPtr;
+    dInfoPtr->chunkPoolPtr = chunkPtr;
+    dInfoPtr->chunkPoolPtr->prevPtr = NULL;
+    data->chunkPtr = NULL;
+    assert(data->countChunks > 0);
+    data->countChunks -= 1;
+}
+
+static void
+LayoutDoWidthAdjustmentForContextDrawing(
+    LayoutData *data)
+{
+#if TK_LAYOUT_WITH_BASE_CHUNKS && TK_DRAW_IN_CONTEXT
+    TkTextDispChunk *chunkPtr = data->chunkPtr;
+
+    if (chunkPtr->prevPtr) {
+	chunkPtr->x += chunkPtr->prevPtr->xAdjustment;
+    }
+
+    if (IsCharChunk(chunkPtr)) {
+	int newWidth;
+
+	CharChunkMeasureChars(chunkPtr, NULL, 0, 0, -1, 0, -1, 0, &newWidth);
+	chunkPtr->xAdjustment = newWidth - chunkPtr->width;
+	chunkPtr->width = newWidth;
+    }
+#endif
+}
+
+static void
+LayoutFinalizeChunk(
+    LayoutData *data)
+{
+    const TkTextDispChunkProcs *layoutProcs;
+
+    if (!data->chunkPtr) {
+	return;
+    }
+
+    layoutProcs = data->chunkPtr->layoutProcs;
+
+    if (!layoutProcs) {
+	assert(data->chunkPtr->numBytes == 0);
+	assert(!data->chunkPtr->clientData);
+	LayoutFreeChunk(data);
+	return;
+    }
+
+    if (layoutProcs->type & TEXT_DISP_CONTENT) {
+	data->lastCharChunkPtr = data->chunkPtr;
+	if (!data->firstCharChunkPtr) {
+	    data->firstCharChunkPtr = data->chunkPtr;
+	}
+	if (layoutProcs->type & TEXT_DISP_TEXT) {
+	    LayoutDoWidthAdjustmentForContextDrawing(data);
+	}
+    }
+    if (data->chunkPtr->breakIndex > 0) {
+	data->breakChunkPtr = data->chunkPtr;
+    }
+    if (!data->firstChunkPtr) {
+	assert(!data->lastChunkPtr);
+	data->firstChunkPtr = data->chunkPtr;
+    } else {
+	assert(data->lastChunkPtr);
+	data->lastChunkPtr->nextPtr = data->chunkPtr;
+    }
+    data->lastChunkPtr = data->chunkPtr;
+    data->dispLineOffset += data->chunkPtr->numBytes;
+    data->chunkPtr = NULL;
+}
+
+static TkTextDispChunkSection *
+LayoutNewSection(
+    TextDInfo *dInfoPtr)
+{
+    TkTextDispChunkSection *sectionPtr = dInfoPtr->sectionPoolPtr;
+
+    if (sectionPtr) {
+	dInfoPtr->sectionPoolPtr = dInfoPtr->sectionPoolPtr->nextPtr;
+    } else {
+	DEBUG_ALLOC(tkTextCountNewSection++);
+	sectionPtr = malloc(sizeof(TkTextDispChunkSection));
+    }
+
+    memset(sectionPtr, 0, sizeof(TkTextDispChunkSection));
+    return sectionPtr;
+}
+
+static void
+LayoutMakeNewChunk(
+    LayoutData *data)
+{
+    TkTextDispChunk *newChunkPtr;
+    TextDInfo *dInfoPtr = data->textPtr->dInfoPtr;
+
+    LayoutFinalizeChunk(data);
+    if ((newChunkPtr = dInfoPtr->chunkPoolPtr)) {
+	dInfoPtr->chunkPoolPtr = newChunkPtr->nextPtr;
+    } else {
+	newChunkPtr = malloc(sizeof(TkTextDispChunk));
+	DEBUG_ALLOC(tkTextCountNewChunk++);
+    }
+    memset(newChunkPtr, 0, sizeof(TkTextDispChunk));
+    newChunkPtr->prevPtr = data->lastChunkPtr;
+    newChunkPtr->prevCharChunkPtr = data->lastCharChunkPtr;
+    newChunkPtr->stylePtr = GetStyle(data->textPtr, NULL);
+    newChunkPtr->x = data->x;
+    newChunkPtr->byteOffset = data->dispLineOffset;
+    data->chunkPtr = newChunkPtr;
+    data->countChunks += 1;
+}
+
+static void
+LayoutSkipBytes(
+    LayoutData *data,
+    DLine *dlPtr,
+    const TkTextIndex *indexPtr1,
+    const TkTextIndex *indexPtr2)
+{
+    LayoutMakeNewChunk(data);
+    data->chunkPtr->layoutProcs = &layoutElideProcs;
+    data->chunkPtr->numBytes = TkTextIndexCountBytes(indexPtr1, indexPtr2);
+}
+
+static void
+LayoutSetupChunk(
+    LayoutData *data,
+    TkTextSegment *segPtr)
+{
+    TkTextDispChunk *chunkPtr = data->chunkPtr;
+    TkText *textPtr = data->textPtr;
+    TextStyle *stylePtr;
+
+    assert(segPtr->tagInfoPtr);
+    assert(chunkPtr->stylePtr == textPtr->dInfoPtr->defaultStyle);
+    assert(chunkPtr->stylePtr->refCount > 1);
+
+    chunkPtr->stylePtr->refCount -= 1;
+    chunkPtr->stylePtr = stylePtr = GetStyle(textPtr, segPtr);
+
+    if (data->wrapMode == TEXT_WRAPMODE_CODEPOINT) {
+	const TkTextPixelInfo *pixelInfo = TkBTreeLinePixelInfo(textPtr, data->logicalLinePtr);
+
+	if (!data->brks) {
+	    Tcl_HashEntry *hPtr;
+	    BreakInfo *breakInfo;
+	    int new;
+
+	    hPtr = Tcl_CreateHashEntry(&textPtr->sharedTextPtr->breakInfoTable,
+		    (void *) data->logicalLinePtr, &new);
+
+	    if (new) {
+		breakInfo = malloc(sizeof(BreakInfo));
+		breakInfo->refCount = 1;
+		breakInfo->brks = NULL;
+		data->logicalLinePtr->changed = false;
+		Tcl_SetHashValue(hPtr, breakInfo);
+		DEBUG_ALLOC(tkTextCountNewBreakInfo++);
+	    } else {
+		breakInfo = Tcl_GetHashValue(hPtr);
+		breakInfo->refCount += 1;
+
+		/*
+		 * We have to avoid repeated computations of line break information,
+		 * so we use the 'changed' flag of the logical line for the determination
+		 * whether a recomputation has to be performed. This is the only purpose
+		 * of flag 'changed', and required because our current line break
+		 * information algorithm has to process the whole logical line. If this
+		 * behavior will change - for example a switch to the ICU library - then
+		 * flag 'changed' has no use anymore and can be removed. But currently
+		 * all line modifications have to update this flag.
+		 */
+
+		if (data->logicalLinePtr->changed) {
+		    new = true;
+		    data->logicalLinePtr->changed = false;
+		}
+	    }
+
+	    if (new) {
+		unsigned brksSize;
+
+		/*
+		 * In this case we have to parse the whole logical line for the computation
+		 * of the break locations.
+		 */
+
+		brksSize = LayoutComputeBreakLocations(data);
+		breakInfo->brks = realloc(breakInfo->brks, brksSize);
+		memcpy(breakInfo->brks, textPtr->brksBuffer, brksSize);
+		DEBUG(stats.breakInfo += 1);
+	    }
+
+	    data->breakInfo = breakInfo;
+	    data->brks = breakInfo->brks;
+	}
+
+	if (segPtr->sectionPtr) {
+	    chunkPtr->brks = data->brks;
+	    if (data->displayLineNo > 0) {
+		assert(pixelInfo->dispLineInfo);
+		chunkPtr->brks += pixelInfo->dispLineInfo->entry[data->displayLineNo].byteOffset;
+	    } else {
+		/* Consider that inside peers the line may start after byte index zero. */
+		chunkPtr->brks += data->byteOffset;
+	    }
+	    chunkPtr->brks += data->dispLineOffset;
+	} else {
+	    /* This is an artificial chunk for the realization of spelling changes. */
+	    assert(chunkPtr->numBytes <= sizeof(doNotBreakAtAll));
+	    chunkPtr->brks = doNotBreakAtAll;
+	}
+    }
+
+    if (data->numBytesSoFar == 0) {
+	const TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+	const StyleValues *sValuePtr = stylePtr->sValuePtr;
+
+	data->tabArrayPtr = sValuePtr->tabArrayPtr;
+	data->tabStyle = sValuePtr->tabStyle;
+	data->justify = sValuePtr->justify;
+	data->rMargin = sValuePtr->rMargin;
+	data->wrapMode = sValuePtr->wrapMode;
+	data->x = data->paragraphStart ? sValuePtr->lMargin1 : sValuePtr->lMargin2;
+	data->width = dInfoPtr->maxX - dInfoPtr->x - data->rMargin;
+	data->maxX = data->wrapMode == TEXT_WRAPMODE_NONE ? -1 : MAX(data->width, data->x);
+
+	chunkPtr->x = data->x;
+
+	if (data->cursorChunkPtr) {
+	    data->cursorChunkPtr->x = data->x;
+	}
+    }
+}
+
+static bool
+LayoutChars(
+    LayoutData *data,
+    TkTextSegment *segPtr,
+    int size,
+    int byteOffset)
+{
+    const char *base = segPtr->body.chars + byteOffset;
+    TkTextDispChunk *chunkPtr;
+    bool gotTab = false;
+    bool finished = true;
+    unsigned maxBytes;
+    unsigned numBytes;
+
+    assert(size - byteOffset > 0); /* this will ensure maxBytes > 0 */
+    assert(byteOffset < size);
+    assert(segPtr->typePtr->layoutProc);
+
+    LayoutMakeNewChunk(data);
+    LayoutSetupChunk(data, segPtr);
+
+    chunkPtr = data->chunkPtr;
+    maxBytes = size - byteOffset;
+
+    if (data->textPtr->showEndOfLine
+	    && base[maxBytes - 1] == '\n'
+	    && segPtr->sectionPtr->linePtr->nextPtr != TkBTreeGetLastLine(data->textPtr)) {
+	maxBytes -= 1; /* now may beome zero */
+    }
+
+    if (maxBytes == 0) {
+	/*
+	 * Can only happen if we are at end of logical line.
+	 */
+
+	segPtr = data->textPtr->dInfoPtr->endOfLineSegPtr;
+	base = segPtr->body.chars;
+	maxBytes = segPtr->size;
+	byteOffset = 0;
+    } else if (segPtr->typePtr != &tkTextHyphenType
+    		&& segPtr->sectionPtr) { /* ignore artifical segments (spelling changes) */
+	if (data->wrapMode == TEXT_WRAPMODE_CODEPOINT) {
+	    const char *brks = chunkPtr->brks;
+	    unsigned i;
+
+	    assert(brks);
+
+	    for (i = 1; i < maxBytes; ++i) {
+		if (brks[i] == LINEBREAK_MUSTBREAK) {
+		    if (i < maxBytes - 2 && base[i] != '\n') {
+			maxBytes = i + 1;
+		    }
+		    break;
+		}
+	    }
+	}
+
+	if (data->textPtr->hyphenate && finished) {
+	    const char *p = base;
+
+	    /*
+	     * Check whether the "tripleconsonant" rule has to be applied. This rule is
+	     * very special, because in this case we are virtually doing the opposite.
+	     * Instead of doing a spelling change when hyphenating, we are doing a spelling
+	     * change when *not* hyphenating.
+	     */
+
+	    if (IsConsonant(*p)
+		    && data->lastCharChunkPtr
+		    && data->lastCharChunkPtr->prevCharChunkPtr
+		    && data->lastChunkPtr
+		    && data->lastChunkPtr->layoutProcs
+		    && data->lastChunkPtr->layoutProcs->type == TEXT_DISP_HYPHEN
+		    && *p == GetLastCharInChunk(data->lastCharChunkPtr->prevCharChunkPtr)
+		    && *p == GetSecondLastCharInChunk(data->lastCharChunkPtr->prevCharChunkPtr)) {
+		const char *nextCharPtr;
+
+		if (maxBytes > 1) {
+		    nextCharPtr = p + 1;
+		} else {
+		    const TkTextSegment *nextCharSegPtr = LayoutGetNextSegment(segPtr);
+		    nextCharPtr = nextCharSegPtr ? nextCharSegPtr->body.chars : NULL;
+		}
+
+		/* For Norwegian it's required to consider 'j' as a vowel. */
+		if (nextCharPtr && (nextCharPtr[0] == 'j' || IsUmlautOrVowel(nextCharPtr))) {
+		    /*
+		     * Probably we have to apply hyphen rule "tripleconsonant" to the first
+		     * character after possible (but unapplied) hyphenation point.
+		     */
+
+		    const StyleValues *sValPtr = data->lastChunkPtr->stylePtr->sValuePtr;
+		    int hyphenRules = FilterHyphenRules(sValPtr->hyphenRules, sValPtr->lang);
+
+		    if (hyphenRules & (1 << TK_TEXT_HYPHEN_TRIPLE_CONSONANT)) {
+			/* Schi(ff-f)ahrt -> Schi(ff)ahrt */
+			byteOffset += 1;
+			base += 1;
+			maxBytes -= 1; /* now may become zero */
+			chunkPtr->skipFirstChar = true;
+		    }
+		}
+	    }
+	}
+
+	if (data->trimSpaces) {
+	    int i;
+
+	    for (i = 0; i < maxBytes; ++i) {
+		if (base[i] == ' ' && base[i + 1] == ' ') {
+		    while (base[i] == ' ') {
+			++i;
+		    }
+		    maxBytes = i;
+		    data->skipSpaces = true;
+		    break;
+		}
+	    }
+	}
+
+	/*
+	 * See if there is a tab in the current chunk; if so, only layout
+	 * characters up to (and including) the tab.
+	 */
+
+	if (data->justify == TK_TEXT_JUSTIFY_LEFT) {
+	    const char *p = base;
+	    int i;
+
+	    /* TODO: also TK_TEXT_JUSTIFY_RIGHT should support tabs */
+	    /* TODO: direction of tabs should depend on gravity of insert mark?! */
+
+	    for (i = 0; i < maxBytes; ++i, ++p) {
+		if (*p == '\t') {
+		    maxBytes = i + 1;
+		    gotTab = true;
+		    break;
+		}
+	    }
+	} else if (data->justify == TK_TEXT_JUSTIFY_FULL) {
+	    const char *p = base;
+	    const char *e = p + maxBytes;
+
+	    for ( ; p < e && !IsExpandableSpace(p); ++p) {
+		if (*p == '\t') {
+		    chunkPtr->numSpaces = 0;
+		    maxBytes = p - base + 1;
+		    gotTab = true;
+		    break;
+		}
+	    }
+	    if (!gotTab && p < e) {
+		assert(IsExpandableSpace(p));
+
+		do {
+		    chunkPtr->numSpaces += 1;
+
+		    if (*p == '\t'
+			    && (!data->tabArrayPtr || data->tabIndex < data->tabArrayPtr->numTabs)) {
+			/*
+			 * Don't expand spaces if we have numeric tabs.
+			 */
+			chunkPtr->numSpaces = 0;
+			gotTab = true;
+			p += 1;
+			break;
+		    }
+
+		    p = Tcl_UtfNext(p);
+		} while (IsExpandableSpace(p));
+
+		maxBytes = p - base;
+	    }
+	}
+    }
+
+    if (maxBytes == 0) {
+	/*
+	 * In seldom cases, if hyphenation is activated, we may have an empty
+	 * chunk here, caused by the "tripleconsonant" rule. This chunk has to
+	 * consume one character.
+	 */
+
+	assert(size == 1);
+	assert(chunkPtr->skipFirstChar);
+	data->chunkPtr->layoutProcs = &layoutElideProcs;
+	data->chunkPtr->numBytes = 1;
+	return true;
+    }
+
+    numBytes = LayoutMakeCharInfo(data, segPtr, byteOffset, maxBytes);
+
+    if (segPtr->typePtr->layoutProc(&data->index, segPtr, byteOffset,
+	    data->maxX - data->tabSize, numBytes, data->numBytesSoFar == 0,
+	    data->wrapMode, data->textPtr->spaceMode, chunkPtr) == 0) {
+	/*
+	 * No characters from this segment fit in the window: this means
+	 * we're at the end of the display line.
+	 */
+
+	chunkPtr->numSpaces = 0;
+	return false;
+    }
+
+    if (numBytes == chunkPtr->numBytes) {
+	chunkPtr->numBytes = maxBytes;
+	assert(maxBytes > 0);
+
+	if (data->trimSpaces && base[maxBytes - 1] == ' ') {
+	    data->skipSpaces = true;
+	}
+    }
+
+    assert(chunkPtr->numBytes + chunkPtr->skipFirstChar > 0);
+
+    LayoutFinalizeCharInfo(data, gotTab);
+    data->x += chunkPtr->width;
+
+    if (segPtr == data->textPtr->dInfoPtr->endOfLineSegPtr) {
+	chunkPtr->numBytes = (chunkPtr->numBytes == maxBytes) ? 1 : 0;
+	chunkPtr->breakIndex = chunkPtr->numBytes;
+	maxBytes = 1;
+    } else {
+	chunkPtr->numBytes += chunkPtr->skipFirstChar;
+    }
+
+    data->numBytesSoFar += chunkPtr->numBytes;
+    data->numSpaces += chunkPtr->numSpaces;
+
+    if (chunkPtr->numBytes != maxBytes + chunkPtr->skipFirstChar) {
+	return false;
+    }
+
+    /*
+     * If we're at a new tab, adjust the layout for all the chunks pertaining to the
+     * previous tab. Also adjust the amount of space left in the line to account for
+     * space that will be eaten up by the tab.
+     */
+
+    if (gotTab) {
+	if (data->tabIndex >= 0) {
+	    data->lastChunkPtr->nextPtr = data->chunkPtr; /* we need the complete chain. */
+	    AdjustForTab(data);
+	    data->lastChunkPtr->nextPtr = NULL; /* restore */
+	    data->x = chunkPtr->x + chunkPtr->width;
+	}
+	data->tabChunkPtr = chunkPtr;
+	ComputeSizeOfTab(data);
+	if (data->maxX >= 0 && data->tabSize >= data->maxX - data->x) {
+	    return false; /* end of line reached */
+	}
+    }
+
+    return finished;
+}
+
+static bool
+LayoutHyphen(
+    LayoutData *data,
+    TkTextSegment *segPtr)
+{
+    bool rc;
+
+    assert(segPtr->sectionPtr); /* don't works with artificial segments */
+
+    if (data->textPtr->hyphenate) {
+	LayoutMakeNewChunk(data);
+	LayoutSetupChunk(data, segPtr);
+	data->numBytesSoFar += segPtr->size;
+	segPtr->body.hyphen.textSize = 0;
+	data->chunkPtr->layoutProcs = &layoutHyphenProcs;
+	data->chunkPtr->clientData = segPtr;
+	data->chunkPtr->breakIndex = -1;
+	data->chunkPtr->numBytes = segPtr->size;
+	data->chunkPtr->hyphenRules = segPtr->body.hyphen.rules;
+	segPtr->refCount += 1;
+	rc = true;
+    } else {
+	SetupHyphenChars(segPtr, 0);
+	rc = LayoutChars(data, segPtr, segPtr->body.hyphen.textSize, 0);
+	data->chunkPtr->numBytes = MIN(1, data->chunkPtr->numBytes);
+    }
+
+    data->chunkPtr->breakIndex = data->chunkPtr->numBytes;
+    return rc;
+}
+
+static bool
+LayoutEmbedded(
+    LayoutData *data,
+    TkTextSegment *segPtr)
+{
+    assert(segPtr->typePtr->layoutProc);
+
+    LayoutMakeNewChunk(data);
+
+    if (segPtr->typePtr->layoutProc(&data->index, segPtr, 0, data->maxX - data->tabSize, 0,
+	    data->numBytesSoFar == 0, data->wrapMode, data->textPtr->spaceMode, data->chunkPtr) != 1) {
+	return false;
+    }
+
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+    data->baseChunkPtr = NULL;
+#endif
+    LayoutSetupChunk(data, segPtr);
+    data->numBytesSoFar += data->chunkPtr->numBytes;
+    data->x += data->chunkPtr->width;
+
+    if (segPtr->typePtr->group == SEG_GROUP_IMAGE) {
+	data->textPtr->dInfoPtr->countImages += 1;
+    } else {
+	data->textPtr->dInfoPtr->countWindows += 1;
+    }
+
+    return true;
+}
+
+static bool
+LayoutMark(
+    LayoutData *data,
+    TkTextSegment *segPtr)
+{
+    assert(segPtr->typePtr->layoutProc);
+
+    if (segPtr != data->textPtr->insertMarkPtr) {
+	return false;
+    }
+    LayoutMakeNewChunk(data);
+    segPtr->typePtr->layoutProc(&data->index, segPtr, 0, data->maxX - data->tabSize, 0,
+	    data->numBytesSoFar == 0, data->wrapMode, data->textPtr->spaceMode, data->chunkPtr);
+    return true;
+}
+
+static bool
+LayoutLogicalLine(
+    LayoutData *data,
+    DLine *dlPtr)
+{
+    TkTextSegment *segPtr, *endPtr;
+    int byteIndex, byteOffset;
+
+    assert(!TkTextIsElided(&data->index));
+
+    byteIndex = TkTextIndexGetByteIndex(&data->index);
+
+    if (data->textPtr->hyphenate && data->displayLineNo > 0) {
+	const TkTextDispLineInfo *dispLineInfo;
+	int byteOffset;
+	int hyphenRule;
+
+	segPtr = TkTextIndexGetContentSegment(&data->index, &byteOffset);
+	dispLineInfo = TkBTreeLinePixelInfo(data->textPtr, data->logicalLinePtr)->dispLineInfo;
+	assert(dispLineInfo);
+	hyphenRule = dispLineInfo->entry[data->displayLineNo - 1].hyphenRule;
+
+	switch (hyphenRule) {
+	case TK_TEXT_HYPHEN_REPEAT:
+	case TK_TEXT_HYPHEN_TREMA:
+	case TK_TEXT_HYPHEN_DOUBLE_DIGRAPH: {
+	    int numBytes = 0; /* prevents compiler warning */
+	    TkTextSegment *nextCharSegPtr;
+	    char buf[1];
+	    bool cont;
+
+	    /*
+	     * We have to realize spelling changes.
+	     */
+
+	    switch (hyphenRule) {
+	    case TK_TEXT_HYPHEN_REPEAT:
+		buf[0] = '-';
+		numBytes = 1;
+		break;
+	    case TK_TEXT_HYPHEN_TREMA:
+		assert(UCHAR(segPtr->body.chars[byteOffset]) == 0xc3);
+		buf[0] = UmlautToVowel(ConvertC3Next(segPtr->body.chars[byteOffset + 1]));
+		numBytes = 2;
+		break;
+	    case TK_TEXT_HYPHEN_DOUBLE_DIGRAPH:
+		buf[0] = segPtr->body.chars[0];
+		numBytes = 1;
+		break;
+	    }
+	    nextCharSegPtr = TkBTreeMakeCharSegment(buf, 1, segPtr->tagInfoPtr);
+	    cont = LayoutChars(data, nextCharSegPtr, 1, 0);
+	    TkBTreeFreeSegment(nextCharSegPtr);
+	    data->chunkPtr->numBytes = numBytes;
+	    if (!cont) {
+		LayoutFinalizeChunk(data);
+		return false;
+	    }
+	    TkTextIndexForwBytes(data->textPtr, &data->index, data->chunkPtr->numBytes, &data->index);
+	    byteIndex += data->chunkPtr->numBytes;
+	    break;
+	}
+	}
+    }
+
+    segPtr = TkTextIndexGetFirstSegment(&data->index, &byteOffset);
+    endPtr = data->textPtr->endMarker;
+
+    if (segPtr->typePtr == &tkTextLinkType) {
+	segPtr = segPtr->nextPtr;
+    }
+
+    /*
+     * Each iteration of the loop below creates one TkTextDispChunk for the
+     * new display line. The line will always have at least one chunk (for the
+     * newline character at the end, if there's nothing else available).
+     */
+
+    while (true) {
+	if (segPtr->typePtr == &tkTextCharType) {
+	    if (data->skipSpaces) {
+		if (segPtr->body.chars[byteOffset] == ' ') {
+		    TkTextIndex index = data->index;
+		    int offset = byteOffset;
+
+		    while (segPtr->body.chars[byteOffset] == ' ') {
+			byteOffset += 1;
+		    }
+		    TkTextIndexForwBytes(data->textPtr, &index, byteOffset - offset, &data->index);
+		    LayoutSkipBytes(data, dlPtr, &index, &data->index);
+		    byteIndex = TkTextIndexGetByteIndex(&data->index);
+		}
+		data->skipSpaces = false;
+	    }
+	    if (segPtr->size > byteOffset) {
+		if (!LayoutChars(data, segPtr, segPtr->size, byteOffset)) {
+		    /* finished with this display line */
+		    LayoutFinalizeChunk(data);
+		    return false;
+		}
+		assert(data->chunkPtr);
+		byteIndex += data->chunkPtr->numBytes;
+		if ((byteOffset += data->chunkPtr->numBytes) == segPtr->size) {
+		    segPtr = segPtr->nextPtr;
+		    byteOffset = 0;
+		}
+	    } else {
+		assert(segPtr->size == byteOffset);
+		segPtr = segPtr->nextPtr;
+		byteOffset = 0;
+	    }
+	} else {
+	    switch (segPtr->typePtr->group) {
+	    case SEG_GROUP_HYPHEN:
+		if (!LayoutHyphen(data, segPtr)) {
+		    /* finished with this display line */
+		    LayoutFinalizeChunk(data);
+		    return false;
+		}
+		byteIndex += segPtr->size;
+		data->skipSpaces = false;
+		break;
+	    case SEG_GROUP_IMAGE:
+	    case SEG_GROUP_WINDOW:
+		if (!LayoutEmbedded(data, segPtr)) {
+		    /* finished with this display line */
+		    LayoutFinalizeChunk(data);
+		    return false;
+		}
+		byteIndex += segPtr->size;
+		data->skipSpaces = false;
+		break;
+	    case SEG_GROUP_MARK:
+		if (segPtr == endPtr) {
+		    /*
+		     * We need a final chunk containing the final newline, otherwise x position
+		     * lookup will not work. Here we will not use LayoutSkipBytes() for the bytes
+		     * between current position and last char in line, because this would require
+		     * an inconsistent index, and it's easier to avoid this. It's only a single
+		     * newline which terminates the line, so no bad things will happen if we omit
+		     * this skip-chunk.
+		     */
+		    segPtr = segPtr->sectionPtr->linePtr->lastPtr;
+		    LayoutChars(data, segPtr, segPtr->size, segPtr->size - 1);
+		} else {
+		    if (LayoutMark(data, segPtr)) {
+			data->cursorChunkPtr = data->chunkPtr;
+		    }
+		    assert(segPtr->size == 0);
+		}
+		break;
+	    case SEG_GROUP_BRANCH: {
+		TkTextIndex index = data->index;
+		assert(segPtr->typePtr == &tkTextBranchType);
+		assert(segPtr->size == 0);
+		TkTextIndexSetSegment(&data->index, segPtr = segPtr->body.branch.nextPtr);
+		LayoutSkipBytes(data, dlPtr, &index, &data->index);
+		byteIndex = TkTextIndexGetByteIndex(&data->index);
+		break;
+	    }
+	    case SEG_GROUP_PROTECT:
+	    case SEG_GROUP_TAG:
+	    case SEG_GROUP_CHAR:
+		assert(!"unexpected segment type");
+		break;
+	    }
+	    segPtr = segPtr->nextPtr;
+	    byteOffset = 0;
+	}
+	if (!segPtr) {
+	    LayoutFinalizeChunk(data);
+	    return true;
+	}
+	TkTextIndexSetPosition(&data->index, byteIndex, segPtr);
+    }
+
+    return false; /* never reached */
+}
+
+static void
+LayoutDestroyChunks(
+    LayoutData *data)
+{
+    TkTextDispChunk *chunkPtr = data->lastChunkPtr;
+    TextDInfo *dInfoPtr;
+
+    if (chunkPtr == data->breakChunkPtr) {
+	return;
+    }
+
+    dInfoPtr = data->textPtr->dInfoPtr;
+
+    /*
+     * We have to destroy the chunks backward, because the context support
+     * is expecting this.
+     */
+
+    for ( ; chunkPtr != data->breakChunkPtr; chunkPtr = chunkPtr->prevPtr) {
+	assert(chunkPtr != data->firstCharChunkPtr);
+	assert(chunkPtr->layoutProcs);
+	assert(!chunkPtr->sectionPtr);
+
+	data->numSpaces -= chunkPtr->numSpaces;
+	data->dispLineOffset -= chunkPtr->numBytes;
+	data->numBytesSoFar -= chunkPtr->numBytes;
+	data->countChunks -= 1;
+
+	if (chunkPtr == data->cursorChunkPtr) {
+	    data->cursorChunkPtr = NULL;
+	} else if (chunkPtr == data->lastCharChunkPtr) {
+	    data->lastCharChunkPtr = chunkPtr->prevCharChunkPtr;
+	}
+	if (chunkPtr->layoutProcs->type == TEXT_DISP_IMAGE) {
+	    dInfoPtr->countImages -= 1;
+	} else if (chunkPtr->layoutProcs->type == TEXT_DISP_WINDOW) {
+	    dInfoPtr->countWindows -= 1;
+	}
+	LayoutUndisplay(data, chunkPtr);
+	LayoutReleaseChunk(data->textPtr, chunkPtr);
+	DEBUG(chunkPtr->stylePtr = NULL);
+    }
+
+    data->lastChunkPtr->nextPtr = dInfoPtr->chunkPoolPtr;
+    dInfoPtr->chunkPoolPtr = data->breakChunkPtr->nextPtr;
+    dInfoPtr->chunkPoolPtr->prevPtr = NULL;
+    data->breakChunkPtr->nextPtr = NULL;
+    data->lastChunkPtr = data->breakChunkPtr;
+    data->chunkPtr = NULL;
+    data->x = data->lastChunkPtr->x + data->lastChunkPtr->width;
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+    data->baseChunkPtr = data->breakChunkPtr->baseChunkPtr;
+#endif
+}
+
+static void
+LayoutBreakLine(
+    LayoutData *data,
+    const TkTextIndex *indexPtr)	/* Index of display line start. */
+{
+    if (!data->breakChunkPtr) {
+	/*
+	 * This code makes sure that we don't accidentally display chunks with
+	 * no characters at the end of the line (such as the insertion
+	 * cursor). These chunks belong on the next line. So, throw away
+	 * everything after the last chunk that has characters in it.
+	 */
+
+	data->breakChunkPtr = data->lastCharChunkPtr;
+    }
+
+    while (IsHyphenChunk(data->breakChunkPtr)) {
+	TkTextDispChunk *hyphenChunkPtr;
+	TkTextDispChunk *prevChunkPtr;
+	TkTextDispChunk *nextChunkPtr;
+
+	/*
+	 * This can only happen if the breaking chunk is a hyphen segment.
+	 * So try to hyphenate at this point. Normally this will succeed,
+	 * but in seldom cases the hyphenation does not fit, then we have
+	 * to search back for the next breaking chunk.
+	 */
+
+	hyphenChunkPtr = data->breakChunkPtr;
+	prevChunkPtr = hyphenChunkPtr->prevCharChunkPtr;
+	nextChunkPtr = LayoutGetNextCharChunk(hyphenChunkPtr);
+
+	if (prevChunkPtr && nextChunkPtr) {
+	    TkTextSegment *hyphenSegPtr = hyphenChunkPtr->clientData;
+
+	    LayoutApplyHyphenRules(data, prevChunkPtr, hyphenChunkPtr, nextChunkPtr);
+	    data->breakChunkPtr = prevChunkPtr;
+	    LayoutDestroyChunks(data);
+
+	    if (data->decreaseNumBytes > 0) {
+		TkTextIndex index = *indexPtr;
+		TkTextSegment *segPtr;
+		unsigned newNumBytes = 0;
+		unsigned numBytes;
+
+		/*
+		 * We need a new layout of the preceding char chunk because of possible
+		 * spelling changes.
+		 */
+
+		while (data->decreaseNumBytes >= prevChunkPtr->numBytes
+			&& prevChunkPtr != data->firstCharChunkPtr) {
+		    data->decreaseNumBytes -= prevChunkPtr->numBytes;
+		    newNumBytes += prevChunkPtr->numBytes;
+		    prevChunkPtr = prevChunkPtr->prevPtr;
+		}
+
+		data->breakChunkPtr = prevChunkPtr;
+		LayoutDestroyChunks(data);
+		newNumBytes += prevChunkPtr->numBytes;
+
+		if (data->decreaseNumBytes > 0) {
+		    segPtr = CHAR_CHUNK_GET_SEGMENT(prevChunkPtr);
+		    prevChunkPtr->numBytes -= data->decreaseNumBytes;
+		    numBytes = prevChunkPtr->numBytes;
+		    assert(prevChunkPtr->layoutProcs);
+		    LayoutUndisplay(data, prevChunkPtr);
+		    data->chunkPtr = prevChunkPtr;
+		    LayoutMakeCharInfo(data, segPtr, prevChunkPtr->segByteOffset, numBytes);
+		    TkTextIndexForwBytes(data->textPtr, &index, prevChunkPtr->byteOffset, &index);
+		    segPtr->typePtr->layoutProc(&index, segPtr, prevChunkPtr->segByteOffset,
+			    data->maxX, numBytes, 0, data->wrapMode, data->textPtr->spaceMode,
+			    prevChunkPtr);
+		    LayoutFinalizeCharInfo(data, false); /* second parameter doesn't matter here */
+
+		    if (prevChunkPtr->numBytes != numBytes && prevChunkPtr != data->firstCharChunkPtr) {
+			/*
+			 * The content doesn't fits into the display line (but it must fit if
+			 * this is the first char chunk).
+			 */
+			hyphenSegPtr = NULL;
+		    }
+		}
+
+		prevChunkPtr->numBytes = newNumBytes;
+		data->chunkPtr = NULL;
+	    }
+
+	    if (hyphenSegPtr) {
+		int maxX = data->maxX;
+		bool fits;
+
+		data->x = prevChunkPtr->x + prevChunkPtr->width;
+		if (prevChunkPtr == data->firstCharChunkPtr && prevChunkPtr->breakIndex <= 0) {
+		    data->maxX = INT_MAX; /* The hyphen must be shown. */
+		}
+		fits = LayoutChars(data, hyphenSegPtr, hyphenSegPtr->body.hyphen.textSize, 0);
+		assert(!fits || data->chunkPtr->numBytes == hyphenSegPtr->body.hyphen.textSize);
+		hyphenChunkPtr = data->chunkPtr;
+		data->maxX = maxX;
+
+		if (fits) {
+		    /* The hyphen fits, so we're done. */
+		    LayoutFinalizeChunk(data);
+		    hyphenChunkPtr->numBytes = 1 + data->increaseNumBytes;
+		    return;
+		}
+
+		LayoutFreeChunk(data);
+		data->hyphenRule = 0;
+	    }
+	}
+
+	/*
+	 * We couldn't hyphenate, so search for next candidate for wrapping.
+	 */
+
+	if (IsHyphenChunk(data->breakChunkPtr)) {
+	    if (!(data->breakChunkPtr = data->breakChunkPtr->prevPtr)) {
+		return;
+	    }
+	}
+	if (data->breakChunkPtr->breakIndex <= 0) {
+	    do {
+		if (!(data->breakChunkPtr = data->breakChunkPtr->prevPtr)) {
+		    return;
+		}
+	    } while (data->breakChunkPtr->breakIndex <= 0 && !IsHyphenChunk(data->breakChunkPtr));
+	}
+
+	data->chunkPtr = NULL;
+    }
+
+    /*
+     * Now check if we must break because the line length have been exceeded. At this point
+     * hyphenation is not involved.
+     */
+
+    if (data->breakChunkPtr
+	    && (data->lastChunkPtr != data->breakChunkPtr
+		|| (data->lastChunkPtr->breakIndex > 0
+		    && data->lastChunkPtr->breakIndex != data->lastChunkPtr->numBytes))) {
+	unsigned addNumBytes = 0;
+
+	LayoutDestroyChunks(data);
+
+	if (data->breakChunkPtr->breakIndex > 0 && data->breakChunkPtr->numSpaces > 0) {
+	    const TkTextDispChunk *breakChunkPtr = data->breakChunkPtr;
+	    const CharInfo *ciPtr = breakChunkPtr->clientData;
+	    const char *p = ciPtr->u.chars + ciPtr->baseOffset + breakChunkPtr->breakIndex;
+	    const char *q = Tcl_UtfPrev(p, ciPtr->u.chars + ciPtr->baseOffset);
+
+	    if (IsExpandableSpace(q)
+		    && !(breakChunkPtr->wrappedAtSpace
+			&& breakChunkPtr->breakIndex == breakChunkPtr->numBytes)) {
+		addNumBytes = p - q;
+		data->breakChunkPtr->breakIndex -= addNumBytes;
+		data->breakChunkPtr->numSpaces -= 1;
+		data->numSpaces -= 1;
+	    }
+	}
+
+	if (data->breakChunkPtr->breakIndex != data->breakChunkPtr->numBytes) {
+	    TkTextSegment *segPtr;
+	    TkTextDispChunk *chunkPtr = data->breakChunkPtr;
+	    TkTextIndex index = *indexPtr;
+
+	    LayoutUndisplay(data, chunkPtr);
+	    data->chunkPtr = chunkPtr;
+	    TkTextIndexForwBytes(data->textPtr, &index, chunkPtr->byteOffset, &index);
+	    segPtr = TkTextIndexGetContentSegment(&index, NULL);
+	    LayoutMakeCharInfo(data, segPtr, chunkPtr->segByteOffset, data->breakChunkPtr->breakIndex);
+	    segPtr->typePtr->layoutProc(&index, segPtr, chunkPtr->segByteOffset, data->maxX,
+		    data->breakChunkPtr->breakIndex, 0, data->wrapMode, data->textPtr->spaceMode,
+		    chunkPtr);
+	    LayoutFinalizeCharInfo(data, false); /* second parameter doesn't matter here */
+	    LayoutDoWidthAdjustmentForContextDrawing(data);
+	    chunkPtr->numBytes += addNumBytes;
+
+	    if (chunkPtr->skipFirstChar) {
+		chunkPtr->numBytes += 1;
+	    }
+	}
+    }
+
+    /*
+     * Remove all the empty chunks at end of line. In this way we avoid to have
+     * an insert cursur chunk at end of line, which should belong to the next line.
+     */
+
+    if (data->lastChunkPtr->numBytes == 0) {
+	data->breakChunkPtr = data->breakChunkPtr->prevPtr;
+	assert(data->breakChunkPtr);
+	while (data->breakChunkPtr->numBytes == 0) {
+	    data->breakChunkPtr = data->breakChunkPtr->prevPtr;
+	    assert(data->breakChunkPtr);
+	}
+	LayoutDestroyChunks(data);
+    }
+}
+
+static void
+LayoutFullJustification(
+    LayoutData *data,
+    DLine *dlPtr)
+{
+    TkTextDispChunk *chunkPtr;
+    TkTextDispChunk *nextChunkPtr;
+    unsigned numSpaces;
+    int remainingPixels;
+    int shiftX;
+
+    numSpaces = data->numSpaces;
+    remainingPixels = data->maxX - dlPtr->length;
+
+    if (numSpaces == 0 || remainingPixels <= 0) {
+	return;
+    }
+
+    shiftX = 0;
+    chunkPtr = dlPtr->chunkPtr;
+
+    while ((nextChunkPtr = chunkPtr->nextPtr)) {
+	if (chunkPtr->numSpaces > 0) {
+	    unsigned expand = 0;
+	    unsigned i;
+
+	    assert(IsCharChunk(chunkPtr));
+
+	    for (i = 0; i < chunkPtr->numSpaces; ++i) {
+		unsigned space;
+
+		assert(numSpaces > 0);
+		space = (remainingPixels + numSpaces - 1)/numSpaces;
+		expand += space;
+		remainingPixels -= space;
+		numSpaces -= 1;
+	    }
+
+	    shiftX += expand;
+	    chunkPtr->width += expand;
+	    chunkPtr->additionalWidth = expand;
+	}
+
+	nextChunkPtr->x += shiftX;
+	chunkPtr = nextChunkPtr;
+    }
+}
+
+static bool
+LayoutPrevDispLineEndsWithSpace(
+    const TkText *textPtr,
+    const TkTextSegment *segPtr,
+    int offset)
+{
+    assert(segPtr);
+    assert(offset < segPtr->size);
+
+    if (TkTextSegmentIsElided(textPtr, segPtr)) {
+	if (!(segPtr = TkBTreeFindStartOfElidedRange(textPtr->sharedTextPtr, textPtr, segPtr))) {
+	    return false;
+	}
+	offset = -1;
+    }
+
+    if (offset == -1) {
+	while (true) {
+	    if (!(segPtr = segPtr->prevPtr)) {
+		return false;
+	    }
+	    switch ((int) segPtr->typePtr->group) {
+	    case SEG_GROUP_CHAR:
+		return segPtr->body.chars[segPtr->size - 1] == ' ';
+	    case SEG_GROUP_BRANCH:
+		if (segPtr->typePtr == &tkTextLinkType) {
+		    segPtr = segPtr->body.link.prevPtr;
+		}
+	    	break;
+	    case SEG_GROUP_MARK:
+		/* skip */
+		break;
+	    case SEG_GROUP_HYPHEN:
+	    case SEG_GROUP_IMAGE:
+	    case SEG_GROUP_WINDOW:
+	    	return false;
+	    }
+	}
+    }
+
+    return segPtr->typePtr == &tkTextCharType && segPtr->body.chars[offset] == ' ';
+}
+
+static DLine *
+LayoutDLine(
+    const TkTextIndex *indexPtr,/* Beginning of display line. May not necessarily point to
+    				 * a character segment. */
+    int displayLineNo)		/* Display line number of logical line, needed for caching. */
+{
+    TextDInfo *dInfoPtr;
+    DLine *dlPtr;
+    TkText *textPtr;
+    StyleValues *sValPtr;
+    TkTextDispChunk *chunkPtr;
+    TkTextDispChunkSection *sectionPtr;
+    TkTextDispChunkSection *prevSectionPtr;
+    TkTextSegment *segPtr;
+    LayoutData data;
+    bool endOfLogicalLine;
+    bool isStartOfLine;
+    int ascent, descent, leading, jIndent;
+    unsigned countChunks;
+    unsigned chunksPerSection;
+    int length, offset;
+
+    assert(displayLineNo >= 0);
+    assert((displayLineNo == 0) ==
+	    (IsStartOfNotMergedLine(indexPtr) || TkTextIndexIsStartOfText(indexPtr)));
+
+    DEBUG(stats.numLayouted += 1);
+
+    textPtr = indexPtr->textPtr;
+    assert(textPtr);
+    dInfoPtr = textPtr->dInfoPtr;
+
+    /*
+     * Create and initialize a new DLine structure.
+     */
+
+    if (dInfoPtr->dLinePoolPtr) {
+	dlPtr = dInfoPtr->dLinePoolPtr;
+	dInfoPtr->dLinePoolPtr = dlPtr->nextPtr;
+    } else {
+	dlPtr = malloc(sizeof(DLine));
+	DEBUG_ALLOC(tkTextCountNewDLine++);
+    }
+    dlPtr = memset(dlPtr, 0, sizeof(DLine));
+    dlPtr->flags = NEW_LAYOUT|OLD_Y_INVALID;
+    dlPtr->index = *indexPtr;
+    dlPtr->displayLineNo = displayLineNo;
+    TkTextIndexToByteIndex(&dlPtr->index);
+    isStartOfLine = TkTextIndexIsStartOfLine(&dlPtr->index);
+
+    /*
+     * Initialize layout data.
+     */
+
+    memset(&data, 0, sizeof(data));
+    data.index = dlPtr->index;
+    data.justify = textPtr->justify;
+    data.tabIndex = -1;
+    data.tabStyle = TK_TEXT_TABSTYLE_TABULAR;
+    data.wrapMode = textPtr->wrapMode;
+    data.paragraphStart = displayLineNo == 0;
+    data.trimSpaces = textPtr->spaceMode == TEXT_SPACEMODE_TRIM;
+    data.displayLineNo = displayLineNo;
+    data.textPtr = textPtr;
+
+    if (data.paragraphStart) {
+	dlPtr->flags |= PARAGRAPH_START;
+	data.logicalLinePtr = TkTextIndexGetLine(indexPtr);
+	data.byteOffset = TkTextIndexGetByteIndex(indexPtr);
+    } else {
+	TkTextLine *linePtr = TkTextIndexGetLine(indexPtr);
+	TkTextIndex index2 = *indexPtr;
+
+	data.logicalLinePtr = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+	DEBUG(TkTextIndexSetPeer(&index2, NULL)); /* allow index outside of peer */
+	TkTextIndexSetByteIndex2(&index2, data.logicalLinePtr, 0);
+	data.byteOffset = TkTextIndexCountBytes(&index2, indexPtr);
+    }
+
+    segPtr = TkTextIndexGetContentSegment(indexPtr, &offset);
+    data.skipSpaces = data.trimSpaces && LayoutPrevDispLineEndsWithSpace(textPtr, segPtr, offset - 1);
+
+    /*
+     * Skip elided region.
+     */
+
+    if (TkTextSegmentIsElided(textPtr, segPtr)) {
+	segPtr = TkBTreeFindEndOfElidedRange(textPtr->sharedTextPtr, textPtr, segPtr);
+	TkTextIndexSetSegment(&data.index, segPtr);
+	LayoutSkipBytes(&data, dlPtr, indexPtr, &data.index);
+
+	/*
+	 * NOTE: it is possible that we have reached now the end of text. This is
+	 * the only case that an empty display line can be produced, which will be
+	 * linked into the list of display lines. It's only a single superfluous
+	 * line, so we can live with that.
+	 */
+
+	if (TkTextIndexIsEndOfText(&data.index)) {
+	    assert(data.chunkPtr);
+	    assert(!data.chunkPtr->nextPtr);
+	    dlPtr->byteCount = data.chunkPtr->numBytes;
+	    LayoutFreeChunk(&data);
+	    LayoutUpdateLineHeightInformation(&data, dlPtr, data.logicalLinePtr, true, 0);
+	    return dlPtr;
+	}
+    }
+
+    endOfLogicalLine = LayoutLogicalLine(&data, dlPtr);
+    assert(data.numBytesSoFar > 0);
+
+    /*
+     * We're at the end of the display line. Throw away everything after the
+     * most recent word break, if there is one; this may potentially require
+     * the last chunk to be layed out again. Also perform hyphenation, if
+     * enabled, this probably requires the re-layout of a few chunks at the
+     * end of the line.
+     */
+
+    if (!endOfLogicalLine) {
+	LayoutBreakLine(&data, &dlPtr->index);
+    }
+
+    if (data.textPtr->hyphenate) {
+	TkTextDispChunk *chunkPtr = data.firstChunkPtr->nextPtr;
+
+	/*
+	 * Remove all unused hyphen segments, this will speed up the display process,
+	 * because this removal will be done only one time, but the display process
+	 * may iterate over the chunks several times.
+	 */
+
+	while (chunkPtr) {
+	    TkTextDispChunk *nextChunkPtr = chunkPtr->nextPtr;
+
+	    if (nextChunkPtr && chunkPtr->width == 0 && chunkPtr != data.cursorChunkPtr) {
+		chunkPtr->prevPtr->numBytes += chunkPtr->numBytes;
+
+		if ((chunkPtr->prevPtr->nextPtr = nextChunkPtr)) {
+		    nextChunkPtr->prevPtr = chunkPtr->prevPtr;
+		    data.chunkPtr = chunkPtr;
+		    LayoutFreeChunk(&data);
+		}
+	    }
+
+	    chunkPtr = nextChunkPtr;
+	}
+    }
+
+    /*
+     * This has to be done after LayoutBreakLine.
+     */
+
+    dlPtr->chunkPtr = data.firstChunkPtr;
+    dlPtr->lastChunkPtr = data.lastChunkPtr;
+    dlPtr->cursorChunkPtr = data.cursorChunkPtr;
+    dlPtr->firstCharChunkPtr = data.firstCharChunkPtr;
+    dlPtr->breakInfo = data.breakInfo;
+
+    /*
+     * Make tab adjustments for the last tab stop, if there is one.
+     */
+
+    if (data.tabIndex >= 0) {
+	assert(data.tabChunkPtr);
+	AdjustForTab(&data);
+    }
+
+    /*
+     * Make one more pass over the line to recompute various things like its
+     * height, length, and total number of bytes. Also modify the x-locations
+     * of chunks to reflect justification.
+     */
+
+    if (data.wrapMode == TEXT_WRAPMODE_NONE) {
+	data.maxX = dInfoPtr->maxX - dInfoPtr->x - data.rMargin;
+    }
+    length = dlPtr->length = data.lastChunkPtr->x + data.lastChunkPtr->width;
+    if (data.wrapMode != TEXT_WRAPMODE_NONE) {
+	length = MIN(length, data.maxX);
+    }
+
+    jIndent = 0;
+
+    switch (data.justify) {
+    case TK_TEXT_JUSTIFY_LEFT:
+    	/* no action */
+	break;
+    case TK_TEXT_JUSTIFY_RIGHT:
+	jIndent = data.maxX - length;
+	break;
+    case TK_TEXT_JUSTIFY_FULL:
+	if (!endOfLogicalLine) {
+	    LayoutFullJustification(&data, dlPtr);
+	}
+	break;
+    case TK_TEXT_JUSTIFY_CENTER:
+	jIndent = (data.maxX - length)/2;
+	break;
+    }
+
+    ascent = descent = 0;
+    sectionPtr = prevSectionPtr = NULL;
+    chunksPerSection = (data.countChunks + MAX_SECTIONS_PER_LINE - 1)/MAX_SECTIONS_PER_LINE;
+    chunksPerSection = MAX(chunksPerSection, MIN_CHUNKS_PER_SECTION);
+    countChunks = chunksPerSection - 1;
+
+    for (chunkPtr = dlPtr->chunkPtr; chunkPtr; chunkPtr = chunkPtr->nextPtr) {
+	if (++countChunks == chunksPerSection) {
+	    /*
+	     * Create next section.
+	     */
+	    sectionPtr = LayoutNewSection(dInfoPtr);
+	    if (prevSectionPtr) {
+		prevSectionPtr->nextPtr = sectionPtr;
+	    }
+	    sectionPtr->chunkPtr = chunkPtr;
+	    prevSectionPtr = sectionPtr;
+	    countChunks = 0;
+	}
+	chunkPtr->sectionPtr = sectionPtr;
+	sectionPtr->numBytes += chunkPtr->numBytes;
+	dlPtr->byteCount += chunkPtr->numBytes;
+	chunkPtr->x += jIndent;
+	ascent = MAX(ascent, chunkPtr->minAscent);
+	descent = MAX(descent, chunkPtr->minDescent);
+	dlPtr->height = MAX(dlPtr->height, chunkPtr->minHeight);
+	sValPtr = chunkPtr->stylePtr->sValuePtr;
+	if (sValPtr->borderWidth > 0 && sValPtr->relief != TK_RELIEF_FLAT) {
+	    dlPtr->flags |= HAS_3D_BORDER;
+	}
+    }
+
+    leading = ascent + descent;
+
+    if (dlPtr->height < leading) {
+	dlPtr->height = leading;
+	dlPtr->baseline = ascent;
+    } else {
+	dlPtr->baseline = ascent + (dlPtr->height - leading)/2;
+    }
+
+    sValPtr = dlPtr->chunkPtr->stylePtr->sValuePtr;
+
+    dlPtr->spaceAbove = isStartOfLine ? sValPtr->spacing1 : (sValPtr->spacing2 + 1)/2;
+    dlPtr->spaceBelow = endOfLogicalLine ? sValPtr->spacing3 : sValPtr->spacing2/2;
+    dlPtr->height += dlPtr->spaceAbove + dlPtr->spaceBelow;
+    dlPtr->baseline += dlPtr->spaceAbove;
+    /* line length may have changed because of justification */
+    dlPtr->length = data.lastChunkPtr->x + jIndent + data.lastChunkPtr->width;
+
+    LayoutUpdateLineHeightInformation(&data, dlPtr, data.logicalLinePtr,
+	    endOfLogicalLine, data.hyphenRule);
+
+    return dlPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * CheckIfLineMetricIsUpToDate --
+ *
+ *	This function wil be invoked after update of line metric calculations.
+ *	It checks whether the all line metrics are up-to-date, and will
+ *	invoke the appropriate actions.
+ *
+ * Results:
+ *	Returns true if the widget has not been deleted by receiver of the
+ *	triggered callback.
+ *
+ * Side effects:
+ *	Firing the <<WidgetViewSync>> event, scrollbar update, and resetting
+ *	some states.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+TriggerWatchCursor(
+    TkText *textPtr)
+{
+    if (textPtr->watchCmd) {
+	TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+	char buf[2][2*TK_POS_CHARS + 2];
+
+	if (memcmp(&dInfoPtr->curPixelPos, &dInfoPtr->prevPixelPos, sizeof(PixelPos)) != 0) {
+	    textPtr->sharedTextPtr->triggerWatchCmd = false;
+	    snprintf(buf[0], sizeof(buf[0]), "@%d,%d",
+		    dInfoPtr->curPixelPos.xFirst, dInfoPtr->curPixelPos.yFirst);
+	    snprintf(buf[1], sizeof(buf[1]), "@%d,%d",
+		    dInfoPtr->curPixelPos.xLast, dInfoPtr->curPixelPos.yLast);
+	    TkTextTriggerWatchCmd(textPtr, "view", buf[0], buf[1], NULL, false);
+	    memcpy(&textPtr->dInfoPtr->prevPixelPos, &textPtr->dInfoPtr->curPixelPos, sizeof(PixelPos));
+	    textPtr->sharedTextPtr->triggerWatchCmd = true;
+	}
+    }
+
+    return !(textPtr->flags & DESTROYED);
+}
+
+static void
+UpdateLineMetricsFinished(
+    TkText *textPtr,
+    bool sendImmediately)
+{
+    assert(TkRangeListIsEmpty(textPtr->dInfoPtr->lineMetricUpdateRanges));
+
+    textPtr->dInfoPtr->flags &= ~(ASYNC_UPDATE|ASYNC_PENDING);
+    textPtr->dInfoPtr->pendingUpdateLineMetricsFinished = false;
+
+    TkTextRunAfterSyncCmd(textPtr);
+
+    /*
+     * Fire the <<WidgetViewSync>> event since the widget view is in sync
+     * with its internal data (actually it will be after the next trip
+     * through the event loop, because the widget redraws at idle-time).
+     */
+
+    TkTextGenerateWidgetViewSyncEvent(textPtr, sendImmediately);
+}
+
+static void
+RunUpdateLineMetricsFinished(
+    ClientData clientData)
+{
+    TkText *textPtr = (TkText *) clientData;
+
+    if (!(textPtr->flags & DESTROYED)) {
+	textPtr->dInfoPtr->pendingUpdateLineMetricsFinished = false;
+	if (TkRangeListIsEmpty(textPtr->dInfoPtr->lineMetricUpdateRanges)) {
+	    UpdateLineMetricsFinished(textPtr, true);
+	}
+    }
+}
+
+static void
+CheckIfLineMetricIsUpToDate(
+    TkText *textPtr)
+{
+    if (textPtr->sharedTextPtr->allowUpdateLineMetrics
+	    && TkRangeListIsEmpty(textPtr->dInfoPtr->lineMetricUpdateRanges)) {
+	/*
+	 * Remove the async handler.
+	 */
+
+	if (textPtr->dInfoPtr->lineUpdateTimer) {
+	    Tcl_DeleteTimerHandler(textPtr->dInfoPtr->lineUpdateTimer);
+	    textPtr->refCount -= 1;
+	    textPtr->dInfoPtr->lineUpdateTimer = NULL;
+	}
+
+	/*
+	 * If we have a full update, then also update the scrollbar.
+	 */
+
+	GetYView(textPtr->interp, textPtr, true);
+
+	if (!(TriggerWatchCursor(textPtr))) {
+	    return; /* the widget has been deleted */
+	}
+
+	/*
+	 * Report finish of full update.
+	 */
+
+	if (!textPtr->dInfoPtr->pendingUpdateLineMetricsFinished) {
+	    textPtr->dInfoPtr->pendingUpdateLineMetricsFinished = true;
+	    Tcl_DoWhenIdle(RunUpdateLineMetricsFinished, (ClientData) textPtr);
+	}
+
+	if (tkBTreeDebug) {
+	    CheckLineMetricConsistency(textPtr);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * SaveDisplayLines --
+ *
+ *	Save the display lines, produced during line metric computation,
+ *	for displaying. So UpdateDisplayInfo eventually must not re-compute
+ *	these lines. This function will only be called if it is sure that
+ *	DisplayText will be triggered afterwards, because UpdateDisplayInfo
+ *	(called by DisplayText) is responsible for releasing the unused lines.
+ *	The caller is responsible that the display will be saved in order from
+ *	top to bottom, without gaps.
+ *
+ *	Saving the produced display lines is an important speed improvement
+ *	(especially on Mac). Consider the following use case:
+ *
+ *	1. The text widget will be created.
+ *	2. Content will be inserted.
+ *	3. The view will be changed (for example to the end of the file).
+ *
+ *	In this case MeasureDown will produce display lines for line metric
+ *	calculation, needed for the change of the view, and afterwards
+ *	UpdateDisplayInfo needs (some of) these lines for displaying.
+ *
+ *	Note that no more lines will be saved than fitting into the widget,
+ *	all surplus lines will be released immediately.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The display lines will be saved in TextDInfo. Function UpdateDisplayInfo
+ *	is responsible to release the unused lines. The cached lines in
+ *	argument 'info' will be taken over, this means that 'info->dLinePtr'
+ *	is NULL after this function has done his work.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+SaveDisplayLines(
+    TkText *textPtr,
+    DisplayInfo *info,
+    bool append)	/* Append to previously saved lines if 'true', otherwise prepend. */
+{
+    TextDInfo *dInfoPtr;
+    DLine *firstPtr, *lastPtr;
+    int height, viewHeight;
+
+    if (!(firstPtr = info->dLinePtr)) {
+	return;
+    }
+
+    assert(info->lastDLinePtr);
+    lastPtr = info->lastDLinePtr;
+    dInfoPtr = textPtr->dInfoPtr;
+    height = dInfoPtr->savedDisplayLinesHeight + info->heightOfCachedLines;
+    viewHeight = Tk_Height(textPtr->tkwin) - 2*textPtr->highlightWidth;
+    /* we need some overhead, because the widget may show lines only partially */
+    viewHeight += info->dLinePtr->height;
+
+    if (append) {
+	if (dInfoPtr->lastSavedDLinePtr) {
+	    dInfoPtr->lastSavedDLinePtr->nextPtr = firstPtr;
+	    firstPtr->prevPtr = dInfoPtr->lastSavedDLinePtr;
+	} else {
+	    dInfoPtr->savedDLinePtr = firstPtr;
+	}
+	dInfoPtr->lastSavedDLinePtr = lastPtr;
+	firstPtr = lastPtr = dInfoPtr->savedDLinePtr;
+	while (lastPtr->nextPtr && height >= viewHeight - lastPtr->height) {
+	    height -= lastPtr->height;
+	    lastPtr = lastPtr->nextPtr;
+	}
+	if (firstPtr != lastPtr) {
+	    FreeDLines(textPtr, firstPtr, lastPtr, DLINE_FREE_TEMP);
+	    assert(dInfoPtr->savedDLinePtr == lastPtr);
+	}
+    } else {
+	if (dInfoPtr->savedDLinePtr) {
+	    lastPtr->nextPtr = dInfoPtr->savedDLinePtr;
+	    dInfoPtr->savedDLinePtr->prevPtr = lastPtr;
+	} else {
+	    dInfoPtr->lastSavedDLinePtr = lastPtr;
+	}
+	dInfoPtr->savedDLinePtr = firstPtr;
+	firstPtr = lastPtr = dInfoPtr->lastSavedDLinePtr;
+	while (firstPtr->prevPtr && height >= viewHeight - firstPtr->height) {
+	    height -= firstPtr->height;
+	    firstPtr = firstPtr->prevPtr;
+	}
+	if (firstPtr != lastPtr) {
+	    FreeDLines(textPtr, firstPtr->nextPtr, NULL, DLINE_FREE_TEMP);
+	    assert(!firstPtr->nextPtr);
+	    dInfoPtr->lastSavedDLinePtr = firstPtr;
+	}
+    }
+
+    dInfoPtr->savedDisplayLinesHeight = height;
+    info->dLinePtr = info->lastDLinePtr = NULL;
+    info->numCachedLines = 0;
+    info->heightOfCachedLines = 0;
+    assert(!dInfoPtr->savedDLinePtr == !dInfoPtr->lastSavedDLinePtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ComputeDisplayLineInfo --
+ *
+ *	This functions computes the display line information for struct
+ *	DisplayInfo. If the cached information is still incomplete for
+ *	this computation then LayoutDLine will be used for the computation
+ *	of the missing display lines.
+ *
+ *	If additional display line computation is required for the line
+ *	metric computation, then these lines will ba cached, but only
+ *	the last produced lines which can fit into the widget (this means:
+ *	no more lines than fitting into the widget will be cached).
+ *
+ * Results:
+ *	The attributes of 'info' will be set. The return value is the
+ *	corresponding logical line.
+ *
+ * Side effects:
+ *	The cache may be filled with more line metric information.
+ *	Furthermore some of the produced display lines will be cached,
+ *	the caller is responsible to release these lines.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextDispLineEntry *
+SearchDispLineEntry(
+    TkTextDispLineEntry *first,
+    const TkTextDispLineEntry *last,
+    unsigned byteOffset)
+{
+    /*
+     * NOTE: here 'last' is the last entry (not the pointer after the last
+     * element as usual).
+     */
+
+    if (byteOffset >= last->byteOffset) {
+	return (TkTextDispLineEntry *) last; /* frequent case */
+    }
+
+    while (first != last) {
+	TkTextDispLineEntry *mid = first + (last - first)/2;
+
+	if (byteOffset >= (mid + 1)->byteOffset) {
+	    first = mid + 1;
+	} else {
+	    last = mid;
+	}
+    }
+
+    return first;
+}
+
+static void
+InsertDLine(
+    TkText *textPtr,
+    DisplayInfo *info,
+    DLine *dlPtr,
+    unsigned viewHeight)
+{
+    DLine *firstPtr = info->dLinePtr;
+
+    assert(!dlPtr->nextPtr);
+    assert(!dlPtr->prevPtr);
+
+    info->heightOfCachedLines += dlPtr->height;
+
+    if (firstPtr && info->heightOfCachedLines >= viewHeight + firstPtr->height) {
+	info->heightOfCachedLines -= firstPtr->height;
+	if ((info->dLinePtr = firstPtr->nextPtr)) {
+	    info->dLinePtr->prevPtr = NULL;
+	} else {
+	    info->lastDLinePtr = NULL;
+	}
+	firstPtr->nextPtr = NULL;
+	FreeDLines(textPtr, firstPtr, NULL, DLINE_FREE_TEMP);
+    } else {
+	info->numCachedLines += 1;
+    }
+    if (info->lastDLinePtr) {
+	assert(info->dLinePtr);
+	info->lastDLinePtr->nextPtr = dlPtr;
+	dlPtr->prevPtr = info->lastDLinePtr;
+    } else {
+	assert(!info->dLinePtr);
+	info->dLinePtr = dlPtr;
+    }
+    info->lastDLinePtr = dlPtr;
+}
+
+static TkTextLine *
+ComputeDisplayLineInfo(
+    TkText *textPtr,
+    const TkTextIndex *indexPtr,
+    DisplayInfo *info)
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    TkTextPixelInfo *pixelInfo;
+    TkTextDispLineInfo *dispLineInfo;
+    TkTextDispLineEntry *entry;
+    TkTextLine *logicalLinePtr;
+    TkTextLine *linePtr;
+    unsigned byteOffset;
+    unsigned startByteOffset;
+    unsigned viewHeight;
+
+    assert(info);
+
+    linePtr = TkTextIndexGetLine(indexPtr);
+    logicalLinePtr = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+    pixelInfo = TkBTreeLinePixelInfo(textPtr, logicalLinePtr);
+    dispLineInfo = pixelInfo->dispLineInfo;
+    info->index = *indexPtr;
+    TkTextIndexSetToStartOfLine2(&info->index, logicalLinePtr);
+    startByteOffset = TkTextIndexGetByteIndex(&info->index);
+    byteOffset = TkTextIndexCountBytes(&info->index, indexPtr);
+    byteOffset += TkTextIndexGetByteIndex(&info->index);
+
+    info->pixelInfo = pixelInfo;
+    info->displayLineNo = 0;
+    info->numDispLines = 1;
+    info->entry = info->entryBuffer;
+    info->dLinePtr = info->lastDLinePtr = NULL;
+    info->nextByteOffset = -1;
+    info->numCachedLines = 0;
+    info->heightOfCachedLines = 0;
+    info->linePtr = linePtr;
+
+    if (dInfoPtr->lineMetricUpdateEpoch == (pixelInfo->epoch & EPOCH_MASK)) {
+	if (!dispLineInfo) {
+	    TkTextLine *nextLogicalLinePtr =
+		    TkBTreeNextLogicalLine(textPtr->sharedTextPtr, textPtr, logicalLinePtr);
+
+	    entry = info->entryBuffer;
+	    if (logicalLinePtr->nextPtr == nextLogicalLinePtr
+		    && TkTextIndexIsStartOfLine(&info->index)) {
+		info->nextByteOffset = logicalLinePtr->size - byteOffset;
+		entry->byteOffset = 0;
+		(entry + 1)->byteOffset = logicalLinePtr->size;
+	    } else {
+		TkTextIndex index2 = info->index;
+		TkTextIndexSetToStartOfLine2(&index2, nextLogicalLinePtr);
+		info->nextByteOffset = TkTextIndexCountBytes(&info->index, &index2);
+		entry->byteOffset = TkTextIndexGetByteIndex(&info->index);
+		(entry + 1)->byteOffset = entry->byteOffset + info->nextByteOffset;
+	    }
+	    info->byteOffset = byteOffset;
+	    info->isComplete = true;
+	    info->pixels = pixelInfo->height;
+	    entry->height = pixelInfo->height;
+	    entry->pixels = pixelInfo->height;
+	    byteOffset = (entry + 1)->byteOffset - startByteOffset;
+	    TkTextIndexForwBytes(textPtr, &info->index, byteOffset, &info->index);
+	    return logicalLinePtr;
+	}
+
+	if (dispLineInfo->numDispLines > 0) {
+	    const TkTextDispLineEntry *last;
+	    unsigned nextByteOffset;
+
+	    last = dispLineInfo->entry + dispLineInfo->numDispLines;
+	    entry = SearchDispLineEntry(dispLineInfo->entry, last, byteOffset);
+
+	    if (entry != last) {
+		info->entry = entry;
+		info->byteOffset = byteOffset - entry->byteOffset;
+		info->nextByteOffset = (entry + 1)->byteOffset - byteOffset;
+		info->displayLineNo = entry - dispLineInfo->entry;
+		info->numDispLines = dispLineInfo->numDispLines;
+		info->pixels = (last - 1)->pixels;
+		info->isComplete = (dInfoPtr->lineMetricUpdateEpoch == pixelInfo->epoch);
+		byteOffset = last->byteOffset - startByteOffset;
+		TkTextIndexForwBytes(textPtr, &info->index, byteOffset, &info->index);
+		return logicalLinePtr;
+	    }
+
+	    /*
+	     * If we reach this point, then we need more information than already
+	     * computed for this line.
+	     */
+
+	    info->displayLineNo = dispLineInfo->numDispLines;
+	    nextByteOffset = last->byteOffset - dispLineInfo->entry[0].byteOffset;
+	    TkBTreeMoveForward(&info->index, nextByteOffset);
+	    byteOffset -= nextByteOffset;
+	}
+    }
+
+    /*
+     * Compute missing line metric information. Don't throw away the produced display
+     * lines, probably the caller might use it. But do not cache more than fitting into
+     * the widget.
+     */
+
+    viewHeight = Tk_Height(textPtr->tkwin) - 2*textPtr->highlightWidth;
+    /* we need some overhead, because the widget may show lines only partially */
+    viewHeight += dInfoPtr->dLinePtr ? dInfoPtr->dLinePtr->height : 20;
+
+    while (true) {
+	DLine *dlPtr;
+
+	if (dInfoPtr->lastMetricDLinePtr
+		&& TkTextIndexIsEqual(&info->index, &dInfoPtr->lastMetricDLinePtr->index)) {
+	    dlPtr = dInfoPtr->lastMetricDLinePtr;
+	    dInfoPtr->lastMetricDLinePtr = NULL;
+	    assert(dlPtr->displayLineNo == info->displayLineNo);
+	} else {
+	    dlPtr = LayoutDLine(&info->index, info->displayLineNo);
+	}
+	InsertDLine(textPtr, info, dlPtr, viewHeight);
+	TkTextIndexForwBytes(textPtr, &info->index, dlPtr->byteCount, &info->index);
+	if (dInfoPtr->lineMetricUpdateEpoch == pixelInfo->epoch || byteOffset < dlPtr->byteCount) {
+	    info->byteOffset = byteOffset;
+	    info->nextByteOffset = dlPtr->byteCount - byteOffset;
+	    info->isComplete = (dInfoPtr->lineMetricUpdateEpoch == pixelInfo->epoch);
+	    break;
+	}
+	byteOffset -= dlPtr->byteCount;
+	info->displayLineNo += 1;
+    }
+
+    /*
+     * Note that LayoutDLine may re-allocate 'pixelInfo->dispLineInfo',
+     * so variable 'dispLineInfo' is in general not valid anymore.
+     */
+
+    dispLineInfo = pixelInfo->dispLineInfo;
+
+    if (dispLineInfo) {
+	info->numDispLines = dispLineInfo->numDispLines;
+	info->entry = dispLineInfo->entry + info->displayLineNo;
+	info->pixels = dispLineInfo->entry[dispLineInfo->numDispLines - 1].pixels;
+    } else {
+	info->pixels = pixelInfo->height;
+	info->entryBuffer[0].height = pixelInfo->height;
+	info->entryBuffer[0].pixels = pixelInfo->height;
+	info->entryBuffer[0].byteOffset = byteOffset;
+	info->entryBuffer[1].byteOffset = info->nextByteOffset + info->byteOffset;
+    }
+
+    return logicalLinePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ComputeMissingMetric --
+ *
+ *	This functions is continuing the computation of an unfinished
+ *	display line metric, which can only happen if a logical line
+ *	is wrapping into several display lines. It may not be required
+ *	to compute all missing display lines, the computation stops
+ *	until the threshold has been reached. But the compuation will
+ *	always stop at the end of the logical line.
+ *
+ *	Possible threshold types are THRESHOLD_BYTE_OFFSET,
+ *	THRESHOLD_PIXEL_DISTANCE, and THRESHOLD_LINE_OFFSET. The two
+ *	former thresholds will be specified absolute (but relative to
+ *	start of logical line), and the latter thresholds will be specified
+ *	relative to info->displayLineNo.
+ *
+ *	If additional display line computation is required for the line
+ *	metric computation, then these lines will ba cached, but only
+ *	the last produced lines which can fit into the widget (this means:
+ *	no more lines than fitting into the widget will be cached).
+ *
+ *	It is important that this function is only computing the relevant
+ *	line metric. It may happen that a logical line may wrap into
+ *	thousands of display lines, but if only the first 100 (following
+ *	lines) are needed, then only the first 100 should be computed here,
+ *	not more.
+ *
+ * Results:
+ *	The attributes of 'info' will be updated.
+ *
+ * Side effects:
+ *	The cache may be filled with more line metric information.
+ *	Furthermore some of the produced display lines will be cached,
+ *	the caller is responsible to release these lines.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+ComputeMissingMetric(
+    TkText *textPtr,
+    DisplayInfo *info,
+    Threshold thresholdType,
+    int threshold)
+{
+    int byteOffset, additionalLines;
+    int displayLineNo;
+    int *metricPtr = NULL; /* avoids compiler warning */
+    unsigned viewHeight;
+    TkTextIndex index;
+
+    assert(threshold >= 0);
+
+    if (info->isComplete) {
+	return;
+    }
+
+    additionalLines = info->numDispLines - info->displayLineNo;
+    assert(additionalLines > 0);
+    byteOffset = info->entry[additionalLines].byteOffset;
+    displayLineNo = info->numDispLines;
+    viewHeight = Tk_Height(textPtr->tkwin) - 2*textPtr->highlightWidth;
+    /* we need some overhead, because the widget may show lines only partially */
+    viewHeight += textPtr->dInfoPtr->dLinePtr ? textPtr->dInfoPtr->dLinePtr->height : 20;
+    TkTextIndexForwBytes(textPtr, &info->index,
+	    byteOffset - info->entry[additionalLines - 1].byteOffset, &index);
+
+    switch (thresholdType) {
+    case THRESHOLD_BYTE_OFFSET:    metricPtr = &byteOffset; break;
+    case THRESHOLD_LINE_OFFSET:    metricPtr = &additionalLines; break;
+    case THRESHOLD_PIXEL_DISTANCE: metricPtr = &info->pixels; break;
+    }
+
+    while (threshold >= *metricPtr) {
+	DLine *dlPtr = LayoutDLine(&info->index, displayLineNo++);
+	info->pixels += dlPtr->height;
+	byteOffset += dlPtr->byteCount;
+	info->numDispLines += 1;
+	additionalLines -= 1;
+	TkTextIndexForwBytes(textPtr, &info->index, dlPtr->byteCount, &info->index);
+	InsertDLine(textPtr, info, dlPtr, viewHeight);
+
+	if (IsStartOfNotMergedLine(&info->index)) {
+	    info->isComplete = true;
+	    break;
+	}
+    }
+
+    info->entry = info->pixelInfo->dispLineInfo->entry + info->displayLineNo;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UpdateDisplayInfo --
+ *
+ *	This function is invoked to recompute some or all of the DLine
+ *	structures for a text widget. At the time it is called the DLine
+ *	structures still left in the widget are guaranteed to be correct
+ *	except that (a) the y-coordinates aren't necessarily correct, (b)
+ *	there may be missing structures (the DLine structures get removed as
+ *	soon as they are potentially out-of-date), and (c) DLine structures
+ *	that don't start at the beginning of a line may be incorrect if
+ *	previous information in the same line changed size in a way that moved
+ *	a line boundary (DLines for any info that changed will have been
+ *	deleted, but not DLines for unchanged info in the same text line).
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Upon return, the DLine information for textPtr correctly reflects the
+ *	positions where characters will be displayed. However, this function
+ *	doesn't actually bring the display up-to-date.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+LineIsUpToDate(
+    TkText *textPtr,
+    DLine *dlPtr,
+    unsigned lineMetricUpdateEpoch)
+{
+    const TkTextPixelInfo *pixelInfo = TkBTreeLinePixelInfo(textPtr, TkTextIndexGetLine(&dlPtr->index));
+    const TkTextDispLineInfo *dispLineInfo = pixelInfo->dispLineInfo;
+    unsigned epoch = pixelInfo->epoch;
+
+    assert(!(epoch & PARTIAL_COMPUTED_BIT) || dispLineInfo);
+
+    return (epoch & EPOCH_MASK) == lineMetricUpdateEpoch
+	    && (!dispLineInfo || dlPtr->displayLineNo < dispLineInfo->numDispLines);
+}
+
+static void
+UpdateDisplayInfo(
+    TkText *textPtr)	/* Text widget to update. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    DLine *dlPtr;
+    DLine *topLine;
+    DLine *bottomLine;
+    DLine *newTopLine;
+    DLine *savedDLine;		/* usable saved display lines */
+    DLine *prevSavedDLine;	/* last old unfreed display line */
+    TkTextIndex index;
+    TkTextLine *lastLinePtr;
+    TkTextLine *linePtr;
+    DisplayInfo info;
+    int y, maxY, xPixelOffset, maxOffset;
+    int displayLineNo;
+    unsigned epoch;
+
+    if (!(dInfoPtr->flags & DINFO_OUT_OF_DATE)) {
+	return;
+    }
+    dInfoPtr->flags &= ~DINFO_OUT_OF_DATE;
+
+    /*
+     * At first, update the default style, and reset cached chunk.
+     */
+
+    UpdateDefaultStyle(textPtr);
+    dInfoPtr->currChunkPtr = NULL;
+
+    /*
+     * Release the cached display lines.
+     */
+
+    FreeDLines(textPtr, NULL, NULL, DLINE_CACHE);
+
+    /*
+     * Delete any DLines that are now above the top of the window.
+     */
+
+    index = textPtr->topIndex;
+    prevSavedDLine = NULL;
+    savedDLine = dInfoPtr->savedDLinePtr;
+
+    if ((dlPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, &index))) {
+	/*
+	 * Don't throw away unused display lines immediately, because it may happen
+	 * that we will reuse some of them later.
+	 */
+
+	prevSavedDLine = FreeDLines(textPtr, dInfoPtr->dLinePtr, dlPtr, DLINE_SAVE);
+    }
+
+    /*
+     * Scan through the contents of the window from top to bottom, recomputing
+     * information for lines that are missing.
+     */
+
+    linePtr = TkTextIndexGetLine(&index);
+    lastLinePtr = TkBTreeGetLastLine(textPtr);
+    dlPtr = dInfoPtr->dLinePtr;
+    topLine = bottomLine = NULL;
+    y = dInfoPtr->y - dInfoPtr->newTopPixelOffset;
+    maxY = dInfoPtr->maxY;
+    newTopLine = NULL;
+    epoch = dInfoPtr->lineMetricUpdateEpoch;
+    dInfoPtr->maxLength = 0;
+
+    if (IsStartOfNotMergedLine(&index)) {
+	displayLineNo = 0;
+    } else {
+	ComputeDisplayLineInfo(textPtr, &index, &info);
+	TkTextIndexBackBytes(textPtr, &index, info.byteOffset, &index);
+	displayLineNo = info.displayLineNo;
+
+	if (info.lastDLinePtr) {
+	    /*
+	     * Keep last produced display line, probably we can re-use it for new top line.
+	     */
+
+	    newTopLine = info.lastDLinePtr;
+	    if (newTopLine->prevPtr) {
+		newTopLine->prevPtr->nextPtr = NULL;
+		newTopLine->prevPtr = NULL;
+	    } else {
+		assert(info.dLinePtr == info.lastDLinePtr);
+		info.dLinePtr = info.lastDLinePtr = NULL;
+	    }
+	    assert(!newTopLine->nextPtr);
+	}
+	FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+    }
+
+    /*
+     * If we have saved display lines from a previous metric computation,
+     * then we will search for the first re-usable line.
+     */
+
+    while (savedDLine && TkTextIndexCompare(&savedDLine->index, &index) < 0) {
+	savedDLine = savedDLine->nextPtr;
+    }
+
+    /*
+     * If we have a cached top-line, then insert this line into the list of saved lines.
+     */
+
+    if (newTopLine) {
+	/*
+	 * If we have a cached top-line, then it's not possible that this line
+	 * is also in the list of saved lines (because ComputeDisplayLineInfo
+	 * cannot produce a display line if the metric of this line is already
+	 * known, and the line metric is known as soon as the line has been
+	 * computed). This means that we can prepend this top-line to the list
+	 * of saved lines.
+	 */
+
+	assert(!savedDLine || TkTextIndexCompare(&savedDLine->index, &newTopLine->index) > 0);
+
+	if ((newTopLine->nextPtr = savedDLine)) {
+	    newTopLine->prevPtr = savedDLine->prevPtr;
+	    savedDLine->prevPtr = newTopLine;
+	} else if (dInfoPtr->savedDLinePtr) {
+	    dInfoPtr->lastSavedDLinePtr->nextPtr = newTopLine;
+	    newTopLine->prevPtr = dInfoPtr->lastSavedDLinePtr;
+	    dInfoPtr->lastSavedDLinePtr = newTopLine;
+	}
+	if (dInfoPtr->savedDLinePtr == savedDLine) {
+	    dInfoPtr->savedDLinePtr = newTopLine;
+	}
+	if (!dInfoPtr->lastSavedDLinePtr) {
+	    dInfoPtr->lastSavedDLinePtr = newTopLine;
+	}
+
+	savedDLine = newTopLine;
+    } else {
+	newTopLine = savedDLine;
+    }
+
+    if (newTopLine && !prevSavedDLine) {
+	prevSavedDLine = newTopLine->prevPtr;
+    }
+
+    while (linePtr != lastLinePtr) {
+	int cmp;
+
+	/*
+	 * There are three possibilities right now:
+	 *
+	 * (a) the next DLine (dlPtr) corresponds exactly to the next
+	 *     information we want to display: just use it as-is.
+	 *
+	 * (b) the next DLine corresponds to a different line, or to a segment
+	 *     that will be coming later in the same line: leave this DLine
+	 *     alone in the hopes that we'll be able to use it later, then
+	 *     create a new DLine in front of it.
+	 *
+	 * (c) the next DLine corresponds to a segment in the line we want,
+	 *     but it's a segment that has already been processed or will
+	 *     never be processed. Delete the DLine and try again.
+	 *
+	 * One other twist on all this. It's possible for 3D borders to
+	 * interact between lines (see DisplayLineBackground) so if a line is
+	 * relayed out and has styles with 3D borders, its neighbors have to
+	 * be redrawn if they have 3D borders too, since the interactions
+	 * could have changed (the neighbors don't have to be relayed out,
+	 * just redrawn).
+	 */
+
+	if (!dlPtr
+		|| TkTextIndexGetLine(&dlPtr->index) != linePtr
+		|| !LineIsUpToDate(textPtr, dlPtr, epoch)
+		|| (cmp = TkTextIndexCompare(&index, &dlPtr->index)) < 0) {
+	    /*
+	     * Case (b) -- must make new DLine.
+	     */
+
+	    TK_TEXT_DEBUG(LogTextRelayout(textPtr, &index));
+	    if (savedDLine && TkTextIndexIsEqual(&index, &savedDLine->index)) {
+		dlPtr = savedDLine;
+		savedDLine = savedDLine->nextPtr;
+		if (dInfoPtr->savedDLinePtr == dlPtr) {
+		    dInfoPtr->savedDLinePtr = dlPtr->nextPtr;
+		}
+		if (dInfoPtr->lastSavedDLinePtr == dlPtr) {
+		    dInfoPtr->lastSavedDLinePtr = dlPtr->prevPtr;
+		}
+		if (dlPtr->prevPtr) {
+		    dlPtr->prevPtr->nextPtr = dlPtr->nextPtr;
+		}
+		if (dlPtr->nextPtr) {
+		    dlPtr->nextPtr->prevPtr = dlPtr->prevPtr;
+		}
+		dlPtr->prevPtr = dlPtr->nextPtr = NULL;
+		DEBUG(stats.numReused++);
+	    } else {
+		dlPtr = LayoutDLine(&index, displayLineNo);
+	    }
+	    assert(!(dlPtr->flags & (LINKED|CACHED|DELETED)));
+	    if (!bottomLine) {
+		if ((dlPtr->nextPtr = dInfoPtr->dLinePtr)) {
+		    dInfoPtr->dLinePtr->prevPtr = dlPtr;
+		}
+		dInfoPtr->dLinePtr = dlPtr;
+	    } else {
+		if ((dlPtr->nextPtr = bottomLine->nextPtr)) {
+		    bottomLine->nextPtr->prevPtr = dlPtr;
+		}
+		bottomLine->nextPtr = dlPtr;
+		dlPtr->prevPtr = bottomLine;
+
+		if (bottomLine->flags & HAS_3D_BORDER) {
+		    bottomLine->flags |= OLD_Y_INVALID;
+		}
+	    }
+	    DEBUG(dlPtr->flags |= LINKED);
+	} else if (cmp == 0) {
+	    /*
+	     * Case (a) - can use existing display line as-is.
+	     */
+
+	    if (bottomLine && (dlPtr->flags & HAS_3D_BORDER) && (bottomLine->flags & NEW_LAYOUT)) {
+		dlPtr->flags |= OLD_Y_INVALID;
+	    }
+	    assert(dlPtr->displayLineNo == displayLineNo);
+	} else /* if (cmp > 0) */ {
+	    /*
+	     * Case (c) - dlPtr is useless. Discard it and start again with the next display line.
+	     */
+
+	    DLine *nextPtr = dlPtr->nextPtr;
+	    FreeDLines(textPtr, dlPtr, nextPtr, DLINE_UNLINK);
+	    dlPtr = nextPtr;
+	    continue;
+	}
+
+	/*
+	 * Advance to the start of the next display line.
+	 */
+
+	dlPtr->y = y;
+	y += dlPtr->height;
+	TkTextIndexForwBytes(textPtr, &index, dlPtr->byteCount, &index);
+	linePtr = TkTextIndexGetLine(&index);
+
+	if (linePtr->logicalLine && TkTextIndexIsStartOfLine(&index)) {
+	    displayLineNo = 0;
+	} else {
+	    displayLineNo += 1;
+	}
+
+	bottomLine = dlPtr;
+	dlPtr = dlPtr->nextPtr;
+
+	/*
+	 * It's important to have the following check here rather than in the
+	 * while statement for the loop, so that there's always at least one
+	 * DLine generated, regardless of how small the window is. This keeps
+	 * a lot of other code from breaking.
+	 */
+
+	if (y >= maxY) {
+	    break;
+	}
+    }
+
+    /* Delete any DLine structures that don't fit on the screen. */
+    FreeDLines(textPtr, dlPtr, NULL, DLINE_UNLINK);
+    topLine = dInfoPtr->dLinePtr;
+
+    /*
+     * If there is extra space at the bottom of the window (because we've hit
+     * the end of the text), then bring in more lines at the top of the
+     * window, if there are any, to fill in the view.
+     *
+     * Since the top line may only be partially visible, we try first to
+     * simply show more pixels from that line (newTopPixelOffset). If that
+     * isn't enough, we have to layout more lines.
+     */
+
+    if (y < maxY) {
+	/*
+	 * This counts how many vertical pixels we have left to fill by
+	 * pulling in more display pixels either from the first currently
+	 * displayed, or the lines above it.
+	 */
+
+	int spaceLeft = maxY - y;
+
+	if (spaceLeft <= dInfoPtr->newTopPixelOffset) {
+	    /*
+	     * We can fill up all the needed space just by showing more of the
+	     * current top line.
+	     */
+
+	    dInfoPtr->newTopPixelOffset -= spaceLeft;
+	    y += spaceLeft;
+	    spaceLeft = 0;
+	} else {
+	    TkTextLine *linePtr;
+	    TkTextLine *firstLinePtr;
+
+	    /*
+	     * Add in all of the current top line, which won't be enough to bring y
+	     * up to maxY (if it was we would be in the 'if' block above).
+	     */
+
+	    y += dInfoPtr->newTopPixelOffset;
+	    dInfoPtr->newTopPixelOffset = 0;
+	    spaceLeft = maxY - y;
+
+	    /*
+	     * Layout an entire text line (potentially > 1 display line), then
+	     * link in as many display lines as fit without moving the bottom
+	     * line out of the window. Repeat this until all the extra space
+	     * has been used up or we've reached the beginning of the text.
+	     */
+
+	    if (spaceLeft > 0) {
+		firstLinePtr = TkBTreeGetStartLine(textPtr)->prevPtr;
+		index = topLine ? topLine->index : textPtr->topIndex;
+		savedDLine = prevSavedDLine;
+		if (TkTextIndexBackBytes(textPtr, &index, 1, &index) == 1) {
+		    firstLinePtr = linePtr = NULL; /* we are already at start of text */
+		} else {
+		    linePtr = TkTextIndexGetLine(&index);
+		}
+
+		for ( ; linePtr != firstLinePtr && spaceLeft > 0; linePtr = linePtr->prevPtr) {
+		    if (linePtr != TkTextIndexGetLine(&index)) {
+			TkTextIndexSetToLastChar2(&index, linePtr);
+		    }
+		    linePtr = ComputeDisplayLineInfo(textPtr, &index, &info);
+
+		    do {
+			if (info.lastDLinePtr) {
+			    dlPtr = info.lastDLinePtr;
+			    if (dlPtr->prevPtr) {
+				dlPtr->prevPtr->nextPtr = NULL;
+				info.lastDLinePtr = dlPtr->prevPtr;
+				dlPtr->prevPtr = NULL;
+				assert(dlPtr != info.dLinePtr);
+			    } else {
+				assert(info.dLinePtr == info.lastDLinePtr);
+				info.dLinePtr = info.lastDLinePtr = NULL;
+			    }
+			} else {
+			    TkTextIndexSetToStartOfLine2(&index, linePtr);
+			    TkTextIndexForwBytes(textPtr, &index, info.entry->byteOffset, &index);
+			    if (savedDLine && TkTextIndexIsEqual(&index, &savedDLine->index)) {
+				dlPtr = savedDLine;
+				savedDLine = savedDLine->prevPtr;
+				if (dlPtr->prevPtr) {
+				    dlPtr->prevPtr->nextPtr = dlPtr->nextPtr;
+				} else {
+				    dInfoPtr->savedDLinePtr = dlPtr->nextPtr;
+				}
+				if (dlPtr->nextPtr) {
+				    dlPtr->nextPtr->prevPtr = dlPtr->prevPtr;
+				} else {
+				    dInfoPtr->lastSavedDLinePtr = dlPtr->prevPtr;
+				}
+				dlPtr->prevPtr = dlPtr->nextPtr = NULL;
+			    } else {
+				dlPtr = LayoutDLine(&index, info.displayLineNo);
+			    }
+			}
+			if ((dlPtr->nextPtr = topLine)) {
+			    topLine->prevPtr = dlPtr;
+			} else {
+			    bottomLine = dlPtr;
+			}
+			topLine = dlPtr;
+			DEBUG(dlPtr->flags |= LINKED);
+			TK_TEXT_DEBUG(LogTextRelayout(textPtr, &dlPtr->index));
+			spaceLeft -= dlPtr->height;
+			info.displayLineNo -= 1;
+			info.entry -= 1;
+		    } while (spaceLeft > 0 && info.displayLineNo >= 0);
+
+		    dInfoPtr->dLinePtr = topLine;
+		    /* Delete remaining cached lines. */
+		    FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+		}
+	    }
+
+	    /*
+	     * We've either filled in the space we wanted to or we've run out
+	     * of display lines at the top of the text. Note that we already
+	     * set dInfoPtr->newTopPixelOffset to zero above.
+	     */
+
+	    if (spaceLeft < 0) {
+		/*
+		 * We've laid out a few too many vertical pixels at or above
+		 * the first line. Therefore we only want to show part of the
+		 * first displayed line, so that the last displayed line just
+		 * fits in the window.
+		 */
+
+		dInfoPtr->newTopPixelOffset = -spaceLeft;
+
+		/*
+		 * If the entire first line we laid out is shorter than the new offset:
+		 * this should not occur and would indicate a bad problem in the logic above.
+		 */
+
+		assert(dInfoPtr->newTopPixelOffset < topLine->height);
+	    }
+	}
+
+	/*
+	 * Now we're all done except that the y-coordinates in all the DLines
+	 * are wrong and the top index for the text is wrong. Update them.
+	 */
+
+	if (topLine) {
+	    dInfoPtr->dLinePtr = topLine;
+	    textPtr->topIndex = topLine->index;
+	    assert(textPtr->topIndex.textPtr);
+	    TkTextIndexToByteIndex(&textPtr->topIndex);
+	    y = dInfoPtr->y - dInfoPtr->newTopPixelOffset;
+	    for (dlPtr = topLine; dlPtr; dlPtr = dlPtr->nextPtr) {
+		assert(y <= dInfoPtr->maxY);
+		dlPtr->y = y;
+		y += dlPtr->height;
+	    }
+	}
+    }
+
+    /*
+     * If the old top or bottom line has scrolled elsewhere on the screen, we
+     * may not be able to re-use its old contents by copying bits (e.g., a
+     * beveled edge that was drawn when it was at the top or bottom won't be
+     * drawn when the line is in the middle and its neighbor has a matching
+     * background). Similarly, if the new top or bottom line came from
+     * somewhere else on the screen, we may not be able to copy the old bits.
+     */
+
+    if (topLine) {
+	dInfoPtr->maxLength = MAX(dInfoPtr->maxLength, topLine->length);
+
+	if ((topLine->flags & (TOP_LINE|HAS_3D_BORDER)) == HAS_3D_BORDER) {
+	    topLine->flags |= OLD_Y_INVALID;
+	}
+	if ((bottomLine->flags & (BOTTOM_LINE|HAS_3D_BORDER)) == HAS_3D_BORDER) {
+	    bottomLine->flags |= OLD_Y_INVALID;
+	}
+
+	if (topLine != bottomLine) {
+	    topLine->flags &= ~BOTTOM_LINE;
+	    bottomLine->flags &= ~TOP_LINE;
+
+	    for (dlPtr = topLine->nextPtr; dlPtr != bottomLine; dlPtr = dlPtr->nextPtr) {
+		dInfoPtr->maxLength = MAX(dInfoPtr->maxLength, dlPtr->length);
+
+		if ((topLine->flags & HAS_3D_BORDER) && (dlPtr->flags & (TOP_LINE|BOTTOM_LINE))) {
+		    dlPtr->flags |= OLD_Y_INVALID;
+		}
+
+		/*
+		 * If the old top-line was not completely showing (i.e. the
+		 * pixelOffset is non-zero) and is no longer the top-line, then we
+		 * must re-draw it.
+		 */
+
+		if ((dlPtr->flags & TOP_LINE) && dInfoPtr->topPixelOffset != 0) {
+		    dlPtr->flags |= OLD_Y_INVALID;
+		}
+
+		dlPtr->flags &= ~(TOP_LINE|BOTTOM_LINE);
+	    }
+
+	    dInfoPtr->maxLength = MAX(dInfoPtr->maxLength, bottomLine->length);
+	}
+
+	topLine->flags |= TOP_LINE;
+	bottomLine->flags |= BOTTOM_LINE;
+
+	dInfoPtr->topPixelOffset = dInfoPtr->newTopPixelOffset;
+	dInfoPtr->curYPixelOffset = GetYPixelCount(textPtr, topLine);
+	dInfoPtr->curYPixelOffset += dInfoPtr->topPixelOffset;
+    }
+
+    dInfoPtr->lastDLinePtr = bottomLine;
+
+    /*
+     * Delete remaining saved lines.
+     */
+
+    FreeDLines(textPtr, dInfoPtr->savedDLinePtr, NULL, DLINE_FREE_TEMP);
+
+    /*
+     * Arrange for scrollbars to be updated.
+     */
+
+    textPtr->flags |= UPDATE_SCROLLBARS;
+
+    /*
+     * Deal with horizontal scrolling:
+     * 1. If there's empty space to the right of the longest line, shift the
+     *	  screen to the right to fill in the empty space.
+     * 2. If the desired horizontal scroll position has changed, force a full
+     *	  redisplay of all the lines in the widget.
+     * 3. If the wrap mode isn't "none" then re-scroll to the base position.
+     */
+
+    maxOffset = dInfoPtr->maxLength - (dInfoPtr->maxX - dInfoPtr->x);
+    xPixelOffset = MAX(0, MIN(dInfoPtr->newXPixelOffset, maxOffset));
+
+    /*
+     * Here's a problem: see the tests textDisp-29.2.1-4
+     *
+     * If the widget is being created, but has not yet been configured it will
+     * have a maxY of 1 above, and we won't have examined all the lines
+     * (just the first line, in fact), and so maxOffset will not be a true
+     * reflection of the widget's lines. Therefore we must not overwrite the
+     * original newXPixelOffset in this case.
+     */
+
+    if (!(((Tk_FakeWin *) (textPtr->tkwin))->flags & TK_NEED_CONFIG_NOTIFY)) {
+	dInfoPtr->newXPixelOffset = xPixelOffset;
+    }
+
+    if (xPixelOffset != dInfoPtr->curXPixelOffset) {
+	dInfoPtr->curXPixelOffset = xPixelOffset;
+	for (dlPtr = topLine; dlPtr; dlPtr = dlPtr->nextPtr) {
+	    dlPtr->flags |= OLD_Y_INVALID;
+	}
+	textPtr->configureBboxTree = true;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FreeDLines --
+ *
+ *	This function is called to free up all of the resources associated
+ *	with one or more DLine structures.
+ *
+ * Results:
+ *	Returns the last unfreed line if action is DLINE_SAVE, otherwise
+ *	NULL will be returned.
+ *
+ * Side effects:
+ *	Memory gets freed and various other resources are released.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+LineIsOutsideOfPeer(
+    const TkText *textPtr,
+    const TkTextIndex *indexPtr)
+{
+    const TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+
+    if (textPtr->startMarker != sharedTextPtr->startMarker) {
+	const TkTextLine *linePtr = textPtr->startMarker->sectionPtr->linePtr;
+	int no1 = TkTextIndexGetLineNumber(indexPtr, NULL);
+	int no2 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, linePtr, NULL);
+
+	if (no1 < no2) {
+	    return true;
+	}
+    }
+    if (textPtr->endMarker != sharedTextPtr->endMarker) {
+	const TkTextLine *linePtr = textPtr->endMarker->sectionPtr->linePtr;
+	int no1 = TkTextIndexGetLineNumber(indexPtr, NULL);
+	int no2 = TkBTreeLinesTo(sharedTextPtr->tree, NULL, linePtr, NULL);
+
+	if (no1 > no2) {
+	    return true;
+	}
+    }
+    return false;
+}
+
+static void
+ReleaseLines(
+    TkText *textPtr,
+    DLine *firstPtr,
+    DLine *lastPtr,
+    FreeDLineAction action)
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    DLine *dlPtr, *lastDeletedPtr = NULL; /* avoids compiler warning */
+
+    assert(firstPtr);
+    assert(firstPtr != lastPtr);
+
+    for (dlPtr = firstPtr; dlPtr != lastPtr; dlPtr = dlPtr->nextPtr) {
+	TkTextDispChunk *chunkPtr;
+
+	assert(!(dlPtr->flags & DELETED));
+	assert((action == DLINE_UNLINK || action == DLINE_UNLINK_KEEP_BRKS)
+		== !!(dlPtr->flags & LINKED));
+	assert((action == DLINE_CACHE) == !!(dlPtr->flags & CACHED));
+	assert(dlPtr != dInfoPtr->savedDLinePtr || dlPtr == firstPtr);
+	assert(dlPtr->chunkPtr || (!dlPtr->lastChunkPtr && !dlPtr->breakInfo));
+
+	if (dlPtr->lastChunkPtr) {
+	    TkTextDispChunkSection *sectionPtr = NULL;
+
+	    /*
+	     * We have to destroy the chunks backward, because the context support
+	     * is expecting this.
+	     */
+
+	    for (chunkPtr = dlPtr->lastChunkPtr; chunkPtr; chunkPtr = chunkPtr->prevPtr) {
+		if (chunkPtr->layoutProcs->undisplayProc) {
+		    chunkPtr->layoutProcs->undisplayProc(textPtr, chunkPtr);
+		}
+		LayoutReleaseChunk(textPtr, chunkPtr);
+		DEBUG(chunkPtr->stylePtr = NULL);
+
+		if (chunkPtr->sectionPtr != sectionPtr) {
+		    sectionPtr = chunkPtr->sectionPtr;
+		    sectionPtr->nextPtr = dInfoPtr->sectionPoolPtr;
+		    dInfoPtr->sectionPoolPtr = sectionPtr;
+		}
+	    }
+
+	    if (dlPtr->breakInfo
+		    && (action != DLINE_UNLINK_KEEP_BRKS || LineIsOutsideOfPeer(textPtr, &dlPtr->index))
+		    && --dlPtr->breakInfo->refCount == 0) {
+		assert(dlPtr->breakInfo->brks);
+		free(dlPtr->breakInfo->brks);
+		free(dlPtr->breakInfo);
+		Tcl_DeleteHashEntry(Tcl_FindHashEntry(
+			&textPtr->sharedTextPtr->breakInfoTable,
+			(void *) TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr,
+			    TkTextIndexGetLine(&dlPtr->index))));
+		DEBUG_ALLOC(tkTextCountDestroyBreakInfo++);
+	    }
+
+	    dlPtr->lastChunkPtr->nextPtr = dInfoPtr->chunkPoolPtr;
+	    dInfoPtr->chunkPoolPtr = dlPtr->chunkPtr;
+	    assert(!dInfoPtr->chunkPoolPtr->prevPtr);
+	}
+
+	lastDeletedPtr = dlPtr;
+	DEBUG(dlPtr->flags = DELETED);
+    }
+
+    assert(lastDeletedPtr);
+    lastDeletedPtr->nextPtr = dInfoPtr->dLinePoolPtr;
+    dInfoPtr->dLinePoolPtr = firstPtr;
+
+    if (lastPtr) {
+	lastPtr->prevPtr = firstPtr->prevPtr;
+    }
+    if (firstPtr->prevPtr) {
+	firstPtr->prevPtr->nextPtr = lastPtr;
+    }
+}
+
+static DLine *
+FreeDLines(
+    TkText *textPtr,		/* Information about overall text widget. */
+    DLine *firstPtr,		/* Pointer to first DLine to free up. */
+    DLine *lastPtr,		/* Pointer to DLine just after last one to free (NULL means
+    				 * everything starting with firstPtr). */
+    FreeDLineAction action)	/* DLINE_UNLINK means DLines are currently linked into the list
+    				 * rooted at textPtr->dInfoPtr->dLinePtr and they have to be
+				 * unlinked. DLINE_FREE_TEMP, and DLINE_CACHE means the DLine given
+				 * is just a temporary one and we shouldn't invalidate anything for
+				 * the overall widget. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+    switch (action) {
+    case DLINE_CACHE:
+	assert(!lastPtr);
+	if (firstPtr) {
+	    DLine *prevPtr = firstPtr->prevPtr;
+
+	    assert(!(firstPtr->flags & LINKED));
+	    assert(!(firstPtr->flags & CACHED));
+	    assert(!(firstPtr->flags & DELETED));
+	    assert(firstPtr != dInfoPtr->savedDLinePtr);
+
+	    /*
+	     * Firstly unlink this line from chain.
+	     */
+
+	    if (firstPtr == dInfoPtr->dLinePtr) {
+		dInfoPtr->dLinePtr = firstPtr->nextPtr;
+	    }
+	    if (firstPtr == dInfoPtr->lastDLinePtr) {
+		dInfoPtr->lastDLinePtr = prevPtr;
+	    }
+	    if (prevPtr) {
+		prevPtr->nextPtr = firstPtr->nextPtr;
+	    }
+	    if (firstPtr->nextPtr) {
+		firstPtr->nextPtr->prevPtr = prevPtr;
+	    }
+	    firstPtr->prevPtr = NULL;
+
+	    /*
+	     * Then link into the chain of cached lines.
+	     */
+
+	    if ((firstPtr->nextPtr = dInfoPtr->cachedDLinePtr)) {
+		dInfoPtr->cachedDLinePtr->prevPtr = firstPtr;
+	    } else {
+		dInfoPtr->lastCachedDLinePtr = firstPtr;
+	    }
+	    dInfoPtr->cachedDLinePtr = firstPtr;
+
+	    DEBUG(firstPtr->flags &= ~LINKED);
+	    DEBUG(firstPtr->flags |= CACHED);
+	    DEBUG(stats.numCached += 1);
+
+	    if (dInfoPtr->numCachedLines < MAX_CACHED_DISPLAY_LINES) {
+		dInfoPtr->numCachedLines += 1;
+		return NULL;
+	    }
+
+	    /*
+	     * Release oldest cached display line.
+	     */
+
+	    if ((firstPtr = dInfoPtr->lastCachedDLinePtr)) {
+		firstPtr->prevPtr->nextPtr = NULL;
+	    }
+	    dInfoPtr->lastCachedDLinePtr = dInfoPtr->lastCachedDLinePtr->prevPtr;
+	} else {
+	    if (!(firstPtr = dInfoPtr->cachedDLinePtr)) {
+		return NULL;
+	    }
+	    dInfoPtr->cachedDLinePtr = dInfoPtr->lastCachedDLinePtr = NULL;
+	    dInfoPtr->numCachedLines = 0;
+	}
+	ReleaseLines(textPtr, firstPtr, lastPtr, action);
+	break;
+    case DLINE_METRIC:
+	assert(!lastPtr);
+	if (dInfoPtr->lastMetricDLinePtr) {
+	    ReleaseLines(textPtr, dInfoPtr->lastMetricDLinePtr, NULL, DLINE_FREE_TEMP);
+	    dInfoPtr->lastMetricDLinePtr = NULL;
+	}
+	if (firstPtr) {
+	    assert(!firstPtr->nextPtr);
+	    assert(!(firstPtr->flags & (LINKED|CACHED|DELETED)));
+	    dInfoPtr->lastMetricDLinePtr = firstPtr;
+	    if (firstPtr->prevPtr) {
+		firstPtr->prevPtr->nextPtr = NULL;
+		firstPtr->prevPtr = NULL;
+	    }
+	}
+    	break;
+    case DLINE_FREE_TEMP:
+	if (!firstPtr || firstPtr == lastPtr) {
+	    return NULL;
+	}
+	DEBUG(stats.lineHeightsRecalculated += 1);
+	assert(!(firstPtr->flags & LINKED));
+	assert(!(firstPtr->flags & CACHED));
+	if (firstPtr == dInfoPtr->savedDLinePtr) {
+	    dInfoPtr->savedDLinePtr = NULL;
+	    if (!lastPtr) {
+		dInfoPtr->lastSavedDLinePtr = NULL;
+	    } else {
+		dInfoPtr->savedDLinePtr = lastPtr;
+	    }
+	} else {
+	    assert(!lastPtr || lastPtr != dInfoPtr->lastSavedDLinePtr);
+	}
+	assert(!dInfoPtr->savedDLinePtr == !dInfoPtr->lastSavedDLinePtr);
+	ReleaseLines(textPtr, firstPtr, lastPtr, action);
+	break;
+    case DLINE_UNLINK:
+    case DLINE_UNLINK_KEEP_BRKS:
+	if (!firstPtr || firstPtr == lastPtr) {
+	    return NULL;
+	}
+	assert(firstPtr->flags & LINKED);
+	assert(firstPtr != dInfoPtr->savedDLinePtr);
+	if (dInfoPtr->dLinePtr == firstPtr) {
+	    if ((dInfoPtr->dLinePtr = lastPtr)) {
+		lastPtr->prevPtr = NULL;
+	    }
+	} else {
+	    DLine *prevPtr = firstPtr->prevPtr;
+
+	    if (prevPtr && (prevPtr->nextPtr = lastPtr)) {
+		lastPtr->prevPtr = prevPtr;
+	    }
+	}
+	if (!lastPtr) {
+	    dInfoPtr->lastDLinePtr = firstPtr->prevPtr;
+	}
+	dInfoPtr->dLinesInvalidated = true;
+	assert(!dInfoPtr->dLinePtr || !dInfoPtr->dLinePtr->prevPtr);
+	ReleaseLines(textPtr, firstPtr, lastPtr, action);
+	break;
+    case DLINE_SAVE: {
+	if (!firstPtr || firstPtr == lastPtr) {
+	    return NULL;
+	}
+	assert(firstPtr == dInfoPtr->dLinePtr);
+	assert(lastPtr);
+
+	unsigned epoch = dInfoPtr->lineMetricUpdateEpoch;
+	DLine *dlPtr;
+
+	assert(lastPtr->prevPtr);
+	dInfoPtr->dLinePtr = lastPtr;
+
+	/*
+	 * Free all expired lines, we will only save valid lines.
+	 */
+
+	dlPtr = firstPtr;
+	while (dlPtr != lastPtr) {
+	    DLine *nextPtr = dlPtr->nextPtr;
+
+	    assert(dlPtr->flags & LINKED);
+
+	    if (LineIsUpToDate(textPtr, dlPtr, epoch)) {
+		DEBUG(dlPtr->flags &= ~LINKED);
+	    } else {
+		if (dlPtr == firstPtr) {
+		    firstPtr = nextPtr;
+		}
+		ReleaseLines(textPtr, dlPtr, nextPtr, DLINE_UNLINK);
+	    }
+
+	    dlPtr = nextPtr;
+	}
+
+	assert(!firstPtr->prevPtr);
+
+	if (firstPtr == lastPtr) {
+	    dInfoPtr->savedDLinePtr = NULL;
+	    dInfoPtr->lastSavedDLinePtr = NULL;
+	    return NULL;
+	}
+
+	lastPtr = lastPtr->prevPtr;
+	lastPtr->nextPtr->prevPtr = NULL;
+	lastPtr->nextPtr = NULL;
+
+	if (!dInfoPtr->savedDLinePtr) {
+	    dInfoPtr->savedDLinePtr = firstPtr;
+	    dInfoPtr->lastSavedDLinePtr = lastPtr;
+	} else if (TkTextIndexCompare(&lastPtr->index, &dInfoPtr->savedDLinePtr->index) < 0) {
+	    lastPtr->nextPtr = dInfoPtr->savedDLinePtr;
+	    dInfoPtr->savedDLinePtr->prevPtr = lastPtr;
+	    dInfoPtr->savedDLinePtr = firstPtr;
+	} else {
+	    assert(TkTextIndexCompare(&firstPtr->index, &dInfoPtr->lastSavedDLinePtr->index) > 0);
+	    firstPtr->prevPtr = dInfoPtr->lastSavedDLinePtr;
+	    dInfoPtr->lastSavedDLinePtr->nextPtr = firstPtr;
+	    dInfoPtr->lastSavedDLinePtr = lastPtr;
+	}
+
+	return lastPtr;
+    }
+    }
+
+    return NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DisplayDLine --
+ *
+ *	This function is invoked to draw a single line on the screen.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The line given by dlPtr is drawn at its correct position in textPtr's
+ *	window. Note that this is one *display* line, not one *text* line.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+DisplayDLine(
+    TkText *textPtr,	/* Text widget in which to draw line. */
+    DLine *dlPtr,	/* Information about line to draw. */
+    DLine *prevPtr,	/* Line just before one to draw, or NULL if dlPtr is the top line. */
+    Pixmap pixmap)	/* Pixmap to use for double-buffering. Caller must make sure
+			 * it's large enough to hold line. */
+{
+    TkTextDispChunk *chunkPtr;
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    Display *display;
+    StyleValues *sValuePtr;
+    int lineHeight, yOffs;
+    int yBase, height, baseline, screenY, xOffs;
+    int xIndent, rMargin;
+    bool delayBlockCursorDrawing;
+
+    if (!dlPtr->chunkPtr) {
+	return;
+    }
+
+    display = Tk_Display(textPtr->tkwin);
+    delayBlockCursorDrawing = false;
+
+    lineHeight = dlPtr->height;
+    if (lineHeight + dlPtr->y > dInfoPtr->maxY) {
+	lineHeight = dInfoPtr->maxY - dlPtr->y;
+    }
+    if (dlPtr->y < dInfoPtr->y) {
+	yOffs = dInfoPtr->y - dlPtr->y;
+	lineHeight -= yOffs;
+    } else {
+	yOffs = 0;
+    }
+
+    /*
+     * First, clear the area of the line to the background color for the text widget.
+     */
+
+    Tk_Fill3DRectangle(textPtr->tkwin, pixmap, textPtr->border, 0, 0,
+	    Tk_Width(textPtr->tkwin), dlPtr->height, 0, TK_RELIEF_FLAT);
+
+    /*
+     * Second, draw background information for the whole line.
+     */
+
+    DisplayLineBackground(textPtr, dlPtr, prevPtr, pixmap);
+
+    /*
+     * Third, draw the background color of the left and right margins.
+     */
+
+    sValuePtr = dlPtr->firstCharChunkPtr->stylePtr->sValuePtr;
+    rMargin = (sValuePtr->wrapMode == TEXT_WRAPMODE_NONE) ? 0 : sValuePtr->rMargin;
+    xIndent = GetLeftLineMargin(dlPtr, sValuePtr);
+
+    if (sValuePtr->lMarginColor != NULL) {
+        Tk_Fill3DRectangle(textPtr->tkwin, pixmap, sValuePtr->lMarginColor, 0, 0,
+                xIndent + dInfoPtr->x - dInfoPtr->curXPixelOffset,
+                dlPtr->height, 0, TK_RELIEF_FLAT);
+    }
+    if (sValuePtr->rMarginColor != NULL) {
+        Tk_Fill3DRectangle(textPtr->tkwin, pixmap, sValuePtr->rMarginColor,
+                dInfoPtr->maxX - rMargin + dInfoPtr->curXPixelOffset,
+                0, rMargin, dlPtr->height, 0, TK_RELIEF_FLAT);
+    }
+
+    yBase = dlPtr->spaceAbove;
+    height = dlPtr->height - dlPtr->spaceAbove - dlPtr->spaceBelow;
+    baseline = dlPtr->baseline - dlPtr->spaceAbove;
+    screenY = dlPtr->y + dlPtr->spaceAbove;
+    xOffs = dInfoPtr->x - dInfoPtr->curXPixelOffset;
+
+    /*
+     * Redraw the insertion cursor, if it is visible on this line. Must do it here rather
+     * than in the foreground pass below because otherwise a wide insertion cursor will
+     * obscure the character to its left.
+     *
+     * If the user has specified a foreground color for characters "behind" the block cursor,
+     * we have to draw the cursor after the text has been drawn, see below.
+     */
+
+    if (dlPtr->cursorChunkPtr && textPtr->state == TK_TEXT_STATE_NORMAL) {
+	delayBlockCursorDrawing = dInfoPtr->insertFgGC && TkTextDrawBlockCursor(textPtr);
+
+	if (!delayBlockCursorDrawing) {
+	    dlPtr->cursorChunkPtr->layoutProcs->displayProc(textPtr, dlPtr->cursorChunkPtr,
+		    dlPtr->cursorChunkPtr->x + xOffs, yBase, height, baseline, display, pixmap, screenY);
+	}
+    }
+
+    /*
+     * Iterate through all of the chunks to redraw all of foreground information.
+     */
+
+    for (chunkPtr = dlPtr->chunkPtr; chunkPtr; chunkPtr = chunkPtr->nextPtr) {
+	if (chunkPtr == dlPtr->cursorChunkPtr) {
+	    /* Don't display the insertion cursor, this will be done separately. */
+	    continue;
+	}
+
+	if (chunkPtr->layoutProcs->displayProc) {
+	    int x = chunkPtr->x + xOffs;
+
+	    if (x + chunkPtr->width <= 0 || dInfoPtr->maxX <= x) {
+		/*
+		 * Note: we have to call the displayProc even for chunks that are off-screen.
+		 * This is needed, for example, so that embedded windows can be unmapped in
+		 * this case. Display the chunk at a coordinate that can be clearly identified
+		 * by the displayProc as being off-screen to the left (the displayProc may not
+		 * be able to tell if something is off to the right).
+		 */
+
+		x = -chunkPtr->width;
+	    }
+
+	    chunkPtr->layoutProcs->displayProc(textPtr, chunkPtr, x, yBase, height,
+		    baseline, display, pixmap, screenY);
+
+	    if (dInfoPtr->dLinesInvalidated) {
+		/*
+		 * The display process has invalidated any display line, so terminate,
+		 * because the display process will be repeated with valid display lines.
+		 */
+		return;
+	    }
+	}
+    }
+
+    if (delayBlockCursorDrawing) {
+	/*
+	 * Draw the block cursor and redraw the characters "behind" the block cursor.
+	 */
+
+	int cxMin, cxMax, cWidth, cOffs;
+	GC bgGC;
+
+	assert(dInfoPtr->insertFgGC != None);
+
+	cxMin = dlPtr->cursorChunkPtr->x + xOffs;
+	cWidth = TkTextGetCursorWidth(textPtr, &cxMin, &cOffs);
+
+	if ((bgGC = dlPtr->cursorChunkPtr->stylePtr->bgGC) == None) {
+	    Tk_3DBorder border;
+
+	    if (!(border = dlPtr->cursorChunkPtr->stylePtr->sValuePtr->border)) {
+		border = textPtr->border;
+	    }
+	    bgGC = Tk_GCForColor(Tk_3DBorderColor(border), Tk_WindowId(textPtr->tkwin));
+	}
+
+	cxMin += cOffs;
+	cxMax = cxMin + cWidth;
+
+#if CLIPPING_IS_WORKING
+	/*
+	 * This is the right implementation if XSetClipRectangles would work; still untested.
+	 */
+	{
+	    XRectangle crect;
+
+	    crect.x = cxMin;
+	    crect.y = yBase;
+	    crect.width = cWidth;
+	    crect.height = height;
+
+	    XFillRectangle(display, pixmap, bgGC, crect.x, crect.y, crect.width, crect.height);
+	    dlPtr->cursorChunkPtr->layoutProcs->displayProc(textPtr, chunkPtr, cxMin, yBase, height,
+		    baseline, display, pixmap, screenY);
+
+	    /* for any reason this doesn't work with the Tk lib even under X11 */
+	    XSetClipRectangles(display, dInfoPtr->insertFgGC, 0, 0, &crect, 1, Unsorted);
+
+	    for (chunkPtr = dlPtr->chunkPtr; chunkPtr; chunkPtr = chunkPtr->nextPtr) {
+		int x = chunkPtr->x + xOffs;
+
+		if (x >= cxMax) {
+		    break;
+		}
+		if (IsCharChunk(chunkPtr) && cxMin <= x + chunkPtr->width) {
+		    GC fgGC = chunkPtr->stylePtr->fgGC;
+
+		    chunkPtr->stylePtr->fgGC = dInfoPtr->insertFgGC;
+		    chunkPtr->layoutProcs->displayProc(textPtr, chunkPtr, x, yBase, height,
+			    baseline, display, pixmap, screenY);
+		    chunkPtr->stylePtr->fgGC = fgGC;
+		}
+	    }
+	}
+#else /* if !CLIPPING_IS_WORKING */
+	/*
+	 * We don't have clipping, so we need a different approach.
+	 */
+	{
+	    Pixmap pm = Tk_GetPixmap(display, Tk_WindowId(textPtr->tkwin),
+		    cWidth, height, Tk_Depth(textPtr->tkwin));
+
+	    XFillRectangle(display, pm, bgGC, 0, 0, cWidth, height);
+	    chunkPtr = dlPtr->cursorChunkPtr;
+
+	    /* we are using a (pointer) hack in TkTextInsertDisplayProc */
+	    chunkPtr->layoutProcs->displayProc(textPtr, MarkPointer(chunkPtr),
+		    cxMin, yBase, height, baseline, display, pm, screenY);
+
+	    while (chunkPtr->prevPtr && chunkPtr->x + xOffs + chunkPtr->width > cxMin) {
+		chunkPtr = chunkPtr->prevPtr;
+	    }
+	    for ( ; chunkPtr; chunkPtr = chunkPtr->nextPtr) {
+		int x = chunkPtr->x + xOffs;
+
+		if (x >= cxMax) {
+		    break;
+		}
+		if (IsCharChunk(chunkPtr)) {
+		    GC fgGC = chunkPtr->stylePtr->fgGC;
+
+		    chunkPtr->stylePtr->fgGC = dInfoPtr->insertFgGC;
+		    chunkPtr->layoutProcs->displayProc(textPtr, chunkPtr, x - cxMin, 0,
+			    height, baseline, display, pm, screenY);
+		    chunkPtr->stylePtr->fgGC = fgGC;
+		}
+	    }
+
+	    XCopyArea(display, pm, pixmap, dInfoPtr->copyGC, 0, 0, cWidth, height, cxMin, yBase);
+	    Tk_FreePixmap(display, pm);
+	}
+#endif /* CLIPPING_IS_WORKING */
+    }
+
+    /*
+     * Copy the pixmap onto the screen. If this is the first or last line on
+     * the screen then copy a piece of the line, so that it doesn't overflow
+     * into the border area.
+     *
+     * Another special trick: consider the padding area left/right of the line;
+     * this is because the insertion cursor sometimes overflows onto that area
+     * and we want to get as much of the cursor as possible.
+     */
+
+    xOffs = MIN(textPtr->padX, textPtr->insertWidth/2);
+    XCopyArea(display, pixmap, Tk_WindowId(textPtr->tkwin), dInfoPtr->copyGC,
+	    dInfoPtr->x - xOffs, yOffs, dInfoPtr->maxX - dInfoPtr->x + 2*xOffs, lineHeight,
+	    dInfoPtr->x - xOffs, dlPtr->y + yOffs);
+
+    DEBUG(stats.linesRedrawn += 1);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * DisplayLineBackground --
+ *
+ *	This function is called to fill in the background for a display line.
+ *	It draws 3D borders cleverly so that adjacent chunks with the same
+ *	style (whether on the same line or different lines) have a single 3D
+ *	border around the whole region.
+ *
+ * Results:
+ *	There is no return value. Pixmap is filled in with background
+ *	information for dlPtr.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+/*
+ * The following function determines whether two styles have the same background
+ * so that, for example, no beveled border should be drawn between them.
+ */
+
+static bool
+SameBackground(
+    const TextStyle *s1,
+    const TextStyle *s2)
+{
+    return s1->sValuePtr->border == s2->sValuePtr->border
+	&& s1->sValuePtr->borderWidth == s2->sValuePtr->borderWidth
+	&& s1->sValuePtr->relief == s2->sValuePtr->relief
+	&& s1->sValuePtr->bgStipple == s2->sValuePtr->bgStipple
+	&& s1->sValuePtr->indentBg == s2->sValuePtr->indentBg;
+}
+
+static void
+DisplayLineBackground(
+    TkText *textPtr,		/* Text widget containing line. */
+    DLine *dlPtr,		/* Information about line to draw. */
+    DLine *prevPtr,		/* Line just above dlPtr, or NULL if dlPtr is the top-most line in
+    				 * the window. */
+    Pixmap pixmap)		/* Pixmap to use for double-buffering. Caller must make sure it's
+    				 * large enough to hold line. Caller must also have filled it with
+				 * the background color for the widget. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    TkTextDispChunk *chunkPtr;	/* Pointer to chunk in the current line. */
+    TkTextDispChunk *chunkPtr2;	/* Pointer to chunk in the line above or below the current one. NULL
+    				 * if we're to the left of or to the right of the chunks in the line. */
+    TkTextDispChunk *nextPtr2;	/* Next chunk after chunkPtr2 (it's not the same as chunkPtr2->nextPtr
+    				 * in the case where chunkPtr2 is NULL because the line is indented). */
+    int leftX;			/* The left edge of the region we're currently working on. */
+    int leftXIn;		/* 0 means beveled edge at leftX slopes right as it goes down,
+    				 * 1 means it slopes left as it goes down. */
+    int rightX;			/* Right edge of chunkPtr. */
+    int rightX2;		/* Right edge of chunkPtr2. */
+    int matchLeft;		/* Does the style of this line match that of its neighbor just to the
+    				 * left of the current x coordinate? */
+    int matchRight;		/* Does line's style match its neighbor just to the right of the
+    				 * current x-coord? */
+    int minX, maxX, xOffset, xIndent, borderWidth;
+    StyleValues *sValuePtr;
+    Display *display;
+    const int y = 0;
+
+    /*
+     * Pass 1: scan through dlPtr from left to right. For each range of chunks
+     * with the same style, draw the main background for the style plus the
+     * vertical parts of the 3D borders (the left and right edges).
+     */
+
+    display = Tk_Display(textPtr->tkwin);
+    minX = dInfoPtr->curXPixelOffset;
+    xOffset = dInfoPtr->x - minX;
+    maxX = minX + dInfoPtr->maxX - dInfoPtr->x;
+    chunkPtr = dlPtr->chunkPtr;
+    xIndent = 0;
+
+    /*
+     * Note A: in the following statement, and a few others later in this file
+     * marked with "See Note A above", the right side of the assignment was
+     * replaced with 0 on 6/18/97. This has the effect of highlighting the
+     * empty space to the left of a line whenever the leftmost character of
+     * the line is highlighted. This way, multi-line highlights always line up
+     * along their left edges. However, this may look funny in the case where
+     * a single word is highlighted. To undo the change, replace "leftX = 0"
+     * with "leftX = chunkPtr->x" and "rightX2 = 0" with "rightX2 =
+     * nextPtr2->x" here and at all the marked points below. This restores the
+     * old behavior where empty space to the left of a line is not
+     * highlighted, leaving a ragged left edge for multi-line highlights.
+     */
+
+    for (leftX = 0; leftX < maxX; chunkPtr = chunkPtr->nextPtr) {
+	if (chunkPtr->nextPtr && SameBackground(chunkPtr->nextPtr->stylePtr, chunkPtr->stylePtr)) {
+	    continue;
+	}
+	sValuePtr = chunkPtr->stylePtr->sValuePtr;
+	rightX = chunkPtr->x + chunkPtr->width;
+	if (!chunkPtr->nextPtr && rightX < maxX) {
+	    rightX = maxX;
+	}
+	if (chunkPtr->stylePtr->bgGC != None) {
+	    int indent = 0;
+
+	    /*
+	     * Not visible - bail out now.
+	     */
+
+	    if (rightX + xOffset <= 0) {
+		leftX = rightX;
+		continue;
+	    }
+
+	    /*
+	     * Compute additional offset if -indentbackground is set.
+	     */
+
+	    if (leftX == 0 && sValuePtr->indentBg) {
+		xIndent = GetLeftLineMargin(dlPtr, sValuePtr);
+		if (leftX + xIndent > rightX) {
+		    xIndent = rightX - leftX;
+		}
+		indent = xIndent;
+	    }
+
+	    /*
+	     * Trim the start position for drawing to be no further away than -borderWidth.
+	     * The reason is that on many X servers drawing from -32768 (or less) to
+	     * +something simply does not display correctly. [Patch #541999]
+	     */
+
+	    if (leftX + xOffset + indent < -sValuePtr->borderWidth) {
+		leftX = -sValuePtr->borderWidth - xOffset - indent;
+	    }
+	    if (rightX - leftX - indent > 32767) {
+		rightX = leftX + indent + 32767;
+	    }
+
+            /*
+             * Prevent the borders from leaking on adjacent characters,
+             * which would happen for too large border width.
+             */
+
+            borderWidth = sValuePtr->borderWidth;
+            if (leftX + sValuePtr->borderWidth > rightX) {
+                borderWidth = rightX - leftX;
+            }
+
+	    XFillRectangle(display, pixmap, chunkPtr->stylePtr->bgGC,
+		    leftX + xOffset + indent, y, rightX - leftX - indent, dlPtr->height);
+	    if (sValuePtr->relief != TK_RELIEF_FLAT) {
+		Tk_3DVerticalBevel(textPtr->tkwin, pixmap, sValuePtr->border,
+			leftX + xOffset + indent, y, borderWidth,
+			dlPtr->height, 1, sValuePtr->relief);
+		Tk_3DVerticalBevel(textPtr->tkwin, pixmap, sValuePtr->border,
+			rightX - borderWidth + xOffset, y, borderWidth,
+			dlPtr->height, 0, sValuePtr->relief);
+	    }
+	}
+	leftX = rightX;
+    }
+
+    /*
+     * Pass 2: draw the horizontal bevels along the top of the line. To do
+     * this, scan through dlPtr from left to right while simultaneously
+     * scanning through the line just above dlPtr. ChunkPtr2 and nextPtr2
+     * refer to two adjacent chunks in the line above.
+     */
+
+    chunkPtr = dlPtr->chunkPtr;
+    leftX = 0;				/* See Note A above. */
+    leftXIn = 1;
+    rightX = chunkPtr->x + chunkPtr->width;
+    if (!chunkPtr->nextPtr && rightX < maxX) {
+	rightX = maxX;
+    }
+    chunkPtr2 = NULL;
+    if (prevPtr && prevPtr->chunkPtr) {
+	/*
+	 * Find the chunk in the previous line that covers leftX.
+	 */
+
+	nextPtr2 = prevPtr->chunkPtr;
+	rightX2 = 0;			/* See Note A above. */
+	while (rightX2 <= leftX) {
+	    if (!(chunkPtr2 = nextPtr2)) {
+		break;
+	    }
+	    nextPtr2 = chunkPtr2->nextPtr;
+	    rightX2 = chunkPtr2->x + chunkPtr2->width;
+	    if (!nextPtr2) {
+		rightX2 = INT_MAX;
+	    }
+	}
+    } else {
+	nextPtr2 = NULL;
+	rightX2 = INT_MAX;
+    }
+
+    while (leftX < maxX) {
+	matchLeft = chunkPtr2 && SameBackground(chunkPtr2->stylePtr, chunkPtr->stylePtr);
+	sValuePtr = chunkPtr->stylePtr->sValuePtr;
+	if (rightX <= rightX2) {
+	    /*
+	     * The chunk in our line is about to end. If its style changes
+	     * then draw the bevel for the current style.
+	     */
+
+	    if (!chunkPtr->nextPtr
+		    || !SameBackground(chunkPtr->stylePtr, chunkPtr->nextPtr->stylePtr)) {
+		if (!matchLeft && sValuePtr->relief != TK_RELIEF_FLAT) {
+		    int indent = (leftX == 0) ? xIndent : 0;
+		    Tk_3DHorizontalBevel(textPtr->tkwin, pixmap,
+			    sValuePtr->border, leftX + xOffset + indent, y,
+			    rightX - leftX - indent, sValuePtr->borderWidth,
+			    leftXIn, 1, 1, sValuePtr->relief);
+		}
+		leftX = rightX;
+		leftXIn = 1;
+
+		/*
+		 * If the chunk in the line above is also ending at the same
+		 * point then advance to the next chunk in that line.
+		 */
+
+		if (rightX == rightX2 && chunkPtr2) {
+		    goto nextChunk2;
+		}
+	    }
+	    chunkPtr = chunkPtr->nextPtr;
+	    if (!chunkPtr) {
+		break;
+	    }
+	    rightX = chunkPtr->x + chunkPtr->width;
+	    if (!chunkPtr->nextPtr && rightX < maxX) {
+		rightX = maxX;
+	    }
+	    continue;
+	}
+
+	/*
+	 * The chunk in the line above is ending at an x-position where there
+	 * is no change in the style of the current line. If the style above
+	 * matches the current line on one side of the change but not on the
+	 * other, we have to draw an L-shaped piece of bevel.
+	 */
+
+	matchRight = nextPtr2 && SameBackground(nextPtr2->stylePtr, chunkPtr->stylePtr);
+	if (matchLeft && !matchRight) {
+            borderWidth = sValuePtr->borderWidth;
+            if (rightX2 - borderWidth < leftX) {
+                borderWidth = rightX2 - leftX;
+            }
+	    if (sValuePtr->relief != TK_RELIEF_FLAT) {
+		Tk_3DVerticalBevel(textPtr->tkwin, pixmap, sValuePtr->border,
+			rightX2 - borderWidth + xOffset, y, borderWidth,
+			sValuePtr->borderWidth, 0, sValuePtr->relief);
+	    }
+	    leftX = rightX2 - borderWidth;
+	    leftXIn = 0;
+	} else if (!matchLeft && matchRight && sValuePtr->relief != TK_RELIEF_FLAT) {
+	    int indent = (leftX == 0) ? xIndent : 0;
+            borderWidth = sValuePtr->borderWidth;
+            if (rightX2 + borderWidth > rightX) {
+                borderWidth = rightX - rightX2;
+            }
+	    Tk_3DVerticalBevel(textPtr->tkwin, pixmap, sValuePtr->border, rightX2 + xOffset,
+		    y, borderWidth, sValuePtr->borderWidth, 1, sValuePtr->relief);
+	    Tk_3DHorizontalBevel(textPtr->tkwin, pixmap, sValuePtr->border,
+		    leftX + xOffset + indent, y,
+		    rightX2 + borderWidth - leftX - indent,
+		    sValuePtr->borderWidth, leftXIn, 0, 1,
+		    sValuePtr->relief);
+	}
+
+    nextChunk2:
+	chunkPtr2 = nextPtr2;
+	if (!chunkPtr2) {
+	    rightX2 = INT_MAX;
+	} else {
+	    nextPtr2 = chunkPtr2->nextPtr;
+	    rightX2 = chunkPtr2->x + chunkPtr2->width;
+	    if (!nextPtr2) {
+		rightX2 = INT_MAX;
+	    }
+	}
+    }
+
+    /*
+     * Pass 3: draw the horizontal bevels along the bottom of the line. This
+     * uses the same approach as pass 2.
+     */
+
+    chunkPtr = dlPtr->chunkPtr;
+    leftX = 0;				/* See Note A above. */
+    leftXIn = 0;
+    rightX = chunkPtr->x + chunkPtr->width;
+    if (!chunkPtr->nextPtr && rightX < maxX) {
+	rightX = maxX;
+    }
+    chunkPtr2 = NULL;
+    if (dlPtr->nextPtr && dlPtr->nextPtr->chunkPtr) {
+	/*
+	 * Find the chunk in the next line that covers leftX.
+	 */
+
+	nextPtr2 = dlPtr->nextPtr->chunkPtr;
+	rightX2 = 0;			/* See Note A above. */
+	while (rightX2 <= leftX) {
+	    chunkPtr2 = nextPtr2;
+	    if (!chunkPtr2) {
+		break;
+	    }
+	    nextPtr2 = chunkPtr2->nextPtr;
+	    rightX2 = chunkPtr2->x + chunkPtr2->width;
+	    if (!nextPtr2) {
+		rightX2 = INT_MAX;
+	    }
+	}
+    } else {
+	nextPtr2 = NULL;
+	rightX2 = INT_MAX;
+    }
+
+    while (leftX < maxX) {
+	matchLeft = chunkPtr2 && SameBackground(chunkPtr2->stylePtr, chunkPtr->stylePtr);
+	sValuePtr = chunkPtr->stylePtr->sValuePtr;
+	if (rightX <= rightX2) {
+	    if (!chunkPtr->nextPtr
+		    || !SameBackground(chunkPtr->stylePtr, chunkPtr->nextPtr->stylePtr)) {
+		if (!matchLeft && sValuePtr->relief != TK_RELIEF_FLAT) {
+		    int indent = (leftX == 0) ? xIndent : 0;
+		    Tk_3DHorizontalBevel(textPtr->tkwin, pixmap,
+			    sValuePtr->border, leftX + xOffset + indent,
+			    y + dlPtr->height - sValuePtr->borderWidth,
+			    rightX - leftX - indent, sValuePtr->borderWidth,
+			    leftXIn, 0, 0, sValuePtr->relief);
+		}
+		leftX = rightX;
+		leftXIn = 0;
+		if (rightX == rightX2 && chunkPtr2) {
+		    goto nextChunk2b;
+		}
+	    }
+	    chunkPtr = chunkPtr->nextPtr;
+	    if (!chunkPtr) {
+		break;
+	    }
+	    rightX = chunkPtr->x + chunkPtr->width;
+	    if (!chunkPtr->nextPtr && rightX < maxX) {
+		rightX = maxX;
+	    }
+	    continue;
+	}
+
+	matchRight = nextPtr2 && SameBackground(nextPtr2->stylePtr, chunkPtr->stylePtr);
+	if (matchLeft && !matchRight) {
+            borderWidth = sValuePtr->borderWidth;
+            if (rightX2 - borderWidth < leftX) {
+                borderWidth = rightX2 - leftX;
+            }
+	    if (sValuePtr->relief != TK_RELIEF_FLAT) {
+		Tk_3DVerticalBevel(textPtr->tkwin, pixmap, sValuePtr->border,
+			rightX2 - borderWidth + xOffset,
+			y + dlPtr->height - sValuePtr->borderWidth,
+			borderWidth, sValuePtr->borderWidth, 0,
+			sValuePtr->relief);
+	    }
+	    leftX = rightX2 - borderWidth;
+	    leftXIn = 1;
+	} else if (!matchLeft && matchRight && sValuePtr->relief != TK_RELIEF_FLAT) {
+	    int indent = (leftX == 0) ? xIndent : 0;
+            borderWidth = sValuePtr->borderWidth;
+            if (rightX2 + borderWidth > rightX) {
+                borderWidth = rightX - rightX2;
+            }
+	    Tk_3DVerticalBevel(textPtr->tkwin, pixmap, sValuePtr->border,
+		    rightX2 + xOffset, y + dlPtr->height - sValuePtr->borderWidth,
+		    borderWidth, sValuePtr->borderWidth, 1, sValuePtr->relief);
+	    Tk_3DHorizontalBevel(textPtr->tkwin, pixmap, sValuePtr->border,
+		    leftX + xOffset + indent, y + dlPtr->height - sValuePtr->borderWidth,
+		    rightX2 + borderWidth - leftX - indent, sValuePtr->borderWidth,
+		    leftXIn, 1, 0, sValuePtr->relief);
+	}
+
+    nextChunk2b:
+	chunkPtr2 = nextPtr2;
+	if (!chunkPtr2) {
+	    rightX2 = INT_MAX;
+	} else {
+	    nextPtr2 = chunkPtr2->nextPtr;
+	    rightX2 = chunkPtr2->x + chunkPtr2->width;
+	    if (!nextPtr2) {
+		rightX2 = INT_MAX;
+	    }
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * AsyncUpdateLineMetrics --
+ *
+ *	This function is invoked as a background handler to update the pixel-
+ *	height calculations of individual lines in an asychronous manner.
+ *
+ *	Currently a timer-handler is used for this purpose, which continuously
+ *	reschedules itself. It may well be better to use some other approach
+ *	(e.g., a background thread). We can't use an idle-callback because of
+ *	a known bug in Tcl/Tk in which idle callbacks are not allowed to
+ *	re-schedule themselves. This just causes an effective infinite loop.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Line heights may be recalculated.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+AsyncUpdateLineMetrics(
+    ClientData clientData)	/* Information about widget. */
+{
+    TkText *textPtr = clientData;
+    TextDInfo *dInfoPtr;
+
+    if (TkTextReleaseIfDestroyed(textPtr)) {
+	return;
+    }
+
+    dInfoPtr = textPtr->dInfoPtr;
+    dInfoPtr->lineUpdateTimer = NULL;
+
+    if (!textPtr->sharedTextPtr->allowUpdateLineMetrics) {
+	return; /* not yet configured */
+    }
+
+    if (dInfoPtr->flags & REDRAW_PENDING) {
+	dInfoPtr->flags |= ASYNC_PENDING|ASYNC_UPDATE;
+	return;
+    }
+
+    /*
+     * Update the lines in blocks of about 24 recalculations, or 250+ lines
+     * examined, so we pass in 256 for 'doThisMuch'.
+     */
+
+    UpdateLineMetrics(textPtr, 256);
+    TK_TEXT_DEBUG(LogTextInvalidateLine(textPtr, 0));
+
+    if (TkRangeListIsEmpty(dInfoPtr->lineMetricUpdateRanges)) {
+	/*
+	 * We have looped over all lines, so we're done. We must release our
+	 * refCount on the widget (the timer token was already set to NULL
+	 * above). If there is a registered aftersync command, run that first.
+	 */
+
+	if (!dInfoPtr->pendingUpdateLineMetricsFinished) {
+	    UpdateLineMetricsFinished(textPtr, false);
+	    GetYView(textPtr->interp, textPtr, true);
+	}
+	TkTextDecrRefCountAndTestIfDestroyed(textPtr);
+    } else {
+	/*
+	 * Re-arm the timer. We already have a refCount on the text widget so no
+	 * need to adjust that.
+	 */
+
+	dInfoPtr->lineUpdateTimer = Tcl_CreateTimerHandler(1, AsyncUpdateLineMetrics, textPtr);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UpdateLineMetrics --
+ *
+ *	This function updates the pixel height calculations of a range of
+ *	lines in the widget. The range is from lineNum to endLine, but
+ *	this function may return earlier, once a certain number of lines
+ *	has been examined. The line counts are from 0.
+ *
+ * Results:
+ *	The index of the last line examined (or zero if we are about to wrap
+ *	around from end to beginning of the widget).
+ *
+ * Side effects:
+ *	Line heights may be recalculated.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static unsigned
+NextLineNum(
+    TkTextLine *linePtr,
+    unsigned lineNum,
+    const TkTextIndex *indexPtr)
+{
+    TkText *textPtr;
+
+    assert(indexPtr->textPtr);
+
+    if (linePtr->nextPtr == TkTextIndexGetLine(indexPtr)) {
+	return lineNum + 1;
+    }
+
+    textPtr = indexPtr->textPtr;
+    return TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, TkTextIndexGetLine(indexPtr), NULL);
+}
+
+static void
+UpdateLineMetrics(
+    TkText *textPtr,		/* Information about widget. */
+    unsigned doThisMuch)	/* How many lines to check, or how many 10s of lines to recalculate. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    const TkRange *range = TkRangeListFirst(dInfoPtr->lineMetricUpdateRanges);
+    unsigned maxDispLines = UINT_MAX;
+    unsigned count = 0;
+
+    assert(textPtr->sharedTextPtr->allowUpdateLineMetrics);
+
+    while (range) {
+	TkTextLine *linePtr;
+	TkTextLine *logicalLinePtr;
+	int lineNum = range->low;
+	int high = range->high;
+
+	linePtr = TkBTreeFindLine(textPtr->sharedTextPtr->tree, textPtr, lineNum);
+	logicalLinePtr = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+
+	if (linePtr != logicalLinePtr) {
+	    lineNum = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, logicalLinePtr, NULL);
+	    linePtr = logicalLinePtr;
+	}
+
+	while (lineNum <= high) {
+	    TkTextPixelInfo *pixelInfo;
+
+	    TK_TEXT_DEBUG(LogTextInvalidateLine(textPtr, count));
+
+	    /*
+	     * Now update the line's metrics if necessary.
+	     */
+
+	    pixelInfo = TkBTreeLinePixelInfo(textPtr, linePtr);
+
+	    if (pixelInfo->epoch == dInfoPtr->lineMetricUpdateEpoch) {
+		int firstLineNum = lineNum;
+
+		/*
+		 * This line is already up to date. That means there's nothing to do here.
+		 */
+
+		if (linePtr->nextPtr->logicalLine) {
+		    linePtr = linePtr->nextPtr;
+		    lineNum += 1;
+		} else {
+		    linePtr = TkBTreeNextLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+		    lineNum = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, linePtr, NULL);
+		}
+
+		TkRangeListRemove(dInfoPtr->lineMetricUpdateRanges, firstLineNum, lineNum - 1);
+	    } else {
+		TkTextIndex index;
+
+		TkTextIndexClear(&index, textPtr);
+		TkTextIndexSetToStartOfLine2(&index, linePtr);
+
+		/*
+		 * Update the line and update the counter, counting 8 for each display line
+		 * we actually re-layout. But in case of synchronous update we do a full
+		 * computation.
+		 */
+
+		if (textPtr->syncTime > 0) {
+		    maxDispLines = (doThisMuch - count + 7)/8;
+		}
+		count += 8*TkTextUpdateOneLine(textPtr, linePtr, &index, maxDispLines);
+
+		if (pixelInfo->epoch & PARTIAL_COMPUTED_BIT) {
+		    /*
+		     * We didn't complete the logical line, because it produced very many
+		     * display lines - it must be a long line wrapped many times.
+		     */
+		    return;
+		}
+
+		/*
+		 * We're done with this line.
+		 */
+
+		lineNum = NextLineNum(linePtr, lineNum, &index);
+		linePtr = TkTextIndexGetLine(&index);
+	    }
+
+	    if ((++count >= doThisMuch)) {
+		return;
+	    }
+	}
+
+	/* The update process has removed the finished lines. */
+	range = TkRangeListFirst(dInfoPtr->lineMetricUpdateRanges);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextUpdateLineMetrics --
+ *
+ *	This function updates the pixel height calculations of a range of
+ *	lines in the widget. The range is from lineNum to endLine. The line
+ *	counts are from 0.
+ *
+ *	All lines in the range will be updated. This will potentially take
+ *	quite some time for a large range of lines.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Line heights may be recalculated.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextUpdateLineMetrics(
+    TkText *textPtr,		/* Information about widget. */
+    unsigned lineNum,		/* Start at this line. */
+    unsigned endLine)		/* Go no further than this line. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    const TkRange *range;
+
+    assert(lineNum <= endLine);
+    assert(endLine <= TkBTreeNumLines(textPtr->sharedTextPtr->tree, textPtr));
+    assert(textPtr->sharedTextPtr->allowUpdateLineMetrics);
+
+    dInfoPtr->insideLineMetricUpdate = true;
+
+    if ((range = TkRangeListFindNearest(dInfoPtr->lineMetricUpdateRanges, lineNum))) {
+	TkTextLine *linePtr = NULL;
+	unsigned count = 0;
+	int high = range->high;
+
+	lineNum = range->low;
+	endLine = MIN(endLine, TkBTreeNumLines(textPtr->sharedTextPtr->tree, textPtr) - 1);
+
+	while (true) {
+	    const TkTextPixelInfo *pixelInfo;
+
+	    if (lineNum > high) {
+		/*
+		 * Note that the update process has removed the finished lines.
+		 */
+
+		if (!(range = TkRangeListFindNearest(dInfoPtr->lineMetricUpdateRanges, lineNum))) {
+		    break;
+		}
+		linePtr = NULL;
+		lineNum = range->low;
+		high = range->high;
+	    }
+
+	    if (lineNum > endLine) {
+		break;
+	    }
+
+	    if (!linePtr) {
+		linePtr = TkBTreeFindLine(textPtr->sharedTextPtr->tree, textPtr, lineNum);
+		linePtr = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+	    }
+
+	    TK_TEXT_DEBUG(LogTextInvalidateLine(textPtr, count));
+	    assert(linePtr->nextPtr);
+
+	    pixelInfo = TkBTreeLinePixelInfo(textPtr, linePtr);
+
+	    if (pixelInfo->epoch != dInfoPtr->lineMetricUpdateEpoch) {
+		TkTextIndex index;
+
+		/*
+		 * This line is not (fully) up-to-date.
+		 */
+
+		TkTextIndexClear(&index, textPtr);
+		TkTextIndexSetToStartOfLine2(&index, linePtr);
+		TkTextUpdateOneLine(textPtr, linePtr, &index, UINT_MAX);
+		assert(IsStartOfNotMergedLine(&index) || TkTextIndexIsEndOfText(&index));
+		lineNum = NextLineNum(linePtr, lineNum, &index);
+		linePtr = TkTextIndexGetLine(&index);
+	    } else {
+		int firstLineNum = lineNum;
+
+		if (linePtr->nextPtr->logicalLine) {
+		    linePtr = linePtr->nextPtr;
+		    lineNum += 1;
+		} else {
+		    linePtr = TkBTreeNextLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+		    lineNum = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, linePtr, NULL);
+		}
+
+		TkRangeListRemove(dInfoPtr->lineMetricUpdateRanges, firstLineNum, lineNum - 1);
+	    }
+	}
+    }
+
+    dInfoPtr->insideLineMetricUpdate = false;
+    CheckIfLineMetricIsUpToDate(textPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextInvalidateLineMetrics, TextInvalidateLineMetrics --
+ *
+ *	Mark a number of text lines as having invalid line metric
+ *	calculations. Depending on 'action' which indicates whether
+ *	the given lines are simply invalid or have been inserted or
+ *	deleted, the pre-existing asynchronous line update range may
+ *	need to be adjusted.
+ *
+ *	If linePtr is NULL then 'lineCount' and 'action' are ignored
+ *	and all lines are invalidated.
+ *
+ *	If linePtr is the last (artificial) line, then do nothing.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	May schedule an asychronous callback.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+ResetPixelInfo(
+    TkTextPixelInfo *pixelInfo)
+{
+    TkTextDispLineInfo *dispLineInfo = pixelInfo->dispLineInfo;
+
+    if (dispLineInfo) {
+	if (pixelInfo->epoch & PARTIAL_COMPUTED_BIT) {
+	    dispLineInfo->numDispLines = dispLineInfo->entry[dispLineInfo->numDispLines].pixels;
+	}
+    }
+    pixelInfo->epoch = 0;
+}
+
+static void
+StartAsyncLineCalculation(
+    TkText *textPtr)
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+    if (!textPtr->sharedTextPtr->allowUpdateLineMetrics) {
+	return;
+    }
+
+    /*
+     * Reset cached chunk.
+     */
+
+    dInfoPtr->currChunkPtr = NULL;
+    InvokeAsyncUpdateLineMetrics(textPtr);
+
+    if (!(dInfoPtr->flags & ASYNC_UPDATE)) {
+	dInfoPtr->flags |= ASYNC_UPDATE;
+	TkTextGenerateWidgetViewSyncEvent(textPtr, false);
+    }
+}
+
+static void
+TextInvalidateLineMetrics(
+    TkText *textPtr,		/* Widget record for text widget. */
+    TkTextLine *linePtr,	/* Invalidation starts from this line; can be NULL, but only in
+    				 * case of simple invalidation. */
+    unsigned lineCount,		/* And includes this amount of following lines. */
+    TkTextInvalidateAction action)
+				/* Indicates what type of invalidation occurred (insert, delete,
+				 * or simple). */
+{
+    TkRangeList *ranges = textPtr->dInfoPtr->lineMetricUpdateRanges;
+    unsigned totalLines = TkBTreeNumLines(textPtr->sharedTextPtr->tree, textPtr);
+    unsigned epoch = textPtr->dInfoPtr->lineMetricUpdateEpoch;
+    bool isMonospaced = UseMonospacedLineHeights(textPtr);
+    unsigned lineNum = 0; /* suppress compiler warning */
+
+    assert(linePtr || action == TK_TEXT_INVALIDATE_ONLY);
+    assert(TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, linePtr, NULL) + lineCount
+	    < totalLines + (action == TK_TEXT_INVALIDATE_INSERT));
+
+    if (linePtr) {
+	int deviation;
+
+	lineNum = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, linePtr, &deviation);
+
+	assert(lineNum < totalLines);
+	assert(deviation >= 0);
+
+	if (deviation) {
+	    lineCount -= MIN(lineCount, deviation);
+	}
+
+	if (action != TK_TEXT_INVALIDATE_ONLY
+	    	&& !isMonospaced
+		&& linePtr == TkBTreeGetStartLine(textPtr)
+		&& lineCount + 1 >= totalLines) {
+	    linePtr = NULL;
+	}
+    } else if (isMonospaced) {
+	linePtr = TkBTreeGetStartLine(textPtr);
+	lineCount = totalLines;
+    }
+
+    if (linePtr) {
+	if (TkRangeListSize(ranges) >= 200) {
+	    /*
+	     * The range list is a great data structure for fast management of update
+	     * information, but this list is not designed for a large amount of entries.
+	     * If this arbitrarily chosen number of entries has been reached we will
+	     * compact the list, because in this case the line traversal may be faster
+	     * than the management of this list. Note that reaching this point is in
+	     * general not expected, especially since the range list is amalgamating
+	     * adjacent ranges automatically.
+	     */
+
+	    int low = TkRangeListLow(ranges);
+	    int high = TkRangeListHigh(ranges);
+
+	    TkRangeListClear(ranges);
+	    ranges = TkRangeListAdd(ranges, low, high);
+	}
+
+	switch (action) {
+	case TK_TEXT_INVALIDATE_ONLY: {
+	    int counter = MIN(lineCount, totalLines - lineNum);
+
+	    if (isMonospaced) {
+		TkBTreeUpdatePixelHeights(textPtr, linePtr, lineCount, epoch);
+	    } else {
+		ranges = TkRangeListAdd(ranges, lineNum, lineNum + lineCount);
+		ResetPixelInfo(TkBTreeLinePixelInfo(textPtr, linePtr));
+
+		if (!TkRangeListContainsRange(ranges, lineNum + 1, lineNum + counter)) {
+		    /*
+		     * Invalidate the height calculations of each line in the given range.
+		     * Note that normally only a few lines will be invalidated (in current
+		     * case with simple invalidation). Also note that the other cases
+		     * (insert, delete) do not need invalidation of single lines, because
+		     * inserted lines should be invalid per default, and deleted lines don't
+		     * need invalidation at all.
+		     */
+
+		    for ( ; counter > 0; --counter) {
+			ResetPixelInfo(TkBTreeLinePixelInfo(textPtr, linePtr = linePtr->nextPtr));
+		    }
+		}
+	    }
+	    break;
+	}
+	case TK_TEXT_INVALIDATE_ELIDE: {
+	    int counter = MIN(lineCount, totalLines - lineNum);
+
+	    if (isMonospaced) {
+		TkBTreeUpdatePixelHeights(textPtr, linePtr, lineCount, epoch);
+	    } else {
+		TkTextLine *mergedLinePtr = NULL;
+		unsigned count;
+
+		if (!linePtr->logicalLine) {
+#if 1		    /* TODO: is this sufficient? */
+		    assert(linePtr->prevPtr);
+		    linePtr = linePtr->prevPtr;
+		    lineNum -= 1;
+		    lineCount += 1;
+#else		    /* TODO: this is sufficient anyway! */
+		    TkTextLine *logicalLinePtr =
+			    TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+
+		    count = TkBTreeCountLines(textPtr->sharedTextPtr->tree, logicalLinePtr, linePtr);
+		    lineNum -= count;
+		    lineCount += count;
+#endif
+		}
+
+		ranges = TkRangeListAdd(ranges, lineNum, lineNum + lineCount);
+		count = 1;
+
+		/*
+		 * Invalidate the height calculations of each line in the given range.
+		 * For merged lines (any line which is not a logical line) we have to
+		 * reset the display line count.
+		 */
+
+		for ( ; counter > 0; --counter, linePtr = linePtr->nextPtr) {
+		    if (linePtr->logicalLine) {
+			if (mergedLinePtr) {
+			    TkBTreeResetDisplayLineCounts(textPtr, mergedLinePtr, count);
+			    mergedLinePtr = NULL;
+			}
+			ResetPixelInfo(TkBTreeLinePixelInfo(textPtr, linePtr));
+		    } else {
+			if (!mergedLinePtr) {
+			    mergedLinePtr = linePtr;
+			    count = 1;
+			} else {
+			    count += 1;
+			}
+		    }
+		}
+		if (mergedLinePtr) {
+		    TkBTreeResetDisplayLineCounts(textPtr, mergedLinePtr, count);
+		}
+	    }
+	    break;
+	}
+	case TK_TEXT_INVALIDATE_DELETE:
+	    textPtr->dInfoPtr->lastLineNo -= lineCount;
+	    if (isMonospaced) {
+		return;
+	    }
+	    if (lineCount > 0) {
+		TkTextIndex index;
+		DLine *dlPtr;
+
+		TkRangeListDelete(ranges, lineNum + 1, lineNum + lineCount);
+
+		/*
+		 * Free all display lines in specified range. This is required, otherwise
+		 * it may happen that we are accessing deleted (invalid) data (bug in
+		 * old implementation).
+		 */
+
+		TkTextIndexClear(&index, textPtr);
+		TkTextIndexSetToStartOfLine2(&index, linePtr->nextPtr);
+		if ((dlPtr = FindDLine(textPtr, textPtr->dInfoPtr->dLinePtr, &index))) {
+		    TkTextIndexSetToEndOfLine2(&index,
+			    TkBTreeFindLine(textPtr->sharedTextPtr->tree, textPtr, lineNum + lineCount));
+		    FreeDLines(textPtr, dlPtr, FindDLine(textPtr, dlPtr, &index), DLINE_UNLINK);
+		}
+	    }
+	    ranges = TkRangeListAdd(ranges, lineNum, lineNum);
+	    ResetPixelInfo(TkBTreeLinePixelInfo(textPtr, linePtr));
+	    break;
+	case TK_TEXT_INVALIDATE_INSERT:
+	    if (lineCount > 0 && lineNum + 1 < totalLines) {
+		int lastLine = MIN(lineNum + lineCount, totalLines - 1);
+		ranges = TkRangeListInsert(ranges, lineNum + 1, lastLine);
+	    }
+	    textPtr->dInfoPtr->lastLineNo += lineCount;
+	    if (isMonospaced) {
+		TkBTreeUpdatePixelHeights(textPtr, linePtr, lineCount, epoch);
+	    } else {
+		ranges = TkRangeListAdd(ranges, lineNum, lineNum);
+		ResetPixelInfo(TkBTreeLinePixelInfo(textPtr,
+			TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr)));
+	    }
+	    break;
+	}
+
+	assert(TkRangeListIsEmpty(ranges) || TkRangeListHigh(ranges) < totalLines);
+    } else {
+	/*
+	 * This invalidates the height of all lines in the widget.
+	 */
+
+	textPtr->dInfoPtr->lineMetricUpdateEpoch += 1;
+	if (action == TK_TEXT_INVALIDATE_DELETE) {
+	    TkRangeListClear(ranges);
+	    FreeDLines(textPtr, textPtr->dInfoPtr->dLinePtr, NULL, DLINE_UNLINK);
+	    totalLines -= lineCount;
+	    textPtr->dInfoPtr->lastLineNo -= lineCount;
+	} else if (action == TK_TEXT_INVALIDATE_INSERT) {
+	    textPtr->dInfoPtr->lastLineNo += lineCount;
+	}
+	ranges = TkRangeListAdd(ranges, 0, totalLines - 1);
+    }
+
+    FreeDLines(textPtr, NULL, NULL, DLINE_CACHE);  /* clear cache */
+    FreeDLines(textPtr, NULL, NULL, DLINE_METRIC); /* clear cache */
+    FreeDLines(textPtr, textPtr->dInfoPtr->savedDLinePtr, NULL, DLINE_FREE_TEMP);
+    textPtr->dInfoPtr->lineMetricUpdateRanges = ranges;
+    textPtr->dInfoPtr->currChunkPtr = NULL;
+
+    if (textPtr->syncTime == 0) {
+#if 0 /* TODO: is it required to update 'lastLineNo' at this place? */
+	textPtr->dInfoPtr->lastLineNo = TkBTreeNumLines(textPtr->sharedTextPtr->tree, NULL);
+#endif
+    } else {
+	StartAsyncLineCalculation(textPtr);
+    }
+}
+
+void
+TkTextInvalidateLineMetrics(
+    TkSharedText *sharedTextPtr,/* Shared widget section for all peers, or NULL. */
+    TkText *textPtr,		/* Widget record for text widget. */
+    TkTextLine *linePtr,	/* Invalidation starts from this line. */
+    unsigned lineCount,		/* And includes this many following lines. */
+    TkTextInvalidateAction action)
+				/* Indicates what type of invalidation occurred (insert,
+    				 * delete, or simple). */
+{
+    if (!sharedTextPtr) {
+	if (textPtr->sharedTextPtr->allowUpdateLineMetrics) {
+	    TextInvalidateLineMetrics(textPtr, linePtr, lineCount, action);
+	}
+    } else if (sharedTextPtr->allowUpdateLineMetrics) {
+	textPtr = sharedTextPtr->peers;
+
+	while (textPtr) {
+	    int numLines = lineCount;
+	    TkTextLine *firstLinePtr = linePtr;
+
+	    if (textPtr->startMarker != sharedTextPtr->startMarker) {
+		TkTextLine *startLinePtr = TkBTreeGetStartLine(textPtr);
+		unsigned lineNo = TkBTreeLinesTo(sharedTextPtr->tree, NULL, firstLinePtr, NULL);
+		unsigned firstLineNo = TkBTreeLinesTo(sharedTextPtr->tree, NULL, startLinePtr, NULL);
+
+		if (firstLineNo > lineNo) {
+		    firstLinePtr = startLinePtr;
+		    numLines -= firstLineNo - lineNo;
+		}
+	    }
+	    if (textPtr->endMarker != sharedTextPtr->endMarker) {
+		TkTextLine *lastLinePtr = TkBTreeGetLastLine(textPtr);
+		unsigned lineNo = TkBTreeLinesTo(sharedTextPtr->tree, NULL, firstLinePtr, NULL);
+		unsigned endLineNo = TkBTreeLinesTo(sharedTextPtr->tree, NULL, lastLinePtr, NULL);
+
+		if (endLineNo <= lineNo + numLines) {
+		    numLines = endLineNo - lineNo - 1;
+		}
+	    }
+
+	    if (numLines >= 0) {
+		TextInvalidateLineMetrics(textPtr, firstLinePtr, numLines, action);
+	    }
+
+	    textPtr = textPtr->next;
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextFindDisplayIndex -
+ *
+ *	This function is computing the index of display line start; the
+ *	computation starts at given index, and is searching some display
+ *	lines forward or backward, as specified with 'displayLineOffset'.
+ *
+ * Results:
+ *	Modifies indexPtr to point to the wanted display line start.
+ *
+ *	If xOffset is non-NULL, it is set to the x-pixel offset of the given
+ *	original index within the given display line.
+ *
+ * Side effects:
+ *	See 'LayoutDLine' and 'FreeDLines'.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextFindDisplayIndex(
+    TkText *textPtr,
+    TkTextIndex *indexPtr,
+    int displayLineOffset,
+    int *xOffset)
+{
+    DisplayInfo info;
+    TkTextLine *linePtr;
+    TkTextLine *lastLinePtr;
+    unsigned byteOffset;
+    bool upToDate;
+    int myXOffset;
+
+    assert(textPtr);
+
+    if (!xOffset) {
+	xOffset = &myXOffset;
+    }
+
+    lastLinePtr = TkBTreeGetLastLine(textPtr);
+    linePtr = TkTextIndexGetLine(indexPtr);
+
+    if (displayLineOffset >= 0 && linePtr == lastLinePtr) {
+	*xOffset = 0;
+	return;
+    }
+    if (displayLineOffset <= 0 && TkTextIndexIsStartOfText(indexPtr)) {
+	*xOffset = 0;
+	return;
+    }
+
+    if (linePtr == lastLinePtr) {
+	displayLineOffset += 1;
+	*xOffset = 0;
+	xOffset = NULL;
+	TkTextIndexSetToLastChar2(indexPtr, linePtr->prevPtr);
+    }
+
+    if (displayLineOffset > 0) {
+	upToDate = TkRangeListIsEmpty(textPtr->dInfoPtr->lineMetricUpdateRanges);
+    } else {
+	upToDate = TestIfLinesUpToDate(indexPtr);
+    }
+    linePtr = ComputeDisplayLineInfo(textPtr, indexPtr, &info);
+
+    if (xOffset) {
+	if (IsStartOfNotMergedLine(indexPtr)) {
+	    *xOffset = 0;
+	} else {
+	    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+	    DLine *dlPtr = info.lastDLinePtr;
+	    TkTextIndex index = *indexPtr;
+
+	    TkTextIndexBackBytes(textPtr, &index, info.byteOffset, &index);
+
+	    if (!dlPtr) {
+		dlPtr = FindCachedDLine(textPtr, indexPtr);
+
+		if (!dlPtr
+			&& !(dInfoPtr->flags & DINFO_OUT_OF_DATE)
+			&& TkTextIndexCompare(indexPtr, &textPtr->topIndex) >= 0) {
+		    dlPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, indexPtr);
+		}
+		if (!dlPtr) {
+		    dlPtr = LayoutDLine(&index, info.displayLineNo);
+		    FreeDLines(textPtr, dlPtr, NULL, DLINE_CACHE);
+		}
+	    }
+
+	    *xOffset = DLineXOfIndex(textPtr, dlPtr, TkTextIndexCountBytes(&dlPtr->index, indexPtr));
+	}
+    }
+
+    if (upToDate) {
+	const TkTextDispLineInfo *dispLineInfo;
+
+	assert(!info.dLinePtr);
+
+	/*
+	 * The display line information is complete for the required range, so
+	 * use it for finding the requested display line.
+	 */
+
+	if (displayLineOffset == 0) {
+	    byteOffset = info.entry->byteOffset;
+	} else {
+	    if (displayLineOffset > 0) {
+		linePtr = TkBTreeNextDisplayLine(textPtr, linePtr, &info.displayLineNo,
+			displayLineOffset);
+	    } else {
+		linePtr = TkBTreePrevDisplayLine(textPtr, linePtr, &info.displayLineNo,
+			-displayLineOffset);
+	    }
+	    dispLineInfo = TkBTreeLinePixelInfo(textPtr, linePtr)->dispLineInfo;
+	    byteOffset = dispLineInfo ? dispLineInfo->entry[info.displayLineNo].byteOffset : 0;
+	}
+    } else {
+	unsigned removedLines;
+
+	/*
+	 * We want to cache last produced display line, because it's likely that this
+	 * line will be used afterwards.
+	 */
+
+	removedLines = 0;
+	if (info.lastDLinePtr) {
+	    DLine *prevPtr = info.lastDLinePtr->prevPtr;
+	    FreeDLines(textPtr, info.lastDLinePtr, NULL, DLINE_CACHE);
+	    if (info.dLinePtr == info.lastDLinePtr) { info.dLinePtr = NULL; }
+	    info.lastDLinePtr = prevPtr;
+	    info.numCachedLines -= 1;
+	    removedLines = 1;
+	}
+
+	TkTextIndexBackBytes(textPtr, indexPtr, info.byteOffset, indexPtr);
+
+	if (displayLineOffset > 0) {
+	    ComputeMissingMetric(textPtr, &info, THRESHOLD_LINE_OFFSET, displayLineOffset);
+	    info.numDispLines -= info.displayLineNo;
+
+	    while (true) {
+		const TkTextDispLineEntry *last;
+
+		if (info.numDispLines >= displayLineOffset) {
+		    last = info.entry + displayLineOffset;
+		    byteOffset = last->byteOffset;
+		    break;
+		}
+		last = info.entry + info.numDispLines;
+		byteOffset = last->byteOffset;
+		displayLineOffset -= info.numDispLines;
+		TkTextIndexForwBytes(textPtr, indexPtr, byteOffset, indexPtr);
+		linePtr = TkTextIndexGetLine(indexPtr);
+		if (linePtr == lastLinePtr) {
+		    break;
+		}
+		FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+		ComputeDisplayLineInfo(textPtr, indexPtr, &info);
+		ComputeMissingMetric(textPtr, &info, THRESHOLD_LINE_OFFSET, displayLineOffset);
+		assert(info.displayLineNo == 0);
+	    }
+	} else if (displayLineOffset < 0) {
+	    info.numDispLines = info.displayLineNo + 1;
+
+	    while (true) {
+		TkTextLine *prevLine;
+
+		if (-displayLineOffset < info.numDispLines) {
+		    int skipBack;
+
+		    byteOffset = (info.entry + displayLineOffset)->byteOffset;
+		    skipBack = displayLineOffset;
+
+		    /*
+		     * We want to cache this display line, because it's likely that this
+		     * line will be used afterwards. Take into account that probably the
+		     * last cached line has been removed.
+		     */
+
+		    if ((skipBack -= removedLines) >= 0 && info.numCachedLines > skipBack) {
+			DLine *dlPtr = info.lastDLinePtr;
+			while (dlPtr && skipBack--) {
+			    dlPtr = dlPtr->prevPtr;
+			}
+			if (dlPtr == info.dLinePtr) {
+			    info.dLinePtr = dlPtr->nextPtr;
+			}
+			if (dlPtr == info.lastDLinePtr) {
+			    info.lastDLinePtr = dlPtr->prevPtr;
+			}
+			FreeDLines(textPtr, dlPtr, NULL, DLINE_CACHE);
+		    }
+		    break;
+		}
+		displayLineOffset += info.numDispLines;
+		if (!(prevLine = TkBTreePrevLine(textPtr, linePtr))) {
+		    byteOffset = info.entry[0].byteOffset;
+		    break;
+		}
+		TkTextIndexSetToLastChar2(indexPtr, linePtr = prevLine);
+		FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+		linePtr = ComputeDisplayLineInfo(textPtr, indexPtr, &info);
+		removedLines = 0;
+	    }
+	} else {
+	    byteOffset = info.entry[0].byteOffset;
+	}
+
+	/*
+	 * We want to cache last produced display line, because it's likely that this
+	 * line will be used afterwards.
+	 */
+
+	if (info.lastDLinePtr) {
+	    FreeDLines(textPtr, info.lastDLinePtr, NULL, DLINE_CACHE);
+	    if (info.dLinePtr == info.lastDLinePtr) { info.dLinePtr = NULL; }
+	}
+
+	FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+    }
+
+    /* set to first byte, not to start of line */
+    DEBUG(indexPtr->discardConsistencyCheck = true);
+    TkTextIndexSetByteIndex2(indexPtr, linePtr, 0);
+    DEBUG(indexPtr->discardConsistencyCheck = false);
+    TkTextIndexForwBytes(textPtr, indexPtr, byteOffset, indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextCountDisplayLines -
+ *
+ *	This function is counting the number of visible display lines
+ *	between given indices. This function will be used for computing
+ *	"count -displaylines".
+ *
+ * Results:
+ *	The number of visible display lines inside given range.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkTextCountDisplayLines(
+    TkText *textPtr,			/* Widget record for text widget. */
+    const TkTextIndex *indexFrom,	/* Start counting at this index. */
+    const TkTextIndex *indexTo)		/* Stop counting before this index. */
+{
+    const TkTextPixelInfo *pixelInfo1;
+    const TkTextPixelInfo *pixelInfo2;
+    TkTextDispLineInfo *dispLineInfo;
+    TkTextDispLineEntry *entry;
+    TkTextDispLineEntry *lastEntry;
+    TkTextLine *linePtr1;
+    TkTextLine *linePtr2;
+    TkTextIndex index;
+    unsigned byteOffset;
+    int numLines;
+
+    assert(TkTextIndexCompare(indexFrom, indexTo) <= 0);
+    assert(textPtr->sharedTextPtr->allowUpdateLineMetrics);
+
+    TkTextUpdateLineMetrics(textPtr, TkTextIndexGetLineNumber(indexFrom, textPtr),
+	    TkTextIndexGetLineNumber(indexTo, textPtr));
+
+    linePtr1 = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, TkTextIndexGetLine(indexFrom));
+    linePtr2 = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, TkTextIndexGetLine(indexTo));
+    pixelInfo1 = linePtr1->pixelInfo;
+    pixelInfo2 = linePtr2->pixelInfo;
+
+    if (!pixelInfo1->dispLineInfo) {
+	numLines = 0;
+    } else {
+	index = *indexFrom;
+	TkTextIndexSetToStartOfLine2(&index, linePtr1);
+	byteOffset = TkTextIndexCountBytes(&index, indexFrom);
+	dispLineInfo = pixelInfo1->dispLineInfo;
+	lastEntry = dispLineInfo->entry + dispLineInfo->numDispLines;
+	entry = SearchDispLineEntry(dispLineInfo->entry, lastEntry, byteOffset);
+	numLines = -(entry - dispLineInfo->entry);
+    }
+
+    while (true) {
+	if (pixelInfo1->dispLineInfo) {
+	    if (pixelInfo1 == pixelInfo2) {
+		index = *indexTo;
+		TkTextIndexSetToStartOfLine2(&index, linePtr2);
+		byteOffset = TkTextIndexCountBytes(&index, indexTo);
+		dispLineInfo = pixelInfo2->dispLineInfo;
+		lastEntry = dispLineInfo->entry + dispLineInfo->numDispLines;
+		entry = SearchDispLineEntry(dispLineInfo->entry, lastEntry, byteOffset);
+		return numLines + (entry - dispLineInfo->entry);
+	    }
+	    numLines += pixelInfo1->dispLineInfo->numDispLines;
+	} else if (pixelInfo1 == pixelInfo2) {
+	    return numLines;
+	} else {
+	    numLines += 1;
+	}
+	linePtr1 = TkBTreeNextLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr1);
+	pixelInfo1 = linePtr1->pixelInfo;
+    }
+
+    return 0; /* never reached */
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextFindDisplayLineStartEnd --
+ *
+ *	This function is invoked to find the index of the beginning or end of
+ *	the particular display line on which the given index sits, whether
+ *	that line is displayed or not.
+ *
+ *	If 'end' is 'false', we look for the start, and if 'end' is 'true'
+ *	we look for the end.
+ *
+ *	If the beginning of the current display line is elided, and we are
+ *	looking for the start of the line, then the returned index will be the
+ *	first elided index on the display line.
+ *
+ *	Similarly if the end of the current display line is elided and we are
+ *	looking for the end, then the returned index will be the last elided
+ *	index on the display line.
+ *
+ * Results:
+ *	Modifies indexPtr to point to the given end.
+ *
+ * Side effects:
+ *	See 'LayoutDLine' and 'FreeDLines'.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+FindDisplayLineStartEnd(
+    TkText *textPtr,		/* Widget record for text widget. */
+    TkTextIndex *indexPtr,	/* Index we will adjust to the display line start or end. */
+    bool end,			/* 'false' = start, 'true' = end. */
+    int cacheType)		/* Argument for FreeDLines, either DLINE_CACHE or DLINE_METRIC. */
+{
+    DisplayInfo info;
+    int byteCount;
+
+    if (TkTextIndexGetLine(indexPtr) == TkBTreeGetLastLine(textPtr)
+	    || (!end && IsStartOfNotMergedLine(indexPtr))) {
+	/*
+	 * Nothing to do, because we are at start/end of a display line.
+	 */
+
+	return;
+    }
+
+    ComputeDisplayLineInfo(textPtr, indexPtr, &info);
+    byteCount = end ? -(info.nextByteOffset - 1) : info.byteOffset;
+    TkTextIndexBackBytes(textPtr, indexPtr, byteCount, indexPtr);
+
+    if (end) {
+	int offset;
+	int skipBack = 0;
+	TkTextSegment *segPtr = TkTextIndexGetContentSegment(indexPtr, &offset);
+	char const *p = segPtr->body.chars + offset;
+
+	/*
+	 * We don't want an offset inside a multi-byte sequence, so find the start
+	 * of the current character.
+	 */
+
+	while (p > segPtr->body.chars && (*p & 0xc0) == 0x80) {
+	    p -= 1;
+	    skipBack += 1;
+	}
+	TkTextIndexBackBytes(textPtr, indexPtr, skipBack, indexPtr);
+    }
+
+    /*
+     * We want to cache last produced display line, because it's likely that this
+     * line will be used afterwards.
+     */
+
+    if (info.lastDLinePtr) {
+	FreeDLines(textPtr, info.lastDLinePtr, NULL, cacheType);
+	if (info.dLinePtr == info.lastDLinePtr) {
+	    info.dLinePtr = NULL; /* don't release it twice */
+	}
+    }
+
+    FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+}
+
+void
+TkTextFindDisplayLineStartEnd(
+    TkText *textPtr,		/* Widget record for text widget. */
+    TkTextIndex *indexPtr,	/* Index we will adjust to the display line start or end. */
+    bool end)			/* 'false' = start, 'true' = end. */
+{
+    return FindDisplayLineStartEnd(textPtr, indexPtr, end, DLINE_CACHE);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * CalculateDisplayLineHeight --
+ *
+ *	This function is invoked to recalculate the height of the particular
+ *	display line which starts with the given index, whether that line is
+ *	displayed or not.
+ *
+ *	This function does not, in itself, update any cached information about
+ *	line heights. That should be done, where necessary, by its callers.
+ *
+ *	The behaviour of this function is _undefined_ if indexPtr is not
+ *	currently at the beginning of a display line.
+ *
+ * Results:
+ *	The number of vertical pixels used by the display line.
+ *
+ *	If 'byteCountPtr' is non-NULL, then returns in that pointer the number
+ *	of byte indices on the given display line (which can be used to update
+ *	indexPtr in a loop).
+ *
+ *	If 'numLogicalLinesMergedPtr' is non-NULL, then returns in that pointer the
+ *	number of extra logical lines merged into the given display line.
+ *
+ * Side effects:
+ *	The combination of 'LayoutDLine' and 'FreeDLines' seems like a rather
+ *	time-consuming way of gathering the information we need, so this would
+ *	be a good place to look to speed up the calculations. In particular
+ *	these calls will map and unmap embedded windows respectively, which I
+ *	would hope isn't exactly necessary!
+ *
+ *----------------------------------------------------------------------
+ */
+
+#if !NDEBUG
+static bool
+IsAtStartOfDisplayLine(
+    const TkTextIndex *indexPtr)
+{
+    TkTextIndex index2 = *indexPtr;
+
+    assert(indexPtr->textPtr);
+
+    FindDisplayLineStartEnd(indexPtr->textPtr, &index2, DISP_LINE_START, DLINE_METRIC);
+    return TkTextIndexCompare(&index2, indexPtr) == 0;
+}
+#endif
+
+static int
+CalculateDisplayLineHeight(
+    TkText *textPtr,		/* Widget record for text widget. */
+    const TkTextIndex *indexPtr,/* The index at the beginning of the display line of interest. */
+    unsigned *byteCountRef)	/* NULL or used to return the number of byte indices on the given
+    				 * display line. */
+{
+    DisplayInfo info;
+
+    assert(IsAtStartOfDisplayLine(indexPtr));
+
+    /*
+     * Special case for artificial last line.
+     */
+
+    if (TkTextIndexGetLine(indexPtr) == TkBTreeGetLastLine(textPtr)) {
+	if (byteCountRef) { *byteCountRef = 0; }
+	return 0;
+    }
+
+    ComputeDisplayLineInfo(textPtr, indexPtr, &info);
+
+    /*
+     * Last computed line has to be cached temporarily.
+     */
+
+    if (info.lastDLinePtr) {
+	FreeDLines(textPtr, info.lastDLinePtr, NULL, DLINE_METRIC);
+	if (info.dLinePtr == info.lastDLinePtr) {
+	    info.dLinePtr = NULL; /* don't release it twice */
+	}
+    }
+
+    FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+    if (byteCountRef) { *byteCountRef = info.nextByteOffset + info.byteOffset; }
+    assert(info.entry->height != 0xffffffff);
+    return info.entry->height;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextGetViewOffset --
+ *
+ *	This function returns the x and y offset of the current view.
+ *
+ * Results:
+ *	The pixel offset of the current view.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextGetViewOffset(
+    TkText *textPtr,		/* Widget record for text widget. */
+    int *x,			/* X offset */
+    int *y)			/* Y offset */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+    if (dInfoPtr && dInfoPtr->dLinePtr) {
+	*x = dInfoPtr->curXPixelOffset;
+	*y = dInfoPtr->curYPixelOffset;
+    } else {
+	*x = 0;
+	*y = 0;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetPixelsTo --
+ *
+ *	This function computes the pixels between the first display line
+ *	of the logical line (belonging to given position), and the display
+ *	line at the specified position.
+ *
+ *	If the line metric computation of the specified logical line is
+ *	not yet finished, and 'info' is not NULL, then ComputeMissingMetric
+ *	will be used to compute the missing metric compuation.
+ *
+ * Results:
+ *	The pixels from first display line (belonging to given position) to
+ *	specified display line.
+ *
+ * Side effects:
+ *	Just the ones of ComputeMissingMetric.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static unsigned
+GetPixelsTo(
+    TkText *textPtr,
+    const TkTextIndex *indexPtr,
+    bool inclusiveLastLine,
+    DisplayInfo *info)		/* can be NULL */
+{
+    TkTextLine *logicalLinePtr;
+    const TkTextPixelInfo *pixelInfo;
+    TkTextDispLineInfo *dispLineInfo;
+    const TkTextDispLineEntry *lastEntry;
+    const TkTextDispLineEntry *entry;
+    TkTextIndex index;
+    unsigned byteOffset;
+
+    logicalLinePtr = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr,
+	    TkTextIndexGetLine(indexPtr));
+    if (logicalLinePtr == TkBTreeGetLastLine(textPtr)) {
+	return 0;
+    }
+    pixelInfo = TkBTreeLinePixelInfo(textPtr, logicalLinePtr);
+
+    if (!info && (pixelInfo->epoch & EPOCH_MASK) != textPtr->dInfoPtr->lineMetricUpdateEpoch) {
+	return 0;
+    }
+
+    if (!(dispLineInfo = pixelInfo->dispLineInfo)) {
+	return inclusiveLastLine ? pixelInfo->height : 0;
+    }
+
+    index = *indexPtr;
+    TkTextIndexSetToStartOfLine2(&index, logicalLinePtr);
+    byteOffset = TkTextIndexCountBytes(&index, indexPtr);
+    lastEntry = dispLineInfo->entry + dispLineInfo->numDispLines;
+    entry = SearchDispLineEntry(dispLineInfo->entry, lastEntry, byteOffset);
+
+    if (entry == lastEntry) {
+	/*
+	 * This happens if the line metric calculation for this logical line is not yet complete.
+	 */
+
+	if (info) {
+	    unsigned numDispLinesSoFar = dispLineInfo->numDispLines;
+
+	    ComputeMissingMetric(textPtr, info, THRESHOLD_BYTE_OFFSET, byteOffset);
+	    lastEntry = dispLineInfo->entry + dispLineInfo->numDispLines;
+	    entry = SearchDispLineEntry(dispLineInfo->entry + numDispLinesSoFar, lastEntry, byteOffset);
+	    if (entry == lastEntry) {
+		entry -= 1;
+	    }
+	} else {
+	    assert(dispLineInfo->numDispLines > 0);
+	    entry -= 1;
+	}
+    } else if (!inclusiveLastLine && entry-- == dispLineInfo->entry) {
+	return 0;
+    }
+
+    return entry->pixels;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexYPixels --
+ *
+ *	This function is invoked to calculate the number of vertical pixels
+ *	between the first index of the text widget and the given index. The
+ *	range from first logical line to given logical line is determined
+ *	using the cached values, and the range inside the given logical line
+ *	is calculated on the fly.
+ *
+ * Results:
+ *	The pixel distance between first pixel in the widget and the
+ *	top of the index's current display line (could be zero).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextIndexYPixels(
+    TkText *textPtr,		/* Widget record for text widget. */
+    const TkTextIndex *indexPtr)/* The index of which we want the pixel distance from top of
+    				 * text widget to top of index. */
+{
+    /* Note that TkBTreePixelsTo is computing up to start of the logical line. */
+    return TkBTreePixelsTo(textPtr, TkTextIndexGetLine(indexPtr)) +
+	    GetPixelsTo(textPtr, indexPtr, false, NULL);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextUpdateOneLine --
+ *
+ *	This function is invoked to recalculate the height of a particular
+ *	logical line, whether that line is displayed or not.
+ *
+ *	It must NEVER be called for the artificial last TkTextLine which is
+ *	used internally for administrative purposes only. That line must
+ *	retain its initial height of 0 otherwise the pixel height calculation
+ *	maintained by the B-tree will be wrong.
+ *
+ * Results:
+ *	The number of display lines in the logical line. This could be zero if
+ *	the line is totally elided.
+ *
+ * Side effects:
+ *	Line heights may be recalculated, and a timer to update the scrollbar
+ *	may be installed. Also see the called function CalculateDisplayLineHeight
+ *	for its side effects.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextUpdateOneLine(
+    TkText *textPtr,		/* Widget record for text widget. */
+    TkTextLine *linePtr,	/* The line of which to calculate the height. */
+    TkTextIndex *indexPtr,	/* Either NULL or an index at the start of a display line belonging
+    				 * to linePtr, at which we wish to start (e.g. up to which we have
+				 * already calculated). On return this will be set to the first index
+				 * on the next line. */
+    unsigned maxDispLines)	/* Don't compute more than this number of display lines. */
+{
+    TkTextIndex index;
+    TkTextLine *logicalLinePtr;
+    TkTextPixelInfo *pixelInfo;
+    unsigned displayLines;
+    unsigned updateCounter;
+    unsigned pixelHeight;
+
+    assert(linePtr != TkBTreeGetLastLine(textPtr));
+
+    if (!indexPtr) {
+	TkTextIndexClear(&index, textPtr);
+	TkTextIndexSetToStartOfLine2(&index, linePtr);
+	indexPtr = &index;
+    }
+
+    linePtr = TkTextIndexGetLine(indexPtr);
+    logicalLinePtr = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+    pixelInfo = TkBTreeLinePixelInfo(textPtr, logicalLinePtr);
+
+    if (pixelInfo->epoch == (textPtr->dInfoPtr->lineMetricUpdateEpoch | PARTIAL_COMPUTED_BIT)) {
+	const TkTextDispLineInfo *dispLineInfo = pixelInfo->dispLineInfo;
+	unsigned bytes;
+
+	/*
+	 * We are inside a partial computation. Continue with next display line.
+	 */
+
+	assert(dispLineInfo);
+	assert(dispLineInfo->numDispLines > 0);
+	bytes = dispLineInfo->entry[dispLineInfo->numDispLines].byteOffset;
+	bytes -= dispLineInfo->entry[0].byteOffset;
+	TkTextIndexSetToStartOfLine2(indexPtr, logicalLinePtr);
+	TkTextIndexForwBytes(textPtr, indexPtr, bytes, indexPtr);
+	linePtr = TkTextIndexGetLine(indexPtr);
+	assert(!linePtr->logicalLine || !TkTextIndexIsStartOfLine(indexPtr));
+    } else if (!linePtr->logicalLine || !TkTextIndexIsStartOfLine(indexPtr)) {
+	/*
+	 * CalculateDisplayLineHeight must be called with an index at the beginning
+	 * of a display line. Force this to happen. This is needed when
+	 * TkTextUpdateOneLine is called with a line that is merged with its
+	 * previous line: the number of merged logical lines in a display line is
+	 * calculated correctly only when CalculateDisplayLineHeight receives
+	 * an index at the beginning of a display line. In turn this causes the
+	 * merged lines to receive their correct zero pixel height in
+	 * TkBTreeAdjustPixelHeight.
+	 */
+
+	FindDisplayLineStartEnd(textPtr, indexPtr, DISP_LINE_START, DLINE_METRIC);
+	linePtr = TkTextIndexGetLine(indexPtr);
+    }
+
+    assert(linePtr->nextPtr);
+    updateCounter = textPtr->dInfoPtr->lineMetricUpdateCounter;
+    pixelHeight = 0;
+    displayLines = 0;
+
+    /*
+     * Iterate through all display-lines corresponding to the single logical
+     * line 'linePtr' (and lines merged into this line due to eol elision),
+     * adding up the pixel height of each such display line as we go along.
+     * The final total is, therefore, the total height of all display lines
+     * made up by the logical line 'linePtr' and subsequent logical lines
+     * merged into this line.
+     */
+
+    while (true) {
+	unsigned bytes, height;
+	bool atEnd;
+
+	/*
+	 * Currently this call doesn't have many side-effects. However, if in
+	 * the future we change the code so there are side-effects (such as
+	 * adjusting linePtr->pixelHeight), then the code might not quite work
+	 * as intended.
+	 */
+
+        height = CalculateDisplayLineHeight(textPtr, indexPtr, &bytes);
+	atEnd = TkTextIndexForwBytes(textPtr, indexPtr, bytes, indexPtr) == 1
+		|| TkTextIndexIsEndOfText(indexPtr);
+
+	assert(bytes > 0);
+
+	if (height > 0) {
+	    pixelHeight += height;
+	    displayLines += 1;
+	}
+
+	if (atEnd) {
+	    break; /* we are at the end */
+	}
+
+	if (linePtr != TkTextIndexGetLine(indexPtr)) {
+	    if (TkTextIndexGetLine(indexPtr)->logicalLine) {
+		break; /* we've reached the end of the logical line */
+	    }
+	    linePtr = TkTextIndexGetLine(indexPtr);
+	} else {
+	    /*
+	     * We must still be on the same wrapped line, on a new logical
+	     * line merged with the logical line 'linePtr'.
+	     */
+	}
+
+	if (displayLines == maxDispLines) {
+	    /*
+	     * We are calculating a limited number of display lines at a time, to avoid huge delays.
+	     */
+
+	    /* check that LayoutUpdateLineHeightInformation has set this bit */
+	    assert(pixelInfo->epoch & PARTIAL_COMPUTED_BIT);
+	    break;
+	}
+    }
+
+    if (updateCounter != textPtr->dInfoPtr->lineMetricUpdateCounter) {
+	/*
+	 * Otherwise nothing relevant has changed.
+	 */
+
+	if (tkTextDebug) {
+	    char buffer[2*TCL_INTEGER_SPACE + 1];
+
+	    if (!TkBTreeNextLine(textPtr, linePtr)) {
+		Tcl_Panic("Must never ever update line height of last artificial line");
+	    }
+
+	    pixelHeight = TkBTreeNumPixels(textPtr);
+	    snprintf(buffer, sizeof(buffer), "%u %u",
+		    TkBTreeLinesTo(indexPtr->tree, textPtr, linePtr, NULL), pixelHeight);
+	    LOG("tk_textNumPixels", buffer);
+	}
+
+	if (!textPtr->dInfoPtr->scrollbarTimer) {
+	    InvokeAsyncUpdateYScrollbar(textPtr);
+	}
+    }
+
+    return displayLines;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DisplayText --
+ *
+ *	This function is invoked as a when-idle handler to update the display.
+ *	It only redisplays the parts of the text widget that are out of date.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Information is redrawn on the screen.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+DisplayText(
+    ClientData clientData)	/* Information about widget. */
+{
+    TkText *textPtr = clientData;
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    DLine *dlPtr;
+    Pixmap pixmap;
+    int maxHeight, borders;
+    int bottomY = 0;		/* Initialization needed only to stop compiler warnings. */
+    Tcl_Interp *interp;
+
+#ifdef MAC_OSX_TK
+    /*
+     * If drawing is disabled, all we need to do is clear the REDRAW_PENDING flag.
+     */
+    TkWindow *winPtr = (TkWindow *)(textPtr->tkwin);
+    MacDrawable *macWin = winPtr->privatePtr;
+    if (macWin && (macWin->flags & TK_DO_NOT_DRAW)) {
+	dInfoPtr->flags &= ~REDRAW_PENDING;
+	if (dInfoPtr->flags & ASYNC_PENDING) {
+	    assert(dInfoPtr->flags & ASYNC_UPDATE);
+	    dInfoPtr->flags &= ~ASYNC_PENDING;
+	    /* continue with asynchronous pixel-height calculation */
+	    InvokeAsyncUpdateLineMetrics(textPtr);
+	}
+	return;
+    }
+#endif /* MAC_OSX_TK */
+
+    if (textPtr->flags & DESTROYED) {
+	return; /* the widget has been deleted */
+    }
+
+    interp = textPtr->interp;
+    Tcl_Preserve(interp);
+
+    TK_TEXT_DEBUG(Tcl_SetVar2(interp, "tk_textRelayout", NULL, "", TCL_GLOBAL_ONLY));
+
+    if (!Tk_IsMapped(textPtr->tkwin) || dInfoPtr->maxX <= dInfoPtr->x || dInfoPtr->maxY <= dInfoPtr->y) {
+	UpdateDisplayInfo(textPtr);
+	dInfoPtr->flags &= ~REDRAW_PENDING;
+	goto doScrollbars;
+    }
+    DEBUG(stats.numRedisplays += 1);
+    TK_TEXT_DEBUG(Tcl_SetVar2(interp, "tk_textRedraw", NULL, "", TCL_GLOBAL_ONLY));
+
+    /*
+     * Choose a new current item if that is needed (this could cause event
+     * handlers to be invoked, hence the preserve/release calls and the loop,
+     * since the handlers could conceivably necessitate yet another current
+     * item calculation). The textPtr check is because the whole window could go
+     * away in the meanwhile.
+     */
+
+    if (dInfoPtr->flags & REPICK_NEEDED) {
+	textPtr->refCount += 1;
+	dInfoPtr->flags &= ~REPICK_NEEDED;
+	dInfoPtr->currChunkPtr = NULL;
+	TkTextPickCurrent(textPtr, &textPtr->pickEvent);
+	if (TkTextDecrRefCountAndTestIfDestroyed(textPtr)) {
+	    goto end;
+	}
+    }
+
+    /*
+     * First recompute what's supposed to be displayed.
+     */
+
+    UpdateDisplayInfo(textPtr);
+    dInfoPtr->dLinesInvalidated = false;
+
+    /*
+     * See if it's possible to bring some parts of the screen up-to-date by
+     * scrolling (copying from other parts of the screen). We have to be
+     * particularly careful with the top and bottom lines of the display,
+     * since these may only be partially visible and therefore not helpful for
+     * some scrolling purposes.
+     */
+
+    for (dlPtr = dInfoPtr->dLinePtr; dlPtr; dlPtr = dlPtr->nextPtr) {
+	DLine *dlPtr2;
+	int offset, height, y, oldY;
+	TkRegion damageRgn;
+
+	/*
+	 * These tests are, in order:
+	 *
+	 * 1. If the line is already marked as invalid
+	 * 2. If the line hasn't moved
+	 * 3. If the line overlaps the bottom of the window and we are scrolling up.
+	 * 4. If the line overlaps the top of the window and we are scrolling down.
+	 *
+	 * If any of these tests are true, then we can't scroll this line's
+	 * part of the display.
+	 *
+	 * Note that even if tests 3 or 4 aren't true, we may be able to
+	 * scroll the line, but we still need to be sure to call embedded
+	 * window display procs on top and bottom lines if they have any
+	 * portion non-visible (see below).
+	 */
+
+	if ((dlPtr->flags & OLD_Y_INVALID)
+		|| dlPtr->y == dlPtr->oldY
+		|| ((dlPtr->oldY + dlPtr->height) > dInfoPtr->maxY && dlPtr->y < dlPtr->oldY)
+		|| (dlPtr->oldY < dInfoPtr->y && dlPtr->y > dlPtr->oldY)) {
+	    continue;
+	}
+
+	/*
+	 * This line is already drawn somewhere in the window so it only needs
+	 * to be copied to its new location. See if there's a group of lines
+	 * that can all be copied together.
+	 */
+
+	offset = dlPtr->y - dlPtr->oldY;
+	height = dlPtr->height;
+	y = dlPtr->y;
+	for (dlPtr2 = dlPtr->nextPtr; dlPtr2; dlPtr2 = dlPtr2->nextPtr) {
+	    if ((dlPtr2->flags & OLD_Y_INVALID)
+		    || dlPtr2->oldY + offset != dlPtr2->y
+		    || dlPtr2->oldY + dlPtr2->height > dInfoPtr->maxY) {
+		break;
+	    }
+	    height += dlPtr2->height;
+	}
+
+	/*
+	 * Reduce the height of the area being copied if necessary to avoid
+	 * overwriting the border area.
+	 */
+
+	if (y + height > dInfoPtr->maxY) {
+	    height = dInfoPtr->maxY - y;
+	}
+	oldY = dlPtr->oldY;
+	if (y < dInfoPtr->y) {
+	    /*
+	     * Adjust if the area being copied is going to overwrite the top
+	     * border of the window (so the top line is only half onscreen).
+	     */
+
+	    int y_off = dInfoPtr->y - dlPtr->y;
+	    height -= y_off;
+	    oldY += y_off;
+	    y = dInfoPtr->y;
+	}
+
+#if 0 /* TODO: this can happen in certain situations, but shouldn't happen */
+	assert(height > 0); /* otherwise dInfoPtr->topPixelOffset is wrong */
+#else
+	if (height <= 0) {
+	    fprintf(stderr, "DisplayText: height <= 0 is unexpected\n");
+	}
+#endif
+
+	/*
+	 * Update the lines we are going to scroll to show that they have been copied.
+	 */
+
+	while (true) {
+	    /*
+	     * The DLine already has OLD_Y_INVALID cleared.
+	     */
+
+	    dlPtr->oldY = dlPtr->y;
+	    if (dlPtr->nextPtr == dlPtr2) {
+		break;
+	    }
+	    dlPtr = dlPtr->nextPtr;
+	}
+
+	/*
+	 * Scan through the lines following the copied ones to see if we are
+	 * going to overwrite them with the copy operation. If so, mark them
+	 * for redisplay.
+	 */
+
+	for ( ; dlPtr2; dlPtr2 = dlPtr2->nextPtr) {
+	    if (!(dlPtr2->flags & OLD_Y_INVALID)
+		    && dlPtr2->oldY + dlPtr2->height > y
+		    && dlPtr2->oldY < y + height) {
+		dlPtr2->flags |= OLD_Y_INVALID;
+	    }
+	}
+
+	/*
+	 * Now scroll the lines. This may generate damage which we handle by
+	 * calling TextInvalidateRegion to mark the display blocks as stale.
+	 */
+
+	damageRgn = TkCreateRegion();
+	if (TkScrollWindow(textPtr->tkwin, dInfoPtr->scrollGC, dInfoPtr->x,
+		oldY, dInfoPtr->maxX - dInfoPtr->x, height, 0, y - oldY, damageRgn)) {
+#ifdef MAC_OSX_TK
+	    /* the processing of the Expose event is damaging the region on Mac */
+#else
+	    TextInvalidateRegion(textPtr, damageRgn);
+#endif
+	}
+	DEBUG(stats.numCopies += 1);
+	TkDestroyRegion(damageRgn);
+
+	if (y != oldY) {
+	    textPtr->configureBboxTree = true;
+	}
+    }
+
+    /*
+     * Clear the REDRAW_PENDING flag here. This is actually pretty tricky. We want to
+     * wait until *after* doing the scrolling, since that could generate more areas to
+     * redraw and don't want to reschedule a redisplay for them. On the other hand, we
+     * can't wait until after all the redisplaying, because the act of redisplaying
+     * could actually generate more redisplays (e.g. in the case of a nested window
+     * with event bindings triggered by redisplay).
+     */
+
+    dInfoPtr->flags &= ~REDRAW_PENDING;
+
+    /*
+     * Redraw the borders if that's needed.
+     */
+
+    if (dInfoPtr->flags & REDRAW_BORDERS) {
+	TK_TEXT_DEBUG(LOG("tk_textRedraw", "borders"));
+
+	if (!textPtr->tkwin) {
+	    /*
+	     * The widget has been deleted. Don't do anything.
+	     */
+
+	    goto end;
+	}
+
+	Tk_Draw3DRectangle(textPtr->tkwin, Tk_WindowId(textPtr->tkwin),
+		textPtr->border, textPtr->highlightWidth,
+		textPtr->highlightWidth,
+		Tk_Width(textPtr->tkwin) - 2*textPtr->highlightWidth,
+		Tk_Height(textPtr->tkwin) - 2*textPtr->highlightWidth,
+		textPtr->borderWidth, textPtr->relief);
+	if (textPtr->highlightWidth != 0) {
+	    GC fgGC, bgGC;
+
+	    bgGC = Tk_GCForColor(textPtr->highlightBgColorPtr, Tk_WindowId(textPtr->tkwin));
+	    if (textPtr->flags & HAVE_FOCUS) {
+		fgGC = Tk_GCForColor(textPtr->highlightColorPtr, Tk_WindowId(textPtr->tkwin));
+		TkpDrawHighlightBorder(textPtr->tkwin, fgGC, bgGC,
+			textPtr->highlightWidth, Tk_WindowId(textPtr->tkwin));
+	    } else {
+		TkpDrawHighlightBorder(textPtr->tkwin, bgGC, bgGC,
+			textPtr->highlightWidth, Tk_WindowId(textPtr->tkwin));
+	    }
+	}
+	borders = textPtr->borderWidth + textPtr->highlightWidth;
+	if (textPtr->padY > 0) {
+	    Tk_Fill3DRectangle(textPtr->tkwin, Tk_WindowId(textPtr->tkwin),
+		    textPtr->border, borders, borders,
+		    Tk_Width(textPtr->tkwin) - 2*borders, textPtr->padY,
+		    0, TK_RELIEF_FLAT);
+	    Tk_Fill3DRectangle(textPtr->tkwin, Tk_WindowId(textPtr->tkwin),
+		    textPtr->border, borders,
+		    Tk_Height(textPtr->tkwin) - borders - textPtr->padY,
+		    Tk_Width(textPtr->tkwin) - 2*borders,
+		    textPtr->padY, 0, TK_RELIEF_FLAT);
+	}
+	if (textPtr->padX > 0) {
+	    Tk_Fill3DRectangle(textPtr->tkwin, Tk_WindowId(textPtr->tkwin),
+		    textPtr->border, borders, borders + textPtr->padY,
+		    textPtr->padX,
+		    Tk_Height(textPtr->tkwin) - 2*borders -2*textPtr->padY,
+		    0, TK_RELIEF_FLAT);
+	    Tk_Fill3DRectangle(textPtr->tkwin, Tk_WindowId(textPtr->tkwin),
+		    textPtr->border,
+		    Tk_Width(textPtr->tkwin) - borders - textPtr->padX,
+		    borders + textPtr->padY, textPtr->padX,
+		    Tk_Height(textPtr->tkwin) - 2*borders -2*textPtr->padY,
+		    0, TK_RELIEF_FLAT);
+	}
+	dInfoPtr->flags &= ~REDRAW_BORDERS;
+    }
+
+    /*
+     * Now we have to redraw the lines that couldn't be updated by scrolling.
+     * First, compute the height of the largest line and allocate an off-
+     * screen pixmap to use for double-buffered displays.
+     */
+
+    maxHeight = -1;
+    for (dlPtr = dInfoPtr->dLinePtr; dlPtr; dlPtr = dlPtr->nextPtr) {
+	if (dlPtr->height > maxHeight && ((dlPtr->flags & OLD_Y_INVALID) || dlPtr->oldY != dlPtr->y)) {
+	    maxHeight = dlPtr->height;
+	}
+	bottomY = dlPtr->y + dlPtr->height;
+    }
+
+    /*
+     * There used to be a line here which restricted 'maxHeight' to be no
+     * larger than 'dInfoPtr->maxY', but this is incorrect for the case where
+     * individual lines may be taller than the widget _and_ we have smooth
+     * scrolling. What we can do is restrict maxHeight to be no larger than
+     * 'dInfoPtr->maxY + dInfoPtr->topPixelOffset'.
+     */
+
+    if (maxHeight > dInfoPtr->maxY + dInfoPtr->topPixelOffset) {
+	maxHeight = (dInfoPtr->maxY + dInfoPtr->topPixelOffset);
+    }
+
+    if (maxHeight > 0) {
+	pixmap = Tk_GetPixmap(Tk_Display(textPtr->tkwin),
+		Tk_WindowId(textPtr->tkwin), Tk_Width(textPtr->tkwin),
+		maxHeight, Tk_Depth(textPtr->tkwin));
+
+	for (dlPtr = dInfoPtr->dLinePtr; dlPtr && dlPtr->y < dInfoPtr->maxY; dlPtr = dlPtr->nextPtr) {
+	    if (!dlPtr->chunkPtr) {
+		continue;
+	    }
+	    if ((dlPtr->flags & OLD_Y_INVALID) || dlPtr->oldY != dlPtr->y) {
+		if (tkTextDebug) {
+		    char string[TK_POS_CHARS];
+
+		    TkTextPrintIndex(textPtr, &dlPtr->index, string);
+		    LOG("tk_textRedraw", string);
+		}
+		DisplayDLine(textPtr, dlPtr, dlPtr->prevPtr, pixmap);
+		if (dInfoPtr->dLinesInvalidated) {
+		    Tk_FreePixmap(Tk_Display(textPtr->tkwin), pixmap);
+		    goto doScrollbars;
+		}
+		dlPtr->oldY = dlPtr->y;
+		dlPtr->flags &= ~(NEW_LAYOUT | OLD_Y_INVALID);
+	    } else if (dInfoPtr->countWindows > 0
+		    && dlPtr->chunkPtr
+		    && (dlPtr->y < 0 || dlPtr->y + dlPtr->height > dInfoPtr->maxY)) {
+		TkTextDispChunk *chunkPtr;
+
+		/*
+		 * It's the first or last DLine which are also overlapping the
+		 * top or bottom of the window, but we decided above it wasn't
+		 * necessary to display them (we were able to update them by
+		 * scrolling). This is fine, except that if the lines contain
+		 * any embedded windows, we must still call the display proc
+		 * on them because they might need to be unmapped or they
+		 * might need to be moved to reflect their new position.
+		 * Otherwise, everything else moves, but the embedded window
+		 * doesn't!
+		 *
+		 * So, we loop through all the chunks, calling the display
+		 * proc of embedded windows only.
+		 */
+
+		for (chunkPtr = dlPtr->chunkPtr; chunkPtr; chunkPtr = chunkPtr->nextPtr) {
+		    int x;
+
+		    if (chunkPtr->layoutProcs->type != TEXT_DISP_WINDOW) {
+			continue;
+		    }
+		    x = chunkPtr->x + dInfoPtr->x - dInfoPtr->curXPixelOffset;
+		    if (x + chunkPtr->width <= 0 || x >= dInfoPtr->maxX) {
+			/*
+			 * Note: we have to call the displayProc even for
+			 * chunks that are off-screen. This is needed, for
+			 * example, so that embedded windows can be unmapped
+			 * in this case. Display the chunk at a coordinate
+			 * that can be clearly identified by the displayProc
+			 * as being off-screen to the left (the displayProc
+			 * may not be able to tell if something is off to the
+			 * right).
+			 */
+
+			x = -chunkPtr->width;
+		    }
+		    chunkPtr->layoutProcs->displayProc(textPtr, chunkPtr, x,
+			    dlPtr->spaceAbove,
+			    dlPtr->height - dlPtr->spaceAbove - dlPtr->spaceBelow,
+			    dlPtr->baseline - dlPtr->spaceAbove, NULL,
+			    (Drawable) None, dlPtr->y + dlPtr->spaceAbove);
+		}
+
+	    }
+	}
+	Tk_FreePixmap(Tk_Display(textPtr->tkwin), pixmap);
+    }
+
+    /*
+     * See if we need to refresh the part of the window below the last line of
+     * text (if there is any such area). Refresh the padding area on the left
+     * too, since the insertion cursor might have been displayed there
+     * previously).
+     */
+
+    if (dInfoPtr->topOfEof > dInfoPtr->maxY) {
+	dInfoPtr->topOfEof = dInfoPtr->maxY;
+    }
+    if (bottomY < dInfoPtr->topOfEof) {
+	TK_TEXT_DEBUG(LOG("tk_textRedraw", "eof"));
+
+	if (textPtr->flags & DESTROYED) {
+	    goto end; /* the widget has been deleted */
+	}
+
+	Tk_Fill3DRectangle(textPtr->tkwin, Tk_WindowId(textPtr->tkwin),
+		textPtr->border, dInfoPtr->x - textPtr->padX, bottomY,
+		dInfoPtr->maxX - (dInfoPtr->x - textPtr->padX),
+		dInfoPtr->topOfEof - bottomY, 0, TK_RELIEF_FLAT);
+    }
+    dInfoPtr->topOfEof = bottomY;
+
+    /*
+     * Update the vertical scrollbar, if there is one. Note: it's important to
+     * clear REDRAW_PENDING here, just in case the scroll function does
+     * something that requires redisplay.
+     */
+
+  doScrollbars:
+    if (textPtr->flags & UPDATE_SCROLLBARS) {
+
+	/*
+	 * Update the vertical scrollbar, if any.
+	 */
+
+	textPtr->flags &= ~UPDATE_SCROLLBARS;
+	if (textPtr->yScrollCmd || textPtr->watchCmd) {
+	    GetYView(textPtr->interp, textPtr, true);
+	}
+
+	/*
+	 * Update the horizontal scrollbar, if any.
+	 */
+
+	if (textPtr->xScrollCmd || textPtr->watchCmd) {
+	    GetXView(textPtr->interp, textPtr, true);
+	}
+
+	if (!(TriggerWatchCursor(textPtr))) {
+	    goto end; /* the widget has been deleted */
+	}
+    }
+
+    if (dInfoPtr->flags & ASYNC_PENDING) {
+	assert(dInfoPtr->flags & ASYNC_UPDATE);
+	dInfoPtr->flags &= ~ASYNC_PENDING;
+	/* continue with asynchronous pixel-height calculation */
+	InvokeAsyncUpdateLineMetrics(textPtr);
+    }
+
+  end:
+    Tcl_Release(interp);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextEventuallyRepick --
+ *
+ *	This function is invoked whenever something happens that could change
+ *	the current character or the tags associated with it.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	A repick is scheduled as an idle handler.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextEventuallyRepick(
+    TkText *textPtr)		/* Widget record for text widget. */
+{
+    textPtr->dInfoPtr->flags |= REPICK_NEEDED;
+    DisplayTextWhenIdle(textPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextRedrawRegion --
+ *
+ *	This function is invoked to schedule a redisplay for a given region of
+ *	a text widget. The redisplay itself may not occur immediately: it's
+ *	scheduled as a when-idle handler.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Information will eventually be redrawn on the screen.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextRedrawRegion(
+    TkText *textPtr,		/* Widget record for text widget. */
+    int x, int y,		/* Coordinates of upper-left corner of area to be redrawn, in
+    				 * pixels relative to textPtr's window. */
+    int width, int height)	/* Width and height of area to be redrawn. */
+{
+    TkRegion damageRgn = TkCreateRegion();
+    XRectangle rect;
+
+    rect.x = x;
+    rect.y = y;
+    rect.width = width;
+    rect.height = height;
+    TkUnionRectWithRegion(&rect, damageRgn, damageRgn);
+    TextInvalidateRegion(textPtr, damageRgn);
+    TkDestroyRegion(damageRgn);
+
+    DisplayTextWhenIdle(textPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextInvalidateRegion --
+ *
+ *	Mark a region of text as invalid.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Updates the display information for the text widget.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+TextInvalidateRegion(
+    TkText *textPtr,		/* Widget record for text widget. */
+    TkRegion region)		/* Region of area to redraw. */
+{
+    DLine *dlPtr;
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    int maxY, inset;
+    XRectangle rect;
+
+    /*
+     * Find all lines that overlap the given region and mark them for redisplay.
+     */
+
+    TkClipBox(region, &rect);
+    maxY = rect.y + rect.height;
+    for (dlPtr = dInfoPtr->dLinePtr; dlPtr; dlPtr = dlPtr->nextPtr) {
+	if (!(dlPtr->flags & OLD_Y_INVALID)
+		&& TkRectInRegion(region, rect.x, dlPtr->y, rect.width, dlPtr->height) != RectangleOut) {
+	    dlPtr->flags |= OLD_Y_INVALID;
+	}
+    }
+    if (dInfoPtr->topOfEof < maxY) {
+	dInfoPtr->topOfEof = maxY;
+    }
+    dInfoPtr->currChunkPtr = NULL;
+
+    /*
+     * Schedule the redisplay operation if there isn't one already scheduled.
+     */
+
+    inset = textPtr->borderWidth + textPtr->highlightWidth;
+    if (rect.x < inset + textPtr->padX
+	    || rect.y < inset + textPtr->padY
+	    || (int) (rect.x + rect.width) > Tk_Width(textPtr->tkwin) - inset - textPtr->padX
+	    || maxY > Tk_Height(textPtr->tkwin) - inset - textPtr->padY) {
+	dInfoPtr->flags |= REDRAW_BORDERS;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextChanged --
+ *
+ *	This function is invoked when info in a text widget is about to be
+ *	modified in a way that changes how it is displayed (e.g. characters
+ *	were inserted or deleted, or tag information was changed). This
+ *	function must be called *before* a change is made, so that indexes in
+ *	the display information are still valid.
+ *
+ *	Note: if the range of indices may change geometry as well as simply
+ *	requiring redisplay, then the caller should also call
+ *	TkTextInvalidateLineMetrics.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The range of character between index1Ptr (inclusive) and index2Ptr
+ *	(exclusive) will be redisplayed at some point in the future (the
+ *	actual redisplay is scheduled as a when-idle handler).
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+TextChanged(
+    TkText *textPtr,			/* Widget record for text widget, or NULL. */
+    const TkTextIndex *index1Ptr,	/* Index of first character to redisplay. */
+    const TkTextIndex *index2Ptr)	/* Index of character just after last one to redisplay. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    TkTextLine *lastLinePtr = TkBTreeGetLastLine(textPtr);
+    DLine *firstPtr = NULL;
+    DLine *lastPtr= NULL;
+    TkTextIndex rounded;
+    TkTextLine *linePtr;
+
+    /*
+     * Find the DLines corresponding to index1Ptr and index2Ptr. There is one
+     * tricky thing here, which is that we have to relayout in units of whole
+     * text lines: This is necessary because the indices stored in the display
+     * lines will no longer be valid. It's also needed because any edit could
+     * change the way lines wrap.
+     * To relayout in units of whole text (logical) lines, round index1Ptr
+     * back to the beginning of its text line (or, if this line start is
+     * elided, to the beginning of the text line that starts the display line
+     * it is included in), and include all the display lines after index2Ptr,
+     * up to the end of its text line (or, if this line end is elided, up to
+     * the end of the first non elided text line after this line end).
+     */
+
+    if ((linePtr = TkTextIndexGetLine(index1Ptr)) != lastLinePtr) {
+	rounded = *index1Ptr;
+	TkTextIndexSetLine(&rounded, TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr));
+
+	if (!(firstPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, &rounded))) {
+	    /*
+	     * index1Ptr pertains to no display line, i.e this index is after
+	     * the last display line. Since index2Ptr is after index1Ptr, there
+	     * is no display line to free/redisplay and we can return early.
+	     */
+	} else {
+	    rounded = *index2Ptr;
+	    linePtr = TkTextIndexGetLine(index2Ptr);
+	    if (linePtr == lastLinePtr) {
+		linePtr = NULL;
+	    } else {
+		linePtr = TkBTreeNextLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr);
+		TkTextIndexSetLine(&rounded, linePtr);
+	    }
+
+	    if (!linePtr) {
+		lastPtr = NULL;
+	    } else {
+		/*
+		 * 'rounded' now points to the start of a display line as well as the
+		 * start of a logical line not merged with its previous line, and
+		 * this index is the closest after index2Ptr.
+		 */
+
+		lastPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, &rounded);
+
+		/*
+		 * At least one display line is supposed to change. This makes the
+		 * redisplay OK in case the display line we expect to get here was
+		 * unlinked by a previous call to TkTextChanged and the text widget
+		 * did not update before reaching this point. This happens for
+		 * instance when moving the cursor up one line.
+		 * Note that lastPtr != NULL here, otherwise we would have returned
+		 * earlier when we tested for firstPtr being NULL.
+		 */
+
+		if (lastPtr && lastPtr == firstPtr) {
+		    lastPtr = lastPtr->nextPtr;
+		}
+	    }
+	}
+    }
+
+    /*
+     * Schedule both a redisplay and a recomputation of display information.
+     * It's done here rather than the end of the function for two reasons:
+     *
+     * 1. If there are no display lines to update we'll want to return
+     *	  immediately, well before the end of the function.
+     *
+     * 2. It's important to arrange for the redisplay BEFORE calling
+     *	  FreeDLines. The reason for this is subtle and has to do with
+     *	  embedded windows. The chunk delete function for an embedded window
+     *	  will schedule an idle handler to unmap the window. However, we want
+     *	  the idle handler for redisplay to be called first, so that it can
+     *	  put the embedded window back on the screen again (if appropriate).
+     *	  This will prevent the window from ever being unmapped, and thereby
+     *	  avoid flashing.
+     */
+
+    DisplayTextWhenIdle(textPtr);
+    dInfoPtr->flags |= DINFO_OUT_OF_DATE|REPICK_NEEDED;
+    dInfoPtr->currChunkPtr = NULL;
+
+    /*
+     * Delete all the DLines from firstPtr up to but not including lastPtr.
+     */
+
+    FreeDLines(textPtr, firstPtr, lastPtr, DLINE_UNLINK_KEEP_BRKS);
+}
+
+void
+TkTextChanged(
+    TkSharedText *sharedTextPtr,	/* Shared widget section, or NULL. */
+    TkText *textPtr,			/* Widget record for text widget, or NULL. */
+    const TkTextIndex *index1Ptr,	/* Index of first character to redisplay. */
+    const TkTextIndex *index2Ptr)	/* Index of character just after last one to redisplay. */
+{
+    assert(!sharedTextPtr != !textPtr);
+
+    if (!sharedTextPtr) {
+	TextChanged(textPtr, index1Ptr, index2Ptr);
+    } else {
+	TkTextIndex index1 = *index1Ptr;
+	TkTextIndex index2 = *index2Ptr;
+
+	for (textPtr = sharedTextPtr->peers; textPtr; textPtr = textPtr->next) {
+	    DEBUG(index1.discardConsistencyCheck = true);
+	    DEBUG(index2.discardConsistencyCheck = true);
+	    TkTextIndexSetPeer(&index1, textPtr);
+	    TkTextIndexSetPeer(&index2, textPtr);
+	    TextChanged(textPtr, &index1, &index2);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextRedrawTag --
+ *
+ *	This function is invoked to request a redraw of all characters in a
+ *	given range that have a particular tag on or off. It's called, for
+ *	example, when tag options change.
+ *
+ * Results:
+ *	Return whether any redraw will happen.
+ *
+ * Side effects:
+ *	Information on the screen may be redrawn, and the layout of the screen
+ *	may change.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+TextRedrawTag(
+    TkText *textPtr,		/* Widget record for text widget. */
+    const TkTextIndex *index1Ptr,
+    				/* First character in range to consider for redisplay. NULL
+				 * means start at beginning of text. */
+    const TkTextIndex *index2Ptr,
+    				/* Character just after last one to consider for redisplay.
+				 * NULL means process all the characters in the text. */
+    bool affectsDisplayGeometry)/* Whether the display geometry is affected. */
+{
+    TextDInfo *dInfoPtr;
+    DLine *dlPtr;
+    DLine *endPtr;
+
+    if (textPtr->flags & DESTROYED) {
+	return;
+    }
+
+    assert(index1Ptr);
+    assert(index2Ptr);
+    assert(textPtr);
+
+    dInfoPtr = textPtr->dInfoPtr;
+    dlPtr = dInfoPtr->dLinePtr;
+
+    if (!dlPtr) {
+	return;
+    }
+
+    /*
+     * Invalidate the pixel calculation of all lines in the given range.
+     */
+
+    if (affectsDisplayGeometry) {
+	TkTextLine *startLine, *endLine;
+	unsigned lineCount;
+
+	dInfoPtr->currChunkPtr = NULL; /* reset cached chunk */
+	endLine = TkTextIndexGetLine(index2Ptr);
+	if (endLine == textPtr->endMarker->sectionPtr->linePtr) {
+	    assert(endLine->prevPtr);
+	    endLine = endLine->prevPtr;
+	}
+	lineCount = TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, endLine, NULL);
+	startLine = TkTextIndexGetLine(index1Ptr);
+	lineCount -= TkBTreeLinesTo(textPtr->sharedTextPtr->tree, textPtr, startLine, NULL);
+	TkTextInvalidateLineMetrics(NULL, textPtr, startLine, lineCount, TK_TEXT_INVALIDATE_ONLY);
+    }
+
+    /*
+     * Round up the starting position if it's before the first line visible on
+     * the screen (we only care about what's on the screen).
+     */
+
+    if (TkTextIndexCompare(&dlPtr->index, index1Ptr) > 0) {
+	index1Ptr = &dlPtr->index;
+    }
+
+    /*
+     * Schedule a redisplay and layout recalculation if they aren't already
+     * pending. This has to be done before calling FreeDLines, for the reason
+     * given in TkTextChanged.
+     */
+
+    DisplayTextWhenIdle(textPtr);
+    dInfoPtr->flags |= DINFO_OUT_OF_DATE|REPICK_NEEDED;
+
+    /*
+     * Each loop through the loop below is for one range of characters where
+     * the tag's current state is different than its eventual state. At the
+     * top of the loop, search contains information about the first character
+     * in the range.
+     */
+
+    dlPtr = FindDLine(textPtr, dlPtr, index1Ptr);
+
+    if (dlPtr) {
+	/*
+	 * Find the first DLine structure that's past the end of the range.
+	 */
+
+	endPtr = FindDLine(textPtr, dlPtr, index2Ptr);
+	if (endPtr && TkTextIndexCompare(&endPtr->index, index2Ptr) < 0) {
+	    endPtr = endPtr->nextPtr;
+	}
+
+	/*
+	 * Delete all of the display lines in the range, so that they'll be
+	 * re-layed out and redrawn.
+	 */
+
+	FreeDLines(textPtr, dlPtr, endPtr, DLINE_UNLINK);
+    }
+}
+
+static void
+RedrawTagsInPeer(
+    const TkSharedText *sharedTextPtr,
+    TkText *textPtr,
+    TkTextIndex *indexPtr1,
+    TkTextIndex *indexPtr2,
+    bool affectsDisplayGeometry)
+{
+    TkTextIndex start, end;
+
+    if (!textPtr->dInfoPtr || !textPtr->dInfoPtr->dLinePtr) {
+	return;
+    }
+
+    if (textPtr->startMarker != sharedTextPtr->startMarker) {
+	TkTextIndexSetupToStartOfText(&start, textPtr, sharedTextPtr->tree);
+	if (TkTextIndexCompare(indexPtr1, &start) <= 0) {
+	    indexPtr1 = &start;
+	}
+    }
+
+    if (textPtr->endMarker != sharedTextPtr->endMarker) {
+	TkTextIndexSetupToEndOfText(&end, textPtr, sharedTextPtr->tree);
+	if (TkTextIndexCompare(indexPtr2, &end) <= 0) {
+	    indexPtr2 = &end;
+	}
+    }
+
+    TkTextIndexSetPeer(indexPtr1, textPtr);
+    TkTextIndexSetPeer(indexPtr2, textPtr);
+    TextRedrawTag(textPtr, indexPtr1, indexPtr2, affectsDisplayGeometry);
+}
+
+bool
+TkTextRedrawTag(
+    const TkSharedText *sharedTextPtr,
+    				/* Shared widget section, or NULL if textPtr is not NULL. */
+    TkText *textPtr,		/* Widget record for text widget, or NULL if sharedTextPtr is not
+    				 * NULL. */
+    const TkTextIndex *index1Ptr,
+    				/* First character in range to consider for redisplay. NULL means
+				 * start at beginning of text. */
+    const TkTextIndex *index2Ptr,
+    				/* Character just after last one to consider for redisplay. NULL
+				 * means process all the characters in the text. Note that either
+				 * both indices are NULL, or both are non-Null. */
+    const TkTextTag *tagPtr,	/* Information about tag, can be NULL, but only if the indices are
+    				 * non-NULL*/
+    bool affectsDisplayGeometry)/* Whether the display geometry is affected. If argument tagPtr is
+    				 * given, then also this tag will be tested if the display geometry
+				 * is affected. */
+{
+    assert(!index1Ptr == !index2Ptr);
+    assert(index1Ptr || tagPtr);
+    assert(sharedTextPtr || textPtr);
+
+    if (!sharedTextPtr && !textPtr->dInfoPtr->dLinePtr) {
+	return false;
+    }
+
+    if (tagPtr && tagPtr->affectsDisplayGeometry) {
+	affectsDisplayGeometry = true;
+    }
+
+    if (!index1Ptr) {
+	TkTextSegment *endMarker;
+	TkTextSearch search;
+	TkTextIndex startIndex, endIndex;
+
+	if (!sharedTextPtr) {
+	    TkTextIndexClear2(&startIndex, NULL, textPtr->sharedTextPtr->tree);
+	    TkTextIndexClear2(&endIndex, NULL, textPtr->sharedTextPtr->tree);
+	    TkTextIndexSetSegment(&startIndex, textPtr->startMarker);
+	    TkTextIndexSetSegment(&endIndex, textPtr->endMarker);
+	    endMarker = textPtr->endMarker;
+	} else {
+	    TkTextIndexClear2(&startIndex, NULL, sharedTextPtr->tree);
+	    TkTextIndexClear2(&endIndex, NULL, sharedTextPtr->tree);
+	    TkTextIndexSetSegment(&startIndex, sharedTextPtr->startMarker);
+	    TkTextIndexSetSegment(&endIndex, sharedTextPtr->endMarker);
+	    endMarker = sharedTextPtr->endMarker;
+	}
+
+	/*
+	 * Now we try to restrict the range, because redrawing is in general an expensive
+	 * operation.
+	 */
+
+	if (tagPtr) {
+	    bool found = false;
+
+	    TkBTreeStartSearch(&startIndex, &endIndex, tagPtr, &search, SEARCH_EITHER_TAGON_TAGOFF);
+
+	    while (true) {
+		if (!TkBTreeNextTag(&search)) {
+		    return found;
+		}
+		if (search.tagon) {
+		    /* we need end of range */
+		    startIndex = search.curIndex;
+		    TkBTreeNextTag(&search);
+		    assert(search.segPtr); /* search must not fail */
+		} else {
+		    assert(!found);
+		}
+		found = true;
+		assert(!search.tagon);
+		if (!sharedTextPtr) {
+		    TextRedrawTag(textPtr, &startIndex, &search.curIndex, affectsDisplayGeometry);
+		} else {
+		    for (textPtr = sharedTextPtr->peers; textPtr; textPtr = textPtr->next) {
+			RedrawTagsInPeer(sharedTextPtr, textPtr, &startIndex, &search.curIndex,
+				affectsDisplayGeometry);
+		    }
+		}
+	    }
+	} else {
+	    const TkBitField *discardTags = NULL;
+	    TkTextSegment *segPtr;
+	    TkTextIndex index2;
+
+	    if (affectsDisplayGeometry) {
+		if (sharedTextPtr) {
+		    discardTags = sharedTextPtr->notAffectDisplayTags;
+		} else {
+		    discardTags = textPtr->sharedTextPtr->notAffectDisplayTags;
+		}
+	    }
+	    if (!(segPtr = TkBTreeFindNextTagged(&startIndex, &endIndex, discardTags))) {
+		return false;
+	    }
+	    index2 = endIndex;
+
+	    while (segPtr) {
+		TkTextSegment *endPtr;
+
+		TkTextIndexSetSegment(&startIndex, segPtr);
+		endPtr = TkBTreeFindNextUntagged(&startIndex, &endIndex, discardTags);
+
+		if (!endPtr) {
+		    endPtr = endMarker;
+		}
+
+		TkTextIndexSetSegment(&index2, endPtr);
+
+		if (!sharedTextPtr) {
+		    TextRedrawTag(textPtr, &startIndex, &index2, affectsDisplayGeometry);
+		} else {
+		    for (textPtr = sharedTextPtr->peers; textPtr; textPtr = textPtr->next) {
+			RedrawTagsInPeer(sharedTextPtr, textPtr, &startIndex, &index2,
+				affectsDisplayGeometry);
+		    }
+		}
+	    }
+	}
+    } else if (!sharedTextPtr) {
+	TextRedrawTag(textPtr, index1Ptr, index2Ptr, affectsDisplayGeometry);
+    } else {
+	TkTextIndex index1 = *index1Ptr;
+	TkTextIndex index2 = *index2Ptr;
+
+	for (textPtr = sharedTextPtr->peers; textPtr; textPtr = textPtr->next) {
+	    RedrawTagsInPeer(sharedTextPtr, textPtr, &index1, &index2, affectsDisplayGeometry);
+	}
+    }
+
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextRelayoutWindow --
+ *
+ *	This function is called when something has happened that invalidates
+ *	the whole layout of characters on the screen, such as a change in a
+ *	configuration option for the overall text widget or a change in the
+ *	window size. It causes all display information to be recomputed and
+ *	the window to be redrawn.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	All the display information will be recomputed for the window and the
+ *	window will be redrawn.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextRelayoutWindow(
+    TkText *textPtr,		/* Widget record for text widget. */
+    int mask)			/* OR'd collection of bits showing what has changed. */
+{
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    XGCValues gcValues;
+    GC newGC;
+    bool recomputeGeometry;
+    bool asyncLineCalculation;
+    int firstLineNo;
+    int lastLineNo;
+    int maxX;
+
+    if ((mask & TK_TEXT_LINE_REDRAW_BOTTOM_LINE) && dInfoPtr->lastDLinePtr) {
+	dInfoPtr->lastDLinePtr->flags |= OLD_Y_INVALID;
+    }
+
+    /*
+     * Schedule the window redisplay. See TkTextChanged for the reason why
+     * this has to be done before any calls to FreeDLines.
+     */
+
+    DisplayTextWhenIdle(textPtr);
+    dInfoPtr->flags |= REDRAW_BORDERS|DINFO_OUT_OF_DATE|REPICK_NEEDED;
+
+    /*
+     * (Re-)create the graphics context for drawing the traversal highlight.
+     */
+
+    gcValues.graphics_exposures = False;
+    newGC = Tk_GetGC(textPtr->tkwin, GCGraphicsExposures, &gcValues);
+    if (dInfoPtr->copyGC != None) {
+	Tk_FreeGC(textPtr->display, dInfoPtr->copyGC);
+    }
+    dInfoPtr->copyGC = newGC;
+
+    /*
+     * (Re-)create the graphics context for drawing the characters "behind" the block cursor.
+     */
+
+    if (dInfoPtr->insertFgGC != None) {
+	Tk_FreeGC(textPtr->display, dInfoPtr->insertFgGC);
+	dInfoPtr->insertFgGC = None;
+    }
+    if (textPtr->state == TK_TEXT_STATE_NORMAL
+	    && textPtr->blockCursorType
+	    && textPtr->showInsertFgColor) {
+	gcValues.foreground = textPtr->insertFgColorPtr->pixel;
+	dInfoPtr->insertFgGC = Tk_GetGC(textPtr->tkwin, GCForeground, &gcValues);
+    }
+
+    maxX = MAX(Tk_Width(textPtr->tkwin) - dInfoPtr->x, dInfoPtr->x + 1);
+    firstLineNo = TkBTreeLinesTo(sharedTextPtr->tree, NULL, TkBTreeGetStartLine(textPtr), NULL);
+    lastLineNo = TkBTreeLinesTo(sharedTextPtr->tree, NULL, TkBTreeGetLastLine(textPtr), NULL);
+    recomputeGeometry = (maxX != dInfoPtr->maxX) || (mask & TK_TEXT_LINE_GEOMETRY);
+
+    /*
+     * Throw away all the current display lines, except the visible ones if
+     * they will not change.
+     */
+
+    if (recomputeGeometry || (mask & TK_TEXT_LINE_REDRAW)) {
+	FreeDLines(textPtr, dInfoPtr->dLinePtr, NULL, DLINE_UNLINK_KEEP_BRKS);
+    }
+
+    FreeDLines(textPtr, NULL, NULL, DLINE_CACHE);  /* release cached display lines */
+    FreeDLines(textPtr, NULL, NULL, DLINE_METRIC); /* release cached lines */
+    FreeDLines(textPtr, dInfoPtr->savedDLinePtr, NULL, DLINE_FREE_TEMP);
+
+    /*
+     * Recompute some overall things for the layout. Even if the window gets very small,
+     * pretend that there's at least one pixel of drawing space in it.
+     */
+
+    assert(textPtr->highlightWidth >= 0);
+    assert(textPtr->borderWidth >= 0);
+
+    dInfoPtr->x = textPtr->highlightWidth + textPtr->borderWidth + textPtr->padX;
+    dInfoPtr->y = textPtr->highlightWidth + textPtr->borderWidth + textPtr->padY;
+
+    dInfoPtr->maxX = MAX(Tk_Width(textPtr->tkwin) - dInfoPtr->x, dInfoPtr->x + 1);
+
+    /*
+     * This is the only place where dInfoPtr->maxY is set.
+     */
+
+    dInfoPtr->maxY = MAX(Tk_Height(textPtr->tkwin) - dInfoPtr->y, dInfoPtr->y + 1);
+    dInfoPtr->topOfEof = dInfoPtr->maxY;
+
+    /*
+     * If the upper-left character isn't the first in a line, recompute it.
+     * This is necessary because a change in the window's size or options
+     * could change the way lines wrap.
+     */
+
+    if (!IsStartOfNotMergedLine(&textPtr->topIndex)) {
+	TkTextFindDisplayLineStartEnd(textPtr, &textPtr->topIndex, DISP_LINE_START);
+    }
+
+    /*
+     * Invalidate cached scrollbar positions, so that scrollbars sliders will be udpated.
+     */
+
+    dInfoPtr->xScrollFirst = dInfoPtr->xScrollLast = -1;
+    dInfoPtr->yScrollFirst = dInfoPtr->yScrollLast = -1;
+
+    /*
+     * Invalidate cached cursor chunk.
+     */
+
+    dInfoPtr->currChunkPtr = NULL;
+
+    if (mask & TK_TEXT_LINE_GEOMETRY) {
+	/* Setup end of line segment. */
+	SetupEolSegment(textPtr, dInfoPtr);
+    }
+
+    asyncLineCalculation = false;
+
+#if SPEEDUP_MONOSPACED_LINE_HEIGHTS
+    if (TestMonospacedLineHeights(textPtr)) {
+	TkRangeList *ranges = textPtr->dInfoPtr->lineMetricUpdateRanges;
+
+	if (!TkRangeListIsEmpty(ranges)) {
+	    TkBTreeUpdatePixelHeights(textPtr,
+		    TkBTreeFindLine(sharedTextPtr->tree, textPtr, TkRangeListLow(ranges)),
+		    TkRangeListSpan(ranges), dInfoPtr->lineMetricUpdateEpoch);
+	    TkRangeListClear(ranges);
+	}
+	if (dInfoPtr->lineHeight != textPtr->lineHeight) {
+	    TkBTreeUpdatePixelHeights(textPtr, TkBTreeGetStartLine(textPtr), lastLineNo - firstLineNo,
+		    dInfoPtr->lineMetricUpdateEpoch);
+	    dInfoPtr->lineHeight = textPtr->lineHeight;
+	}
+    } else
+#endif
+    if (recomputeGeometry) {
+	/*
+	 * Set up line metric recalculation.
+	 */
+
+	dInfoPtr->lineHeight = 0;
+	TkRangeListClear(dInfoPtr->lineMetricUpdateRanges);
+	if (lastLineNo > firstLineNo) {
+	    dInfoPtr->lineMetricUpdateRanges =
+		    TkRangeListAdd(dInfoPtr->lineMetricUpdateRanges, 0, lastLineNo - firstLineNo - 1);
+	    dInfoPtr->lineMetricUpdateEpoch += 1;
+	    asyncLineCalculation = true;
+	}
+    } else {
+	TkTextIndex index;
+	DLine *dlPtr;
+	int numLines;
+
+	dInfoPtr->lineHeight = 0;
+
+	/*
+	 * We have to handle -startindex, -endIndex.
+	 */
+
+	if (lastLineNo == firstLineNo) {
+	    FreeDLines(textPtr, dInfoPtr->dLinePtr, NULL, DLINE_UNLINK);
+	    TkRangeListClear(dInfoPtr->lineMetricUpdateRanges);
+	} else if (dInfoPtr->lastLineNo <= firstLineNo || lastLineNo <= dInfoPtr->firstLineNo) {
+	    FreeDLines(textPtr, dInfoPtr->dLinePtr, NULL, DLINE_UNLINK);
+	    TkRangeListClear(dInfoPtr->lineMetricUpdateRanges);
+	    dInfoPtr->lineMetricUpdateRanges = TkRangeListAdd(
+		    dInfoPtr->lineMetricUpdateRanges, 0, lastLineNo - firstLineNo - 1);
+	    asyncLineCalculation = true;
+	} else {
+	    if (firstLineNo < dInfoPtr->firstLineNo) {
+		dInfoPtr->lineMetricUpdateRanges = TkRangeListInsert(
+			dInfoPtr->lineMetricUpdateRanges, 0, dInfoPtr->firstLineNo - firstLineNo - 1);
+		asyncLineCalculation = true;
+	    } else if (dInfoPtr->firstLineNo < firstLineNo) {
+		TkTextIndexSetupToStartOfText(&index, textPtr, sharedTextPtr->tree);
+		dlPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, &index);
+		FreeDLines(textPtr, dInfoPtr->dLinePtr, dlPtr, DLINE_UNLINK);
+		numLines = firstLineNo - dInfoPtr->firstLineNo;
+		TkRangeListDelete(dInfoPtr->lineMetricUpdateRanges, 0, numLines - 1);
+	    }
+	    if (dInfoPtr->lastLineNo < lastLineNo) {
+		dInfoPtr->lineMetricUpdateRanges = TkRangeListAdd(
+			dInfoPtr->lineMetricUpdateRanges,
+			dInfoPtr->lastLineNo - dInfoPtr->firstLineNo,
+			lastLineNo - firstLineNo - 1);
+		asyncLineCalculation = true;
+	    } else if (lastLineNo < dInfoPtr->lastLineNo) {
+		TkTextIndexSetupToEndOfText(&index, textPtr, sharedTextPtr->tree);
+		dlPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, &index);
+		FreeDLines(textPtr, dlPtr, NULL, DLINE_UNLINK);
+		TkRangeListTruncateAtEnd(dInfoPtr->lineMetricUpdateRanges, lastLineNo - firstLineNo - 1);
+	    }
+	}
+    }
+
+    dInfoPtr->firstLineNo = firstLineNo;
+    dInfoPtr->lastLineNo = lastLineNo;
+
+    if (asyncLineCalculation) {
+	StartAsyncLineCalculation(textPtr);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextSetYView --
+ *
+ *	This function is called to specify what lines are to be displayed in a
+ *	text widget.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The display will (eventually) be updated so that the position given by
+ *	"indexPtr" is visible on the screen at the position determined by
+ *	"pickPlace".
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextSetYView(
+    TkText *textPtr,		/* Widget record for text widget. */
+    TkTextIndex *indexPtr,	/* Position that is to appear somewhere in the view. */
+    int pickPlace)		/* 0 means the given index must appear exactly at the top of the
+    				 * screen. TK_TEXT_PICKPLACE (-1) means we get to pick where it
+				 * appears: minimize screen motion or else display line at center
+				 * of screen. TK_TEXT_NOPIXELADJUST (-2) indicates to make the
+				 * given index the top line, but if it is already the top line,
+				 * don't nudge it up or down by a few pixels just to make sure
+				 * it is entirely displayed. Positive numbers indicate the number
+				 * of pixels of the index's line which are to be off the top of
+				 * the screen. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    DLine *dlPtr;
+    int bottomY, close;
+    TkTextIndex tmpIndex;
+    TkTextLine *linePtr;
+    int lineHeight;
+    int topLineNo;
+    int topByteIndex;
+    int32_t overlap;
+
+    if (TkTextIsDeadPeer(textPtr)) {
+	textPtr->topIndex = *indexPtr;
+	TkTextIndexSetPeer(&textPtr->topIndex, textPtr);
+	return;
+    }
+
+    /*
+     * If the specified position is the extra line at the end of the text,
+     * round it back to the last real line.
+     */
+
+    linePtr = TkTextIndexGetLine(indexPtr);
+
+    if (linePtr == TkBTreeGetLastLine(textPtr) && TkTextIndexGetByteIndex(indexPtr) == 0) {
+	assert(linePtr->prevPtr);
+	assert(TkBTreeGetStartLine(textPtr) != linePtr);
+	TkTextIndexSetToEndOfLine2(indexPtr, linePtr->prevPtr);
+    }
+
+    if (pickPlace == TK_TEXT_NOPIXELADJUST) {
+	pickPlace = TkTextIndexIsEqual(&textPtr->topIndex, indexPtr) ? dInfoPtr->topPixelOffset : 0;
+    }
+
+    if (pickPlace != TK_TEXT_PICKPLACE) {
+	/*
+	 * The specified position must go at the top of the screen. Just leave
+	 * all the DLine's alone: we may be able to reuse some of the information
+	 * that's currently on the screen without redisplaying it all.
+	 */
+
+	textPtr->topIndex = *indexPtr;
+	TkTextIndexSetPeer(&textPtr->topIndex, textPtr);
+	TkTextIndexToByteIndex(&textPtr->topIndex);
+        if (!IsStartOfNotMergedLine(indexPtr)) {
+            TkTextFindDisplayLineStartEnd(textPtr, &textPtr->topIndex, DISP_LINE_START);
+        }
+	dInfoPtr->newTopPixelOffset = pickPlace;
+	goto scheduleUpdate;
+    }
+
+    /*
+     * We have to pick where to display the index. First, bring the display
+     * information up to date and see if the index will be completely visible
+     * in the current screen configuration. If so then there's nothing to do.
+     */
+
+    if (dInfoPtr->flags & DINFO_OUT_OF_DATE) {
+	UpdateDisplayInfo(textPtr);
+    }
+    dlPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, indexPtr);
+    if (dlPtr) {
+	if (dlPtr->y + dlPtr->height > dInfoPtr->maxY) {
+	    /*
+	     * Part of the line hangs off the bottom of the screen; pretend
+	     * the whole line is off-screen.
+	     */
+
+	    dlPtr = NULL;
+        } else {
+            if (TkTextIndexCompare(&dlPtr->index, indexPtr) <= 0) {
+                if (dInfoPtr->dLinePtr == dlPtr && dInfoPtr->topPixelOffset != 0) {
+                    /*
+                     * It is on the top line, but that line is hanging off the top
+                     * of the screen. Change the top overlap to zero and update.
+                     */
+
+                    dInfoPtr->newTopPixelOffset = 0;
+                    goto scheduleUpdate;
+		}
+                /*
+                 * The line is already on screen, with no need to scroll.
+                 */
+                return;
+            }
+        }
+    }
+
+    /*
+     * The desired line isn't already on-screen. Figure out what it means to
+     * be "close" to the top or bottom of the screen. Close means within 1/3
+     * of the screen height or within three lines, whichever is greater.
+     *
+     * If the line is not close, place it in the center of the window.
+     */
+
+    tmpIndex = *indexPtr;
+    TkTextFindDisplayLineStartEnd(textPtr, &tmpIndex, DISP_LINE_START);
+    lineHeight = CalculateDisplayLineHeight(textPtr, &tmpIndex, NULL);
+
+    /*
+     * It would be better if 'bottomY' were calculated using the actual height
+     * of the given line, not 'textPtr->lineHeight'.
+     */
+
+    bottomY = (dInfoPtr->y + dInfoPtr->maxY + lineHeight)/2;
+    close = (dInfoPtr->maxY - dInfoPtr->y)/3;
+    if (close < 3*textPtr->lineHeight) {
+	close = 3*textPtr->lineHeight;
+    }
+    if (dlPtr) {
+
+	/*
+	 * The desired line is above the top of screen. If it is "close" to
+	 * the top of the window then make it the top line on the screen.
+	 * MeasureUp counts from the bottom of the given index upwards, so we
+	 * add an extra half line to be sure we count far enough.
+	 */
+
+	MeasureUp(textPtr, &textPtr->topIndex, close + textPtr->lineHeight/2, &tmpIndex, &overlap);
+	if (TkTextIndexCompare(&tmpIndex, indexPtr) <= 0) {
+	    textPtr->topIndex = *indexPtr;
+	    TkTextIndexSetPeer(&textPtr->topIndex, textPtr);
+	    TkTextIndexToByteIndex(&textPtr->topIndex);
+	    TkTextFindDisplayLineStartEnd(textPtr, &textPtr->topIndex, DISP_LINE_START);
+	    dInfoPtr->newTopPixelOffset = 0;
+	    goto scheduleUpdate;
+	}
+    } else {
+	/*
+	 * The desired line is below the bottom of the screen. If it is
+	 * "close" to the bottom of the screen then position it at the bottom
+	 * of the screen.
+	 */
+
+	MeasureUp(textPtr, indexPtr, close + lineHeight - textPtr->lineHeight/2, &tmpIndex, &overlap);
+	if (FindDLine(textPtr, dInfoPtr->dLinePtr, &tmpIndex)) {
+	    bottomY = dInfoPtr->maxY - dInfoPtr->y;
+	}
+    }
+
+    /*
+     * If the window height is smaller than the line height, prefer to make
+     * the top of the line visible.
+     */
+
+    if (dInfoPtr->maxY - dInfoPtr->y < lineHeight) {
+        bottomY = lineHeight;
+    }
+
+    /*
+     * Our job now is to arrange the display so that indexPtr appears as low
+     * on the screen as possible but with its bottom no lower than bottomY.
+     * BottomY is the bottom of the window if the desired line is just below
+     * the current screen, otherwise it is a half-line lower than the center
+     * of the window.
+     */
+
+    MeasureUp(textPtr, indexPtr, bottomY, &textPtr->topIndex, &dInfoPtr->newTopPixelOffset);
+
+  scheduleUpdate:
+    topLineNo = TkTextIndexGetLineNumber(&textPtr->topIndex, NULL);
+    topByteIndex = TkTextIndexGetByteIndex(&textPtr->topIndex);
+
+    if (dInfoPtr->newTopPixelOffset != dInfoPtr->topPixelOffset
+	    || dInfoPtr->topLineNo != topLineNo
+	    || dInfoPtr->topByteIndex != topByteIndex) {
+	DisplayTextWhenIdle(textPtr);
+	dInfoPtr->flags |= DINFO_OUT_OF_DATE|REPICK_NEEDED;
+	dInfoPtr->topLineNo = topLineNo;
+	dInfoPtr->topByteIndex = topByteIndex;
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * FindDisplayLineOffset --
+ *
+ *	Given a line pointer to a logical line, and a distance in
+ *	pixels, find the byte offset of the corresponding display
+ *	line. If only one display line belongs to the given logical
+ *	line, then the offset is always zero.
+ *
+ * Results:
+ *	Returns the offset to the display line at specified pixel
+ *	position, relative to the given logical line. 'distance'
+ *	will be set to the vertical distance in pixels measured
+ *	from the top pixel in specified display line (this means,
+ *	that all the display lines pixels between the top of the
+ *	logical line and the corresponding display line will be
+ *	subtracted).
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static const TkTextDispLineEntry *
+SearchPixelEntry(
+    const TkTextDispLineEntry *first,
+    const TkTextDispLineEntry *last,
+    unsigned pixels)
+{
+    assert(first != last);
+
+    if ((last - 1)->pixels < pixels) {
+	return last - 1; /* catch a frequent case */
+    }
+
+    do {
+	const TkTextDispLineEntry *mid = first + (last - first)/2;
+
+	if (mid->pixels <= pixels) {
+	    first = mid + 1;
+	} else {
+	    last = mid;
+	}
+    } while (first != last);
+
+    return first;
+}
+
+static unsigned
+FindDisplayLineOffset(
+    TkText *textPtr,
+    TkTextLine *linePtr,
+    int32_t *distance)	/* IN:  distance in pixels to logical line
+    			 * OUT: distance in pixels of specified display line. */
+{
+    const TkTextPixelInfo *pixelInfo = TkBTreeLinePixelInfo(textPtr, linePtr);
+    const TkTextDispLineInfo *dispLineInfo = pixelInfo->dispLineInfo;
+    const TkTextDispLineEntry *lastEntry;
+    const TkTextDispLineEntry *entry;
+
+    assert(distance);
+    assert(*distance >= 0);
+    assert(linePtr->logicalLine);
+
+    if (!dispLineInfo) {
+	return 0;
+    }
+
+    lastEntry = dispLineInfo->entry + dispLineInfo->numDispLines;
+    entry = SearchPixelEntry(dispLineInfo->entry, lastEntry, *distance);
+    assert(entry != lastEntry);
+    if (entry == dispLineInfo->entry) {
+	return 0;
+    }
+
+    *distance -= (entry - 1)->pixels;
+    return entry->byteOffset;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MeasureDown --
+ *
+ *	Given one index, find the index of the first character on the highest
+ *	display line that would be displayed no more than "distance" pixels
+ *	below the top of the given index.
+ *
+ * Results:
+ *	The srcPtr is manipulated in place to reflect the new position. We
+ *	return the number of pixels by which 'distance' overlaps the srcPtr
+ *	in 'overlap'. The return valus is 'false' if we are already at top
+ *	of view, otherwise the return valus is 'true'.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+AlreadyAtBottom(
+    const TkText *textPtr)
+{
+    const TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    DLine *dlPtr = dInfoPtr->lastDLinePtr;
+    TkTextIndex index;
+
+    if (!dlPtr) {
+	return true;
+    }
+    if (dlPtr->y + dlPtr->height != dInfoPtr->maxY) {
+	return false;
+    }
+
+    index = dlPtr->index;
+    TkTextIndexForwBytes(textPtr, &index, dlPtr->byteCount, &index);
+    return TkTextIndexIsEndOfText(&index);
+}
+
+static bool
+MeasureDown(
+    TkText *textPtr,		/* Text widget in which to measure. */
+    TkTextIndex *srcPtr,	/* Index of character from which to start measuring. */
+    int distance,		/* Vertical distance in pixels measured from the top pixel in
+    				 * srcPtr's logical line. */
+    int32_t *overlap,		/* The number of pixels by which 'distance' overlaps the srcPtr. */
+    bool saveDisplayLines)	/* Save produced display line for re-use in UpdateDisplayInfo? */
+{
+    const TkTextLine *lastLinePtr;
+    TkTextLine *linePtr;
+    TkTextIndex index;
+    int byteOffset;
+    int32_t myOverlap;
+
+    if (AlreadyAtBottom(textPtr)) {
+	return false;
+    }
+
+    if (!overlap) {
+	overlap = &myOverlap;
+    }
+
+    linePtr = TkTextIndexGetLine(srcPtr);
+    lastLinePtr = TkBTreeGetLastLine(textPtr);
+
+    if (TkRangeListIsEmpty(textPtr->dInfoPtr->lineMetricUpdateRanges)) {
+	int pixelHeight;
+
+	/*
+	 * No display line metric calculation is pending, this is fine,
+	 * now we can use the B-Tree for the measurement.
+	 *
+	 * Note that TkBTreePixelsTo is measuring up to the logical line.
+	 */
+
+	pixelHeight = TkBTreePixelsTo(textPtr, linePtr);
+	pixelHeight += GetPixelsTo(textPtr, srcPtr, false, NULL);
+	pixelHeight += distance;
+	linePtr = TkBTreeFindPixelLine(srcPtr->tree, textPtr, pixelHeight, overlap);
+
+	if (linePtr == lastLinePtr) {
+	    TkTextLine *prevLinePtr = TkBTreePrevLine(textPtr, linePtr);
+	    if (prevLinePtr) {
+		linePtr = prevLinePtr;
+	    }
+	}
+
+	/*
+	 * We have the logical line, and the overlap, now search for the display line.
+	 */
+
+	byteOffset = FindDisplayLineOffset(textPtr, linePtr, overlap);
+    } else {
+	DisplayInfo info;
+
+	/*
+	 * Search down line by line until we'e found the bottom line for given distance.
+	 */
+
+	linePtr = ComputeDisplayLineInfo(textPtr, srcPtr, &info);
+	distance += GetPixelsTo(textPtr, srcPtr, false, &info);
+	index = *srcPtr;
+
+	while (true) {
+	    ComputeMissingMetric(textPtr, &info, THRESHOLD_PIXEL_DISTANCE, distance);
+	    if (saveDisplayLines) {
+		SaveDisplayLines(textPtr, &info, true);
+	    } else {
+		FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+	    }
+
+	    if (distance < info.pixels) {
+		const TkTextDispLineInfo *dispLineInfo = info.pixelInfo->dispLineInfo;
+
+		if (dispLineInfo) {
+		    const TkTextDispLineEntry *entry, *last;
+
+		    last = dispLineInfo->entry + dispLineInfo->numDispLines;
+		    entry = SearchPixelEntry(dispLineInfo->entry, last, distance);
+		    assert(entry < last);
+		    byteOffset = entry->byteOffset;
+		    if (entry != dispLineInfo->entry) {
+			distance -= (entry - 1)->pixels;
+		    }
+		} else {
+		    byteOffset = 0;
+		}
+		break;
+	    }
+
+	    if (TkTextIndexGetLine(&info.index) == lastLinePtr) {
+		byteOffset = 0;
+		break;
+	    }
+	    linePtr = TkTextIndexGetLine(&info.index);
+	    if ((distance -= info.pixels) == 0) {
+		byteOffset = 0;
+		break;
+	    }
+	    TkTextIndexSetToStartOfLine2(&index, linePtr);
+	    linePtr = ComputeDisplayLineInfo(textPtr, &index, &info);
+	}
+
+	*overlap = distance;
+    }
+
+    assert(linePtr != lastLinePtr);
+
+    TkTextIndexSetToStartOfLine2(srcPtr, linePtr);
+    TkTextIndexForwBytes(textPtr, srcPtr, byteOffset, srcPtr);
+
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MeasureUp --
+ *
+ *	Given one index, find the index of the first character on the highest
+ *	display line that would be displayed no more than "distance" pixels
+ *	above the given index.
+ *
+ *	If this function is called with distance=0, it simply finds the first
+ *	index on the same display line as srcPtr. However, there is a another
+ *	function TkTextFindDisplayLineStartEnd designed just for that task
+ *	which is probably better to use.
+ *
+ * Results:
+ *	*dstPtr is filled in with the index of the first character on a
+ *	display line. The display line is found by measuring up "distance"
+ *	pixels above the pixel just below an imaginary display line that
+ *	contains srcPtr. If the display line that covers this coordinate
+ *	actually extends above the coordinate, then return any excess pixels
+ *	in *overlap. The return valus is 'false' if we are already at top
+ *	of view, otherwise the return valus is 'false'.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+AlreadyAtTop(
+    const TkText *textPtr)
+{
+    const TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+    if (!dInfoPtr->dLinePtr) {
+	return true;
+    }
+    return dInfoPtr->topPixelOffset == 0 && TkTextIndexIsStartOfText(&dInfoPtr->dLinePtr->index);
+}
+
+static bool
+MeasureUp(
+    TkText *textPtr,		/* Text widget in which to measure. */
+    const TkTextIndex *srcPtr,	/* Index of character from which to start measuring. */
+    int distance,		/* Vertical distance in pixels measured from the pixel just below
+    				 * the lowest one in srcPtr's line. */
+    TkTextIndex *dstPtr,	/* Index to fill in with result. */
+    int32_t *overlap)		/* Used to store how much of the final index returned was not covered
+    				 * by 'distance'. */
+{
+    TkTextLine *linePtr;
+    TkTextLine *startLinePtr;
+    unsigned byteOffset;
+
+    assert(overlap);
+    assert(dstPtr);
+
+    if (TkTextIndexIsStartOfText(srcPtr) && AlreadyAtTop(textPtr)) {
+	return false;
+    }
+
+    *dstPtr = *srcPtr;
+    startLinePtr = TkBTreeGetStartLine(textPtr);
+    linePtr = TkTextIndexGetLine(srcPtr);
+
+    if (TestIfLinesUpToDate(srcPtr)) {
+	int pixelHeight;
+
+	/*
+	 * No display line height calculation is pending (not in required range),
+	 * this is fine, now we can use the B-Tree for the measurement.
+	 *
+	 * Note that TkBTreePixelsTo is measuring up to the logical line.
+	 */
+
+	pixelHeight  = TkBTreePixelsTo(textPtr, linePtr);
+	pixelHeight += GetPixelsTo(textPtr, srcPtr, true, NULL);
+	pixelHeight -= distance;
+
+	if (pixelHeight <= 0) {
+	    linePtr = startLinePtr;
+	    byteOffset = *overlap = 0;
+	} else {
+	    linePtr = TkBTreeFindPixelLine(srcPtr->tree, textPtr, pixelHeight, overlap);
+	    byteOffset = FindDisplayLineOffset(textPtr, linePtr, overlap);
+	}
+    } else {
+	DisplayInfo info;
+
+	/*
+	 * Search up line by line until we have found the start line for given distance.
+	 */
+
+	linePtr = ComputeDisplayLineInfo(textPtr, srcPtr, &info);
+	SaveDisplayLines(textPtr, &info, false);
+	distance -= GetPixelsTo(textPtr, srcPtr, true, &info);
+
+	while (linePtr != startLinePtr && distance > 0) {
+	    TkTextIndexSetToLastChar2(dstPtr, linePtr->prevPtr);
+	    linePtr = ComputeDisplayLineInfo(textPtr, dstPtr, &info);
+	    SaveDisplayLines(textPtr, &info, false);
+	    distance -= info.pixels;
+	}
+
+	if (distance < 0) {
+	    *overlap = -distance;
+	    byteOffset = FindDisplayLineOffset(textPtr, linePtr, overlap);
+	} else {
+	    byteOffset = *overlap = 0;
+	}
+    }
+
+    TkTextIndexSetToStartOfLine2(dstPtr, linePtr);
+    TkTextIndexForwBytes(textPtr, dstPtr, byteOffset, dstPtr);
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextSeeCmd --
+ *
+ *	This function is invoked to process the "see" option for the widget
+ *	command for text widgets. See the user documentation for details on
+ *	what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+int
+TkTextSeeCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already parsed this command
+    				 * enough to know that objv[1] is "see". */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    TkTextIndex index;
+    int x, y, width, height, lineWidth, byteCount, oneThird, delta;
+    DLine *dlPtr;
+    TkTextDispChunk *chunkPtr;
+
+    if (objc != 3) {
+	Tcl_WrongNumArgs(interp, 2, objv, "index");
+	return TCL_ERROR;
+    }
+    if (!TkTextGetIndexFromObj(interp, textPtr, objv[2], &index)) {
+	return TCL_ERROR;
+    }
+    if (TkTextIsDeadPeer(textPtr)) {
+	return TCL_OK;
+    }
+
+    /*
+     * If the specified position is the extra line at the end of the text,
+     * round it back to the last real line.
+     */
+
+    if (TkTextIndexGetLine(&index) == TkBTreeGetLastLine(textPtr)) {
+	TkTextIndexSetToLastChar2(&index, TkTextIndexGetLine(&index)->prevPtr);
+    }
+
+    /*
+     * First get the desired position into the vertical range of the window.
+     */
+
+    TkTextSetYView(textPtr, &index, TK_TEXT_PICKPLACE);
+
+    /*
+     * Now make sure that the character is in view horizontally.
+     */
+
+    if (dInfoPtr->flags & DINFO_OUT_OF_DATE) {
+	UpdateDisplayInfo(textPtr);
+    }
+    lineWidth = dInfoPtr->maxX - dInfoPtr->x;
+    if (dInfoPtr->maxLength < lineWidth) {
+	return TCL_OK;
+    }
+
+    /*
+     * Take into account that the desired index is past the visible text.
+     * It's also possible that the widget is not yet mapped.
+     */
+
+    if (!(dlPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, &index))) {
+	return TCL_OK;
+    }
+
+    /*
+     * Find the chunk within the display line that contains the desired
+     * index. The chunks making the display line are skipped up to but not
+     * including the one crossing index. Skipping is done based on a
+     * byteCount offset possibly spanning several logical lines in case
+     * they are elided.
+     */
+
+    byteCount = TkTextIndexCountBytes(&dlPtr->index, &index);
+    for (chunkPtr = dlPtr->chunkPtr;
+	    chunkPtr && byteCount >= chunkPtr->numBytes;
+	    chunkPtr = chunkPtr->nextPtr) {
+	byteCount -= chunkPtr->numBytes;
+    }
+
+    /*
+     * Call a chunk-specific function to find the horizontal range of the
+     * character within the chunk. chunkPtr is NULL if trying to see in elided
+     * region.
+     */
+
+    if (chunkPtr) {
+        chunkPtr->layoutProcs->bboxProc(
+		textPtr, chunkPtr, byteCount,
+                dlPtr->y + dlPtr->spaceAbove,
+                dlPtr->height - dlPtr->spaceAbove - dlPtr->spaceBelow,
+                dlPtr->baseline - dlPtr->spaceAbove,
+		&x, &y, &width, &height);
+        delta = x - dInfoPtr->curXPixelOffset;
+        oneThird = lineWidth/3;
+        if (delta < 0) {
+            if (delta < -oneThird) {
+                dInfoPtr->newXPixelOffset = x - lineWidth/2;
+            } else {
+                dInfoPtr->newXPixelOffset += delta;
+            }
+        } else {
+            delta -= lineWidth - width;
+            if (delta <= 0) {
+                return TCL_OK;
+            }
+            if (delta > oneThird) {
+                dInfoPtr->newXPixelOffset = x - lineWidth/2;
+            } else {
+                dInfoPtr->newXPixelOffset += delta;
+            }
+        }
+    }
+    dInfoPtr->flags |= DINFO_OUT_OF_DATE;
+    DisplayTextWhenIdle(textPtr);
+    return TCL_OK;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextXviewCmd --
+ *
+ *	This function is invoked to process the "xview" option for the widget
+ *	command for text widgets. See the user documentation for details on
+ *	what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+int
+TkTextXviewCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already parsed this command
+    				 * enough to know that objv[1] is "xview". */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    int count;
+    double fraction;
+
+    if (dInfoPtr->flags & DINFO_OUT_OF_DATE) {
+	UpdateDisplayInfo(textPtr);
+    }
+
+    if (objc == 2) {
+	GetXView(interp, textPtr, false);
+	return TCL_OK;
+    }
+
+    switch (TextGetScrollInfoObj(interp, textPtr, objc, objv, &fraction, &count)) {
+    case SCROLL_ERROR:
+	return TCL_ERROR;
+    case SCROLL_MOVETO:
+	dInfoPtr->newXPixelOffset = (int) (MIN(1.0, MAX(0.0, fraction))*dInfoPtr->maxLength + 0.5);
+	break;
+    case SCROLL_PAGES: {
+	int pixelsPerPage;
+
+	pixelsPerPage = dInfoPtr->maxX - dInfoPtr->x - 2*textPtr->charWidth;
+	dInfoPtr->newXPixelOffset += count*MAX(1, pixelsPerPage);
+	break;
+    }
+    case SCROLL_UNITS:
+	dInfoPtr->newXPixelOffset += count*textPtr->charWidth;
+	break;
+    case SCROLL_PIXELS:
+	dInfoPtr->newXPixelOffset += count;
+	break;
+    }
+
+    dInfoPtr->flags |= DINFO_OUT_OF_DATE;
+    DisplayTextWhenIdle(textPtr);
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * YScrollByPixels --
+ *
+ *	This function is called to scroll a text widget up or down by a given
+ *	number of pixels.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The view in textPtr's window changes to reflect the value of "offset".
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+YScrollByPixels(
+    TkText *textPtr,	/* Widget to scroll. */
+    int offset)		/* Amount by which to scroll, in pixels. Positive means that
+    			 * information later in text becomes visible, negative means
+			 * that information earlier in the text becomes visible. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+    if (offset < 0) {
+	/*
+	 * Now we want to measure up this number of pixels from the top of the
+	 * screen. But the top line may not be totally visible.
+	 */
+
+	offset -= CalculateDisplayLineHeight(textPtr, &textPtr->topIndex, NULL);
+	offset += dInfoPtr->topPixelOffset;
+
+	if (!MeasureUp(textPtr, &textPtr->topIndex, -offset,
+		&textPtr->topIndex, &dInfoPtr->newTopPixelOffset)) {
+	    return; /* already at top, we cannot scroll */
+	}
+    } else if (offset > 0) {
+	/*
+	 * Scrolling down by pixels. Layout lines starting at the top index
+	 * and count through the desired vertical distance.
+	 */
+
+	offset += dInfoPtr->topPixelOffset;
+	if (!MeasureDown(textPtr, &textPtr->topIndex, offset, &dInfoPtr->newTopPixelOffset, true)) {
+	    return; /* already at end, we cannot scroll */
+	}
+	TkTextIndexToByteIndex(&textPtr->topIndex);
+    } else {
+	/*
+	 * offset = 0, so no scrolling required.
+	 */
+	return;
+    }
+
+    assert(TkTextIndexIsEndOfText(&textPtr->topIndex) ?
+	dInfoPtr->newTopPixelOffset == 0 :
+	dInfoPtr->newTopPixelOffset < CalculateDisplayLineHeight(textPtr, &textPtr->topIndex, NULL));
+
+    DisplayTextWhenIdle(textPtr);
+    dInfoPtr->flags |= DINFO_OUT_OF_DATE|REPICK_NEEDED;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * YScrollByLines --
+ *
+ *	This function is called to scroll a text widget up or down by a given
+ *	number of lines.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The view in textPtr's window changes to reflect the value of "offset".
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+ScrollUp(
+    TkText *textPtr,	/* Widget to scroll. */
+    unsigned offset)	/* Amount by which to scroll, in display lines. */
+{
+    TkTextLine *linePtr;
+    unsigned byteOffset;
+    DisplayInfo info;
+    bool upToDate;
+
+    assert(offset > 0);
+
+    /*
+     * Scrolling up, to show earlier information in the text.
+     */
+
+    if (AlreadyAtTop(textPtr)) {
+	return false;
+    }
+
+    if (TkTextIndexIsStartOfText(&textPtr->dInfoPtr->dLinePtr->index)) {
+	textPtr->dInfoPtr->newTopPixelOffset = 0;
+	return true;
+    }
+
+    upToDate = TestIfLinesUpToDate(&textPtr->topIndex);
+    linePtr = ComputeDisplayLineInfo(textPtr, &textPtr->topIndex, &info);
+
+    if (upToDate) {
+	const TkTextDispLineInfo *dispLineInfo;
+
+	assert(!info.dLinePtr);
+
+	/*
+	 * The display line information is complete for the required range, so
+	 * use it for finding the requested display line.
+	 */
+
+	linePtr = TkBTreePrevDisplayLine(textPtr, linePtr, &info.displayLineNo, offset);
+	dispLineInfo = TkBTreeLinePixelInfo(textPtr, linePtr)->dispLineInfo;
+	byteOffset = dispLineInfo ? dispLineInfo->entry[info.displayLineNo].byteOffset : 0;
+    } else {
+	TkTextLine *firstLinePtr;
+	TkTextIndex index;
+
+	/*
+	 * The display line information is incomplete, so we do a search line by line.
+	 * The computed display lines will be saved for displaying.
+	 */
+
+	firstLinePtr = TkBTreeGetStartLine(textPtr);
+	index = textPtr->topIndex;
+	SaveDisplayLines(textPtr, &info, false);
+	info.numDispLines = info.displayLineNo + 1;
+
+	while (true) {
+	    if (info.numDispLines > offset) {
+		byteOffset = (info.entry - offset)->byteOffset;
+		break;
+	    }
+	    offset -= info.numDispLines;
+	    if (linePtr == firstLinePtr) {
+		byteOffset = 0;
+		break;
+	    }
+	    TkTextIndexSetToLastChar2(&index, linePtr->prevPtr);
+	    linePtr = ComputeDisplayLineInfo(textPtr, &index, &info);
+	    SaveDisplayLines(textPtr, &info, false);
+	    assert(!TkBTreeLinePixelInfo(textPtr, linePtr)->dispLineInfo
+		    || info.entry == TkBTreeLinePixelInfo(textPtr, linePtr)->dispLineInfo->entry +
+			    info.numDispLines - 1);
+	}
+    }
+
+    TkTextIndexSetToStartOfLine2(&textPtr->topIndex, linePtr);
+    TkTextIndexForwBytes(textPtr, &textPtr->topIndex, byteOffset, &textPtr->topIndex);
+
+    return true;
+}
+
+static bool
+ScrollDown(
+    TkText *textPtr,	/* Widget to scroll. */
+    unsigned offset)	/* Amount by which to scroll, in display lines. */
+{
+    TkTextLine *linePtr;
+    unsigned byteOffset;
+    DisplayInfo info;
+    bool upToDate;
+
+    assert(offset > 0);
+
+    /*
+     * Scrolling down, to show later information in the text.
+     */
+
+    if (AlreadyAtBottom(textPtr)) {
+	return false;
+    }
+
+    upToDate = TkRangeListIsEmpty(textPtr->dInfoPtr->lineMetricUpdateRanges);
+    linePtr = ComputeDisplayLineInfo(textPtr, &textPtr->topIndex, &info);
+
+    if (upToDate) {
+	const TkTextDispLineInfo *dispLineInfo;
+
+	assert(!info.dLinePtr);
+
+	/*
+	 * The display line information is complete for the required range, so
+	 * use it for finding the requested display line.
+	 */
+
+	linePtr = TkBTreeNextDisplayLine(textPtr, linePtr, &info.displayLineNo, offset);
+	dispLineInfo = TkBTreeLinePixelInfo(textPtr, linePtr)->dispLineInfo;
+	byteOffset = dispLineInfo ? dispLineInfo->entry[info.displayLineNo].byteOffset : 0;
+    } else {
+	TkTextLine *lastLinePtr;
+
+	/*
+	 * The display line information is incomplete, so we do a search line by line.
+	 * The computed display lines will be saved for displaying.
+	 */
+
+	lastLinePtr = TkBTreeGetLastLine(textPtr);
+	ComputeMissingMetric(textPtr, &info, THRESHOLD_LINE_OFFSET, offset);
+	SaveDisplayLines(textPtr, &info, true);
+	info.numDispLines -= info.displayLineNo;
+
+	while (true) {
+	    if (info.numDispLines == offset) {
+		byteOffset = 0;
+		linePtr = linePtr->nextPtr;
+		break;
+	    }
+	    if (info.numDispLines > offset) {
+		byteOffset = (info.entry + offset)->byteOffset;
+		break;
+	    }
+	    offset -= info.numDispLines;
+	    if (TkTextIndexGetLine(&info.index) == lastLinePtr) {
+		byteOffset = (info.entry + info.numDispLines - 1)->byteOffset;
+		break;
+	    }
+	    linePtr = ComputeDisplayLineInfo(textPtr, &info.index, &info);
+	    ComputeMissingMetric(textPtr, &info, THRESHOLD_LINE_OFFSET, offset);
+	    SaveDisplayLines(textPtr, &info, true);
+	}
+    }
+
+    TkTextIndexSetToStartOfLine2(&textPtr->topIndex, linePtr);
+    TkTextIndexForwBytes(textPtr, &textPtr->topIndex, byteOffset, &textPtr->topIndex);
+    return true;
+}
+
+static void
+YScrollByLines(
+    TkText *textPtr,	/* Widget to scroll. */
+    int offset)		/* Amount by which to scroll, in display lines. Positive means
+    			 * that information later in text becomes visible, negative
+			 * means that information earlier in the text becomes visible. */
+{
+    assert(textPtr);
+
+    if (offset < 0) {
+	if (!ScrollUp(textPtr, -offset)) {
+	    return;
+	}
+    } else if (offset > 0) {
+	if (!ScrollDown(textPtr, offset)) {
+	    return;
+	}
+    } else {
+	return;
+    }
+
+    DisplayTextWhenIdle(textPtr);
+    textPtr->dInfoPtr->flags |= DINFO_OUT_OF_DATE|REPICK_NEEDED;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextYviewCmd --
+ *
+ *	This function is invoked to process the "yview" option for the widget
+ *	command for text widgets. See the user documentation for details on
+ *	what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+MakePixelIndex(
+    TkText *textPtr,		/* The text widget. */
+    unsigned pixelIndex,	/* Pixel-index of desired line (0 means first pixel of first
+    				 * line of text). */
+    TkTextIndex *indexPtr)	/* Structure to fill in. */
+{
+    TkTextLine *linePtr;
+    TkTextLine *lastLinePtr;
+    int32_t pixelOffset;
+
+    assert(!TkTextIsDeadPeer(textPtr));
+
+    TkTextIndexClear(indexPtr, textPtr);
+    linePtr = TkBTreeFindPixelLine(textPtr->sharedTextPtr->tree, textPtr, pixelIndex, &pixelOffset);
+    lastLinePtr = TkBTreeGetLastLine(textPtr);
+
+    if (linePtr != lastLinePtr) {
+	int byteOffset = FindDisplayLineOffset(textPtr, linePtr, &pixelOffset);
+	TkTextIndexSetByteIndex2(indexPtr, linePtr, byteOffset);
+    } else {
+	assert(lastLinePtr->prevPtr); /* MakePixelIndex will not be called if peer is empty */
+	linePtr = TkBTreeGetLogicalLine(textPtr->sharedTextPtr, textPtr, linePtr->prevPtr);
+	TkTextIndexSetToLastChar2(indexPtr, linePtr);
+	FindDisplayLineStartEnd(textPtr, indexPtr, DISP_LINE_START, DLINE_CACHE);
+	pixelOffset = CalculateDisplayLineHeight(textPtr, indexPtr, NULL) - 1;
+    }
+
+    return MAX(0, pixelOffset);
+}
+
+static void
+Repick(
+    ClientData clientData)	/* Information about widget. */
+{
+    TkText *textPtr = (TkText *) clientData;
+
+    if (!TkTextReleaseIfDestroyed(textPtr)) {
+	textPtr->dInfoPtr->flags &= ~REPICK_NEEDED;
+	textPtr->dInfoPtr->currChunkPtr = NULL;
+	textPtr->dInfoPtr->repickTimer = NULL;
+	textPtr->dontRepick = false;
+	TkTextPickCurrent(textPtr, &textPtr->pickEvent);
+    }
+}
+
+static void
+DelayRepick(
+    TkText *textPtr)
+{
+    assert(textPtr->dInfoPtr->flags & REPICK_NEEDED);
+
+    if (textPtr->responsiveness > 0) {
+	TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+	if (dInfoPtr->repickTimer) {
+	    Tcl_DeleteTimerHandler(dInfoPtr->repickTimer);
+	} else {
+	    textPtr->refCount += 1;
+	}
+	textPtr->dontRepick = true;
+	dInfoPtr->flags &= ~REPICK_NEEDED;
+	dInfoPtr->repickTimer = Tcl_CreateTimerHandler(textPtr->responsiveness, Repick, textPtr);
+    }
+}
+
+int
+TkTextYviewCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already parsed this command
+    				 * enough to know that objv[1] is "yview". */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    int pickPlace;
+    int pixels, count;
+    int switchLength;
+    double fraction;
+    TkTextIndex index;
+
+    if (dInfoPtr->flags & DINFO_OUT_OF_DATE) {
+	UpdateDisplayInfo(textPtr);
+    }
+
+    if (objc == 2) {
+	GetYView(interp, textPtr, false);
+	return TCL_OK;
+    }
+
+    /*
+     * Next, handle the old syntax: "pathName yview ?-pickplace? where"
+     */
+
+    pickPlace = 0;
+    if (Tcl_GetString(objv[2])[0] == '-') {
+	const char *switchStr = Tcl_GetStringFromObj(objv[2], &switchLength);
+
+	if (switchLength >= 2 && strncmp(switchStr, "-pickplace", switchLength) == 0) {
+	    pickPlace = 1;
+	    if (objc != 4) {
+		Tcl_WrongNumArgs(interp, 3, objv, "lineNum|index");
+		return TCL_ERROR;
+	    }
+	}
+    }
+
+    if (objc == 3 || pickPlace) {
+	int lineNum;
+
+	if (Tcl_GetIntFromObj(interp, objv[2 + pickPlace], &lineNum) == TCL_OK) {
+	    TkTextMakeByteIndex(textPtr->sharedTextPtr->tree, textPtr, lineNum, 0, &index);
+	    TkTextSetYView(textPtr, &index, 0);
+	} else {
+	    /*
+	     * The argument must be a regular text index.
+	     */
+
+	    Tcl_ResetResult(interp);
+	    if (!TkTextGetIndexFromObj(interp, textPtr, objv[2 + pickPlace], &index)) {
+		return TCL_ERROR;
+	    }
+	    TkTextSetYView(textPtr, &index, pickPlace ? TK_TEXT_PICKPLACE : 0);
+	}
+    } else {
+	/*
+	 * New syntax: dispatch based on objv[2].
+	 */
+
+	switch (TextGetScrollInfoObj(interp, textPtr, objc, objv, &fraction, &count)) {
+	case SCROLL_ERROR:
+	    return TCL_ERROR;
+	case SCROLL_MOVETO: {
+	    int numPixels = TkBTreeNumPixels(textPtr);
+	    int topMostPixel;
+
+	    if (numPixels == 0 || TkTextIsDeadPeer(textPtr)) {
+		/*
+		 * If the window is totally empty no scrolling is needed, and the
+		 * MakePixelIndex call below will fail.
+		 */
+		break;
+	    }
+	    if (fraction > 1.0) {
+		fraction = 1.0;
+	    } else if (fraction < 0.0) {
+		fraction = 0.0;
+	    }
+
+	    /*
+	     * Calculate the pixel count for the new topmost pixel in the topmost
+	     * line of the window. Note that the interpretation of 'fraction' is
+	     * that it counts from 0 (top pixel in buffer) to 1.0 (one pixel past
+	     * the last pixel in buffer).
+	     */
+
+	    topMostPixel = MAX(0, MIN((int) (fraction*numPixels + 0.5), numPixels - 1));
+
+	    /*
+	     * This function returns the number of pixels by which the given line
+	     * should overlap the top of the visible screen.
+	     *
+	     * This is then used to provide smooth scrolling.
+	     */
+
+	    pixels = MakePixelIndex(textPtr, topMostPixel, &index);
+	    TkTextSetYView(textPtr, &index, pixels);
+	    break;
+	}
+	case SCROLL_PAGES: {
+	    /*
+	     * Scroll up or down by screenfuls. Actually, use the window height
+	     * minus two lines, so that there's some overlap between adjacent
+	     * pages.
+	     */
+
+	    int height = dInfoPtr->maxY - dInfoPtr->y;
+
+	    if (textPtr->lineHeight*4 >= height) {
+		/*
+		 * A single line is more than a quarter of the display. We choose
+		 * to scroll by 3/4 of the height instead.
+		 */
+
+		pixels = 3*height/4;
+		if (pixels < textPtr->lineHeight) {
+		    /*
+		     * But, if 3/4 of the height is actually less than a single
+		     * typical character height, then scroll by the minimum of the
+		     * linespace or the total height.
+		     */
+
+		    if (textPtr->lineHeight < height) {
+			pixels = textPtr->lineHeight;
+		    } else {
+			pixels = height;
+		    }
+		}
+		pixels *= count;
+	    } else {
+		pixels = (height - 2*textPtr->lineHeight)*count;
+	    }
+	    YScrollByPixels(textPtr, pixels);
+	    break;
+	}
+	case SCROLL_PIXELS:
+	    YScrollByPixels(textPtr, count);
+	    break;
+	case SCROLL_UNITS:
+	    YScrollByLines(textPtr, count);
+	    break;
+	}
+    }
+
+    if (dInfoPtr->flags & REPICK_NEEDED) {
+	DelayRepick(textPtr);
+    }
+    return TCL_OK;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextScanCmd --
+ *
+ *	This function is invoked to process the "scan" option for the widget
+ *	command for text widgets. See the user documentation for details on
+ *	what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+int
+TkTextScanCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already parsed this command
+    				 * enough to know that objv[1] is "scan". */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    TkTextIndex index;
+    int c, x, y, totalScroll, gain=10;
+    size_t length;
+
+    if (objc != 5 && objc != 6) {
+	Tcl_WrongNumArgs(interp, 2, objv, "mark x y");
+	Tcl_AppendResult(interp, " or \"", Tcl_GetString(objv[0]), " scan dragto x y ?gain?\"", NULL);
+	/*
+	 * Ought to be: Tcl_WrongNumArgs(interp, 2, objc, "dragto x y ?gain?");
+	 */
+	return TCL_ERROR;
+    }
+    if (Tcl_GetIntFromObj(interp, objv[3], &x) != TCL_OK) {
+	return TCL_ERROR;
+    }
+    if (Tcl_GetIntFromObj(interp, objv[4], &y) != TCL_OK) {
+	return TCL_ERROR;
+    }
+    if (objc == 6 && Tcl_GetIntFromObj(interp, objv[5], &gain) != TCL_OK) {
+	return TCL_ERROR;
+    }
+    c = Tcl_GetString(objv[2])[0];
+    length = strlen(Tcl_GetString(objv[2]));
+    if (c == 'd' && strncmp(Tcl_GetString(objv[2]), "dragto", length) == 0) {
+	int newX, maxX;
+
+	/*
+	 * Amplify the difference between the current position and the mark
+	 * position to compute how much the view should shift, then update the
+	 * mark position to correspond to the new view. If we run off the edge
+	 * of the text, reset the mark point so that the current position
+	 * continues to correspond to the edge of the window. This means that
+	 * the picture will start dragging as soon as the mouse reverses
+	 * direction (without this reset, might have to slide mouse a long
+	 * ways back before the picture starts moving again).
+	 */
+
+	newX = dInfoPtr->scanMarkXPixel + gain*(dInfoPtr->scanMarkX - x);
+	maxX = 1 + dInfoPtr->maxLength - (dInfoPtr->maxX - dInfoPtr->x);
+	if (newX < 0) {
+	    newX = 0;
+	    dInfoPtr->scanMarkXPixel = 0;
+	    dInfoPtr->scanMarkX = x;
+	} else if (newX > maxX) {
+	    newX = maxX;
+	    dInfoPtr->scanMarkXPixel = maxX;
+	    dInfoPtr->scanMarkX = x;
+	}
+	dInfoPtr->newXPixelOffset = newX;
+
+	totalScroll = gain*(dInfoPtr->scanMarkY - y);
+	if (totalScroll != dInfoPtr->scanTotalYScroll) {
+	    index = textPtr->topIndex;
+	    YScrollByPixels(textPtr, totalScroll - dInfoPtr->scanTotalYScroll);
+	    dInfoPtr->scanTotalYScroll = totalScroll;
+	    if (TkTextIndexIsEqual(&index, &textPtr->topIndex)) {
+		dInfoPtr->scanTotalYScroll = 0;
+		dInfoPtr->scanMarkY = y;
+	    }
+	}
+	dInfoPtr->flags |= DINFO_OUT_OF_DATE;
+	DisplayTextWhenIdle(textPtr);
+    } else if (c == 'm' && strncmp(Tcl_GetString(objv[2]), "mark", length) == 0) {
+	dInfoPtr->scanMarkXPixel = dInfoPtr->newXPixelOffset;
+	dInfoPtr->scanMarkX = x;
+	dInfoPtr->scanTotalYScroll = 0;
+	dInfoPtr->scanMarkY = y;
+    } else {
+	Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		"bad scan option \"%s\": must be mark or dragto", Tcl_GetString(objv[2])));
+	Tcl_SetErrorCode(interp, "TCL", "LOOKUP", "INDEX", "scan option", Tcl_GetString(objv[2]), NULL);
+	return TCL_ERROR;
+    }
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetXView --
+ *
+ *	This function computes the fractions that indicate what's visible in a
+ *	text window and, optionally, evaluates a Tcl script to report them to
+ *	the text's associated scrollbar.
+ *
+ * Results:
+ *	If report is zero, then the interp's result is filled in with two real
+ *	numbers separated by a space, giving the position of the left and
+ *	right edges of the window as fractions from 0 to 1, where 0 means the
+ *	left edge of the text and 1 means the right edge. If report is
+ *	non-zero, then the interp's result isn't modified directly, but
+ *	instead a script is evaluated in interp to report the new horizontal
+ *	scroll position to the scrollbar (if the scroll position hasn't
+ *	changed then no script is invoked).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+GetXView(
+    Tcl_Interp *interp,		/* If "report" is FALSE, string describing visible range gets stored
+    				 * in the interp's result. */
+    TkText *textPtr,		/* Information about text widget. */
+    bool report)		/* 'true' means report info to scrollbar if it has changed. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    double first, last;
+    int xMin, xMax;
+    int code;
+    Tcl_Obj *listObj;
+
+    if (dInfoPtr->maxLength > 0) {
+	first = ((double) dInfoPtr->curXPixelOffset)/dInfoPtr->maxLength;
+	last = ((double) (dInfoPtr->curXPixelOffset + dInfoPtr->maxX - dInfoPtr->x))/dInfoPtr->maxLength;
+	if (last > 1.0) {
+	    last = 1.0;
+	}
+	xMin = dInfoPtr->curXPixelOffset;
+	xMax = xMin + dInfoPtr->maxX - dInfoPtr->x;
+    } else {
+	first = 0.0;
+	last = 1.0;
+	xMin = xMax = dInfoPtr->curXPixelOffset;
+    }
+    if (!report) {
+	listObj = Tcl_NewObj();
+	Tcl_ListObjAppendElement(interp, listObj, Tcl_NewDoubleObj(first));
+	Tcl_ListObjAppendElement(interp, listObj, Tcl_NewDoubleObj(last));
+	Tcl_SetObjResult(interp, listObj);
+	return;
+    }
+    if (FP_EQUAL_SCALE(first, dInfoPtr->xScrollFirst, dInfoPtr->maxLength) &&
+	    FP_EQUAL_SCALE(last, dInfoPtr->xScrollLast, dInfoPtr->maxLength)) {
+	return;
+    }
+
+    dInfoPtr->xScrollFirst = first;
+    dInfoPtr->xScrollLast = last;
+    dInfoPtr->curPixelPos.xFirst = xMin;
+    dInfoPtr->curPixelPos.xLast = xMax;
+
+    if (textPtr->xScrollCmd) {
+	char buf1[TCL_DOUBLE_SPACE + 1];
+	char buf2[TCL_DOUBLE_SPACE + 1];
+	Tcl_DString buf;
+
+	buf1[0] = ' ';
+	buf2[0] = ' ';
+	Tcl_PrintDouble(NULL, first, buf1 + 1);
+	Tcl_PrintDouble(NULL, last, buf2 + 1);
+	Tcl_DStringInit(&buf);
+	Tcl_DStringAppend(&buf, textPtr->xScrollCmd, -1);
+	Tcl_DStringAppend(&buf, buf1, -1);
+	Tcl_DStringAppend(&buf, buf2, -1);
+	code = Tcl_EvalEx(interp, Tcl_DStringValue(&buf), -1, 0);
+	Tcl_DStringFree(&buf);
+	if (code != TCL_OK) {
+	    Tcl_AddErrorInfo(interp,
+		    "\n    (horizontal scrolling command executed by text)");
+	    Tcl_BackgroundException(interp, code);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetYPixelCount --
+ *
+ *	How many pixels are there between the absolute top of the widget and
+ *	the top of the given DLine.
+ *
+ *	While this function will work for any valid DLine, it is only ever
+ *	called when dlPtr is the first display line in the widget (by
+ *	'GetYView'). This means that usually this function is a very quick
+ *	calculation, since it can use the pre-calculated linked-list of DLines
+ *	for height information.
+ *
+ *	The only situation where this breaks down is if dlPtr's logical line
+ *	wraps enough times to fill the text widget's current view - in this
+ *	case we won't have enough dlPtrs in the linked list to be able to
+ *	subtract off what we want.
+ *
+ * Results:
+ *	The number of pixels.
+ *
+ *	This value has a valid range between '0' (the very top of the widget)
+ *	and the number of pixels in the total widget minus the pixel-height of
+ *	the last line.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static unsigned
+GetYPixelCount(
+    TkText *textPtr,	/* Information about text widget. */
+    DLine *dlPtr)	/* Information about the layout of a given index. */
+{
+    TkTextLine *linePtr;
+    DisplayInfo info;
+
+    linePtr = ComputeDisplayLineInfo(textPtr, &dlPtr->index, &info);
+    FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+    return TkBTreePixelsTo(textPtr, linePtr) + info.entry->pixels - info.entry->height;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetYView --
+ *
+ *	This function computes the fractions that indicate what's visible in a
+ *	text window and, optionally, evaluates a Tcl script to report them to
+ *	the text's associated scrollbar.
+ *
+ * Results:
+ *	If report is zero, then the interp's result is filled in with two real
+ *	numbers separated by a space, giving the position of the top and
+ *	bottom of the window as fractions from 0 to 1, where 0 means the
+ *	beginning of the text and 1 means the end. If report is non-zero, then
+ *	the interp's result isn't modified directly, but a script is evaluated
+ *	in interp to report the new scroll position to the scrollbar (if the
+ *	scroll position hasn't changed then no script is invoked).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+GetYView(
+    Tcl_Interp *interp,		/* If "report" is 'false', string describing visible range gets
+    				 * stored in the interp's result. */
+    TkText *textPtr,		/* Information about text widget. */
+    bool report)		/* 'true' means report info to scrollbar if it has changed. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    double first, last;
+    DLine *dlPtr;
+    int totalPixels, code, count;
+    int yMin, yMax;
+    Tcl_Obj *listObj;
+
+    dlPtr = dInfoPtr->dLinePtr;
+
+    if (!dlPtr) {
+	return;
+    }
+
+    totalPixels = TkBTreeNumPixels(textPtr);
+
+    if (totalPixels == 0) {
+	first = 0.0;
+	last = 1.0;
+	yMin = yMax = dInfoPtr->topPixelOffset;
+    } else {
+	/*
+	 * Get the pixel count for the first visible pixel of the first
+	 * visible line. If the first visible line is only partially visible,
+	 * then we use 'topPixelOffset' to get the difference.
+	 */
+
+	count = yMin = GetYPixelCount(textPtr, dlPtr);
+	first = (count + dInfoPtr->topPixelOffset) / (double) totalPixels;
+
+	/*
+	 * Add on the total number of visible pixels to get the count to one
+	 * pixel _past_ the last visible pixel. This is how the 'yview'
+	 * command is documented, and also explains why we are dividing by
+	 * 'totalPixels' and not 'totalPixels-1'.
+	 */
+
+	while (dlPtr) {
+	    int extra;
+
+	    count += dlPtr->height;
+	    extra = dlPtr->y + dlPtr->height - dInfoPtr->maxY;
+	    if (extra > 0) {
+		/*
+		 * This much of the last line is not visible, so don't count
+		 * these pixels. Since we've reached the bottom of the window,
+		 * we break out of the loop.
+		 */
+
+		count -= extra;
+		break;
+	    }
+	    dlPtr = dlPtr->nextPtr;
+	}
+
+	if (count > totalPixels) {
+	    /*
+	     * It can be possible, if we do not update each line's pixelHeight
+	     * cache when we lay out individual DLines that the count
+	     * generated here is more up-to-date than that maintained by the
+	     * BTree. In such a case, the best we can do here is to fix up
+	     * 'count' and continue, which might result in small, temporary
+	     * perturbations to the size of the scrollbar. This is basically
+	     * harmless, but in a perfect world we would not have this
+	     * problem.
+	     *
+	     * For debugging purposes, if anyone wishes to improve the text
+	     * widget further, the following 'panic' can be activated. In
+	     * principle it should be possible to ensure the BTree is always
+	     * at least as up to date as the display, so in the future we
+	     * might be able to leave the 'panic' in permanently when we
+	     * believe we have resolved the cache synchronisation issue.
+	     *
+	     * However, to achieve that goal would, I think, require a fairly
+	     * substantial refactorisation of the code in this file so that
+	     * there is much more obvious and explicit coordination between
+	     * calls to LayoutDLine and updating of each TkTextLine's
+	     * pixelHeight. The complicated bit is that LayoutDLine deals with
+	     * individual display lines, but pixelHeight is for a logical
+	     * line.
+	     */
+
+#if 0
+	    Tcl_Panic("Counted more pixels (%d) than expected (%d) total "
+		    "pixels in text widget scroll bar calculation.", count,
+		    totalPixels);
+#elif 0 /* TODO: still happens sometimes, why? */
+	    fprintf(stderr, "warning: Counted more pixels (%d) than expected (%d)\n",
+		    count, totalPixels);
+#endif
+
+	    count = totalPixels;
+	}
+
+	yMax = count;
+	last = ((double) count)/((double) totalPixels);
+    }
+
+    if (!report) {
+	listObj = Tcl_NewObj();
+	Tcl_ListObjAppendElement(interp, listObj, Tcl_NewDoubleObj(first));
+	Tcl_ListObjAppendElement(interp, listObj, Tcl_NewDoubleObj(last));
+	Tcl_SetObjResult(interp, listObj);
+    } else {
+	dInfoPtr->curPixelPos.yFirst = yMin + dInfoPtr->topPixelOffset;
+	dInfoPtr->curPixelPos.yLast = yMax + dInfoPtr->topPixelOffset;
+
+	if (!FP_EQUAL_SCALE(first, dInfoPtr->yScrollFirst, totalPixels) ||
+		!FP_EQUAL_SCALE(last, dInfoPtr->yScrollLast, totalPixels)) {
+	    dInfoPtr->yScrollFirst = first;
+	    dInfoPtr->yScrollLast = last;
+
+	    if (textPtr->yScrollCmd) {
+		char buf1[TCL_DOUBLE_SPACE + 1];
+		char buf2[TCL_DOUBLE_SPACE + 1];
+		Tcl_DString buf;
+
+		buf1[0] = ' ';
+		buf2[0] = ' ';
+		Tcl_PrintDouble(NULL, first, buf1 + 1);
+		Tcl_PrintDouble(NULL, last, buf2 + 1);
+		Tcl_DStringInit(&buf);
+		Tcl_DStringAppend(&buf, textPtr->yScrollCmd, -1);
+		Tcl_DStringAppend(&buf, buf1, -1);
+		Tcl_DStringAppend(&buf, buf2, -1);
+		code = Tcl_EvalEx(interp, Tcl_DStringValue(&buf), -1, 0);
+		Tcl_DStringFree(&buf);
+		if (code != TCL_OK) {
+		    Tcl_AddErrorInfo(interp,
+			    "\n    (vertical scrolling command executed by text)");
+		    Tcl_BackgroundException(interp, code);
+		}
+	    }
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * AsyncUpdateYScrollbar --
+ *
+ *	This function is called to update the vertical scrollbar asychronously
+ *	as the pixel height calculations progress for lines in the widget.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	See 'GetYView'. In particular the scrollbar position and size may be
+ *	changed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+AsyncUpdateYScrollbar(
+    ClientData clientData)	/* Information about widget. */
+{
+    TkText *textPtr = clientData;
+
+    if (!TkTextReleaseIfDestroyed(textPtr)) {
+	TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+
+	if (!dInfoPtr->insideLineMetricUpdate) {
+	    textPtr->dInfoPtr->scrollbarTimer = NULL;
+	    GetYView(textPtr->interp, textPtr, true);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FindCachedDLine --
+ *
+ *	This function is called to find the cached line for given text
+ *	index.
+ *
+ * Results:
+ *	The return value is a pointer to the cached DLine found, or NULL
+ *	if not available.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static DLine *
+FindCachedDLine(
+    TkText *textPtr,
+    const TkTextIndex *indexPtr)
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    DLine *dlPtr;
+
+    for (dlPtr = dInfoPtr->cachedDLinePtr; dlPtr; dlPtr = dlPtr->nextPtr) {
+	if (TkBTreeLinePixelInfo(textPtr, TkTextIndexGetLine(&dlPtr->index))->epoch
+		    == dInfoPtr->lineMetricUpdateEpoch
+		&& TkTextIndexCompare(indexPtr, &dlPtr->index) >= 0) {
+	    TkTextIndex index = dlPtr->index;
+
+	    TkTextIndexForwBytes(textPtr, &index, dlPtr->byteCount, &index);
+	    if (TkTextIndexCompare(indexPtr, &index) < 0) {
+		DEBUG(stats.numHits++);
+		return dlPtr;
+	    }
+	}
+    }
+
+    return NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FindDLine --
+ *
+ *	This function is called to find the DLine corresponding to a given
+ *	text index.
+ *
+ * Results:
+ *	The return value is a pointer to the first DLine found in the list
+ *	headed by dlPtr that displays information at or after the specified
+ *	position. If there is no such line in the list then NULL is returned.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static DLine *
+FindDLine(
+    TkText *textPtr,		/* Widget record for text widget. */
+    DLine *dlPtr,		/* Pointer to first in list of DLines to search. */
+    const TkTextIndex *indexPtr)/* Index of desired character. */
+{
+    DLine *lastDlPtr;
+
+    if (!dlPtr) {
+	return NULL;
+    }
+
+    if (TkTextIndexGetLineNumber(indexPtr, NULL) < TkTextIndexGetLineNumber(&dlPtr->index, NULL)) {
+	/*
+	 * The first display line is already past the desired line.
+	 */
+	return dlPtr;
+    }
+
+    /*
+     * The display line containing the desired index is such that the index
+     * of the first character of this display line is at or before the
+     * desired index, and the index of the first character of the next
+     * display line is after the desired index.
+     */
+
+    while (TkTextIndexCompare(&dlPtr->index, indexPtr) < 0) {
+        lastDlPtr = dlPtr;
+        dlPtr = dlPtr->nextPtr;
+        if (!dlPtr) {
+            TkTextIndex index2;
+            /*
+             * We're past the last display line, either because the desired
+             * index lies past the visible text, or because the desired index
+             * is on the last display line showing the last logical line.
+             */
+            index2 = lastDlPtr->index;
+            TkTextIndexForwBytes(textPtr, &index2, lastDlPtr->byteCount, &index2);
+            if (TkTextIndexCompare(&index2, indexPtr) > 0) {
+                /*
+                 * The desired index is on the last display line, hence return this display line.
+                 */
+                dlPtr = lastDlPtr;
+                break;
+            } else {
+                /*
+                 * The desired index is past the visible text. There is no display line
+		 * displaying something at the desired index, hence return NULL.
+                 */
+                return NULL;
+            }
+        }
+        if (TkTextIndexCompare(&dlPtr->index, indexPtr) > 0) {
+            /*
+             * If we're here then we would normally expect that:
+             *   lastDlPtr->index <= indexPtr < dlPtr->index
+             * i.e. we have found the searched display line being dlPtr.
+             * However it is possible that some DLines were unlinked
+             * previously, leading to a situation where going through
+             * the list of display lines skips display lines that did
+             * exist just a moment ago.
+             */
+
+	    TkTextIndex index;
+            TkTextIndexForwBytes(textPtr, &lastDlPtr->index, lastDlPtr->byteCount, &index);
+            if (TkTextIndexCompare(&index, indexPtr) > 0) {
+                /*
+                 * Confirmed: lastDlPtr->index <= indexPtr < dlPtr->index
+                 */
+                dlPtr = lastDlPtr;
+            } else {
+                /*
+                 * The last (rightmost) index shown by dlPtrPrev is still before the desired
+		 * index. This may be because there was previously a display line between
+		 * dlPtrPrev and dlPtr and this display line has been unlinked.
+                 */
+            }
+            break;
+        }
+    }
+
+    return dlPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextGetFirstXPixel --
+ *
+ *	Get first x-pixel position in current widget.
+ *
+ * Results:
+ *	Returns first x-pixel.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextGetFirstXPixel(
+    const TkText *textPtr)	/* Widget record for text widget. */
+{
+    assert(textPtr);
+    return textPtr->dInfoPtr->x;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextGetFirstYPixel --
+ *
+ *	Get first y-pixel position in current widget.
+ *
+ * Results:
+ *	Returns first y-pixel.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextGetFirstYPixel(
+    const TkText *textPtr)	/* Widget record for text widget. */
+{
+    assert(textPtr);
+    return textPtr->dInfoPtr->y;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextGetLastXPixel --
+ *
+ *	Get last x-pixel position in current widget.
+ *
+ * Results:
+ *	Returns last x-pixel.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextGetLastXPixel(
+    const TkText *textPtr)	/* Widget record for text widget. */
+{
+    assert(textPtr);
+    return textPtr->dInfoPtr->maxX - 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextGetLastYPixel --
+ *
+ *	Get last y-pixel position in current widget.
+ *
+ * Results:
+ *	Returns last y-pixel.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextGetLastYPixel(
+    const TkText *textPtr)	/* Widget record for text widget. */
+{
+    assert(textPtr);
+    return textPtr->dInfoPtr->maxY - 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextCountVisibleImages --
+ *
+ *	Return the number of visible embedded images.
+ *
+ * Results:
+ *	Returns number of visible embedded images.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkTextCountVisibleImages(
+    const TkText *textPtr)	/* Widget record for text widget. */
+{
+    assert(textPtr);
+    return textPtr->dInfoPtr->countImages;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextCountVisibleWindows --
+ *
+ *	Return the number of visible embedded windows.
+ *
+ * Results:
+ *	Returns number of visible embedded windows.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkTextCountVisibleWindows(
+    const TkText *textPtr)	/* Widget record for text widget. */
+{
+    assert(textPtr);
+    return textPtr->dInfoPtr->countWindows;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextPixelIndex --
+ *
+ *	Given an (x,y) coordinate on the screen, find the location of the
+ *	character closest to that location.
+ *
+ * Results:
+ *	The index at *indexPtr is modified to refer to the character on the
+ *	display that is closest to (x,y). It returns whether we have found
+ *	the same chunk as before, this implies that the tags belonging to
+ *	this chunk did not change.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextPixelIndex(
+    TkText *textPtr,		/* Widget record for text widget. */
+    int x, int y,		/* Pixel coordinates of point in widget's window. */
+    TkTextIndex *indexPtr,	/* This index gets filled in with the index of the character
+    				 * nearest to (x,y). */
+    bool *nearest)		/* If non-NULL then gets set to false if (x,y) is actually over the
+    				 * returned index, and true if it is just nearby (e.g. if x,y is on
+				 * the border of the widget). */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    DLine *dlPtr = NULL;
+    DLine *currDLinePtr;
+    TkTextDispChunk *currChunkPtr;
+    bool nearby = false;
+    unsigned epoch;
+
+    /*
+     * Make sure that all of the layout information about what's displayed
+     * where on the screen is up-to-date.
+     */
+
+    if (dInfoPtr->flags & DINFO_OUT_OF_DATE) {
+	UpdateDisplayInfo(textPtr);
+    }
+
+    /*
+     * If the coordinates are above the top of the window, then adjust them to
+     * refer to the upper-right corner of the window. If they're off to one
+     * side or the other, then adjust to the closest side.
+     */
+
+    if (y < dInfoPtr->y) {
+	y = dInfoPtr->y;
+	nearby = true;
+    }
+    if (x >= dInfoPtr->maxX) {
+	x = dInfoPtr->maxX - 1;
+	nearby = true;
+    }
+    if (x < dInfoPtr->x) {
+	x = dInfoPtr->x;
+	nearby = true;
+    }
+
+    /*
+     * Find the display line containing the desired y-coordinate.
+     */
+
+    if (!dInfoPtr->dLinePtr) {
+	if (nearest) {
+	    *nearest = true;
+	}
+	*indexPtr = textPtr->topIndex;
+	return true;
+    }
+
+    epoch = TkBTreeEpoch(textPtr->sharedTextPtr->tree);
+    currChunkPtr = dInfoPtr->currChunkPtr;
+
+    if (currChunkPtr && dInfoPtr->currChunkIndex.stateEpoch == epoch) {
+	currDLinePtr = dInfoPtr->currDLinePtr;
+
+	assert(currChunkPtr->stylePtr); /* otherwise the chunk has been expired */
+
+	if (currDLinePtr->y <= y && y < currDLinePtr->y + currDLinePtr->height) {
+	    int rx = x - dInfoPtr->x + dInfoPtr->curXPixelOffset;
+
+	    if (currChunkPtr->x <= rx && rx < currChunkPtr->x + currChunkPtr->width) {
+		/*
+		 * We have luck, it's inside the cache.
+		 */
+
+		*indexPtr = dInfoPtr->currChunkIndex;
+		DLineIndexOfX(textPtr, currChunkPtr, x, indexPtr);
+		if (nearest) {
+		    *nearest = nearby;
+		}
+		return true;
+	    }
+
+	    dlPtr = currDLinePtr;
+	}
+    }
+
+    if (!dlPtr) {
+	DLine *validDlPtr = dInfoPtr->dLinePtr;
+
+	for (dlPtr = validDlPtr; y >= dlPtr->y + dlPtr->height; dlPtr = dlPtr->nextPtr) {
+	    if (dlPtr->chunkPtr) {
+		validDlPtr = dlPtr;
+	    }
+	    if (!dlPtr->nextPtr) {
+		/*
+		 * Y-coordinate is off the bottom of the displayed text. Use the
+		 * last character on the last line.
+		 */
+
+		if (nearest) {
+		    *nearest = true;
+		}
+		dInfoPtr->currChunkPtr = NULL;
+		*indexPtr = dlPtr->index;
+		assert(dlPtr->byteCount > 0);
+		TkTextIndexForwBytes(textPtr, indexPtr, dlPtr->byteCount - 1, indexPtr);
+		return false;
+	    }
+	}
+	if (!dlPtr->chunkPtr) {
+	    dlPtr = validDlPtr;
+	}
+    }
+
+    currChunkPtr = DLineChunkOfX(textPtr, dlPtr, x, indexPtr, &nearby);
+
+    if (nearest) {
+	*nearest = nearby;
+    }
+
+    if (!nearby) {
+	/*
+	 * Cache the result.
+	 */
+
+	dInfoPtr->currChunkIndex = *indexPtr;
+	TkTextIndexSetEpoch(&dInfoPtr->currChunkIndex, epoch); /* price it as actual */
+	dInfoPtr->currChunkPtr = currChunkPtr;
+	dInfoPtr->currDLinePtr = dlPtr;
+    } else {
+	dInfoPtr->currChunkPtr = NULL;
+    }
+
+    DLineIndexOfX(textPtr, currChunkPtr, x, indexPtr);
+    return false;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DLineIndexOfX --
+ *
+ *	Given an x coordinate in a display line, increase the byte position
+ *	of the index according to the character closest to that location.
+ *
+ *	Together with DLineChunkOfX this is effectively the opposite of
+ *	DLineXOfIndex.
+ *
+ *	Note: use DLineChunkOfX for the computation of the chunk.
+ *
+ * Results:
+ *	The index at *indexPtr is modified to refer to the character on the
+ *	display line that is closest to x.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+DLineIndexOfX(
+    TkText *textPtr,		/* Widget record for text widget. */
+    TkTextDispChunk *chunkPtr,	/* Chunk which contains the character. */
+    int x,			/* Pixel x coordinate of point in widget's window. */
+    TkTextIndex *indexPtr)	/* This byte offset of this index will be increased according
+    				 * to the character position. */
+{
+    /*
+     * If the chunk has more than one byte in it, ask it which character is at
+     * the desired location. In this case we can manipulate
+     * 'indexPtr->byteIndex' directly, because we know we're staying inside a
+     * single logical line.
+     */
+
+    if (chunkPtr && chunkPtr->numBytes > 1) {
+	x -= textPtr->dInfoPtr->x - textPtr->dInfoPtr->curXPixelOffset;
+	TkTextIndexAddToByteIndex(indexPtr, chunkPtr->layoutProcs->measureProc(chunkPtr, x));
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DLineChunkOfX --
+ *
+ *	Given an x coordinate in a display line, find the index of the
+ *	character closest to that location.
+ *
+ *	This is effectively the opposite of DLineXOfIndex.
+ *
+ * Results:
+ *	The index at *indexPtr is modified to refer to the character on the
+ *	display line that is closest to x.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextDispChunk *
+DLineChunkOfX(
+    TkText *textPtr,		/* Widget record for text widget. */
+    DLine *dlPtr,		/* Display information for this display line. */
+    int x,			/* Pixel x coordinate of point in widget's window. */
+    TkTextIndex *indexPtr,	/* This index gets filled in with the index of the character
+    				 * nearest to x. */
+    bool *nearby)		/* If non-NULL then gets set to true if (x,y) is not actually over the
+    				 * returned index, but never set to false. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    TkTextDispChunk *chunkPtr;
+    TkTextDispChunkSection *sectionPtr;
+    unsigned countBytes;
+
+    /*
+     * Scan through the line's chunks to find the one that contains the desired x-coordinate.
+     * Before doing this, translate the x-coordinate from the coordinate system of the window
+     * to the coordinate system of the line (to take account of x-scrolling).
+     */
+
+    chunkPtr = dlPtr->chunkPtr;
+    *indexPtr = dlPtr->index;
+
+    if (!chunkPtr) {
+	/* this may happen if everything is elided */
+	if (nearby) {
+	    *nearby = true;
+	}
+	return chunkPtr;
+    }
+
+    x -= dInfoPtr->x - dInfoPtr->curXPixelOffset;
+
+    if (x < chunkPtr->x) {
+	if (chunkPtr->stylePtr->sValuePtr->indentBg) {
+	    /* if -indentbackground is enabled, then do not trigger when hovering the margin */
+	    *nearby = true;
+	}
+	return chunkPtr;
+    }
+
+    sectionPtr = chunkPtr->sectionPtr;
+    countBytes = chunkPtr->byteOffset;
+
+    while (sectionPtr->nextPtr && x >= sectionPtr->nextPtr->chunkPtr->x) {
+	countBytes += sectionPtr->numBytes;
+	sectionPtr = sectionPtr->nextPtr;
+    }
+
+    chunkPtr = sectionPtr->chunkPtr;
+
+    while (chunkPtr->nextPtr && x >= chunkPtr->x + chunkPtr->width) {
+	countBytes += chunkPtr->numBytes;
+	chunkPtr = chunkPtr->nextPtr;
+    }
+
+    TkTextIndexForwBytes(textPtr, indexPtr, countBytes, indexPtr);
+    return chunkPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexOfX --
+ *
+ *	Given a logical x coordinate (i.e. distance in pixels from the
+ *	beginning of the display line, not taking into account any information
+ *	about the window, scrolling etc.) on the display line starting with
+ *	the given index, adjust that index to refer to the object under the x
+ *	coordinate.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexOfX(
+    TkText *textPtr,		/* Widget record for text widget. */
+    int x,			/* The x coordinate for which we want the index. */
+    TkTextIndex *indexPtr)	/* Index of display line start, which will be adjusted to the
+    				 * index under the given x coordinate. */
+{
+    TextDInfo *dInfoPtr;
+    DLine *dlPtr;
+
+    assert(textPtr);
+
+    if (TkTextIndexGetLine(indexPtr) == TkBTreeGetLastLine(textPtr)) {
+	return;
+    }
+
+    dInfoPtr = textPtr->dInfoPtr;
+    dlPtr = FindCachedDLine(textPtr, indexPtr);
+
+    if (!dlPtr
+	    && !(dInfoPtr->flags & DINFO_OUT_OF_DATE)
+	    && TkTextIndexCompare(indexPtr, &textPtr->topIndex) >= 0) {
+	dlPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, indexPtr);
+    }
+    if (!dlPtr) {
+	DisplayInfo info;
+
+	ComputeDisplayLineInfo(textPtr, indexPtr, &info);
+	if (!(dlPtr = info.lastDLinePtr)) {
+	    TkTextIndex index = *indexPtr;
+
+	    /* we need display line start */
+	    TkTextIndexBackBytes(textPtr, &index, info.byteOffset, &index);
+	    dlPtr = LayoutDLine(&index, info.displayLineNo);
+	} else if ((info.lastDLinePtr = info.lastDLinePtr->prevPtr)) {
+	    dlPtr->prevPtr = info.lastDLinePtr->nextPtr = NULL;
+	} else {
+	    info.dLinePtr = NULL;
+	}
+	FreeDLines(textPtr, dlPtr, NULL, DLINE_CACHE);
+	FreeDLines(textPtr, info.dLinePtr, NULL, DLINE_FREE_TEMP);
+    }
+    x += dInfoPtr->x - dInfoPtr->curXPixelOffset;
+    DLineIndexOfX(textPtr, DLineChunkOfX(textPtr, dlPtr, x, indexPtr, NULL), x, indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DLineXOfIndex --
+ *
+ *	Given a relative byte index on a given display line (i.e. the number
+ *	of byte indices from the beginning of the given display line), find
+ *	the x coordinate of that index within the abstract display line,
+ *	without adjusting for the x-scroll state of the line.
+ *
+ *	This is effectively the opposite of DLineIndexOfX.
+ *
+ *	NB. The 'byteIndex' is relative to the display line, NOT the logical
+ *	line.
+ *
+ * Results:
+ *	The x coordinate.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+DLineXOfIndex(
+    TkText *textPtr,		/* Widget record for text widget. */
+    DLine *dlPtr,		/* Display information for this display line. */
+    int byteIndex)		/* The byte index for which we want the coordinate. */
+{
+    TkTextDispChunkSection *sectionPtr, *nextPtr;
+    TkTextDispChunk *chunkPtr;
+    int x;
+
+    if (byteIndex == 0 || !(sectionPtr = dlPtr->chunkPtr->sectionPtr)) {
+	return 0;
+    }
+
+    while (byteIndex >= sectionPtr->numBytes && (nextPtr = sectionPtr->nextPtr)) {
+	byteIndex -= sectionPtr->numBytes;
+	sectionPtr = nextPtr;
+    }
+
+    chunkPtr = sectionPtr->chunkPtr;
+    assert(chunkPtr);
+
+    /*
+     * Scan through the line's chunks to find the one that contains the desired byte index.
+     */
+
+    x = 0;
+
+    while (true) {
+	if (byteIndex < chunkPtr->numBytes) {
+	    int unused;
+
+	    x = chunkPtr->x;
+	    chunkPtr->layoutProcs->bboxProc(textPtr, chunkPtr, byteIndex,
+		    dlPtr->y + dlPtr->spaceAbove,
+		    dlPtr->height - dlPtr->spaceAbove - dlPtr->spaceBelow,
+		    dlPtr->baseline - dlPtr->spaceAbove, &x, &unused, &unused,
+		    &unused);
+	    break;
+	}
+	if (!chunkPtr->nextPtr || byteIndex == chunkPtr->numBytes) {
+	    x = chunkPtr->x + chunkPtr->width;
+	    break;
+	}
+	byteIndex -= chunkPtr->numBytes;
+	chunkPtr = chunkPtr->nextPtr;
+    }
+
+    return x;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexBbox --
+ *
+ *	Given an index, find the bounding box of the screen area occupied by
+ *	the entity (character, window, image) at that index.
+ *
+ * Results:
+ *	Zero is returned if the index is on the screen. -1 means the index is
+ *	not on the screen. If the return value is 0, then the bounding box of
+ *	the part of the index that's visible on the screen is returned to
+ *	*xPtr, *yPtr, *widthPtr, and *heightPtr.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextIndexBbox(
+    TkText *textPtr,		/* Widget record for text widget. */
+    const TkTextIndex *indexPtr,/* Index whose bounding box is desired. */
+    int *xPtr, int *yPtr,	/* Filled with index's upper-left coordinate. */
+    int *widthPtr, int *heightPtr,
+				/* Filled in with index's dimensions. */
+    int *charWidthPtr)		/* If the 'index' is at the end of a display line and therefore
+    				 * takes up a very large width, this is used to return the smaller
+				 * width actually desired by the index. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    DLine *dlPtr;
+    TkTextDispChunk *chunkPtr;
+    TkTextDispChunkSection *sectionPtr;
+    int byteCount;
+
+    /*
+     * Make sure that all of the screen layout information is up to date.
+     */
+
+    if (dInfoPtr->flags & DINFO_OUT_OF_DATE) {
+	UpdateDisplayInfo(textPtr);
+    }
+
+    /*
+     * Find the display line containing the desired index.
+     */
+
+    dlPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, indexPtr);
+
+    /*
+     * Two cases shall be trapped here because the logic later really
+     * needs dlPtr to be the display line containing indexPtr:
+     *   1. if no display line contains the desired index (NULL dlPtr or no chunk)
+     *   2. if indexPtr is before the first display line, in which case
+     *      dlPtr currently points to the first display line
+     */
+
+    if (!dlPtr || !dlPtr->chunkPtr || TkTextIndexCompare(&dlPtr->index, indexPtr) > 0) {
+	return -1;
+    }
+
+    /*
+     * Find the chunk within the display line that contains the desired
+     * index. The chunks making the display line are skipped up to but not
+     * including the one crossing indexPtr. Skipping is done based on
+     * a byteCount offset possibly spanning several logical lines in case
+     * they are elided.
+     */
+
+    byteCount = TkTextIndexCountBytes(&dlPtr->index, indexPtr);
+    sectionPtr = dlPtr->chunkPtr->sectionPtr;
+
+    while (byteCount >= sectionPtr->numBytes) {
+	byteCount -= sectionPtr->numBytes;
+	if (!(sectionPtr = sectionPtr->nextPtr)) {
+	    return -1;
+	}
+    }
+
+    chunkPtr = sectionPtr->chunkPtr;
+
+    while (byteCount >= chunkPtr->numBytes) {
+	byteCount -= chunkPtr->numBytes;
+	if (!(chunkPtr = chunkPtr->nextPtr)) {
+	    return -1;
+	}
+    }
+
+    /*
+     * Call a chunk-specific function to find the horizontal range of the
+     * character within the chunk, then fill in the vertical range. The
+     * x-coordinate returned by bboxProc is a coordinate within a line, not a
+     * coordinate on the screen. Translate it to reflect horizontal scrolling.
+     */
+
+    chunkPtr->layoutProcs->bboxProc(textPtr, chunkPtr, byteCount,
+	    dlPtr->y + dlPtr->spaceAbove,
+	    dlPtr->height - dlPtr->spaceAbove - dlPtr->spaceBelow,
+	    dlPtr->baseline - dlPtr->spaceAbove, xPtr, yPtr, widthPtr,
+	    heightPtr);
+    *xPtr = *xPtr + dInfoPtr->x - dInfoPtr->curXPixelOffset;
+
+    if (byteCount == chunkPtr->numBytes - 1 && !chunkPtr->nextPtr) {
+	/*
+	 * Last character in display line. Give it all the space up to the line.
+	 */
+
+	if (charWidthPtr) {
+	    *charWidthPtr = dInfoPtr->maxX - *xPtr;
+            if (*charWidthPtr > textPtr->charWidth) {
+                *charWidthPtr = textPtr->charWidth;
+            }
+	}
+	if (*xPtr > dInfoPtr->maxX) {
+	    *xPtr = dInfoPtr->maxX;
+	}
+	*widthPtr = dInfoPtr->maxX - *xPtr;
+    } else {
+	if (charWidthPtr) {
+	    *charWidthPtr = *widthPtr;
+	}
+    }
+
+    if (*widthPtr == 0) {
+	/*
+	 * With zero width (e.g. elided text) we just need to make sure it is
+	 * onscreen, where the '=' case here is ok.
+	 */
+
+	if (*xPtr < dInfoPtr->x) {
+	    return -1;
+	}
+    } else {
+	if (*xPtr + *widthPtr <= dInfoPtr->x) {
+	    return -1;
+	}
+    }
+
+    if (*xPtr + *widthPtr > dInfoPtr->maxX) {
+	*widthPtr = dInfoPtr->maxX - *xPtr;
+	if (*widthPtr <= 0) {
+	    return -1;
+	}
+    }
+
+    if (*yPtr + *heightPtr > dInfoPtr->maxY) {
+	*heightPtr = dInfoPtr->maxY - *yPtr;
+	if (*heightPtr <= 0) {
+	    return -1;
+	}
+    }
+
+    return 0;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextDLineInfo --
+ *
+ *	Given an index, return information about the display line containing
+ *	that character.
+ *
+ * Results:
+ *	'true' is returned if the character is on the screen. 'false' means
+ *	the character isn't on the screen. If the return value is 'true', then
+ *	information is returned in the variables pointed to by xPtr, yPtr,
+ *	widthPtr, heightPtr, and basePtr.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextGetDLineInfo(
+    TkText *textPtr,		/* Widget record for text widget. */
+    const TkTextIndex *indexPtr,/* Index of character whose bounding box is desired. */
+    int *xPtr, int *yPtr,	/* Filled with line's upper-left coordinate. */
+    int *widthPtr, int *heightPtr,
+				/* Filled in with line's dimensions. */
+    int *basePtr)		/* Filled in with the baseline position,
+				 * measured as an offset down from *yPtr. */
+{
+    TextDInfo *dInfoPtr = textPtr->dInfoPtr;
+    DLine *dlPtr;
+    int dlx;
+
+    /*
+     * Make sure that all of the screen layout information is up to date.
+     */
+
+    if (dInfoPtr->flags & DINFO_OUT_OF_DATE) {
+	UpdateDisplayInfo(textPtr);
+    }
+
+    /*
+     * Find the display line containing the desired index.
+     */
+
+    dlPtr = FindDLine(textPtr, dInfoPtr->dLinePtr, indexPtr);
+
+    /*
+     * Two cases shall be trapped here because the logic later really
+     * needs dlPtr to be the display line containing indexPtr:
+     *   1. if no display line contains the desired index (NULL dlPtr)
+     *   2. if indexPtr is before the first display line, in which case
+     *      dlPtr currently points to the first display line
+     */
+
+    if (!dlPtr || TkTextIndexCompare(&dlPtr->index, indexPtr) > 0) {
+	return false;
+    }
+
+    dlx = dlPtr->chunkPtr ? dlPtr->chunkPtr->x : 0;
+    *xPtr = dInfoPtr->x - dInfoPtr->curXPixelOffset + dlx;
+    *widthPtr = dlPtr->length - dlx;
+    *yPtr = dlPtr->y;
+    if (dlPtr->y + dlPtr->height > dInfoPtr->maxY) {
+	*heightPtr = dInfoPtr->maxY - dlPtr->y;
+    } else {
+	*heightPtr = dlPtr->height;
+    }
+    *basePtr = dlPtr->baseline;
+    return true;
+}
+
+/*
+ * Get bounding-box information about an elided chunk.
+ */
+
+static void
+ElideBboxProc(
+    TkText *textPtr,
+    TkTextDispChunk *chunkPtr,	/* Chunk containing desired char. */
+    int index,			/* Index of desired character within the chunk. */
+    int y,			/* Topmost pixel in area allocated for this line. */
+    int lineHeight,		/* Height of line, in pixels. */
+    int baseline,		/* Location of line's baseline, in pixels measured down from y. */
+    int *xPtr, int *yPtr,	/* Gets filled in with coords of character's upper-left pixel.
+    				 * X-coord is in same coordinate system as chunkPtr->x. */
+    int *widthPtr,		/* Gets filled in with width of character, in pixels. */
+    int *heightPtr)		/* Gets filled in with height of character, in pixels. */
+{
+    *xPtr = chunkPtr->x;
+    *yPtr = y;
+    *widthPtr = *heightPtr = 0;
+}
+
+/*
+ * Measure an elided chunk.
+ */
+
+static int
+ElideMeasureProc(
+    TkTextDispChunk *chunkPtr,	/* Chunk containing desired coord. */
+    int x)			/* X-coordinate, in same coordinate system as chunkPtr->x. */
+{
+    return 0;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CharMeasureProc --
+ *
+ *	This function is called to determine which character in a character
+ *	chunk lies over a given x-coordinate.
+ *
+ * Results:
+ *	The return value is the index *within the chunk* of the character that
+ *	covers the position given by "x".
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+CharMeasureProc(
+    TkTextDispChunk *chunkPtr,	/* Chunk containing desired coord. */
+    int x)			/* X-coordinate, in same coordinate system as chunkPtr->x. */
+{
+    return CharChunkMeasureChars(chunkPtr, NULL, 0, 0, chunkPtr->numBytes - 1, chunkPtr->x, x, 0, NULL);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CharBboxProc --
+ *
+ *	This function is called to compute the bounding box of the area
+ *	occupied by a single character.
+ *
+ * Results:
+ *	There is no return value. *xPtr and *yPtr are filled in with the
+ *	coordinates of the upper left corner of the character, and *widthPtr
+ *	and *heightPtr are filled in with the dimensions of the character in
+ *	pixels. Note: not all of the returned bbox is necessarily visible on
+ *	the screen (the rightmost part might be off-screen to the right, and
+ *	the bottommost part might be off-screen to the bottom).
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+CharBboxProc(
+    TkText *textPtr,
+    TkTextDispChunk *chunkPtr,	/* Chunk containing desired char. */
+    int byteIndex,		/* Byte offset of desired character within the chunk */
+    int y,			/* Topmost pixel in area allocated for this line. */
+    int lineHeight,		/* Height of line, in pixels. */
+    int baseline,		/* Location of line's baseline, in pixels measured down from y. */
+    int *xPtr, int *yPtr,	/* Gets filled in with coords of character's upper-left pixel.
+    				 * X-coord is in same coordinate system as chunkPtr->x. */
+    int *widthPtr,		/* Gets filled in with width of character, in pixels. */
+    int *heightPtr)		/* Gets filled in with height of character, in pixels. */
+{
+    CharInfo *ciPtr = chunkPtr->clientData;
+    int offset = ciPtr->baseOffset + byteIndex;
+    int maxX = chunkPtr->width + chunkPtr->x;
+    int nextX;
+
+    CharChunkMeasureChars(chunkPtr, NULL, 0, 0, byteIndex, chunkPtr->x, -1, 0, xPtr);
+
+    if (byteIndex >= ciPtr->numBytes) {
+	/*
+	 * This situation only happens if the last character in a line is a
+	 * space character, in which case it absorbs all of the extra space in
+	 * the line (see TkTextCharLayoutProc).
+	 */
+
+	*widthPtr = maxX - *xPtr;
+    } else if (ciPtr->u.chars[offset] == '\t' && byteIndex == ciPtr->numBytes - 1) {
+	/*
+	 * The desired character is a tab character that terminates a chunk;
+	 * give it all the space left in the chunk.
+	 */
+
+	*widthPtr = maxX - *xPtr;
+    } else {
+	CharChunkMeasureChars(chunkPtr, NULL, 0, byteIndex, byteIndex + 1, *xPtr, -1, 0, &nextX);
+
+	if (nextX >= maxX) {
+	    *widthPtr = maxX - *xPtr;
+	} else {
+	    *widthPtr = nextX - *xPtr;
+
+	    if (chunkPtr->additionalWidth && IsExpandableSpace(ciPtr->u.chars + offset)) {
+		/*
+		 * We've expanded some spaces for full line justification. Compute the
+		 * width of this specific space character.
+		 */
+
+		const char *base = ciPtr->u.chars + ciPtr->baseOffset;
+		const char *q = ciPtr->u.chars + offset;
+		unsigned numSpaces = chunkPtr->numSpaces;
+		unsigned remaining = chunkPtr->additionalWidth;
+
+		do {
+		    unsigned space = (remaining + numSpaces - 1)/numSpaces;
+
+		    *widthPtr += space;
+		    remaining -= space;
+		    assert(numSpaces > 0);
+		    numSpaces -= 1;
+		    if (base == q) {
+			break;
+		    }
+		    q = Tcl_UtfPrev(q, ciPtr->u.chars);
+		} while (IsExpandableSpace(q));
+	    }
+	}
+    }
+
+    *yPtr = y + baseline - chunkPtr->minAscent;
+    *heightPtr = chunkPtr->minAscent + chunkPtr->minDescent;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * AdjustForTab --
+ *
+ *	This function is called to move a series of chunks right in order to
+ *	align them with a tab stop.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The width of chunkPtr gets adjusted so that it absorbs the extra space
+ *	due to the tab. The x locations in all the chunks after chunkPtr are
+ *	adjusted rightward to align with the tab stop given by tabArrayPtr and
+ *	index.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextDispChunk *
+FindEndOfTab(
+    TkTextDispChunk *chunkPtr,
+    int *decimalPtr)
+{
+    TkTextDispChunk *decimalChunkPtr = NULL;
+    bool gotDigit = false;
+
+    *decimalPtr = 0;
+
+    for ( ; chunkPtr; chunkPtr = chunkPtr->nextPtr) {
+	if (IsCharChunk(chunkPtr)) {
+	    CharInfo *ciPtr = chunkPtr->clientData;
+	    const char *s = ciPtr->u.chars + ciPtr->baseOffset;
+	    const char *p;
+	    int i;
+
+	    for (p = s, i = 0; i < ciPtr->numBytes; ++p, ++i) {
+		if (isdigit(*p)) {
+		    gotDigit = true;
+		} else if (*p == '.' || *p == ',') {
+		    *decimalPtr = p - s;
+		    decimalChunkPtr = chunkPtr;
+		} else if (gotDigit) {
+		    if (!decimalChunkPtr) {
+			*decimalPtr = p - s;
+			decimalChunkPtr = chunkPtr;
+		    }
+		    return decimalChunkPtr;
+		}
+	    }
+	}
+    }
+    return decimalChunkPtr;
+}
+
+static void
+AdjustForTab(
+    LayoutData *data)
+{
+    int x, desired = 0, delta, width;
+    TkTextDispChunk *chunkPtr, *nextChunkPtr, *chPtr;
+    TkTextTabArray *tabArrayPtr;
+    TkText *textPtr;
+    int tabX, tabIndex;
+    TkTextTabAlign alignment;
+
+    assert(data->tabIndex >= 0);
+    assert(data->tabChunkPtr);
+
+    chunkPtr = data->tabChunkPtr;
+    nextChunkPtr = chunkPtr->nextPtr;
+
+    if (!nextChunkPtr) {
+	/* Nothing after the actual tab; just return. */
+	return;
+    }
+
+    tabIndex = data->tabIndex;
+    textPtr = data->textPtr;
+    tabArrayPtr = data->tabArrayPtr;
+    x = nextChunkPtr->x;
+
+    /*
+     * If no tab information has been given, assuming tab stops are at 8
+     * average-sized characters. Still ensure we respect the tabular versus
+     * wordprocessor tab style.
+     */
+
+    if (!tabArrayPtr || tabArrayPtr->numTabs == 0) {
+	/*
+	 * No tab information has been given, so use the default
+	 * interpretation of tabs.
+	 */
+
+	unsigned tabWidth = textPtr->charWidth*8;
+
+	tabWidth = MAX(1, tabWidth);
+
+	if (textPtr->tabStyle == TK_TEXT_TABSTYLE_TABULAR) {
+	    desired = tabWidth*(tabIndex + 1);
+	} else {
+	    desired = NextTabStop(tabWidth, x, 0);
+	}
+    } else {
+	if (tabIndex < tabArrayPtr->numTabs) {
+	    alignment = tabArrayPtr->tabs[tabIndex].alignment;
+	    tabX = tabArrayPtr->tabs[tabIndex].location;
+	} else {
+	    /*
+	     * Ran out of tab stops; compute a tab position by extrapolating from
+	     * the last two tab positions.
+	     */
+
+	    tabX = (int) (tabArrayPtr->lastTab +
+		    (tabIndex + 1 - tabArrayPtr->numTabs)*tabArrayPtr->tabIncrement + 0.5);
+	    alignment = tabArrayPtr->tabs[tabArrayPtr->numTabs - 1].alignment;
+	}
+
+	switch (alignment) {
+	case LEFT:
+	    desired = tabX;
+	    break;
+
+	case CENTER:
+	case RIGHT:
+	    /*
+	     * Compute the width of all the information in the tab group, then use
+	     * it to pick a desired location.
+	     */
+
+	    width = 0;
+	    for (chPtr = nextChunkPtr; chPtr; chPtr = chPtr->nextPtr) {
+		width += chPtr->width;
+	    }
+	    desired = tabX - (alignment == CENTER ? width/2 : width);
+	    break;
+
+	case NUMERIC: {
+	    /*
+	     * Search through the text to be tabbed, looking for the last ',' or
+	     * '.' before the first character that isn't a number, comma, period,
+	     * or sign.
+	     */
+
+	    int decimal;
+	    TkTextDispChunk *decimalChunkPtr = FindEndOfTab(nextChunkPtr, &decimal);
+
+	    if (decimalChunkPtr) {
+		int curX;
+
+		CharChunkMeasureChars(decimalChunkPtr, NULL, 0, 0, decimal,
+			decimalChunkPtr->x, -1, 0, &curX);
+		desired = tabX - (curX - x);
+	    } else {
+		/*
+		 * There wasn't a decimal point. Right justify the text.
+		 */
+
+		width = 0;
+		for (chPtr = nextChunkPtr; chPtr; chPtr = chPtr->nextPtr) {
+		    width += chPtr->width;
+		}
+		desired = tabX - width;
+	    }
+	}
+	}
+    }
+
+    /*
+     * Shift all of the chunks to the right so that the left edge is at the
+     * desired location, then expand the chunk containing the tab. Be sure
+     * that the tab occupies at least the width of a space character.
+     */
+
+    delta = MAX(textPtr->spaceWidth, desired - x);
+    for (chPtr = nextChunkPtr; chPtr; chPtr = chPtr->nextPtr) {
+	chPtr->x += delta;
+    }
+    chunkPtr->width += delta;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ComputeSizeOfTab --
+ *
+ *	This estimates the amount of white space that will be consumed by
+ *	a tab.
+ *
+ * Results:
+ *	The 'current tab' is the minimum number of pixels that will be occupied
+ *	by the next tab of tabArrayPtr, assuming that the current position on the
+ *	line is x and the end of the line is maxX. The 'next tab' is determined
+ *	by a combination of the current position (x) which it must be equal to or
+ *	beyond, and the tab count in indexPtr.
+ *
+ *	For numeric tabs, this is a conservative estimate. The 'current tab' is
+ *	always >= 0.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+ComputeSizeOfTab(
+    LayoutData *data)
+{
+    TkText *textPtr;
+    TkTextTabArray *tabArrayPtr;
+    unsigned tabX, tabWidth;
+    TkTextTabAlign alignment;
+
+    textPtr = data->textPtr;
+    tabArrayPtr = data->tabArrayPtr;
+
+    if (!tabArrayPtr || tabArrayPtr->numTabs == 0) {
+	/*
+	 * We're using a default tab spacing of 8 characters.
+	 */
+
+	tabWidth = MAX(1, textPtr->charWidth*8);
+    } else {
+	tabWidth = 0;
+    }
+
+    do {
+	/*
+	 * We were given the count before this tab, so increment it first.
+	 */
+
+	data->tabIndex += 1;
+
+	if (!tabArrayPtr || tabArrayPtr->numTabs == 0) {
+	    /*
+	     * We're using a default tab spacing calculated above.
+	     */
+
+	    tabX = tabWidth*(data->tabIndex + 1);
+	    alignment = LEFT;
+	} else if (data->tabIndex < tabArrayPtr->numTabs) {
+	    tabX = tabArrayPtr->tabs[data->tabIndex].location;
+	    alignment = tabArrayPtr->tabs[data->tabIndex].alignment;
+	} else {
+	    /*
+	     * Ran out of tab stops; compute a tab position by extrapolating.
+	     */
+
+	    tabX = (int) (tabArrayPtr->lastTab
+		    + (data->tabIndex + 1 - tabArrayPtr->numTabs)*tabArrayPtr->tabIncrement
+		    + 0.5);
+	    alignment = tabArrayPtr->tabs[tabArrayPtr->numTabs - 1].alignment;
+	}
+
+	/*
+	 * If this tab stop is before the current x position, then we have two
+	 * cases:
+	 *
+	 * With 'wordprocessor' style tabs, we must obviously continue until
+	 * we reach the text tab stop.
+	 *
+	 * With 'tabular' style tabs, we always use the data->tabIndex'th tab stop.
+	 */
+    } while (tabX <= data->x && data->tabStyle == TK_TEXT_TABSTYLE_WORDPROCESSOR);
+
+    /*
+     * Inform our caller of how many tab stops we've used up.
+     */
+
+    switch (alignment) {
+    case CENTER:
+	/*
+	 * Be very careful in the arithmetic below, because maxX may be the
+	 * largest positive number: watch out for integer overflow.
+	 */
+
+	if (data->maxX - tabX < tabX - data->x) {
+	    data->tabSize = data->maxX - data->x - 2*(data->maxX - tabX);
+	} else {
+	    data->tabSize = 0;
+	}
+	break;
+
+    case RIGHT:
+	data->tabSize = 0;
+	break;
+
+    case LEFT:
+    case NUMERIC:
+	/*
+	 * Note: this treats NUMERIC alignment the same as LEFT alignment, which
+	 * is somewhat conservative. However, it's pretty tricky at this point to
+	 * figure out exactly where the damn decimal point will be.
+	 */
+
+	data->tabSize = tabX - data->x;
+	assert(textPtr->spaceWidth > 0); /* ensure positive size */
+    	break;
+    }
+
+    data->tabSize = MAX(data->tabSize, textPtr->spaceWidth);
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * NextTabStop --
+ *
+ *	Given the current position, determine where the next default tab stop
+ *	would be located. This function is called when the current chunk in
+ *	the text has no tabs defined and so the default tab spacing for the
+ *	font should be used, provided we are using wordprocessor style tabs.
+ *
+ * Results:
+ *	The location in pixels of the next tab stop.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+static int
+NextTabStop(
+    unsigned tabWidth,		/* Default tab width of the widget. */
+    int x,			/* X-position in pixels where last character was drawn. The next
+    				 * tab stop occurs somewhere after this location. */
+    int tabOrigin)		/* The origin for tab stops. May be non-zero if text has been
+    				 * scrolled. */
+{
+    int rem;
+
+    assert(tabWidth > 0);
+
+    tabWidth *= 8;
+    x += tabWidth;
+    if ((rem = (x - tabOrigin) % tabWidth) < 0) {
+	rem += tabWidth;
+    }
+    x -= rem;
+    return x;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * MeasureChars --
+ *
+ *	Determine the number of characters from the string that will fit in
+ *	the given horizontal span. The measurement is done under the
+ *	assumption that Tk_DrawChars will be used to actually display the
+ *	characters.
+ *
+ *	If tabs are encountered in the string, they will be ignored (they
+ *	should only occur as last character of the string anyway).
+ *
+ *	If a newline is encountered in the string, the line will be broken at
+ *	that point.
+ *
+ * Results:
+ *	The return value is the number of bytes from the range of start to end
+ *	in source that fit in the span given by startX and maxX. *nextXPtr is
+ *	filled in with the x-coordinate at which the first character that
+ *	didn't fit would be drawn, if it were to be drawn.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+#if TK_DRAW_IN_CONTEXT
+
+static int
+TkpMeasureChars(
+    Tk_Font tkfont,
+    const char *source,
+    int numBytes,
+    int rangeStart,
+    int rangeLength,
+    int maxLength,
+    int flags,
+    int *lengthPtr)
+{
+    return TkpMeasureCharsInContext(tkfont, source, numBytes, rangeStart,
+	    rangeLength, maxLength, flags, lengthPtr);
+}
+
+#else /* if !TK_DRAW_IN_CONTEXT */
+
+static int
+TkpMeasureChars(
+    Tk_Font tkfont,
+    const char *source,
+    int numBytes,
+    int rangeStart,
+    int rangeLength,
+    int maxLength,
+    int flags,
+    int *lengthPtr)
+{
+    return Tk_MeasureChars(tkfont, source + rangeStart, rangeLength, maxLength, flags, lengthPtr);
+}
+
+#endif /* TK_DRAW_IN_CONTEXT */
+
+static int
+MeasureChars(
+    Tk_Font tkfont,		/* Font in which to draw characters. */
+    const char *source,		/* Characters to be displayed. Need not be NUL-terminated. */
+    int maxBytes,		/* Maximum # of bytes to consider from source. */
+    int rangeStart, int rangeLength,
+				/* Range of bytes to consider in source.*/
+    int startX,			/* X-position at which first character will be drawn. */
+    int maxX,			/* Don't consider any character that would cross this x-position. */
+    int flags,			/* Flags to pass to Tk_MeasureChars. */
+    int *nextXPtr)		/* Return x-position of terminating character here, can be NULL. */
+{
+    int curX, width, ch;
+    const char *special, *end, *start;
+
+    ch = 0;
+    curX = startX;
+    start = source + rangeStart;
+    end = start + rangeLength;
+    special = start;
+
+    while (start < end) {
+	if (start >= special) {
+	    /*
+	     * Find the next special character in the string.
+	     */
+
+	    for (special = start; special < end; ++special) {
+		ch = *special;
+		if (ch == '\t' || ch == '\n') {
+		    break;
+		}
+	    }
+	}
+
+	/*
+	 * Special points at the next special character (or the end of the
+	 * string). Process characters between start and special.
+	 */
+
+	if (maxX >= 0 && curX >= maxX) {
+	    break;
+	}
+	start += TkpMeasureChars(tkfont, source, maxBytes, start - source, special - start,
+		maxX >= 0 ? maxX - curX : -1, flags, &width);
+	curX += width;
+	if (start < special) {
+	    /*
+	     * No more chars fit in line.
+	     */
+
+	    break;
+	}
+	if (special < end) {
+	    if (ch != '\t') {
+		break;
+	    }
+	    start += 1;
+	}
+    }
+
+    if (nextXPtr) {
+	*nextXPtr = curX;
+    }
+    return start - (source + rangeStart);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TextGetScrollInfoObj --
+ *
+ *	This function is invoked to parse "xview" and "yview" scrolling
+ *	commands for text widgets using the new scrolling command syntax
+ *	("moveto" or "scroll" options). It extends the public
+ *	Tk_GetScrollInfoObj function with the addition of "pixels" as a valid
+ *	unit alongside "pages" and "units". It is a shame the core API isn't
+ *	more flexible in this regard.
+ *
+ * Results:
+ *	The return value is either SCROLL_MOVETO, SCROLL_PAGES,
+ *	SCROLL_UNITS, SCROLL_PIXELS or SCROLL_ERROR. This
+ *	indicates whether the command was successfully parsed and what form
+ *	the command took. If SCROLL_MOVETO, *dblPtr is filled in with
+ *	the desired position; if SCROLL_PAGES, SCROLL_PIXELS or
+ *	SCROLL_UNITS, *intPtr is filled in with the number of
+ *	pages/pixels/lines to move (may be negative); if SCROLL_ERROR,
+ *	the interp's result contains an error message.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static ScrollMethod
+TextGetScrollInfoObj(
+    Tcl_Interp *interp,		/* Used for error reporting. */
+    TkText *textPtr,		/* Information about the text widget. */
+    int objc,			/* # arguments for command. */
+    Tcl_Obj *const objv[],	/* Arguments for command. */
+    double *dblPtr,		/* Filled in with argument "moveto" option, if any. */
+    int *intPtr)		/* Filled in with number of pages or lines or pixels to scroll,
+    				 * if any. */
+{
+    static const char *const subcommands[] = {
+	"moveto", "scroll", NULL
+    };
+    enum viewSubcmds {
+	VIEW_MOVETO, VIEW_SCROLL
+    };
+    static const char *const units[] = {
+	"units", "pages", "pixels", NULL
+    };
+    enum viewUnits {
+	VIEW_SCROLL_UNITS, VIEW_SCROLL_PAGES, VIEW_SCROLL_PIXELS
+    };
+    int index;
+
+    if (Tcl_GetIndexFromObjStruct(interp, objv[2], subcommands, sizeof(char *), "option", 0, &index)
+	    != TCL_OK) {
+	return SCROLL_ERROR;
+    }
+
+    switch ((enum viewSubcmds) index) {
+    case VIEW_MOVETO:
+	if (objc != 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "fraction");
+	    return SCROLL_ERROR;
+	}
+	if (Tcl_GetDoubleFromObj(interp, objv[3], dblPtr) != TCL_OK) {
+	    return SCROLL_ERROR;
+	}
+	return SCROLL_MOVETO;
+    case VIEW_SCROLL:
+	if (objc != 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "number units|pages|pixels");
+	    return SCROLL_ERROR;
+	}
+	if (Tcl_GetIndexFromObjStruct(interp, objv[4], units, sizeof(char *), "argument", 0, &index)
+		!= TCL_OK) {
+	    return SCROLL_ERROR;
+	}
+	switch ((enum viewUnits) index) {
+	case VIEW_SCROLL_PAGES:
+	    if (Tcl_GetIntFromObj(interp, objv[3], intPtr) != TCL_OK) {
+		return SCROLL_ERROR;
+	    }
+	    return SCROLL_PAGES;
+	case VIEW_SCROLL_PIXELS:
+	    if (Tk_GetPixelsFromObj(interp, textPtr->tkwin, objv[3], intPtr) != TCL_OK) {
+		return SCROLL_ERROR;
+	    }
+	    return SCROLL_PIXELS;
+	case VIEW_SCROLL_UNITS:
+	    if (Tcl_GetIntFromObj(interp, objv[3], intPtr) != TCL_OK) {
+		return SCROLL_ERROR;
+	    }
+	    return SCROLL_UNITS;
+	}
+    }
+    assert(!"unexpected switch fallthrough");
+    return SCROLL_ERROR; /* should be never reached */
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * AllocCharInfo --
+ *
+ *	Allocate new char info struct. We are using a pool of char info
+ *	structs.
+ *
+ * Results:
+ *	The newly allocated struct, or a free char info struct from
+ *	pool.
+ *
+ * Side effects:
+ *	May allocate some memory.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static CharInfo *
+AllocCharInfo(
+    TkText *textPtr)
+{
+    TextDInfo *dInfoPtr;
+    CharInfo *ciPtr;
+
+    assert(textPtr);
+
+    dInfoPtr = textPtr->dInfoPtr;
+    if ((ciPtr = dInfoPtr->charInfoPoolPtr)) {
+	dInfoPtr->charInfoPoolPtr = dInfoPtr->charInfoPoolPtr->u.next;
+    } else {
+	ciPtr = malloc(sizeof(CharInfo));
+	DEBUG_ALLOC(tkTextCountNewCharInfo++);
+    }
+
+    return ciPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FreeCharInfo --
+ *
+ *	Put back given char info to pool.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+FreeCharInfo(
+    TkText *textPtr,
+    CharInfo *ciPtr)
+{
+    TextDInfo *dInfoPtr;
+
+    assert(textPtr);
+    assert(ciPtr);
+
+    TkBTreeFreeSegment(ciPtr->segPtr);
+    dInfoPtr = textPtr->dInfoPtr;
+    ciPtr->u.next = dInfoPtr->charInfoPoolPtr;
+    dInfoPtr->charInfoPoolPtr = ciPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ComputeBreakIndex --
+ *
+ *	Compute a break location. If we're in word wrap mode, a break
+ *	can occurr after any space character, or at the end of the chunk
+ *	if the the next segment (ignoring those with zero size) is not a
+ *	character segment.
+ *
+ * Results:
+ *	The computed break location.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+ComputeBreakIndex(
+    TkText *textPtr,
+    const TkTextDispChunk *chunkPtr,
+    TkTextSegment *segPtr,
+    int byteOffset,
+    TkWrapMode wrapMode,
+    TkTextSpaceMode spaceMode)
+{
+    switch (wrapMode) {
+    case TEXT_WRAPMODE_NONE:
+	break;
+    case TEXT_WRAPMODE_CHAR:
+    case TEXT_WRAPMODE_NULL:
+	return chunkPtr->numBytes;
+    case TEXT_WRAPMODE_WORD:
+    case TEXT_WRAPMODE_CODEPOINT: {
+	TkTextSegment *nextPtr;
+	const char *p;
+	int count;
+
+	if (segPtr->typePtr == &tkTextHyphenType) {
+	    return 1;
+	}
+
+	if (chunkPtr->numBytes + byteOffset == segPtr->size) {
+	    for (nextPtr = segPtr->nextPtr; nextPtr; nextPtr = nextPtr->nextPtr) {
+		if (nextPtr->size > 0) {
+		    if (!(nextPtr->typePtr->group & (SEG_GROUP_CHAR|SEG_GROUP_HYPHEN))) {
+			return chunkPtr->numBytes;
+		    }
+		    break;
+		} else if (nextPtr->typePtr == &tkTextBranchType) {
+		    nextPtr = nextPtr->body.branch.nextPtr->nextPtr;
+		}
+	    }
+	}
+
+	count = chunkPtr->numBytes;
+	if (chunkPtr->endsWithSyllable) {
+	    assert(chunkPtr->numBytes > 0);
+	    count -= 1;
+	}
+	p = segPtr->body.chars + byteOffset + count - 1;
+
+	if (wrapMode == TEXT_WRAPMODE_WORD) {
+	    /*
+	     * Don't use isspace(); effects are unpredictable (because the result
+	     * is locale dependent) and can lead to odd word-wrapping problems on
+	     * some platforms. Also don't use Tcl_UniCharIsSpace here either, this
+	     * can be used when displaying Markup in read-only mode (except the
+	     * non-breaking space), but in text data there is a difference between
+	     * ASCII spaces and all other spaces, and this difference must be
+	     * visible for the user (line break makes the spaces indistinguishable).
+	     * Keep in mind that the text widget will also be used for editing
+	     * text. What we actually want is only the ASCII space characters, so
+	     * use them explicitly...
+	     *
+	     * NOTE: don't break at hyphen character (U+002D), because the meaning
+	     * of this character is contextual. The user has to use the "codepoint"
+	     * wrap mode if he want's line breaking at hard hyphen characters.
+	     */
+
+	    for ( ; count > 0; --count, --p) {
+		switch (*p) {
+		case ' ':
+		    if (spaceMode == TEXT_SPACEMODE_EXACT) {
+			return -1;
+		    }
+		    /* fallthru */
+		case '\t': case '\n': case '\v': case '\f': case '\r':
+		    return count;
+		}
+	    }
+	} else {
+	    const char *brks;
+	    int i;
+
+	    if (*p == '\n') {
+		return count; /* catch special case end of line */
+	    }
+
+	    brks = chunkPtr->brks;
+	    i = count - 1;
+
+	    /* In this case the break locations must be already computed. */
+	    assert(brks);
+
+	    for ( ; i >= 0; --i, --p) {
+		if (brks[i] == LINEBREAK_ALLOWBREAK) {
+		    if (*p == ' ' && spaceMode == TEXT_SPACEMODE_EXACT) {
+			return -1;
+		    }
+		    return i + 1;
+		}
+	    }
+	}
+	break;
+    }
+    }
+
+    return -1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextCheckDisplayLineConsistency --
+ *
+ *	This function is called for consistency checking of display line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If anything suspicious is found in the display lines, the function
+ *	panics.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextCheckDisplayLineConsistency(
+    const TkText *textPtr)
+{
+    DLine *dlPtr;
+
+    for (dlPtr = textPtr->dInfoPtr->dLinePtr; dlPtr; dlPtr = dlPtr->nextPtr) {
+	if (dlPtr->chunkPtr) {
+	    const TkTextLine *linePtr = TkTextIndexGetLine(&dlPtr->index);
+
+	    if (!linePtr->parentPtr || linePtr->parentPtr == (void *) 0x61616161) {
+		Tcl_Panic("CheckDisplayLineConsisteny: expired index in display line");
+	    }
+	}
+    }
+
+    for (dlPtr = textPtr->dInfoPtr->savedDLinePtr; dlPtr; dlPtr = dlPtr->nextPtr) {
+	if (dlPtr->chunkPtr) {
+	    const TkTextLine *linePtr = TkTextIndexGetLine(&dlPtr->index);
+
+	    if (!linePtr->parentPtr || linePtr->parentPtr == (void *) 0x61616161) {
+		Tcl_Panic("CheckDisplayLineConsisteny: expired index in saved display line");
+	    }
+	}
+    }
+
+    dlPtr = textPtr->dInfoPtr->cachedDLinePtr;
+    if (dlPtr && dlPtr->chunkPtr) {
+	const TkTextLine *linePtr = TkTextIndexGetLine(&dlPtr->index);
+
+	if (!linePtr->parentPtr || linePtr->parentPtr == (void *) 0x61616161) {
+	    Tcl_Panic("CheckDisplayLineConsisteny: expired index in cached display line");
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * CheckLineMetricConsistency --
+ *
+ *	This function is called for consistency checking of display line
+ *	metric information. Call this function only if all line metrics
+ *	are up-to-date.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If anything suspicious is found in the display line metric information,
+ *	the function panics.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+CheckLineMetricConsistency(
+    const TkText *textPtr)
+{
+    const TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    unsigned epoch = textPtr->dInfoPtr->lineMetricUpdateEpoch;
+    const TkTextLine *lastLinePtr;
+    const TkTextLine *linePtr;
+    unsigned lineNum = 0;
+    unsigned reference;
+
+    assert(textPtr->pixelReference >= 0);
+
+    linePtr = TkBTreeGetStartLine(textPtr);
+    lastLinePtr = TkBTreeGetLastLine(textPtr);
+
+    if (textPtr->dInfoPtr->firstLineNo != TkBTreeLinesTo(sharedTextPtr->tree, NULL, linePtr, NULL)) {
+	Tcl_Panic("CheckLineMetricConsistency: firstLineNo is not up-to-date");
+    }
+    if (textPtr->dInfoPtr->lastLineNo != TkBTreeLinesTo(sharedTextPtr->tree, NULL, lastLinePtr, NULL)) {
+	Tcl_Panic("CheckLineMetricConsistency: lastLineNo is not up-to-date");
+    }
+
+    reference = textPtr->pixelReference;
+
+    while (linePtr != lastLinePtr) {
+	const TkTextPixelInfo *pixelInfo = linePtr->pixelInfo + reference;
+	const TkTextDispLineInfo *dispLineInfo = pixelInfo->dispLineInfo;
+
+	if ((pixelInfo->epoch & EPOCH_MASK) != epoch) {
+	    Tcl_Panic("CheckLineMetricConsistency: line metric info is not up-to-date");
+	}
+	if (pixelInfo->epoch & PARTIAL_COMPUTED_BIT) {
+	    Tcl_Panic("CheckLineMetricConsistency: computation of this line is not yet complete");
+	}
+
+	linePtr = linePtr->nextPtr;
+	lineNum += 1;
+
+	while (linePtr != lastLinePtr && !linePtr->logicalLine) {
+	    const TkTextPixelInfo *pixelInfo = linePtr->pixelInfo + reference;
+
+	    if ((pixelInfo->epoch & EPOCH_MASK) != epoch) {
+		Tcl_Panic("CheckLineMetricConsistency: line metric info is not up-to-date");
+	    }
+	    if (pixelInfo->epoch & PARTIAL_COMPUTED_BIT) {
+		Tcl_Panic("CheckLineMetricConsistency: partial flag shouldn't be set");
+	    }
+	    if (pixelInfo->dispLineInfo) {
+		Tcl_Panic("CheckLineMetricConsistency: merged line should not have display line info");
+	    }
+	    if (pixelInfo->height > 0) {
+		Tcl_Panic("CheckLineMetricConsistency: merged line should not have a height");
+	    }
+
+	    linePtr = linePtr->nextPtr;
+	    lineNum += 1;
+	}
+
+	if (!lastLinePtr->nextPtr) {
+	    const TkTextPixelInfo *pixelInfo = lastLinePtr->pixelInfo + reference;
+
+	    if (pixelInfo->epoch & PARTIAL_COMPUTED_BIT) {
+		Tcl_Panic("CheckLineMetricConsistency: partial flag shouldn't be set in last line");
+	    }
+	    if (pixelInfo->dispLineInfo) {
+		Tcl_Panic("CheckLineMetricConsistency: last line should not have display line info");
+	    }
+	    if (pixelInfo->height > 0) {
+		Tcl_Panic("CheckLineMetricConsistency: last line should not have a height");
+	    }
+	}
+
+	if (dispLineInfo) {
+	    unsigned pixels = 0;
+	    unsigned k;
+
+	    if (dispLineInfo->numDispLines == 1) {
+		Tcl_Panic("CheckLineMetricConsistency: this line should not have display line info");
+	    }
+	    for (k = 0; k < dispLineInfo->numDispLines; ++k) {
+		const TkTextDispLineEntry *entry = dispLineInfo->entry + k;
+
+		if (k == 0 && entry->byteOffset != 0) {
+		    Tcl_Panic("CheckLineMetricConsistency: first display line (line %d) should "
+			    "have byte offset zero", lineNum);
+		}
+		if ((entry + 1)->byteOffset <= entry->byteOffset) {
+		    Tcl_Panic("CheckLineMetricConsistency: display line (line %d) has invalid byte "
+			    "offset %d (previous is %d)", lineNum, (entry + 1)->byteOffset,
+			    entry->byteOffset);
+		}
+		if (entry->height == 0) {
+		    Tcl_Panic("CheckLineMetricConsistency: display line (%d) has zero height", lineNum);
+		}
+		pixels += entry->height;
+	    }
+	    if (pixels != pixelInfo->height) {
+		Tcl_Panic("CheckLineMetricConsistency: sum of display line pixels is wrong (line %d)",
+			lineNum);
+	    }
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextCheckLineMetricUpdate --
+ *
+ *	This function is called for consistency checking of display line
+ *	metric update information.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	If anything suspicious is found in the display line metric update
+ *	information, the function panics.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextCheckLineMetricUpdate(
+    const TkText *textPtr)
+{
+    const TkRangeList *ranges;
+    const TkRange *range;
+    TkTextBTree tree;
+    unsigned epoch;
+    int n, total;
+
+    assert(textPtr);
+
+    if (!textPtr->sharedTextPtr->allowUpdateLineMetrics) {
+	return;
+    }
+    if (!textPtr->endMarker->sectionPtr || !textPtr->startMarker->sectionPtr) {
+	/*
+	 * Called inside unlink of start/end marker, in this case we cannot check
+	 * (and we don't need a check here).
+	 */
+	return;
+    }
+
+    ranges = textPtr->dInfoPtr->lineMetricUpdateRanges;
+    tree = textPtr->sharedTextPtr->tree;
+    total = TkBTreeNumLines(tree, textPtr);
+
+    if (!TkRangeListIsEmpty(ranges) && TkRangeListHigh(ranges) >= total) {
+	Tcl_Panic("TkTextCheckLineMetricUpdate: line %d is out of range (max=%d)\n",
+		TkRangeListHigh(ranges), total);
+    }
+
+    range = TkRangeListFirst(ranges);
+    epoch = textPtr->dInfoPtr->lineMetricUpdateEpoch;
+
+    for (n = 0; n < total - 1; ++n) {
+	const TkTextPixelInfo *pixelInfo;
+
+	if (range && range->low == n) {
+	    n = range->high;
+	    range = TkRangeListNext(ranges, range);
+	    continue;
+	}
+
+	pixelInfo = TkBTreeLinePixelInfo(textPtr, TkBTreeFindLine(tree, textPtr, n));
+
+	if (pixelInfo->epoch && (pixelInfo->epoch & EPOCH_MASK) != epoch) {
+	    Tcl_Panic("TkTextCheckLineMetricUpdate: line %d is not up-to-date\n", n);
+	}
+	if (pixelInfo->epoch & PARTIAL_COMPUTED_BIT) {
+	    Tcl_Panic("TkTextCheckLineMetricUpdate: line metric computation (line %d) is not "
+		    "yet complete\n", n);
+	}
+    }
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * CharChunkMeasureChars --
+ *
+ *	Determine the number of characters from a char chunk that will fit in
+ *	the given horizontal span.
+ *
+ *	This is the same as MeasureChars (which see), but in the context of a
+ *	char chunk, i.e. on a higher level of abstraction. Use this function
+ *	whereever possible instead of plain MeasureChars, so that the right
+ *	context is used automatically.
+ *
+ * Results:
+ *	The return value is the number of bytes from the range of start to end
+ *	in source that fit in the span given by startX and maxX. *nextXPtr is
+ *	filled in with the x-coordinate at which the first character that
+ *	didn't fit would be drawn, if it were to be drawn.
+ *
+ * Side effects:
+ *	None.
+ *--------------------------------------------------------------
+ */
+
+static int
+CharChunkMeasureChars(
+    TkTextDispChunk *chunkPtr,	/* Chunk from which to measure. */
+    const char *chars,		/* Chars to use, instead of the chunk's own. Used by the layoutproc
+    				 * during chunk setup. All other callers use NULL. Not NUL-terminated. */
+    int charsLen,		/* Length of the "chars" parameter. */
+    int start, int end,		/* The range of chars to measure inside the chunk (or inside the
+    				 * additional chars). */
+    int startX,			/* Starting x coordinate where the measured span will begin. */
+    int maxX,			/* Maximum pixel width of the span. May be -1 for unlimited. */
+    int flags,			/* Flags to pass to MeasureChars. */
+    int *nextXPtr)		/* The function puts the newly calculated right border x-position of
+    				 * the span here; can be NULL. */
+{
+    Tk_Font tkfont = chunkPtr->stylePtr->sValuePtr->tkfont;
+    CharInfo *ciPtr = chunkPtr->clientData;
+    int fit, rangeStart;
+
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+
+    int widthUntilStart = 0;
+
+    assert(chunkPtr->baseChunkPtr);
+
+    if (!chars) {
+	const Tcl_DString *baseChars = &chunkPtr->baseChunkPtr->baseChars;
+
+	chars = Tcl_DStringValue(baseChars);
+	charsLen = Tcl_DStringLength(baseChars);
+	start += ciPtr->baseOffset;
+	if (end == -1) {
+	    assert(ciPtr->numBytes >= chunkPtr->wrappedAtSpace);
+	    end = ciPtr->baseOffset + ciPtr->numBytes - chunkPtr->wrappedAtSpace;
+	} else {
+	    end += ciPtr->baseOffset;
+	}
+	if (chunkPtr->wrappedAtSpace) {
+	    assert(charsLen >= 1);
+	    charsLen -= 1;
+	}
+    }
+
+    if (start != ciPtr->baseOffset) {
+	MeasureChars(tkfont, chars, charsLen, 0, start, 0, -1, 0, &widthUntilStart);
+    }
+
+    startX = chunkPtr->baseChunkPtr->x + (startX - widthUntilStart - chunkPtr->x);
+    rangeStart = 0;
+
+#else
+
+    rangeStart = start;
+
+    if (!chars) {
+	chars = ciPtr->u.chars;
+	charsLen = ciPtr->numBytes;
+    }
+
+#endif
+
+    if (end == -1) {
+	end = charsLen;
+    }
+
+    fit = MeasureChars(tkfont, chars, charsLen, rangeStart, end - rangeStart,
+	    startX, maxX, flags, nextXPtr);
+
+    return MAX(0, fit - start);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextCharLayoutProc --
+ *
+ *	This function is the "layoutProc" for character segments.
+ *
+ * Results:
+ *	If there is something to display for the chunk then a non-zero value
+ *	is returned and the fields of chunkPtr will be filled in (see the
+ *	declaration of TkTextDispChunk in tkText.h for details). If zero is
+ *	returned it means that no characters from this chunk fit in the
+ *	window. If -1 is returned it means that this segment just doesn't need
+ *	to be displayed (never happens for text).
+ *
+ * Side effects:
+ *	Memory is allocated to hold additional information about the chunk.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+EndsWithSyllable(
+    TkTextSegment *segPtr)
+{
+    if (segPtr->typePtr->group == SEG_GROUP_CHAR) {
+	for (segPtr = segPtr->nextPtr; segPtr; segPtr = segPtr->nextPtr) {
+	    switch (segPtr->typePtr->group) {
+	    case SEG_GROUP_MARK:
+		break;
+	    case SEG_GROUP_HYPHEN:
+		return true;
+	    case SEG_GROUP_BRANCH:
+		if (segPtr->typePtr == &tkTextBranchType) {
+		    segPtr = segPtr->body.branch.nextPtr;
+		    break;
+		}
+		/* fallthru */
+	    default:
+		return false;
+	    }
+	}
+    }
+    return false;
+}
+
+int
+TkTextCharLayoutProc(
+    const TkTextIndex *indexPtr,/* Index of first character to lay out (corresponds to segPtr and
+    				 * offset). */
+    TkTextSegment *segPtr,	/* Segment being layed out. */
+    int byteOffset,		/* Byte offset within segment of first character to consider. */
+    int maxX,			/* Chunk must not occupy pixels at this position or higher. */
+    int maxBytes,		/* Chunk must not include more than this many characters. */
+    bool noCharsYet,		/* 'true' means no characters have been assigned to this display
+    				 * line yet. */
+    TkWrapMode wrapMode,	/* How to handle line wrapping: TEXT_WRAPMODE_CHAR, TEXT_WRAPMODE_NONE,
+    				 * TEXT_WRAPMODE_WORD, or TEXT_WRAPMODE_CODEPOINT. */
+    TkTextSpaceMode spaceMode,	/* How to handle displaying spaces. Must be TEXT_SPACEMODE_NONE,
+    				 * TEXT_SPACEMODE_EXACT, or TEXT_SPACEMODE_TRIM. */
+    TkTextDispChunk *chunkPtr)	/* Structure to fill in with information about this chunk. The x
+    				 * field has already been set by the caller. */
+{
+    Tk_Font tkfont;
+    int nextX, bytesThatFit;
+    Tk_FontMetrics fm;
+    CharInfo *ciPtr;
+    char const *p;
+
+    assert(indexPtr->textPtr);
+    assert(chunkPtr->clientData);
+
+    /*
+     * Figure out how many characters will fit in the space we've got. Include
+     * the next character, even though it won't fit completely, if any of the
+     * following is true:
+     *
+     *	 (a) the chunk contains no characters and the display line contains no
+     *	     characters yet (i.e. the line isn't wide enough to hold even a
+     *	     single character).
+     *
+     *	 (b) at least one pixel of the character is visible, we have not
+     *	     already exceeded the character limit, and the next character is a
+     *	     white space character.
+     */
+
+    tkfont = chunkPtr->stylePtr->sValuePtr->tkfont;
+    ciPtr = chunkPtr->clientData;
+    chunkPtr->layoutProcs = &layoutCharProcs;
+    p = segPtr->body.chars + byteOffset;
+
+    bytesThatFit = CharChunkMeasureChars(chunkPtr, ciPtr->u.chars, ciPtr->baseOffset + maxBytes,
+	    ciPtr->baseOffset, -1, chunkPtr->x, maxX, TK_ISOLATE_END, &nextX);
+
+    /*
+     * NOTE: do not trim white spaces at the end of line, it would be impossible
+     * for the user to see typos like mistakenly typing two consecutive spaces.
+     */
+
+    if (bytesThatFit < maxBytes) {
+	if (bytesThatFit == 0 && noCharsYet) {
+	    int ch, chLen = TkUtfToUniChar(p, &ch);
+
+	    /*
+	     * At least one character should be contained in current display line.
+	     */
+
+	    bytesThatFit = CharChunkMeasureChars(chunkPtr, ciPtr->u.chars, ciPtr->baseOffset + chLen,
+		    ciPtr->baseOffset, -1, chunkPtr->x, -1, 0, &nextX);
+	}
+	if (spaceMode == TEXT_SPACEMODE_TRIM) {
+	    while (isblank(p[bytesThatFit])) {
+		bytesThatFit += 1;
+	    }
+	}
+	if (p[bytesThatFit] == '\n') {
+	    /*
+	     * A newline character takes up no space, so if the previous
+	     * character fits then so does the newline.
+	     */
+
+	    bytesThatFit += 1;
+	} else if (spaceMode == TEXT_SPACEMODE_NONE
+		&& nextX <= maxX
+		&& ((1 << wrapMode) & ((1 << TEXT_WRAPMODE_WORD) | (1 << TEXT_WRAPMODE_CODEPOINT)))
+		&& isblank(p[bytesThatFit])
+		&& !(bytesThatFit == 0
+		    && chunkPtr->prevCharChunkPtr
+		    && chunkPtr->prevCharChunkPtr->wrappedAtSpace)) {
+	    /*
+	     * Space characters are funny, in that they are considered to fit at the end
+	     * of the line. Just give the space character whatever space is left.
+	     */
+
+	    nextX = maxX;
+	    bytesThatFit += 1;
+
+	    /* Do not wrap next chunk in this line. */
+	    chunkPtr->wrappedAtSpace = true;
+	}
+	if (bytesThatFit == 0) {
+	    return 0;
+	}
+    }
+
+    Tk_GetFontMetrics(tkfont, &fm);
+
+    /*
+     * Fill in the chunk structure and allocate and initialize a CharInfo structure. If the
+     * last character is a newline then don't bother to display it.
+     */
+
+    chunkPtr->endsWithSyllable =
+	    p[bytesThatFit] == '\0' && indexPtr->textPtr->hyphenate && EndsWithSyllable(segPtr);
+    chunkPtr->numBytes = bytesThatFit;
+    chunkPtr->segByteOffset = byteOffset;
+    chunkPtr->minAscent = fm.ascent + chunkPtr->stylePtr->sValuePtr->offset;
+    chunkPtr->minDescent = fm.descent - chunkPtr->stylePtr->sValuePtr->offset;
+    chunkPtr->minHeight = 0;
+    chunkPtr->width = nextX - chunkPtr->x;
+    chunkPtr->breakIndex =
+	    ComputeBreakIndex(indexPtr->textPtr, chunkPtr, segPtr, byteOffset, wrapMode, spaceMode);
+
+    ciPtr->numBytes = chunkPtr->numBytes;
+    return 1;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CharDisplayProc --
+ *
+ *	This function is called to display a character chunk on the screen or
+ *	in an off-screen pixmap.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Graphics are drawn.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+CharDisplayProc(
+    TkText *textPtr,
+    TkTextDispChunk *chunkPtr,	/* Chunk that is to be drawn. */
+    int x,			/* X-position in dst at which to draw this chunk (may differ from
+    				 * the x-position in the chunk because of scrolling). */
+    int y,			/* Y-position at which to draw this chunk in dst. */
+    int height,			/* Total height of line. */
+    int baseline,		/* Offset of baseline from y. */
+    Display *display,		/* Display to use for drawing. */
+    Drawable dst,		/* Pixmap or window in which to draw chunk. */
+    int screenY)		/* Y-coordinate in text window that corresponds to y. */
+{
+    assert(chunkPtr->width == 0 || !chunkPtr->stylePtr->sValuePtr->elide);
+
+    if (chunkPtr->width > 0 && x + chunkPtr->width > 0) {
+	/* The chunk has displayable content, and is not off-screen. */
+	DisplayChars(textPtr, chunkPtr, x, y, baseline, display, dst);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * CharUndisplayProc --
+ *
+ *	This function is called when a character chunk is no longer going to
+ *	be displayed. It frees up resources that were allocated to display the
+ *	chunk.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory and other resources get freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+CharUndisplayProc(
+    TkText *textPtr,		/* Overall information about text widget. */
+    TkTextDispChunk *chunkPtr)	/* Chunk that is about to be freed. */
+{
+    CharInfo *ciPtr = chunkPtr->clientData;
+
+    if (!ciPtr) {
+	return;
+    }
+
+#if TK_LAYOUT_WITH_BASE_CHUNKS
+    {
+	TkTextDispChunk *baseChunkPtr = chunkPtr->baseChunkPtr;
+
+	if (chunkPtr == baseChunkPtr) {
+	    /*
+	     * Base chunks are undisplayed first, when DLines are freed or
+	     * partially freed, so this makes sure we don't access their data
+	     * any more.
+	     */
+
+	    Tcl_DStringFree(&baseChunkPtr->baseChars);
+	    DEBUG_ALLOC(tkTextCountDestroyBaseChars++);
+	} else if (baseChunkPtr && ciPtr->numBytes > 0) {
+	    /*
+	     * When other char chunks are undisplayed, drop their characters
+	     * from the base chunk. This usually happens, when they are last
+	     * in a line and need to be re-layed out.
+	     */
+
+	    assert(ciPtr->baseOffset + ciPtr->numBytes == Tcl_DStringLength(&baseChunkPtr->baseChars));
+	    Tcl_DStringSetLength(&baseChunkPtr->baseChars, ciPtr->baseOffset);
+	    baseChunkPtr->baseWidth = 0;
+	}
+
+	if (chunkPtr->prevPtr) {
+	    chunkPtr->x -= chunkPtr->prevPtr->xAdjustment;
+	}
+
+	chunkPtr->baseChunkPtr = NULL;
+    }
+#endif
+
+    FreeCharInfo(textPtr, ciPtr);
+    chunkPtr->clientData = NULL;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * HyphenUndisplayProc --
+ *
+ *	This function is called when a hyphen chunk is no longer going to
+ *	be displayed. It frees up resources that were allocated to display the
+ *	chunk.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory and other resources get freed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+HyphenUndisplayProc(
+    TkText *textPtr,		/* Overall information about text widget. */
+    TkTextDispChunk *chunkPtr)	/* Chunk that is about to be freed. */
+{
+    TkTextSegment *hyphenPtr = chunkPtr->clientData;
+
+    if (hyphenPtr) {
+	TkBTreeFreeSegment(hyphenPtr);
+    }
+    chunkPtr->clientData = NULL;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * DisplayChars --
+ *
+ *	This function is called to display characters on the screen or
+ *	in an off-screen pixmap.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Graphics are drawn.
+ *
+ *--------------------------------------------------------------
+ */
+
+static GC
+GetForegroundGC(
+    const TkText *textPtr,
+    const TkTextDispChunk *chunkPtr)
+{
+    const TkTextSegment *segPtr = ((const CharInfo *) chunkPtr->clientData)->segPtr;
+
+    if (segPtr == textPtr->dInfoPtr->endOfLineSegPtr) {
+	if (chunkPtr->stylePtr->eolGC != None) {
+	    return chunkPtr->stylePtr->eolGC;
+	}
+    } else if (segPtr->typePtr == &tkTextHyphenType) {
+	if (chunkPtr->stylePtr->hyphenGC != None) {
+	    return chunkPtr->stylePtr->hyphenGC;
+	}
+    }
+    return chunkPtr->stylePtr->fgGC;
+}
+
+#if TK_DRAW_IN_CONTEXT
+# if defined(_WIN32) || defined(__UNIX__)
+
+/*****************************************************************************
+ * We need this function for the emulation of context drawing, in this way the
+ * context support can be pre-tested on platforms without sub-pixel accuracy.
+ *****************************************************************************/
+
+static void
+DrawCharsInContext(
+    Display *display,	/* Display on which to draw. */
+    Drawable drawable,	/* Window or pixmap in which to draw. */
+    GC gc,		/* Graphics context for drawing characters. */
+    Tk_Font tkfont,	/* Font in which characters will be drawn; must be the same as font used
+    			 * in GC. */
+    const char *source,	/* UTF-8 string to be displayed. Need not be nul terminated. All Tk
+    			 * meta-characters (tabs, control characters, and newlines) should be
+			 * stripped out of the string that is passed to this function. If they are
+			 * not stripped out, they will be displayed as regular printing characters. */
+    int numBytes,	/* Number of bytes in string. */
+    int rangeStart,	/* Index of first byte to draw. */
+    int rangeLength,	/* Length of range to draw in bytes. */
+    int x, int y,	/* Coordinates at which to place origin of the whole (not just the range)
+    			 * string when drawing. */
+    int xOffset)	/* Offset to x-coordinate, required for emulation of context drawing. */
+{
+    Tk_DrawChars(display, drawable, gc, tkfont, source + rangeStart, rangeLength, xOffset, y);
+}
+
+# else /* if !(defined(_WIN32) || defined(__UNIX__)) */
+
+static void
+DrawCharsInContext(
+    Display *display,	/* Display on which to draw. */
+    Drawable drawable,	/* Window or pixmap in which to draw. */
+    GC gc,		/* Graphics context for drawing characters. */
+    Tk_Font tkfont,	/* Font in which characters will be drawn; must be the same as font used
+    			 * in GC. */
+    const char *source,	/* UTF-8 string to be displayed. Need not be nul terminated. All Tk
+    			 * meta-characters (tabs, control characters, and newlines) should be
+			 * stripped out of the string that is passed to this function. If they are
+			 * not stripped out, they will be displayed as regular printing characters. */
+    int numBytes,	/* Number of bytes in string. */
+    int rangeStart,	/* Index of first byte to draw. */
+    int rangeLength,	/* Length of range to draw in bytes. */
+    int x, int y,	/* Coordinates at which to place origin of the whole (not just the range)
+    			 * string when drawing. */
+    int xOffset)	/* Offset to x-coordinate, not needed here. */
+{
+    TkpDrawCharsInContext(display, drawable, gc, tkfont,
+	    source, numBytes, rangeStart, rangeLength, x, y);
+}
+
+# endif /* defined(_WIN32) || defined(__UNIX__) */
+
+static void
+DrawChars(
+    TkText *textPtr,
+    TkTextDispChunk *chunkPtr,	/* Display the content of this chunk. */
+    int x,			/* X-position in dst at which to draw. */
+    int y,			/* Y-position at which to draw. */
+    int offsetX,		/* Offset in x-direction. */
+    int offsetBytes,		/* Offset in display string. */
+    Display *display,		/* Display to use for drawing. */
+    Drawable dst)		/* Pixmap or window in which to draw chunk. */
+{
+    const TkTextDispChunk *baseChunkPtr;
+    unsigned numBytes;
+
+    assert(chunkPtr->baseChunkPtr);
+
+    baseChunkPtr = chunkPtr->baseChunkPtr;
+    numBytes = Tcl_DStringLength(&baseChunkPtr->baseChars);
+
+    if (numBytes > offsetBytes) {
+	const char *string;
+	const CharInfo *ciPtr;
+	const TextStyle *stylePtr;
+	const StyleValues *sValuePtr;
+	int xDisplacement, start, len;
+	GC fgGC;
+
+	string = Tcl_DStringValue(&baseChunkPtr->baseChars);
+	ciPtr = chunkPtr->clientData;
+	start = ciPtr->baseOffset + offsetBytes;
+	len = ciPtr->numBytes - offsetBytes;
+
+	assert(ciPtr->numBytes >= offsetBytes);
+
+	if (len == 0 || (string[start + len - 1] == '\t' && --len == 0)) {
+	    return;
+	}
+
+	stylePtr = chunkPtr->stylePtr;
+	sValuePtr = stylePtr->sValuePtr;
+	ciPtr = chunkPtr->clientData;
+	xDisplacement = x - chunkPtr->x;
+	fgGC = GetForegroundGC(textPtr, chunkPtr);
+
+	/*
+	 * Draw the text, underline, and overstrike for this chunk.
+	 */
+
+	DrawCharsInContext(display, dst, fgGC, sValuePtr->tkfont, string, numBytes,
+		start, len, baseChunkPtr->x + xDisplacement, y - sValuePtr->offset,
+		chunkPtr->x + textPtr->dInfoPtr->x);
+
+	if (sValuePtr->underline) {
+	    TkUnderlineCharsInContext(display, dst, stylePtr->ulGC, sValuePtr->tkfont, string,
+		    numBytes, baseChunkPtr->x + xDisplacement, y - sValuePtr->offset,
+		    start, start + len);
+	}
+	if (sValuePtr->overstrike) {
+	    Tk_FontMetrics fm;
+
+	    Tk_GetFontMetrics(sValuePtr->tkfont, &fm);
+	    TkUnderlineCharsInContext(display, dst, stylePtr->ovGC, sValuePtr->tkfont, string,
+		    numBytes, baseChunkPtr->x + xDisplacement,
+		    y - sValuePtr->offset - fm.descent - (fm.ascent*3)/10,
+		    start, start + len);
+	}
+    }
+}
+
+#else /* if !TK_DRAW_IN_CONTEXT */
+
+static void
+DrawChars(
+    TkText *textPtr,
+    TkTextDispChunk *chunkPtr,	/* Display the content of this chunk. */
+    int x,			/* X-position in dst at which to draw. */
+    int y,			/* Y-position at which to draw. */
+    int offsetX,		/* Offset from x. */
+    int offsetBytes,		/* Offset in display string. */
+    Display *display,		/* Display to use for drawing. */
+    Drawable dst)		/* Pixmap or window in which to draw chunk. */
+{
+    const CharInfo *ciPtr;
+    int numBytes;
+
+    ciPtr = chunkPtr->clientData;
+    numBytes = ciPtr->numBytes;
+
+    assert(offsetBytes >= ciPtr->baseOffset);
+
+    if (numBytes > offsetBytes) {
+	const TextStyle *stylePtr = chunkPtr->stylePtr;
+
+	if (stylePtr->fgGC != None) {
+	    const StyleValues *sValuePtr;
+	    const char *string;
+	    GC fgGC;
+
+	    string = ciPtr->u.chars + offsetBytes;
+	    numBytes -= offsetBytes;
+
+	    if (string[numBytes - 1] == '\t' && --numBytes == 0) {
+		return;
+	    }
+
+	    sValuePtr = stylePtr->sValuePtr;
+	    fgGC = GetForegroundGC(textPtr, chunkPtr);
+
+	    /*
+	     * Draw the text, underline, and overstrike for this chunk.
+	     */
+
+	    Tk_DrawChars(display, dst, fgGC, sValuePtr->tkfont, string, numBytes,
+		    offsetX, y - sValuePtr->offset);
+	    if (sValuePtr->underline) {
+		Tk_UnderlineChars(display, dst, stylePtr->ulGC, sValuePtr->tkfont,
+			string, offsetX, y - sValuePtr->offset, 0, numBytes);
+
+	    }
+	    if (sValuePtr->overstrike) {
+		Tk_FontMetrics fm;
+
+		Tk_GetFontMetrics(sValuePtr->tkfont, &fm);
+		Tk_UnderlineChars(display, dst, stylePtr->ovGC, sValuePtr->tkfont, string, offsetX,
+			y - sValuePtr->offset - fm.descent - (fm.ascent*3)/10, 0, numBytes);
+	    }
+	}
+    }
+}
+
+#endif /* TK_DRAW_IN_CONTEXT */
+
+static void
+DisplayChars(
+    TkText *textPtr,
+    TkTextDispChunk *chunkPtr,	/* Display the content of this chunk. */
+    int x,			/* X-position in dst at which to draw. */
+    int y,			/* Y-position at which to draw. */
+    int baseline,		/* Offset of baseline from y. */
+    Display *display,		/* Display to use for drawing. */
+    Drawable dst)		/* Pixmap or window in which to draw chunk. */
+{
+    const TextStyle *stylePtr = chunkPtr->stylePtr;
+    int offsetBytes, offsetX;
+
+    assert(!stylePtr->sValuePtr->elide);
+
+    if (stylePtr->fgGC == None) {
+	return;
+    }
+
+    /*
+     * If the text sticks out way to the left of the window, skip over the
+     * characters that aren't in the visible part of the window. This is
+     * essential if x is very negative (such as less than 32K); otherwise
+     * overflow problems will occur in servers that use 16-bit arithmetic,
+     * like X.
+     */
+
+    offsetX = x;
+    offsetBytes = (x >= 0) ? CharChunkMeasureChars(chunkPtr, NULL, 0, 0, -1, x, 0, 0, &offsetX) : 0;
+    DrawChars(textPtr, chunkPtr, x, y + baseline, offsetX, offsetBytes, display, dst);
+}
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 105
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: src/tktext/tkTextImage.c
===================================================================
--- src/tktext/tkTextImage.c	(revision 0)
+++ src/tktext/tkTextImage.c	(working copy)
@@ -0,0 +1,1416 @@
+/*
+ * tkImage.c --
+ *
+ *	This file contains code that allows images to be nested inside text
+ *	widgets. It also implements the "image" widget command for texts.
+ *
+ * Copyright (c) 1997 Sun Microsystems, Inc.
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkPort.h"
+#include "tkText.h"
+#include "tkTextTagSet.h"
+#include "tkTextUndo.h"
+#include <assert.h>
+
+#ifndef MIN
+# define MIN(a,b) ((a) < (b) ? a : b)
+#endif
+#ifndef MAX
+# define MAX(a,b) ((a) < (b) ? b : a)
+#endif
+
+#if NDEBUG
+# define DEBUG(expr)
+#else
+# define DEBUG(expr) expr
+#endif
+
+/*
+ * Support of tk8.5.
+ */
+#ifdef CONST
+# undef CONST
+#endif
+#if TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION == 5
+# define CONST
+#else
+# define CONST const
+#endif
+
+/*
+ * Prototypes for functions defined in this file:
+ */
+
+static void		EmbImageCheckProc(const TkSharedText *sharedTextPtr,
+			    const TkTextSegment *segPtr);
+static Tcl_Obj *	EmbImageInspectProc(const TkSharedText *sharedTextPtr,
+			    const TkTextSegment *segPtr);
+static void		EmbImageBboxProc(TkText *textPtr, TkTextDispChunk *chunkPtr, int index, int y,
+			    int lineHeight, int baseline, int *xPtr, int *yPtr, int *widthPtr,
+			    int *heightPtr);
+static int		EmbImageConfigure(TkText *textPtr, TkTextSegment *eiPtr, int *maskPtr, int objc,
+			    Tcl_Obj *const objv[]);
+static bool		EmbImageDeleteProc(TkTextBTree tree, TkTextSegment *segPtr, int treeGone);
+static void		EmbImageRestoreProc(TkTextSegment *segPtr);
+static void		EmbImageDisplayProc(TkText *textPtr, TkTextDispChunk *chunkPtr, int x, int y,
+			    int lineHeight, int baseline, Display *display, Drawable dst, int screenY);
+static int		EmbImageLayoutProc(const TkTextIndex *indexPtr, TkTextSegment *segPtr,
+			    int offset, int maxX, int maxChars, bool noCharsYet, TkWrapMode wrapMode,
+			    TkTextSpaceMode spaceMode, TkTextDispChunk *chunkPtr);
+static void		EmbImageProc(ClientData clientData, int x, int y, int width, int height,
+			    int imageWidth, int imageHeight);
+static TkTextSegment *	MakeImage(TkText *textPtr);
+static void		ReleaseImage(TkTextSegment *eiPtr);
+
+static const TkTextDispChunkProcs layoutImageProcs = {
+    TEXT_DISP_IMAGE,		/* type */
+    EmbImageDisplayProc,	/* displayProc */
+    NULL,			/* undisplayProc */
+    NULL,			/* measureProc */
+    EmbImageBboxProc,	        /* bboxProc */
+};
+
+/*
+ * We need some private undo/redo stuff.
+ */
+
+static void UndoLinkSegmentPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void RedoLinkSegmentPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void UndoLinkSegmentDestroy(TkSharedText *, TkTextUndoToken *, bool);
+static void UndoLinkSegmentGetRange(const TkSharedText *, const TkTextUndoToken *,
+	TkTextIndex *, TkTextIndex *);
+static void RedoLinkSegmentGetRange(const TkSharedText *, const TkTextUndoToken *,
+	TkTextIndex *, TkTextIndex *);
+static Tcl_Obj *UndoLinkSegmentGetCommand(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *UndoLinkSegmentInspect(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *RedoLinkSegmentInspect(const TkSharedText *, const TkTextUndoToken *);
+
+static const Tk_UndoType undoTokenLinkSegmentType = {
+    TK_TEXT_UNDO_IMAGE,		/* action */
+    UndoLinkSegmentGetCommand,	/* commandProc */
+    UndoLinkSegmentPerform,	/* undoProc */
+    UndoLinkSegmentDestroy,	/* destroyProc */
+    UndoLinkSegmentGetRange,	/* rangeProc */
+    UndoLinkSegmentInspect	/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenLinkSegmentType = {
+    TK_TEXT_REDO_IMAGE,		/* action */
+    UndoLinkSegmentGetCommand,	/* commandProc */
+    RedoLinkSegmentPerform,	/* undoProc */
+    UndoLinkSegmentDestroy,	/* destroyProc */
+    RedoLinkSegmentGetRange,	/* rangeProc */
+    RedoLinkSegmentInspect	/* inspectProc */
+};
+
+typedef struct UndoTokenLinkSegment {
+    const Tk_UndoType *undoType;
+    TkTextSegment *segPtr;
+} UndoTokenLinkSegment;
+
+typedef struct RedoTokenLinkSegment {
+    const Tk_UndoType *undoType;
+    TkTextSegment *segPtr;
+    TkTextUndoIndex index;
+} RedoTokenLinkSegment;
+
+/*
+ * The following structure declares the "embedded image" segment type.
+ */
+
+const Tk_SegType tkTextEmbImageType = {
+    "image",			/* name */
+    SEG_GROUP_IMAGE,		/* group */
+    GRAVITY_NEUTRAL,		/* gravity */
+    EmbImageDeleteProc,		/* deleteProc */
+    EmbImageRestoreProc,	/* restoreProc */
+    EmbImageLayoutProc,		/* layoutProc */
+    EmbImageCheckProc,		/* checkProc */
+    EmbImageInspectProc		/* inspectProc */
+};
+
+/*
+ * Definitions for alignment values:
+ */
+
+static const char *CONST alignStrings[] = {
+    "baseline", "bottom", "center", "top", NULL
+};
+
+typedef enum {
+    ALIGN_BASELINE, ALIGN_BOTTOM, ALIGN_CENTER, ALIGN_TOP
+} alignMode;
+
+/*
+ * Information used for parsing image configuration options:
+ */
+
+static const Tk_OptionSpec optionSpecs[] = {
+    {TK_OPTION_STRING_TABLE, "-align", NULL, NULL,
+	"center", -1, Tk_Offset(TkTextEmbImage, align), 0, alignStrings, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_PIXELS, "-padx", NULL, NULL,
+	"0", -1, Tk_Offset(TkTextEmbImage, padX), 0, 0, 0},
+    {TK_OPTION_PIXELS, "-pady", NULL, NULL,
+	"0", -1, Tk_Offset(TkTextEmbImage, padY), 0, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_STRING, "-image", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextEmbImage, imageString), TK_OPTION_NULL_OK, 0, TK_TEXT_LINE_GEOMETRY},
+    {TK_OPTION_STRING, "-name", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextEmbImage, imageName), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_END, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0}
+};
+
+DEBUG_ALLOC(extern unsigned tkTextCountDestroySegment);
+DEBUG_ALLOC(extern unsigned tkTextCountNewUndoToken);
+DEBUG_ALLOC(extern unsigned tkTextCountNewSegment);
+
+/*
+ * Some helper functions.
+ */
+
+static void
+TextChanged(
+    TkSharedText *sharedTextPtr,
+    TkTextIndex *indexPtr,
+    int mask)
+{
+    TkTextChanged(sharedTextPtr, NULL, indexPtr, indexPtr);
+
+    if (mask & TK_TEXT_LINE_GEOMETRY) {
+	TkTextInvalidateLineMetrics(sharedTextPtr, NULL,
+		TkTextIndexGetLine(indexPtr), 0, TK_TEXT_INVALIDATE_ONLY);
+    }
+}
+
+static void
+GetIndex(
+    const TkSharedText *sharedTextPtr,
+    TkTextSegment *segPtr,
+    TkTextIndex *indexPtr)
+{
+    TkTextIndexClear2(indexPtr, NULL, sharedTextPtr->tree);
+    TkTextIndexSetSegment(indexPtr, segPtr);
+}
+
+/*
+ * Some functions for the undo/redo mechanism.
+ */
+
+static Tcl_Obj *
+UndoLinkSegmentGetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("image", -1));
+    return objPtr;
+}
+
+static Tcl_Obj *
+UndoLinkSegmentInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenLinkSegment *token = (const UndoTokenLinkSegment *) item;
+    Tcl_Obj *objPtr = UndoLinkSegmentGetCommand(sharedTextPtr, item);
+    char buf[TK_POS_CHARS];
+    TkTextIndex index;
+
+    GetIndex(sharedTextPtr, token->segPtr, &index);
+    TkTextIndexPrint(sharedTextPtr, NULL, &index, buf);
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(buf, -1));
+    return objPtr;
+}
+
+static void
+UndoLinkSegmentPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    const UndoTokenLinkSegment *token = (const UndoTokenLinkSegment *) undoInfo->token;
+    TkTextSegment *segPtr = token->segPtr;
+    TkTextIndex index;
+
+    if (redoInfo) {
+	RedoTokenLinkSegment *redoToken;
+	redoToken = malloc(sizeof(RedoTokenLinkSegment));
+	redoToken->undoType = &redoTokenLinkSegmentType;
+	TkBTreeMakeUndoIndex(sharedTextPtr, segPtr, &redoToken->index);
+	redoInfo->token = (TkTextUndoToken *) redoToken;
+	(redoToken->segPtr = segPtr)->refCount += 1;
+	DEBUG_ALLOC(tkTextCountNewUndoToken++);
+    }
+
+    GetIndex(sharedTextPtr, segPtr, &index);
+    TextChanged(sharedTextPtr, &index, TK_TEXT_LINE_GEOMETRY);
+    TkBTreeUnlinkSegment(sharedTextPtr, segPtr);
+    EmbImageDeleteProc(sharedTextPtr->tree, segPtr, 0);
+    TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+}
+
+static void
+UndoLinkSegmentDestroy(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *item,
+    bool reused)
+{
+    UndoTokenLinkSegment *token = (UndoTokenLinkSegment *) item;
+
+    assert(!reused);
+
+    if (--token->segPtr->refCount == 0) {
+	ReleaseImage(token->segPtr);
+    }
+}
+
+static void
+UndoLinkSegmentGetRange(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item,
+    TkTextIndex *startIndex,
+    TkTextIndex *endIndex)
+{
+    const UndoTokenLinkSegment *token = (const UndoTokenLinkSegment *) item;
+
+    GetIndex(sharedTextPtr, token->segPtr, startIndex);
+    *endIndex = *startIndex;
+}
+
+static Tcl_Obj *
+RedoLinkSegmentInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const RedoTokenLinkSegment *token = (const RedoTokenLinkSegment *) item;
+    Tcl_Obj *objPtr = EmbImageInspectProc(sharedTextPtr, token->segPtr);
+    char buf[TK_POS_CHARS];
+    TkTextIndex index;
+    Tcl_Obj *idxPtr;
+
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->index, &index);
+    TkTextIndexPrint(sharedTextPtr, NULL, &index, buf);
+    idxPtr = Tcl_NewStringObj(buf, -1);
+    Tcl_ListObjReplace(NULL, objPtr, 0, 0, 1, &idxPtr);
+    return objPtr;
+}
+
+static void
+RedoLinkSegmentPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    RedoTokenLinkSegment *token = (RedoTokenLinkSegment *) undoInfo->token;
+    TkTextIndex index;
+
+    TkBTreeReInsertSegment(sharedTextPtr, &token->index, token->segPtr);
+
+    if (redoInfo) {
+	redoInfo->token = undoInfo->token;
+	token->undoType = &undoTokenLinkSegmentType;
+    }
+
+    GetIndex(sharedTextPtr, token->segPtr, &index);
+    TextChanged(sharedTextPtr, &index, TK_TEXT_LINE_GEOMETRY);
+    token->segPtr->refCount += 1;
+    TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+}
+
+static void
+RedoLinkSegmentGetRange(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item,
+    TkTextIndex *startIndex,
+    TkTextIndex *endIndex)
+{
+    const RedoTokenLinkSegment *token = (const RedoTokenLinkSegment *) item;
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->index, startIndex);
+    *endIndex = *startIndex;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextImageCmd --
+ *
+ *	This function implements the "image" widget command for text widgets.
+ *	See the user documentation for details on what it does.
+ *
+ * Results:
+ *	A standard Tcl result or error.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+Displayed(
+    const TkTextEmbImage *img,
+    const TkText *peer)
+{
+    return peer->pixelReference < img->numClients
+	    && !TkQTreeRectIsEmpty(&img->bbox[peer->pixelReference]);
+}
+
+int
+TkTextImageCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already
+				 * parsed this command enough to know that
+				 * objv[1] is "image". */
+{
+    int idx;
+    TkTextSegment *eiPtr;
+    TkSharedText *sharedTextPtr;
+    TkTextIndex index;
+    static const char *CONST optionStrings[] = {
+	"bind", "cget", "configure", "create", "names", NULL
+    };
+    enum opts {
+	CMD_BIND, CMD_CGET, CMD_CONF, CMD_CREATE, CMD_NAMES
+    };
+
+    if (objc < 3) {
+	Tcl_WrongNumArgs(interp, 2, objv, "option ?arg arg ...?");
+	return TCL_ERROR;
+    }
+    if (Tcl_GetIndexFromObj(interp, objv[2], optionStrings, "option", 0, &idx) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+
+    switch ((enum opts) idx) {
+    case CMD_BIND: {
+	TkTextEmbImage *img;
+	int rc;
+
+	if (objc < 4 || objc > 6) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "index ?sequence? ?command?");
+	    return TCL_ERROR;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[3], &index)) {
+	    return TCL_ERROR;
+	}
+	eiPtr = TkTextIndexGetContentSegment(&index, NULL);
+	if (eiPtr->typePtr != &tkTextEmbImageType) {
+	    Tcl_AppendResult(interp, "no embedded image at index \"",
+		    Tcl_GetString(objv[3]), "\"", NULL);
+	    Tcl_SetErrorCode(interp, "TK", "TEXT", "NO_IMAGE", NULL);
+	    return TCL_ERROR;
+	}
+	img = &eiPtr->body.ei;
+	rc = TkTextBindEvent(interp, objc - 4, objv + 4, sharedTextPtr,
+		&sharedTextPtr->imageBindingTable, img->name);
+	if (rc == TCL_OK && !img->haveBindings) {
+	    img->haveBindings = true;
+
+	    if (!textPtr->imageBboxTree) {
+		TkText *peer;
+
+		for (peer = sharedTextPtr->peers; peer; peer = peer->next) {
+		    if (Displayed(img, peer)) {
+			TkQTreeRect bbox;
+			int dx, dy;
+
+			/*
+			 * This image is already displayed, so we have to insert the bounding
+			 * box of this image in the lookup tree, but this tree must be
+			 * configured before we can add the bbox.
+			 */
+
+			TkTextGetViewOffset(peer, &dx, &dy);
+			TkQTreeRectSet(&bbox, dx, dy,
+				Tk_Width(peer->tkwin) + dx, Tk_Height(peer->tkwin) + dy);
+			TkQTreeConfigure(&peer->imageBboxTree, &bbox);
+			peer->configureBboxTree = false;
+			TkQTreeInsertRect(peer->imageBboxTree, &img->bbox[peer->pixelReference],
+				(TkQTreeUid) img, 0);
+		    } else if (!peer->imageBboxTree) {
+			peer->configureBboxTree = true;
+		    }
+		}
+	    }
+	}
+	return rc;
+    }
+    case CMD_CGET: {
+	Tcl_Obj *objPtr;
+
+	if (objc != 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "index option");
+	    return TCL_ERROR;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[3], &index)) {
+	    return TCL_ERROR;
+	}
+	eiPtr = TkTextIndexGetContentSegment(&index, NULL);
+	if (eiPtr->typePtr != &tkTextEmbImageType) {
+	    Tcl_AppendResult(interp, "no embedded image at index \"",
+		    Tcl_GetString(objv[3]), "\"", NULL);
+	    return TCL_ERROR;
+	}
+	objPtr = Tk_GetOptionValue(interp, (char *) &eiPtr->body.ei,
+		eiPtr->body.ei.optionTable, objv[4], textPtr->tkwin);
+	if (!objPtr) {
+	    return TCL_ERROR;
+	} else {
+	    Tcl_SetObjResult(interp, objPtr);
+	    return TCL_OK;
+	}
+    }
+    case CMD_CONF:
+	if (objc < 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "index ?option value ...?");
+	    return TCL_ERROR;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[3], &index)) {
+	    return TCL_ERROR;
+	}
+	eiPtr = TkTextIndexGetContentSegment(&index, NULL);
+	if (eiPtr->typePtr != &tkTextEmbImageType) {
+	    Tcl_AppendResult(interp, "no embedded image at index \"",
+		    Tcl_GetString(objv[3]), "\"", NULL);
+	    return TCL_ERROR;
+	}
+	if (objc <= 5) {
+	    Tcl_Obj *objPtr = Tk_GetOptionInfo(interp,
+		    (char *) &eiPtr->body.ei, eiPtr->body.ei.optionTable,
+		    objc == 5 ? objv[4] : NULL, textPtr->tkwin);
+
+	    if (!objPtr) {
+		return TCL_ERROR;
+	    } else {
+		Tcl_SetObjResult(interp, objPtr);
+		return TCL_OK;
+	    }
+	} else {
+	    int mask;
+	    int rc = EmbImageConfigure(textPtr, eiPtr, &mask, objc - 4, objv + 4);
+	    TextChanged(sharedTextPtr, &index, mask);
+	    return rc;
+	}
+    case CMD_CREATE: {
+	    int mask;
+
+	    /*
+	     * Add a new image. Find where to put the new image, and mark that
+	     * position for redisplay.
+	     */
+
+	    if (objc < 4) {
+		Tcl_WrongNumArgs(interp, 3, objv, "index ?option value ...?");
+		return TCL_ERROR;
+	    }
+	    if (!TkTextGetIndexFromObj(interp, textPtr, objv[3], &index)) {
+		return TCL_ERROR;
+	    }
+
+	    if (textPtr->state == TK_TEXT_STATE_DISABLED) {
+#if !SUPPORT_DEPRECATED_MODS_OF_DISABLED_WIDGET
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf("attempt to modify disabled widget"));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "NOT_ALLOWED", NULL);
+		return TCL_ERROR;
+#endif /* SUPPORT_DEPRECATED_MODS_OF_DISABLED_WIDGET */
+	    }
+
+	    /*
+	     * Don't allow insertions on the last line of the text.
+	     */
+
+	    if (!TkTextIndexEnsureBeforeLastChar(&index)) {
+#if SUPPORT_DEPRECATED_MODS_OF_DISABLED_WIDGET
+		return TCL_OK;
+#else
+		Tcl_SetObjResult(textPtr->interp, Tcl_NewStringObj(
+			"cannot insert image into dead peer", -1));
+		Tcl_SetErrorCode(textPtr->interp, "TK", "TEXT", "IMAGE_CREATE_USAGE", NULL);
+		return TCL_ERROR;
+#endif
+	    }
+
+	    /*
+	     * Create the new image segment and initialize it.
+	     */
+
+	    eiPtr = MakeImage(textPtr);
+
+	    /*
+	     * Link the segment into the text widget, then configure it (delete it
+	     * again if the configuration fails).
+	     */
+
+	    TkBTreeLinkSegment(sharedTextPtr, eiPtr, &index);
+	    if (EmbImageConfigure(textPtr, eiPtr, &mask, objc - 4, objv + 4) != TCL_OK) {
+		TkBTreeUnlinkSegment(sharedTextPtr, eiPtr);
+		EmbImageDeleteProc(sharedTextPtr->tree, eiPtr, 0);
+		return TCL_ERROR;
+	    }
+	    TextChanged(sharedTextPtr, &index, mask);
+
+	    if (!TkTextUndoStackIsFull(sharedTextPtr->undoStack)) {
+		UndoTokenLinkSegment *token;
+
+		assert(sharedTextPtr->undoStack);
+		assert(eiPtr->typePtr == &tkTextEmbImageType);
+
+		token = malloc(sizeof(UndoTokenLinkSegment));
+		token->undoType = &undoTokenLinkSegmentType;
+		token->segPtr = eiPtr;
+		eiPtr->refCount += 1;
+		DEBUG_ALLOC(tkTextCountNewUndoToken++);
+
+		TkTextPushUndoToken(sharedTextPtr, token, 0);
+	    }
+
+	    TkTextUpdateAlteredFlag(sharedTextPtr);
+	}
+	return TCL_OK;
+    case CMD_NAMES: {
+	Tcl_HashSearch search;
+	Tcl_HashEntry *hPtr;
+
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	    return TCL_ERROR;
+	}
+	for (hPtr = Tcl_FirstHashEntry(&sharedTextPtr->imageTable, &search);
+		hPtr;
+		hPtr = Tcl_NextHashEntry(&search)) {
+	    Tcl_AppendElement(interp, Tcl_GetHashKey(&sharedTextPtr->imageTable, hPtr));
+	}
+	return TCL_OK;
+    }
+    }
+    assert(!"unexpected switch fallthrough");
+    return TCL_ERROR; /* shouldn't be reached */
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextImageAddClient --
+ *
+ *	This function is called to provide the image binding
+ *	support of a client.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+void
+TkTextImageAddClient(
+    TkSharedText *sharedTextPtr,
+    TkText *textPtr)
+{
+    Tcl_HashSearch search;
+    Tcl_HashEntry *hPtr;
+    TkText *peer;
+
+    for (peer = sharedTextPtr->peers; peer; peer = peer->next) {
+	if (peer != textPtr && (peer->imageBboxTree || peer->configureBboxTree)) {
+	    textPtr->configureBboxTree = true;
+	}
+    }
+
+    for (hPtr = Tcl_FirstHashEntry(&sharedTextPtr->imageTable, &search);
+	    hPtr;
+	    hPtr = Tcl_NextHashEntry(&search)) {
+	TkTextSegment *eiPtr = Tcl_GetHashValue(hPtr);
+	TkTextEmbImage *img = &eiPtr->body.ei;
+
+	if (img->numClients > textPtr->pixelReference) {
+	    memset(&img->bbox[textPtr->pixelReference], 0, sizeof(img->bbox[0]));
+	}
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MakeImage --
+ *
+ *	This function is called to create an image segment.
+ *
+ * Results:
+ *	The return value is the newly created image.
+ *
+ * Side effects:
+ *	Some memory will be allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextSegment *
+MakeImage(
+    TkText *textPtr)		/* Information about text widget that contains embedded image. */
+{
+    TkTextSegment *eiPtr;
+
+    eiPtr = memset(malloc(SEG_SIZE(TkTextEmbImage)), 0, SEG_SIZE(TkTextEmbImage));
+    eiPtr->typePtr = &tkTextEmbImageType;
+    eiPtr->size = 1;
+    eiPtr->refCount = 1;
+    eiPtr->body.ei.sharedTextPtr = textPtr->sharedTextPtr;
+    eiPtr->body.ei.align = ALIGN_CENTER;
+    eiPtr->body.ei.optionTable = Tk_CreateOptionTable(textPtr->interp, optionSpecs);
+    DEBUG_ALLOC(tkTextCountNewSegment++);
+
+    return eiPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextMakeImage --
+ *
+ *	This function is called to create an image segment.
+ *
+ * Results:
+ *	The return value is a standard Tcl result. If TCL_ERROR is returned,
+ *	then the interp's result contains an error message.
+ *
+ * Side effects:
+ *	Some memory will be allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+TkTextSegment *
+TkTextMakeImage(
+    TkText *textPtr,		/* Information about text widget that contains embedded image. */
+    Tcl_Obj *options)		/* Options for this image. */
+{
+    TkTextSegment *eiPtr;
+    Tcl_Obj **objv;
+    int objc;
+
+    assert(options);
+
+    if (Tcl_ListObjGetElements(textPtr->interp, options, &objc, &objv) != TCL_OK) {
+	return NULL;
+    }
+
+    eiPtr = MakeImage(textPtr);
+
+    if (EmbImageConfigure(textPtr, eiPtr, NULL, objc, objv) == TCL_OK) {
+	Tcl_ResetResult(textPtr->interp);
+    } else {
+	EmbImageDeleteProc(textPtr->sharedTextPtr->tree, eiPtr, 0);
+	eiPtr = NULL;
+    }
+
+    return eiPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbImageConfigure --
+ *
+ *	This function is called to handle configuration options for an
+ *	embedded image, using an objc/objv list.
+ *
+ * Results:
+ *	The return value is a standard Tcl result. If TCL_ERROR is returned,
+ *	then the interp's result contains an error message.
+ *
+ * Side effects:
+ *	Configuration information for the embedded image changes, such as
+ *	alignment, or name of the image.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+SetImageName(
+    TkText *textPtr,
+    TkTextSegment *eiPtr,
+    const char *name)
+{
+    Tcl_DString newName;
+    TkTextEmbImage *img;
+    int dummy, length;
+
+    assert(name);
+    assert(!eiPtr->body.ei.name);
+    assert(!eiPtr->body.ei.hPtr);
+
+    /*
+     * Create an unique name for this image.
+     */
+
+    Tcl_DStringInit(&newName);
+    while (Tcl_FindHashEntry(&textPtr->sharedTextPtr->imageTable, name)) {
+	char buf[4 + TCL_INTEGER_SPACE];
+	snprintf(buf, sizeof(buf), "#%d", ++textPtr->sharedTextPtr->imageCount);
+	Tcl_DStringTrunc(&newName, 0);
+	Tcl_DStringAppend(&newName, name, -1);
+	Tcl_DStringAppend(&newName, buf, -1);
+	name = Tcl_DStringValue(&newName);
+    }
+    length = strlen(name);
+
+    img = &eiPtr->body.ei;
+    img->hPtr = Tcl_CreateHashEntry(&textPtr->sharedTextPtr->imageTable, name, &dummy);
+    textPtr->sharedTextPtr->numImages += 1;
+    Tcl_SetHashValue(img->hPtr, eiPtr);
+    img->name = malloc(length + 1);
+    memcpy(img->name, name, length + 1);
+    Tcl_SetObjResult(textPtr->interp, Tcl_NewStringObj(name, -1));
+    Tcl_DStringFree(&newName);
+}
+
+static int
+EmbImageConfigure(
+    TkText *textPtr,		/* Information about text widget that contains embedded image. */
+    TkTextSegment *eiPtr,	/* Embedded image to be configured. */
+    int *maskPtr,		/* Return the bit-wise OR of the typeMask fields of affected options,
+    				 * can be NULL. */
+    int objc,			/* Number of strings in objv. */
+    Tcl_Obj *const objv[])	/* Array of strings describing configuration options. */
+{
+    Tk_Image image;
+    char *name;
+    int width;
+    TkTextEmbImage *img = &eiPtr->body.ei;
+
+    if (maskPtr) {
+	*maskPtr = 0;
+    }
+
+    if (Tk_SetOptions(textPtr->interp, (char *) img, img->optionTable, objc, objv, textPtr->tkwin,
+		NULL, maskPtr) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    /*
+     * Create the image. Save the old image around and don't free it until
+     * after the new one is allocated. This keeps the reference count from
+     * going to zero so the image doesn't have to be recreated if it hasn't
+     * changed.
+     */
+
+    if (img->imageString) {
+	image = Tk_GetImage(textPtr->interp, textPtr->tkwin, img->imageString, EmbImageProc, eiPtr);
+	if (!image) {
+	    return TCL_ERROR;
+	}
+    } else {
+	image = NULL;
+    }
+    if (img->image) {
+	Tk_FreeImage(img->image);
+    }
+    if ((img->image = image)) {
+	Tk_SizeOfImage(image, &width, &img->imgHeight);
+    }
+
+    if (!img->name) {
+	if (!(name = img->imageName) && !(name = img->imageString)) {
+	    Tcl_SetObjResult(textPtr->interp, Tcl_NewStringObj(
+		    "Either a \"-name\" or a \"-image\" argument must be"
+		    " provided to the \"image create\" subcommand", -1));
+	    Tcl_SetErrorCode(textPtr->interp, "TK", "TEXT", "IMAGE_CREATE_USAGE", NULL);
+	    return TCL_ERROR;
+	}
+
+	Tcl_SetObjResult(textPtr->interp, Tcl_NewStringObj(img->name, -1));
+	SetImageName(textPtr, eiPtr, name);
+    }
+
+    return TCL_OK;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbImageInspectProc --
+ *
+ *	This function is invoked to build the information for
+ *	"inspect".
+ *
+ * Results:
+ *	Return a TCL object containing the information for
+ *	"inspect".
+ *
+ * Side effects:
+ *	Storage is allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+EmbImageInspectProc(
+    const TkSharedText *sharedTextPtr,
+    const TkTextSegment *segPtr)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    Tcl_Obj *objPtr2 = Tcl_NewObj();
+    TkTextTag **tagLookup = sharedTextPtr->tagLookup;
+    const TkTextTagSet *tagInfoPtr = segPtr->tagInfoPtr;
+    unsigned i = TkTextTagSetFindFirst(tagInfoPtr);
+    const TkTextEmbImage *img = &segPtr->body.ei;
+    Tcl_DString opts;
+
+    assert(sharedTextPtr->peers);
+
+    for ( ; i != TK_TEXT_TAG_SET_NPOS; i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	const TkTextTag *tagPtr = tagLookup[i];
+	Tcl_ListObjAppendElement(NULL, objPtr2, Tcl_NewStringObj(tagPtr->name, -1));
+    }
+
+    Tcl_DStringInit(&opts);
+    TkTextInspectOptions(sharedTextPtr->peers, &segPtr->body.ei, segPtr->body.ei.optionTable,
+	    &opts, false, false);
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(segPtr->typePtr->name, -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(img->name, -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, objPtr2);
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(Tcl_DStringValue(&opts),
+	    Tcl_DStringLength(&opts)));
+
+    Tcl_DStringFree(&opts);
+    return objPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * ReleaseImage --
+ *
+ *	This function is releasing the embedded image all it's
+ *	associated resources.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The embedded image is deleted, and any resources
+ *	associated with it are released.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+ReleaseImage(
+    TkTextSegment *eiPtr)
+{
+    TkTextEmbImage *img = &eiPtr->body.ei;
+
+    if (img->image) {
+	Tk_FreeImage(img->image);
+    }
+    if (img->sharedTextPtr->imageBindingTable) {
+	Tk_DeleteAllBindings(img->sharedTextPtr->imageBindingTable, (ClientData) img->name);
+    }
+
+    /*
+     * No need to supply a tkwin argument, since we have no window-specific options.
+     */
+
+    Tk_FreeConfigOptions((char *) img, img->optionTable, NULL);
+    if (img->name) {
+	free(img->name);
+    }
+    if (img->bbox) {
+	free(img->bbox);
+    }
+    TkTextTagSetDecrRefCount(eiPtr->tagInfoPtr);
+    FREE_SEGMENT(eiPtr);
+    DEBUG_ALLOC(tkTextCountDestroySegment++);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbImageDeleteProc --
+ *
+ *	This function is invoked by the text B-tree code whenever an
+ *	embedded image lies in a range of characters being deleted.
+ *
+ * Results:
+ *	Returns true to indicate that the deletion has been accepted.
+ *
+ * Side effects:
+ *	The embedded image is deleted, if it exists, and any resources
+ *	associated with it are released.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+EmbImageDeleteProc(
+    TkTextBTree tree,
+    TkTextSegment *eiPtr,	/* Segment being deleted. */
+    int flags)			/* Flags controlling the deletion. */
+{
+    TkTextEmbImage *img = &eiPtr->body.ei;
+
+    assert(eiPtr->refCount > 0);
+
+    if (img->hPtr) {
+	img->sharedTextPtr->numImages -= 1;
+	Tcl_DeleteHashEntry(img->hPtr);
+	img->hPtr = NULL;
+    }
+
+    /*
+     * Remove this image from bounding box tree in all peers, and clear
+     * the information about the currently hovered image if necessary.
+     */
+
+    if (img->haveBindings) {
+	TkText *peer = img->sharedTextPtr->peers;
+
+	for ( ; peer; peer = peer->next) {
+	    if (!(peer->flags & DESTROYED && Displayed(img, peer))) {
+		if (peer->hoveredImageArrSize) {
+		    unsigned i;
+
+		    for (i = 0; i < peer->hoveredImageArrSize; ++i) {
+			if (peer->hoveredImageArr[i] == img) {
+			    /*
+			     * One problem here, the mouse leave event will not be
+			     * triggered anymore. The user should avoid this situation.
+			     */
+			    memmove(peer->hoveredImageArr + i, peer->hoveredImageArr + i + 1,
+				    --peer->hoveredImageArrSize - i);
+			    break;
+			}
+		    }
+		}
+		if (peer->imageBboxTree) {
+		    TkQTreeDeleteRect(peer->imageBboxTree, &img->bbox[peer->pixelReference],
+			    (TkQTreeUid) img);
+		}
+	    }
+	}
+    }
+
+    if (--eiPtr->refCount == 0) {
+	ReleaseImage(eiPtr);
+    }
+
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbImageRestoreProc --
+ *
+ *	This function is called when an image segment will be
+ *	restored from the undo chain.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The name of the mark will be freed, and the mark will be
+ *	re-entered into the hash table.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbImageRestoreProc(
+    TkTextSegment *eiPtr)	/* Segment to reuse. */
+{
+    TkTextEmbImage *img = &eiPtr->body.ei;
+    int isNew;
+
+    if (img->image) {
+	assert(!img->hPtr);
+	img->hPtr = Tcl_CreateHashEntry(&img->sharedTextPtr->imageTable, img->name, &isNew);
+	img->sharedTextPtr->numImages += 1;
+	assert(isNew);
+	Tcl_SetHashValue(img->hPtr, eiPtr);
+    }
+    if (img->bbox) {
+	memset(img->bbox, 0, img->numClients * sizeof(img->bbox[0]));
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbImageLayoutProc --
+ *
+ *	This function is the "layoutProc" for embedded image segments.
+ *
+ * Results:
+ *	1 is returned to indicate that the segment should be displayed. The
+ *	chunkPtr structure is filled in.
+ *
+ * Side effects:
+ *	None, except for filling in chunkPtr.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+EmbImageLayoutProc(
+    const TkTextIndex *indexPtr,/* Identifies first character in chunk. */
+    TkTextSegment *eiPtr,	/* Segment corresponding to indexPtr. */
+    int offset,			/* Offset within segPtr corresponding to indexPtr (always 0). */
+    int maxX,			/* Chunk must not occupy pixels at this position or higher. */
+    int maxChars,		/* Chunk must not include more than this many characters. */
+    bool noCharsYet,		/* 'true' means no characters have been assigned to this line yet. */
+    TkWrapMode wrapMode,	/* Wrap mode to use for line:
+				 * TEXT_WRAPMODE_CHAR, TEXT_WRAPMODE_NONE, or TEXT_WRAPMODE_WORD. */
+    TkTextSpaceMode spaceMode,	/* Not used. */
+    TkTextDispChunk *chunkPtr)	/* Structure to fill in with information about this chunk. The x
+				 * field has already been set by the caller. */
+{
+    TkTextEmbImage *img = &eiPtr->body.ei;
+    int width, height;
+
+    assert(indexPtr->textPtr);
+    assert(offset == 0);
+
+    /*
+     * See if there's room for this image on this line.
+     */
+
+    if (!img->image) {
+	width = 0;
+	height = 0;
+	img->imgHeight = 0;
+    } else {
+	Tk_SizeOfImage(img->image, &width, &height);
+	img->imgHeight = height;
+	width += 2*img->padX;
+	height += 2*img->padY;
+    }
+    if ((width > maxX - chunkPtr->x)
+	    && !noCharsYet
+	    && (indexPtr->textPtr->wrapMode != TEXT_WRAPMODE_NONE)) {
+	return 0;
+    }
+
+    /*
+     * Fill in the chunk structure.
+     */
+
+    chunkPtr->layoutProcs = &layoutImageProcs;
+    chunkPtr->numBytes = 1;
+    if (img->align == ALIGN_BASELINE) {
+	chunkPtr->minAscent = height - img->padY;
+	chunkPtr->minDescent = img->padY;
+	chunkPtr->minHeight = 0;
+    } else {
+	chunkPtr->minAscent = 0;
+	chunkPtr->minDescent = 0;
+	chunkPtr->minHeight = height;
+    }
+    chunkPtr->width = width;
+    chunkPtr->breakIndex = (wrapMode == TEXT_WRAPMODE_NONE) ? -1 : 1;
+    chunkPtr->clientData = eiPtr;
+    return 1;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbImageCheckProc --
+ *
+ *	This function is invoked by the B-tree code to perform consistency
+ *	checks on embedded images.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The function panics if it detects anything wrong with the embedded
+ *	image.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbImageCheckProc(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextSegment *eiPtr)		/* Segment to check. */
+{
+    if (!eiPtr->nextPtr) {
+	Tcl_Panic("EmbImageCheckProc: embedded image is last segment in line");
+    }
+    if (eiPtr->size != 1) {
+	Tcl_Panic("EmbImageCheckProc: embedded image has size %d", eiPtr->size);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbImageDisplayProc --
+ *
+ *	This function is invoked by the text displaying code when it is time
+ *	to actually draw an embedded image chunk on the screen.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The embedded image gets moved to the correct location and drawn onto
+ *	the display.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbImageDisplayProc(
+    TkText *textPtr,
+    TkTextDispChunk *chunkPtr,	/* Chunk that is to be drawn. */
+    int x,			/* X-position in dst at which to draw this
+				 * chunk (differs from the x-position in the
+				 * chunk because of scrolling). */
+    int y,			/* Top of rectangular bounding box for line:
+				 * tells where to draw this chunk in dst
+				 * (x-position is in the chunk itself). */
+    int lineHeight,		/* Total height of line. */
+    int baseline,		/* Offset of baseline from y. */
+    Display *display,		/* Display to use for drawing. */
+    Drawable dst,		/* Pixmap or window in which to draw */
+    int screenY)		/* Y-coordinate in text window that corresponds to y. */
+{
+    TkTextSegment *eiPtr = chunkPtr->clientData;
+    TkTextEmbImage *img = &eiPtr->body.ei;
+    int lineX, imageX, imageY, width, height;
+    TkQTreeRect oldBbox;
+    TkQTreeRect *bbox;
+    Tk_Image image;
+    int dx, dy;
+
+    if (!(image = img->image)) {
+	return;
+    }
+
+    /*
+     * Compute the image's location and size in the text widget, taking into
+     * account the align value for the image.
+     */
+
+    EmbImageBboxProc(textPtr, chunkPtr, 0, y, lineHeight, baseline, &lineX, &imageY, &width, &height);
+    imageX = lineX - chunkPtr->x + x;
+
+    TkTextGetViewOffset(textPtr, &dx, &dy);
+
+    if (textPtr->configureBboxTree) {
+	TkQTreeRect bbox;
+
+	/*
+	 * The view of the widget has changed. This is the appropriate place to
+	 * re-configure the bounding box tree.
+	 */
+
+	TkQTreeRectSet(&bbox, dx, dy, Tk_Width(textPtr->tkwin) + dx, Tk_Height(textPtr->tkwin) + dy);
+	TkQTreeConfigure(&textPtr->imageBboxTree, &bbox);
+	textPtr->configureBboxTree = false;
+    }
+
+    if (img->numClients <= textPtr->pixelReference) {
+	unsigned numClients = textPtr->pixelReference + 1;
+
+	assert((img->numClients == 0) == !img->bbox);
+	img->bbox = realloc(img->bbox, numClients * sizeof(img->bbox[0]));
+	memset(img->bbox + img->numClients, 0, (numClients - img->numClients) * sizeof(img->bbox[0]));
+	img->numClients = numClients;
+    }
+
+    /*
+     * Update the bounding box, used for detection of mouse hovering.
+     */
+
+    bbox = &img->bbox[textPtr->pixelReference];
+    oldBbox = *bbox;
+    bbox->xmin = imageX + dx;
+    bbox->xmax = bbox->xmin + width;
+    bbox->ymin = screenY + imageY + dy;
+    bbox->ymax = bbox->ymin + height;
+
+    if (img->haveBindings && textPtr->imageBboxTree) {
+	const TkQTreeRect *oldBboxPtr = TkQTreeRectIsEmpty(&oldBbox) ? NULL : &oldBbox;
+
+	if (!TkQTreeRectIsEmpty(bbox)) {
+	    TkQTreeUpdateRect(textPtr->imageBboxTree, oldBboxPtr, bbox, (TkQTreeUid) img, 0);
+	} else if (oldBboxPtr) {
+	    /* Possibly this case is not possible at all, but we want to be sure. */
+	    TkQTreeDeleteRect(textPtr->imageBboxTree, oldBboxPtr, (TkQTreeUid) img);
+	}
+    }
+
+    if (x + chunkPtr->width > 0) {
+	/*
+	 * Finally, redraw the image if inside widget area.
+	 */
+
+	Tk_RedrawImage(image, 0, 0, width, height, dst, imageX, imageY);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbImageBboxProc --
+ *
+ *	This function is called to compute the bounding box of the area
+ *	occupied by an embedded image.
+ *
+ * Results:
+ *	There is no return value. *xPtr and *yPtr are filled in with the
+ *	coordinates of the upper left corner of the image, and *widthPtr and
+ *	*heightPtr are filled in with the dimensions of the image in pixels.
+ *	Note: not all of the returned bbox is necessarily visible on the
+ *	screen (the rightmost part might be off-screen to the right, and the
+ *	bottommost part might be off-screen to the bottom).
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbImageBboxProc(
+    TkText *textPtr,
+    TkTextDispChunk *chunkPtr,	/* Chunk containing desired char. */
+    int index,			/* Index of desired character within the chunk. */
+    int y,			/* Topmost pixel in area allocated for this line. */
+    int lineHeight,		/* Total height of line. */
+    int baseline,		/* Location of line's baseline, in pixels measured down from y. */
+    int *xPtr, int *yPtr,	/* Gets filled in with coords of character's upper-left pixel. */
+    int *widthPtr,		/* Gets filled in with width of image, in pixels. */
+    int *heightPtr)		/* Gets filled in with height of image, in pixels. */
+{
+    TkTextSegment *eiPtr = chunkPtr->clientData;
+    TkTextEmbImage *img = &eiPtr->body.ei;
+    Tk_Image image = img->image;
+
+    if (image) {
+	Tk_SizeOfImage(image, widthPtr, heightPtr);
+    } else {
+	*widthPtr = *heightPtr = 0;
+    }
+
+    *xPtr = chunkPtr->x + img->padX;
+
+    switch (img->align) {
+    case ALIGN_BOTTOM:
+	*yPtr = y + (lineHeight - *heightPtr - img->padY);
+	break;
+    case ALIGN_CENTER:
+	*yPtr = y + (lineHeight - *heightPtr)/2;
+	break;
+    case ALIGN_TOP:
+	*yPtr = y + img->padY;
+	break;
+    case ALIGN_BASELINE:
+	*yPtr = y + (baseline - *heightPtr);
+	break;
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextImageIndex --
+ *
+ *	Given the name of an embedded image within a text widget, returns an
+ *	index corresponding to the image's position in the text.
+ *
+ * Results:
+ *	The return value is true if there is an embedded image by the given name
+ *	in the text widget, false otherwise. If the image exists, *indexPtr is
+ *	filled in with its index.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+bool
+TkTextImageIndex(
+    TkText *textPtr,		/* Text widget containing image. */
+    const char *name,		/* Name of image. */
+    TkTextIndex *indexPtr)	/* Index information gets stored here. */
+{
+    Tcl_HashEntry *hPtr;
+    TkTextSegment *eiPtr;
+
+    assert(textPtr);
+
+    if (!(hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->imageTable, name))) {
+	return false;
+    }
+    eiPtr = Tcl_GetHashValue(hPtr);
+    TkTextIndexClear(indexPtr, textPtr);
+    TkTextIndexSetSegment(indexPtr, eiPtr);
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbImageProc --
+ *
+ *	This function is called by the image code whenever an image or its
+ *	contents changes.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The image will be redisplayed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbImageProc(
+    ClientData clientData,	/* Pointer to widget record. */
+    int x, int y,		/* Upper left pixel (within image) that must be redisplayed. */
+    int width, int height,	/* Dimensions of area to redisplay (may be <= 0). */
+    int imgWidth, int imgHeight)/* New dimensions of image. */
+
+{
+    TkTextSegment *eiPtr = clientData;
+    TkTextEmbImage *img = &eiPtr->body.ei;
+
+    if (img->hPtr) {
+	TkTextIndex index;
+	int mask;
+
+	assert(img->image);
+	GetIndex(img->sharedTextPtr, eiPtr, &index);
+	mask = (img->imgHeight == imgHeight) ? 0 : TK_TEXT_LINE_GEOMETRY;
+	TextChanged(img->sharedTextPtr, &index, mask);
+    }
+}
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: src/tktext/tkTextIndex.c
===================================================================
--- src/tktext/tkTextIndex.c	(revision 0)
+++ src/tktext/tkTextIndex.c	(working copy)
@@ -0,0 +1,3900 @@
+/*
+ * tkTextIndex.c --
+ *
+ *	This module provides functions that manipulate indices for text widgets.
+ *
+ * Copyright (c) 1992-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "default.h"
+#include "tkInt.h"
+#include "tkText.h"
+#include <stdlib.h>
+#include <assert.h>
+
+#ifndef MAX
+# define MAX(a,b) (((int) a) < ((int) b) ? b : a)
+#endif
+#ifndef MIN
+# define MIN(a,b) (((int) a) < ((int) b) ? a : b)
+#endif
+
+#if NDEBUG
+# define DEBUG(expr)
+#else
+# define DEBUG(expr) expr
+#endif
+
+/*
+ * Modifiers for index parsing: 'display', 'any' or nothing.
+ */
+
+enum { TKINDEX_NONE, TKINDEX_DISPLAY, TKINDEX_CHAR };
+
+/*
+ * Forward declarations for functions defined later in this file:
+ */
+
+static const char *	ForwBack(TkText *textPtr, const char *string, TkTextIndex *indexPtr);
+static const char *	StartEnd(TkText *textPtr, const char *string, TkTextIndex *indexPtr);
+static bool		GetIndex(Tcl_Interp *interp, TkSharedText *sharedTextPtr, TkText *textPtr,
+			    const char *string, TkTextIndex *indexPtr);
+static TkTextSegment *	IndexToSeg(const TkTextIndex *indexPtr, int *offsetPtr);
+static int		SegToIndex(const TkTextLine *linePtr, const TkTextSegment *segPtr);
+
+/*
+ * This object is no longer in use anymore.
+ *
+ * The cache of indices has been eliminated, because it has worked in only
+ * one case: the user has given a numeric index. But this case is quite seldom,
+ * and the overhead for caching is not considerably faster than the mapping
+ * to an internal index. And the trivial indices, like 1.0 or 1.end, will be
+ * mapped very fast. Furthermore the revised version is using a section
+ * structure for acceleration.
+ */
+#if TCL_MAJOR_VERSION > 8 || TCL_MINOR_VERSION > 5
+const
+#endif /* end of backport to 8.5 */
+Tcl_ObjType tkTextIndexType = {
+    "textindex",/* name */
+    NULL,	/* freeIntRepProc */
+    NULL,	/* dupIntRepProc */
+    NULL,	/* updateStringProc */
+    NULL	/* setFromAnyProc */
+};
+
+/*
+ * A note about sizeof(char). Due to the specification of sizeof in C99,
+ * sizeof(char) is always 1, see section 6.5.3.4:
+ *
+ *	When applied to an operand that has type char, unsigned char, or
+ *	signed char, (or a qualified version thereof) the result is 1.
+ *
+ * This means that the expression "== sizeof(char)" is not required, the
+ * expression "== 1" is good as well.
+ */
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexIsEmpty --
+ *
+ *	Return whether the given index is empty (still unset, or invalid).
+ *
+ * Results:
+ *	True if empty, false otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexIsEmpty(
+    const TkTextIndex *indexPtr)
+{
+    assert(indexPtr);
+    return indexPtr->priv.byteIndex == -1 && !indexPtr->priv.segPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextGetIndexFromObj --
+ *
+ *	Create new text index from given position.
+ *
+ * Results:
+ *	Returns true if and only if the index could be created.
+ *
+ * Side effects:
+ *	Store the new text index in 'indexPtr'.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextGetIndexFromObj(
+    Tcl_Interp *interp,		/* Use this for error reporting. */
+    TkText *textPtr,		/* Information about text widget, can be NULL. */
+    Tcl_Obj *objPtr,		/* Object containing description of position. */
+    TkTextIndex *indexPtr)	/* Store the result here. */
+{
+    assert(textPtr);
+    return GetIndex(interp, textPtr->sharedTextPtr, textPtr, Tcl_GetString(objPtr), indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetLine --
+ *
+ *	Set the line pointer of this index.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+#if !NDEBUG
+static bool
+CheckLine(
+    const TkTextIndex *indexPtr,
+    const TkTextLine *linePtr)
+{
+    assert(linePtr);
+
+    if (indexPtr->stateEpoch == TkBTreeEpoch(indexPtr->tree)) {
+	if (indexPtr->priv.segPtr
+		&& indexPtr->priv.segPtr->sectionPtr->linePtr != indexPtr->priv.linePtr) {
+	    return false;
+	}
+	if (indexPtr->priv.lineNo != -1
+		&& indexPtr->priv.lineNo !=
+		    TkBTreeLinesTo(indexPtr->tree, NULL, indexPtr->priv.linePtr, NULL)) {
+	    return false;
+	}
+	if (indexPtr->priv.lineNoRel != -1
+		&& indexPtr->priv.lineNoRel !=
+		    TkBTreeLinesTo(indexPtr->tree, indexPtr->textPtr, indexPtr->priv.linePtr, NULL)) {
+	    return false;
+	}
+    }
+
+    if (!indexPtr->discardConsistencyCheck && indexPtr->textPtr) {
+	const TkTextLine *startLine = TkBTreeGetStartLine(indexPtr->textPtr);
+	const TkTextLine *endLine = TkBTreeGetLastLine(indexPtr->textPtr);
+	int lineNo = TkBTreeLinesTo(indexPtr->tree, NULL, linePtr, NULL);
+
+	if (lineNo < TkBTreeLinesTo(indexPtr->tree, NULL, startLine, NULL)) {
+	    return false;
+	}
+	if (lineNo > TkBTreeLinesTo(indexPtr->tree, NULL, endLine, NULL)) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+#endif
+
+static int
+FindStartByteIndex(
+    const TkTextIndex *indexPtr)
+{
+    const TkText *textPtr = indexPtr->textPtr;
+    const TkTextSegment *segPtr;
+    const TkTextSection *sectionPtr;
+    int byteIndex;
+
+    if (!textPtr) {
+	return 0;
+    }
+
+    if (textPtr->startMarker == TkBTreeGetShared(indexPtr->tree)->startMarker) {
+	return 0;
+    }
+
+    segPtr = textPtr->startMarker;
+    sectionPtr = segPtr->sectionPtr;
+    byteIndex = 0;
+
+    if (sectionPtr->linePtr == indexPtr->priv.linePtr) {
+	while (segPtr && sectionPtr == segPtr->sectionPtr) {
+	    byteIndex += segPtr->size;
+	    segPtr = segPtr->prevPtr;
+	}
+	while (sectionPtr->prevPtr) {
+	    sectionPtr = sectionPtr->prevPtr;
+	    byteIndex += sectionPtr->size;
+	}
+    }
+
+    return byteIndex;
+}
+
+static bool
+DontNeedSpecialStartLineTreatment(
+    const TkTextIndex *indexPtr)
+{
+    const TkText *textPtr = indexPtr->textPtr;
+
+    return !textPtr
+	    || textPtr->startMarker == TkBTreeGetShared(indexPtr->tree)->startMarker
+	    || indexPtr->priv.linePtr != textPtr->startMarker->sectionPtr->linePtr;
+}
+
+void
+TkTextIndexSetLine(
+    TkTextIndex *indexPtr,
+    TkTextLine *linePtr)
+{
+    assert(linePtr);
+    assert(indexPtr->tree);
+    assert(CheckLine(indexPtr, linePtr));
+
+    indexPtr->stateEpoch = TkBTreeEpoch(indexPtr->tree);
+    indexPtr->priv.lineNo = -1;
+    indexPtr->priv.lineNoRel = -1;
+    indexPtr->priv.segPtr = NULL;
+    indexPtr->priv.byteIndex = -1;
+
+    if ((indexPtr->priv.linePtr = linePtr)) {
+	assert(linePtr->parentPtr); /* expired? */
+
+	if (DontNeedSpecialStartLineTreatment(indexPtr)) {
+	    indexPtr->priv.byteIndex = 0;
+	} else {
+	    indexPtr->priv.segPtr = indexPtr->textPtr->startMarker;
+	    indexPtr->priv.isCharSegment = false;
+	    indexPtr->priv.byteIndex = FindStartByteIndex(indexPtr);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetPosition --
+ *
+ *	Set the byte index and the segment, the user is responsible
+ *	for proper values.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+#if !NDEBUG
+static bool
+CheckByteIndex(
+    const TkTextIndex *indexPtr,
+    const TkTextLine *linePtr,
+    int byteIndex)
+{
+    const TkText *textPtr = indexPtr->textPtr;
+
+    if (byteIndex == -1 && (byteIndex = indexPtr->priv.byteIndex) == -1) {
+	assert(indexPtr->priv.segPtr);
+	assert(!indexPtr->priv.isCharSegment || TkBTreeEpoch(indexPtr->tree) == indexPtr->stateEpoch);
+	byteIndex = SegToIndex(indexPtr->priv.linePtr, indexPtr->priv.segPtr);
+    }
+
+    if (!indexPtr->discardConsistencyCheck && textPtr) {
+	if (linePtr == textPtr->startMarker->sectionPtr->linePtr) {
+	    if (byteIndex < FindStartByteIndex(indexPtr)) {
+		return false;
+	    }
+	}
+	if (linePtr == textPtr->endMarker->sectionPtr->linePtr) {
+	    return byteIndex <= SegToIndex(linePtr, textPtr->endMarker);
+	}
+	if (linePtr == textPtr->endMarker->sectionPtr->linePtr->nextPtr) {
+	    return byteIndex == 0;
+	}
+    }
+
+    return byteIndex < linePtr->size;
+}
+#endif /* !NDEBUG */
+
+void
+TkTextIndexSetPosition(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    int byteIndex,		/* New byte index. */
+    TkTextSegment *segPtr)	/* The segment which belongs to the byte index. */
+{
+    assert(indexPtr->tree);
+    assert(byteIndex >= 0);
+    assert(segPtr);
+    assert(segPtr->typePtr);    /* expired? */
+    assert(segPtr->sectionPtr); /* linked? */
+    assert(CheckLine(indexPtr, segPtr->sectionPtr->linePtr));
+    assert(CheckByteIndex(indexPtr, segPtr->sectionPtr->linePtr, byteIndex));
+
+    indexPtr->stateEpoch = TkBTreeEpoch(indexPtr->tree);
+    indexPtr->priv.linePtr = segPtr->sectionPtr->linePtr;
+    indexPtr->priv.byteIndex = byteIndex;
+    indexPtr->priv.lineNo = -1;
+    indexPtr->priv.lineNoRel = -1;
+    indexPtr->priv.segPtr = segPtr;
+    indexPtr->priv.isCharSegment = segPtr->typePtr == &tkTextCharType;
+
+#if !NDEBUG
+    {
+	int pos = SegToIndex(indexPtr->priv.linePtr, segPtr);
+
+	if (segPtr->typePtr == &tkTextCharType) {
+	    assert(byteIndex - pos < segPtr->size);
+	} else {
+	    assert(pos == byteIndex);
+	}
+    }
+#endif /* !NDEBUG */
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetByteIndex --
+ *
+ *	Set the byte index. We allow to set to the start of the next
+ *	line (this means that argument byteIndex is equal to line size),
+ *	required that the next line exists.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+DontNeedSpecialEndLineTreatment(
+    const TkTextIndex *indexPtr)
+{
+    const TkText *textPtr = indexPtr->textPtr;
+
+    return !textPtr
+	    || textPtr->endMarker == TkBTreeGetShared(indexPtr->tree)->endMarker
+	    || indexPtr->priv.linePtr != textPtr->endMarker->sectionPtr->linePtr;
+}
+
+static int
+FindEndByteIndex(
+    const TkTextIndex *indexPtr)
+{
+    /*
+     * We do not handle the special case with last line, because CheckLine is testing this.
+     */
+
+    if (indexPtr->textPtr && indexPtr->priv.linePtr == TkBTreeGetLastLine(indexPtr->textPtr)) {
+	return 0;
+    }
+    if (DontNeedSpecialEndLineTreatment(indexPtr)) {
+	return indexPtr->priv.linePtr->size - 1;
+    }
+    return SegToIndex(indexPtr->priv.linePtr, indexPtr->textPtr->endMarker);
+}
+
+void
+TkTextIndexSetByteIndex(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    int byteIndex)		/* New byte index. */
+{
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+    assert(byteIndex >= 0);
+
+    if (byteIndex == FindEndByteIndex(indexPtr) + 1) {
+	assert(indexPtr->priv.linePtr->nextPtr);
+	indexPtr->priv.linePtr = indexPtr->priv.linePtr->nextPtr;
+	indexPtr->priv.byteIndex = 0;
+	indexPtr->priv.segPtr = NULL;
+	if (indexPtr->priv.lineNo >= 0) {
+	    indexPtr->priv.lineNo += 1;
+	}
+	if (indexPtr->priv.lineNoRel >= 0) {
+	    indexPtr->priv.lineNoRel += 1;
+	}
+    } else {
+	indexPtr->priv.byteIndex = byteIndex;
+	indexPtr->priv.segPtr = NULL;
+    }
+
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+    assert(CheckByteIndex(indexPtr, indexPtr->priv.linePtr, byteIndex));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetByteIndex2 --
+ *
+ *	Set the new line pointer and the byte index. We allow to set to
+ *	the start of the next line (this means that argument byteIndex
+ *	is equal to line size), required that the next line exists.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexSetByteIndex2(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    TkTextLine *linePtr,	/* Pointer to line. */
+    int byteIndex)		/* New byte index. */
+{
+    assert(indexPtr->tree);
+    assert(linePtr);
+    assert(linePtr->parentPtr); /* expired? */
+    assert(byteIndex >= 0);
+
+    if (indexPtr->priv.linePtr != linePtr) {
+	indexPtr->priv.linePtr = linePtr;
+	indexPtr->priv.lineNo = -1;
+	indexPtr->priv.lineNoRel = -1;
+    }
+    TkTextIndexSetByteIndex(indexPtr, byteIndex);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetSegment --
+ *
+ *	Set the segment pointer.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The byte index will be cleared.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexSetSegment(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    TkTextSegment *segPtr)	/* Pointer to segment. */
+{
+    assert(indexPtr->tree);
+    assert(segPtr);
+    assert(segPtr->typePtr);    /* expired? */
+    assert(segPtr->sectionPtr); /* linked? */
+    assert(CheckLine(indexPtr, segPtr->sectionPtr->linePtr));
+
+    indexPtr->stateEpoch = TkBTreeEpoch(indexPtr->tree);
+    indexPtr->priv.linePtr = segPtr->sectionPtr->linePtr;
+    indexPtr->priv.lineNo = -1;
+    indexPtr->priv.lineNoRel = -1;
+    indexPtr->priv.segPtr = segPtr;
+
+    if (segPtr->typePtr == &tkTextCharType) {
+	indexPtr->priv.byteIndex = SegToIndex(indexPtr->priv.linePtr, segPtr);
+	indexPtr->priv.isCharSegment = true;
+    } else {
+	indexPtr->priv.byteIndex = -1;
+	indexPtr->priv.isCharSegment = false;
+    }
+
+    assert(CheckByteIndex(indexPtr, segPtr->sectionPtr->linePtr, -1));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetToStartOfLine --
+ *
+ *	Set this index to the start of the line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexSetToStartOfLine(
+    TkTextIndex *indexPtr)	/* Pointer to index. */
+{
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+
+    indexPtr->stateEpoch = TkBTreeEpoch(indexPtr->tree);
+    indexPtr->priv.segPtr = NULL;
+    indexPtr->priv.byteIndex = FindStartByteIndex(indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetToStartOfLine2 --
+ *
+ *	Set the new line pointer, and set this index to the start of the line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexSetToStartOfLine2(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    TkTextLine *linePtr)	/* Pointer to line. */
+{
+    assert(indexPtr->tree);
+    assert(linePtr);
+    assert(linePtr->parentPtr); /* expired? */
+    assert(CheckLine(indexPtr, linePtr));
+
+    indexPtr->stateEpoch = TkBTreeEpoch(indexPtr->tree);
+    indexPtr->priv.linePtr = linePtr;
+    indexPtr->priv.segPtr = NULL;
+    indexPtr->priv.lineNo = -1;
+    indexPtr->priv.lineNoRel = -1;
+    indexPtr->priv.byteIndex = FindStartByteIndex(indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetToEndOfLine2 --
+ *
+ *	Set the new line pointer, and set this index to the end of the line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexSetToEndOfLine2(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    TkTextLine *linePtr)	/* Pointer to line. */
+{
+    assert(indexPtr->tree);
+    assert(linePtr);
+    assert(linePtr->parentPtr); /* expired? */
+    assert(linePtr->nextPtr);
+    assert(CheckLine(indexPtr, linePtr->nextPtr));
+
+    indexPtr->stateEpoch = TkBTreeEpoch(indexPtr->tree);
+    indexPtr->priv.segPtr = NULL;
+    indexPtr->priv.lineNo = -1;
+    indexPtr->priv.lineNoRel = -1;
+    indexPtr->priv.linePtr = linePtr->nextPtr;
+    indexPtr->priv.byteIndex = 0;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetToLastChar --
+ *
+ *	Set this index to one byte before the end of the line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexSetToLastChar(
+    TkTextIndex *indexPtr)	/* Pointer to index. */
+{
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+
+    indexPtr->stateEpoch = TkBTreeEpoch(indexPtr->tree);
+    indexPtr->priv.byteIndex = FindEndByteIndex(indexPtr);
+    indexPtr->priv.segPtr = NULL;
+
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetupToStartOfText --
+ *
+ *	Setup this index to the start of the text.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexSetupToStartOfText(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    TkText *textPtr,		/* Text widget for this index, can be NULL. */
+    TkTextBTree tree)		/* B-tree for this index. */
+{
+    assert(indexPtr);
+    assert(tree);
+
+    indexPtr->textPtr = textPtr;
+    indexPtr->tree = tree;
+    indexPtr->stateEpoch = TkBTreeEpoch(tree);
+    indexPtr->priv.lineNo = textPtr ? -1 : 0;
+    indexPtr->priv.lineNoRel = 0;
+    indexPtr->priv.isCharSegment = false;
+    DEBUG(indexPtr->discardConsistencyCheck = false);
+
+    if (textPtr) {
+	indexPtr->priv.segPtr = textPtr->startMarker;
+	indexPtr->priv.linePtr = indexPtr->priv.segPtr->sectionPtr->linePtr;
+	indexPtr->priv.byteIndex = FindStartByteIndex(indexPtr);
+    } else {
+	indexPtr->priv.segPtr = TkBTreeGetShared(tree)->startMarker;
+	indexPtr->priv.linePtr = indexPtr->priv.segPtr->sectionPtr->linePtr;
+	indexPtr->priv.byteIndex = 0;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetupToEndOfText --
+ *
+ *	Setup this index to the end of the text. If a peer is given,
+ *	then this is the start of last line in this peer, otherwise
+ *	it's the start of the very last line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexSetupToEndOfText(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    TkText *textPtr,		/* Text widget for this index, can be NULL. */
+    TkTextBTree tree)		/* B-tree for this index. */
+{
+    assert(indexPtr);
+    assert(tree);
+
+    indexPtr->textPtr = textPtr;
+    indexPtr->tree = tree;
+    indexPtr->stateEpoch = TkBTreeEpoch(tree);
+    indexPtr->priv.lineNo = -1;
+    indexPtr->priv.lineNoRel = -1;
+    DEBUG(indexPtr->discardConsistencyCheck = false);
+
+    if (!textPtr) {
+	indexPtr->priv.segPtr = TkBTreeGetShared(tree)->endMarker;
+	indexPtr->priv.isCharSegment = false;
+	indexPtr->priv.linePtr = indexPtr->priv.segPtr->sectionPtr->linePtr;
+	indexPtr->priv.byteIndex = 0;
+    } else {
+	indexPtr->priv.linePtr = TkBTreeGetLastLine(textPtr);
+	indexPtr->priv.segPtr = indexPtr->priv.linePtr->segPtr;
+	indexPtr->priv.isCharSegment = indexPtr->priv.segPtr->typePtr == &tkTextCharType;
+	indexPtr->priv.byteIndex = 0;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexGetByteIndex --
+ *
+ *	Get the byte index.
+ *
+ * Results:
+ *	The byte index.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextIndexGetByteIndex(
+    const TkTextIndex *indexPtr)	/* Pointer to index. */
+{
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+
+    if (indexPtr->priv.byteIndex == -1) {
+	assert(indexPtr->priv.segPtr);
+	assert(!indexPtr->priv.isCharSegment || TkBTreeEpoch(indexPtr->tree) == indexPtr->stateEpoch);
+	assert(indexPtr->priv.segPtr->typePtr);    /* expired? */
+	assert(indexPtr->priv.segPtr->sectionPtr); /* linked? */
+	assert(indexPtr->priv.segPtr->sectionPtr->linePtr == indexPtr->priv.linePtr);
+	/* is mutable due to concept */
+	((TkTextIndex *)indexPtr)->priv.byteIndex =
+		SegToIndex(indexPtr->priv.linePtr, indexPtr->priv.segPtr);
+    }
+    return indexPtr->priv.byteIndex;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexToByteIndex --
+ *
+ *	Force the conversion from segment pointer to byte index. This
+ *	will unset the segment pointer.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The segment pointer will be unset.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexToByteIndex(
+    TkTextIndex *indexPtr)	/* Pointer to index. */
+{
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+
+    if (indexPtr->priv.byteIndex == -1) {
+	(void) TkTextIndexGetByteIndex(indexPtr);
+    }
+    indexPtr->priv.segPtr = NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexClear --
+ *
+ *	Clear all attributes, and set up the corresponding text pointer.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The given index will be in an invalid state, the TkIndexGet*
+ *	functions cannot be used.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexClear(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    TkText *textPtr)		/* Overall information for text widget. */
+{
+    assert(textPtr);
+
+    indexPtr->textPtr = textPtr;
+    indexPtr->tree = textPtr->sharedTextPtr->tree;
+    indexPtr->stateEpoch = 0;
+    indexPtr->priv.linePtr = NULL;
+    indexPtr->priv.segPtr = NULL;
+    indexPtr->priv.byteIndex = -1;
+    indexPtr->priv.lineNo = -1;
+    indexPtr->priv.lineNoRel = -1;
+    indexPtr->priv.isCharSegment = false;
+    DEBUG(indexPtr->discardConsistencyCheck = false);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexClear2 --
+ *
+ *	Clear all attributes, and set up the corresponding tree.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The given index will be in an invalid state, the TkIndexGet*
+ *	functions cannot be used.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextIndexClear2(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    TkText *textPtr,		/* Overall information for text widget, can be NULL */
+    TkTextBTree tree)		/* B-tree for this index. */
+{
+    assert(textPtr || tree);
+    assert(!textPtr || !tree || textPtr->sharedTextPtr->tree == tree);
+
+    indexPtr->textPtr = textPtr;
+    indexPtr->tree = tree ? tree : textPtr->sharedTextPtr->tree;
+    indexPtr->stateEpoch = 0;
+    indexPtr->priv.linePtr = NULL;
+    indexPtr->priv.segPtr = NULL;
+    indexPtr->priv.byteIndex = -1;
+    indexPtr->priv.lineNo = -1;
+    indexPtr->priv.lineNoRel = -1;
+    indexPtr->priv.isCharSegment = false;
+    DEBUG(indexPtr->discardConsistencyCheck = false);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexGetLineNumber --
+ *
+ *	Get the line number.
+ *
+ * Results:
+ *	The line number.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned
+TkTextIndexGetLineNumber(
+    const TkTextIndex *indexPtr,
+    const TkText *textPtr)	/* we want the line number belonging to this peer, can be NULL */
+{
+    unsigned epoch;
+    int32_t *lineNo;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+    assert(!textPtr || indexPtr->textPtr == textPtr);
+
+    lineNo = (int32_t *) (textPtr ? &indexPtr->priv.lineNoRel : &indexPtr->priv.lineNo);
+    epoch = TkBTreeEpoch(indexPtr->tree);
+
+    if (*lineNo == -1 || indexPtr->stateEpoch != epoch) {
+	TkTextIndex *iPtr = (TkTextIndex *) indexPtr;
+
+	if (iPtr->priv.byteIndex == -1) {
+	    assert(iPtr->priv.segPtr);
+	    assert(!iPtr->priv.isCharSegment || indexPtr->stateEpoch == epoch);
+	    iPtr->priv.byteIndex = SegToIndex(iPtr->priv.linePtr, iPtr->priv.segPtr);
+	    assert(CheckByteIndex(iPtr, iPtr->priv.linePtr, iPtr->priv.byteIndex));
+	}
+	TkTextIndexSetEpoch(iPtr, epoch);
+	*lineNo = TkBTreeLinesTo(iPtr->tree, textPtr, iPtr->priv.linePtr, NULL);
+    } else {
+	assert(*lineNo == TkBTreeLinesTo(indexPtr->tree, textPtr, indexPtr->priv.linePtr, NULL));
+    }
+
+    return *lineNo;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexRebuild --
+ *
+ *	Rebuild the index after possible modifications, it is required
+ *	that TkTextIndexSave has been called before.
+ *
+ * Results:
+ *	Returns whether the original line/byte position could be restored.
+ *	This does not meean that we have the same content at this position,
+ *	this only means that the we have the same position as before.
+ *
+ * Side effects:
+ *	Adjust the line and the byte offset, if required.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexRebuild(
+    TkTextIndex *indexPtr)
+{
+    TkTextLine *linePtr;
+    int byteIndex;
+    int lineNo;
+    bool rc;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.lineNo >= 0 || indexPtr->priv.lineNoRel >= 0);
+    assert(indexPtr->priv.byteIndex >= 0);
+
+    if (indexPtr->stateEpoch == TkBTreeEpoch(indexPtr->tree)) {
+	return true; /* still up-to-date */
+    }
+
+    if (indexPtr->priv.lineNo >= 0) {
+	lineNo = MIN(TkBTreeNumLines(indexPtr->tree, NULL), indexPtr->priv.lineNo);
+	linePtr = TkBTreeFindLine(indexPtr->tree, NULL, lineNo);
+	indexPtr->priv.lineNo = lineNo;
+    } else {
+	lineNo = MIN(TkBTreeNumLines(indexPtr->tree, indexPtr->textPtr), indexPtr->priv.lineNoRel);
+	linePtr = TkBTreeFindLine(indexPtr->tree, indexPtr->textPtr, lineNo);
+	indexPtr->priv.lineNoRel = lineNo;
+    }
+
+    if (!(rc = (linePtr == indexPtr->priv.linePtr))) {
+	indexPtr->priv.linePtr = linePtr;
+    }
+    byteIndex = MIN(indexPtr->priv.byteIndex, FindEndByteIndex(indexPtr));
+    if (byteIndex != indexPtr->priv.byteIndex) {
+	rc = false;
+    }
+    indexPtr->priv.byteIndex = byteIndex;
+    indexPtr->priv.segPtr = NULL;
+
+    return rc;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexRestrictToStartRange --
+ *
+ *	If given index is beyond the range of the widget (at left side),
+ *	then this index will be set to start range.
+ *
+ * Results:
+ *	Returns -1 if the index is earlier than start of range, 0 if index
+ *	is at start of range, and +1 if index is after start of range.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextIndexRestrictToStartRange(
+    TkTextIndex *indexPtr)
+{
+    TkText *textPtr = indexPtr->textPtr;
+    TkTextIndex start;
+    int cmp;
+
+    assert(indexPtr->tree);
+
+    if (!textPtr || textPtr->startMarker == textPtr->sharedTextPtr->startMarker) {
+	return TkTextIndexIsStartOfText(indexPtr) ? 0 : 1;
+    }
+
+    start = *indexPtr;
+    TkTextIndexSetSegment(&start, textPtr->startMarker);
+
+    if ((cmp = TkTextIndexCompare(indexPtr, &start)) < 0) {
+	*indexPtr = start;
+	cmp = -1;
+    }
+
+    return cmp;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexRestrictToEndRange --
+ *
+ *	If given index is beyond the range of the widget (at right side),
+ *	then this index will be set to end range.
+ *
+ * Results:
+ *	Returns +1 if the index has exceeded the range, 0 if index was at
+ *	end of range, and -1 if index is earlier than end of range.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextIndexRestrictToEndRange(
+    TkTextIndex *indexPtr)
+{
+    TkText *textPtr = indexPtr->textPtr;
+    TkTextIndex last;
+    int cmp;
+
+    assert(indexPtr->tree);
+
+    if (!textPtr || textPtr->endMarker == textPtr->sharedTextPtr->endMarker) {
+	return TkTextIndexIsEndOfText(indexPtr) ? 0 : -1;
+    }
+
+    last = *indexPtr;
+    TkTextIndexSetByteIndex2(&last, TkBTreeGetLastLine(textPtr), 0);
+
+    if ((cmp = TkTextIndexCompare(indexPtr, &last)) > 0) {
+	*indexPtr = last;
+	cmp = 1;
+    } else if (cmp < 0) {
+	TkTextIndex end = *indexPtr;
+	TkTextIndexSetSegment(&end, textPtr->endMarker);
+	if (TkTextIndexCompare(indexPtr, &end) > 0) {
+	    *indexPtr = last;
+	    cmp = 0;
+	} else {
+	    cmp = -1;
+	}
+    }
+
+    return cmp;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexEnsureBeforeLastChar --
+ *
+ *	If given index is on last line, then this index will be set to
+ *	the position of the last character in second last line.
+ *
+ * Results:
+ *	Returns 'true' if the index is now before last character position.
+ *	This is not possible if the peer is empty, and in this case this
+ *	function returns 'false'.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexEnsureBeforeLastChar(
+    TkTextIndex *indexPtr)
+{
+    TkText *textPtr = indexPtr->textPtr;
+    const TkTextLine *lastLinePtr;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->textPtr);
+
+    if (TkTextIsDeadPeer(indexPtr->textPtr)) {
+        return false;
+    }
+
+    lastLinePtr = TkBTreeGetLastLine(textPtr);
+
+    if (lastLinePtr == indexPtr->priv.linePtr
+	    && (!textPtr || lastLinePtr != textPtr->startMarker->sectionPtr->linePtr)) {
+	TkTextIndexSetToLastChar2(indexPtr, lastLinePtr->prevPtr);
+    }
+
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexGetContentSegment --
+ *
+ *	Get the pointer to the segment at this byte position which
+ *	contains any content (chars, image, or window).
+ *
+ *	This is the equivalent to the older (and eliminated) function
+ *	TkTextIndexToSeg.
+ *
+ * Results:
+ *	Pointer to a segment with size > 0.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextSegment *
+TkTextIndexGetContentSegment(
+    const TkTextIndex *indexPtr,/* Pointer to index. */
+    int *offset)		/* Get offset in segment, can be NULL. */
+{
+    TkTextSegment *segPtr;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+
+    if ((segPtr = indexPtr->priv.segPtr)
+	    && (!indexPtr->priv.isCharSegment || TkBTreeEpoch(indexPtr->tree) == indexPtr->stateEpoch)) {
+	while (segPtr->size == 0) {
+	    segPtr = segPtr->nextPtr;
+	}
+
+	if (offset) {
+	    if (indexPtr->priv.byteIndex == -1) {
+		*offset = 0;
+	    } else {
+		int byteIndex = SegToIndex(indexPtr->priv.linePtr, segPtr);
+		assert(byteIndex <= indexPtr->priv.byteIndex);
+		assert(indexPtr->priv.byteIndex < byteIndex + segPtr->size);
+		*offset = indexPtr->priv.byteIndex - byteIndex;
+	    }
+	    assert(*offset >= 0);
+	    assert(*offset < segPtr->size);
+	}
+    } else {
+	int myOffset;
+
+	assert(indexPtr->priv.byteIndex >= 0);
+	segPtr = IndexToSeg(indexPtr, &myOffset);
+	if (myOffset == 0) {
+	    TkTextIndex *iPtr = (TkTextIndex *) indexPtr; /* mutable due to concept */
+	    iPtr->priv.segPtr = segPtr;
+	    iPtr->priv.isCharSegment = segPtr->typePtr == &tkTextCharType;
+	}
+	if (offset) {
+	    *offset = myOffset;
+	}
+    }
+
+    return segPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexGetFirstSegment --
+ *
+ *	Get the pointer to first segment at this byte position.
+ *
+ * Results:
+ *	Pointer to a segment.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextSegment *
+TkTextIndexGetFirstSegment(
+    const TkTextIndex *indexPtr,/* Pointer to index. */
+    int *offset)		/* Get offset in segment, can be NULL. */
+{
+    TkTextSegment *segPtr;
+    TkTextSegment *prevPtr;
+    int myOffset;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+
+    if ((segPtr = indexPtr->priv.segPtr)
+	    && (!indexPtr->priv.isCharSegment || TkBTreeEpoch(indexPtr->tree) == indexPtr->stateEpoch)) {
+	if (indexPtr->priv.byteIndex >= 0) {
+	    myOffset = indexPtr->priv.byteIndex - SegToIndex(indexPtr->priv.linePtr, segPtr);
+	    assert(myOffset >= 0);
+	    assert(segPtr->size == 0 || myOffset < segPtr->size);
+	} else {
+	    myOffset = 0;
+	}
+    } else {
+	assert(indexPtr->priv.byteIndex >= 0);
+	segPtr = IndexToSeg(indexPtr, &myOffset);
+    }
+
+    assert(segPtr->typePtr);    /* expired? */
+    assert(segPtr->sectionPtr); /* linked? */
+    assert(segPtr->sectionPtr->linePtr == indexPtr->priv.linePtr);
+
+    if (myOffset == 0) {
+	TkTextIndex *iPtr;
+
+	while ((prevPtr = segPtr->prevPtr) && prevPtr->size == 0) {
+	    segPtr = prevPtr;
+	}
+
+	iPtr = (TkTextIndex *) indexPtr; /* mutable due to concept */
+	iPtr->priv.segPtr = segPtr;
+	iPtr->priv.isCharSegment = segPtr->typePtr == &tkTextCharType;
+    }
+    if (offset) {
+	*offset = myOffset;
+    }
+ 
+    return segPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexIsStartOfLine --
+ *
+ *	Test whether this index refers to the start of a line.
+ *
+ * Results:
+ *	Returns true if the start of a line is referred, zero otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexIsStartOfLine(
+    const TkTextIndex *indexPtr)
+{
+    const TkTextSegment *segPtr;
+    const TkTextSegment *startPtr;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+
+    if (indexPtr->priv.byteIndex >= 0) {
+	return FindStartByteIndex(indexPtr) == indexPtr->priv.byteIndex;
+    }
+
+    assert(indexPtr->priv.segPtr);
+    assert(!indexPtr->priv.isCharSegment || TkBTreeEpoch(indexPtr->tree) == indexPtr->stateEpoch);
+    assert(CheckByteIndex(indexPtr, indexPtr->priv.linePtr, -1));
+
+    startPtr = indexPtr->textPtr ? indexPtr->textPtr->startMarker : NULL;
+    segPtr = indexPtr->priv.segPtr;
+    if (segPtr->size > 0) {
+	segPtr = segPtr->prevPtr;
+    }
+    while (segPtr && segPtr->size == 0) {
+	if (segPtr == startPtr) {
+	    return true;
+	}
+	segPtr = segPtr->prevPtr;
+    }
+
+    return !segPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexIsEndOfLine --
+ *
+ *	Test whether this index refers to the end of the line.
+ *
+ * Results:
+ *	Returns true if the end of the line is referred, false otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexIsEndOfLine(
+    const TkTextIndex *indexPtr)
+{
+    const TkTextSegment *segPtr;
+    const TkTextSegment *endPtr;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+    assert(CheckByteIndex(indexPtr, indexPtr->priv.linePtr, -1));
+
+    if (indexPtr->priv.byteIndex >= 0) {
+	return indexPtr->priv.byteIndex == FindEndByteIndex(indexPtr);
+    }
+
+    assert(indexPtr->priv.segPtr);
+    assert(!indexPtr->priv.isCharSegment || TkBTreeEpoch(indexPtr->tree) == indexPtr->stateEpoch);
+
+    if (indexPtr->priv.linePtr == TkBTreeGetLastLine(indexPtr->textPtr)) {
+	return true;
+    }
+
+    segPtr = indexPtr->priv.segPtr;
+
+    if (DontNeedSpecialEndLineTreatment(indexPtr)) {
+	while (segPtr->size == 0) {
+	    segPtr = segPtr->nextPtr;
+	}
+	return segPtr->size == 1 && segPtr == indexPtr->priv.linePtr->lastPtr;
+    }
+
+    assert(indexPtr->textPtr);
+    assert(indexPtr->textPtr->endMarker != indexPtr->textPtr->sharedTextPtr->endMarker);
+
+    endPtr = indexPtr->textPtr->endMarker;
+    while (segPtr->size == 0) {
+	if (segPtr == endPtr) {
+	    return true;
+	}
+	segPtr = segPtr->nextPtr;
+    }
+
+    return false;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexIsStartOfText --
+ *
+ *	Test whether this index refers to the start of the text.
+ *
+ * Results:
+ *	Returns true if the start of the text is referred, false otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexIsStartOfText(
+    const TkTextIndex *indexPtr)
+{
+    const TkText *textPtr = indexPtr->textPtr;
+    const TkTextSegment *segPtr;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+    assert(CheckByteIndex(indexPtr, indexPtr->priv.linePtr, -1));
+
+    segPtr = textPtr ? textPtr->startMarker : TkBTreeGetShared(indexPtr->tree)->startMarker;
+    return indexPtr->priv.linePtr == segPtr->sectionPtr->linePtr && TkTextIndexIsStartOfLine(indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexIsEndOfText --
+ *
+ *	Test whether this index refers to the end of the text.
+ *
+ * Results:
+ *	Returns true if the end of the text is referred, false otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexIsEndOfText(
+    const TkTextIndex *indexPtr)
+{
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+    assert(CheckByteIndex(indexPtr, indexPtr->priv.linePtr, -1));
+
+    if (indexPtr->textPtr) {
+	return indexPtr->priv.linePtr == TkBTreeGetLastLine(indexPtr->textPtr);
+    }
+    return !indexPtr->priv.linePtr->nextPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexIsEqual --
+ *
+ *	Test whether both given indicies are referring the same byte
+ *	index. Such a test makes sense only if both indices are
+ *	belonging to the same line.
+ *
+ * Results:
+ *	Return true if both indices are equal, otherwise false will be returned.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexIsEqual(
+    const TkTextIndex *indexPtr1,	/* Pointer to index. */
+    const TkTextIndex *indexPtr2)	/* Pointer to index. */
+{
+    const TkTextSegment *segPtr1;
+    const TkTextSegment *segPtr2;
+
+    assert(indexPtr1->priv.linePtr);
+    assert(indexPtr2->priv.linePtr);
+    assert(indexPtr1->priv.linePtr->parentPtr); /* expired? */
+    assert(indexPtr2->priv.linePtr->parentPtr); /* expired? */
+
+    if (indexPtr1->priv.linePtr != indexPtr2->priv.linePtr) {
+	return false;
+    }
+
+    if ((segPtr1 = TkTextIndexGetSegment(indexPtr1))) {
+	if ((segPtr2 = TkTextIndexGetSegment(indexPtr2))) {
+	    while (segPtr1->prevPtr && segPtr1->prevPtr->size == 0) {
+		segPtr1 = segPtr1->prevPtr;
+	    }
+	    while (segPtr2->prevPtr && segPtr2->prevPtr->size == 0) {
+		segPtr2 = segPtr2->prevPtr;
+	    }
+	    return segPtr1 == segPtr2;
+	}
+    }
+
+    return TkTextIndexGetByteIndex(indexPtr1) == TkTextIndexGetByteIndex(indexPtr2);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexCompare --
+ *
+ *	Compare two indicies.
+ *
+ * Results:
+ *	It returns an integer less than, equal to, or greater than zero if
+ *	indexPtr1 is found, respectively, to be less than, to match, or be
+ *	greater than indexPtr2.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextIndexCompare(
+    const TkTextIndex *indexPtr1,	/* Pointer to index. */
+    const TkTextIndex *indexPtr2)	/* Pointer to index. */
+{
+    const TkTextSection *sectionPtr1;
+    const TkTextSection *sectionPtr2;
+    const TkTextSegment *segPtr1;
+    const TkTextSegment *segPtr2;
+
+    assert(indexPtr1->priv.linePtr);
+    assert(indexPtr2->priv.linePtr);
+    assert(indexPtr1->priv.linePtr->parentPtr); /* expired? */
+    assert(indexPtr2->priv.linePtr->parentPtr); /* expired? */
+
+    if (indexPtr1->priv.linePtr != indexPtr2->priv.linePtr) {
+	int lineNo1 = TkTextIndexGetLineNumber(indexPtr1, NULL);
+	int lineNo2 = TkTextIndexGetLineNumber(indexPtr2, NULL);
+
+	return lineNo1 - lineNo2;
+    }
+    if (indexPtr1->priv.byteIndex >= 0 && indexPtr2->priv.byteIndex >= 0) {
+	return indexPtr1->priv.byteIndex - indexPtr2->priv.byteIndex;
+    }
+
+    if (!(segPtr1 = TkTextIndexGetSegment(indexPtr1)) || !(segPtr2 = TkTextIndexGetSegment(indexPtr2))) {
+	return TkTextIndexGetByteIndex(indexPtr1) - TkTextIndexGetByteIndex(indexPtr2);
+    }
+
+    assert(!indexPtr1->priv.isCharSegment || TkBTreeEpoch(indexPtr1->tree) == indexPtr1->stateEpoch);
+    assert(!indexPtr2->priv.isCharSegment || TkBTreeEpoch(indexPtr2->tree) == indexPtr2->stateEpoch);
+
+    segPtr1 = indexPtr1->priv.segPtr;
+    segPtr2 = indexPtr2->priv.segPtr;
+    while (segPtr1->size == 0) {
+	segPtr1 = segPtr1->nextPtr;
+    }
+    while (segPtr2->size == 0) {
+	segPtr2 = segPtr2->nextPtr;
+    }
+    if (segPtr1 == segPtr2) {
+	return 0;
+    }
+    sectionPtr1 = indexPtr1->priv.segPtr->sectionPtr;
+    sectionPtr2 = indexPtr2->priv.segPtr->sectionPtr;
+    if (sectionPtr1 != sectionPtr2) {
+	while (sectionPtr1 && sectionPtr1 != sectionPtr2) {
+	    sectionPtr1 = sectionPtr1->nextPtr;
+	}
+	return sectionPtr1 ? -1 : +1;
+    }
+    segPtr1 = indexPtr1->priv.segPtr;
+    segPtr2 = indexPtr2->priv.segPtr;
+    while (segPtr1 != segPtr2) {
+	if (!(segPtr1 = segPtr1->nextPtr) || segPtr1->sectionPtr != sectionPtr1) {
+	    return +1;
+	}
+    }
+    return -1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexAddToByteIndex --
+ *
+ *	Add given byte offset to byte index.
+ *
+ *	Note that this function allows that the byte index will reach the
+ *	size of the line, in this case the line will be advanced, and the
+ *	byte index will be set to zero.
+ *
+ * Results:
+ *	Returns whether we're on same line.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexAddToByteIndex(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    int byteOffset)		/* Add this offset. */
+{
+    bool rc = true;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+    assert(CheckByteIndex(indexPtr, indexPtr->priv.linePtr, -1));
+
+    if (byteOffset == 0) {
+	return true;
+    }
+
+    if (indexPtr->priv.byteIndex == -1) {
+	(void) TkTextIndexGetByteIndex(indexPtr);
+    }
+
+    if (byteOffset > 0) {
+	if ((indexPtr->priv.byteIndex += byteOffset) > FindEndByteIndex(indexPtr)) {
+	    assert(indexPtr->priv.linePtr->nextPtr);
+	    assert(indexPtr->priv.byteIndex <= indexPtr->priv.linePtr->size);
+	    indexPtr->priv.linePtr = indexPtr->priv.linePtr->nextPtr;
+	    if (indexPtr->priv.lineNo >= 0) {
+		indexPtr->priv.lineNo += 1;
+	    }
+	    if (indexPtr->priv.lineNoRel >= 0) {
+		indexPtr->priv.lineNoRel += 1;
+	    }
+	    indexPtr->priv.byteIndex = 0;
+	    rc = false;
+	}
+    } else {
+	assert(-byteOffset <= indexPtr->priv.byteIndex);
+	indexPtr->priv.byteIndex += byteOffset;
+    }
+
+    indexPtr->priv.segPtr = NULL;
+
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+    assert(CheckByteIndex(indexPtr, indexPtr->priv.linePtr, -1));
+
+    return rc;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkpTextIndexDump --
+ *
+ *	This function is for debugging only, printing the given index
+ *	on stdout.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+#if !NDEBUG
+
+void
+TkpTextIndexDump(
+    TkText *textPtr,		/* May be NULL. */
+    const TkTextIndex *indexPtr)/* Pointer to index. */
+{
+    char buf[TK_POS_CHARS];
+    TkTextIndexPrint(TkTextIndexGetShared(indexPtr), textPtr, indexPtr, buf);
+    printf("%s\n", buf);
+}
+
+#endif /* !NDEBUG */
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextNewIndexObj --
+ *
+ *	This function generates a Tcl_Obj description of an index, suitable
+ *	for reading in again later. The index generated is effectively stable
+ *	to all except insertion/deletion operations on the widget.
+ *
+ * Results:
+ *	A new Tcl_String with refCount zero.
+ *
+ * Side effects:
+ *	A small amount of memory is allocated.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+Tcl_Obj *
+TkTextNewIndexObj(
+    const TkTextIndex *indexPtr)/* Pointer to index. */
+{
+    char buffer[TK_POS_CHARS];
+    int len;
+
+    assert(indexPtr->textPtr);
+
+    len = TkTextPrintIndex(indexPtr->textPtr, indexPtr, buffer);
+    return Tcl_NewStringObj(buffer, len);
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextMakeByteIndex --
+ *
+ *	Given a line index and a byte index, look things up in the B-tree and
+ *	fill in a TkTextIndex structure.
+ *
+ * Results:
+ *	The structure at *indexPtr is filled in with information about the
+ *	character at lineIndex and byteIndex (or the closest existing
+ *	character, if the specified one doesn't exist), and indexPtr is
+ *	returned as result.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+TkTextIndex *
+TkTextMakeByteIndex(
+    TkTextBTree tree,		/* Tree that lineIndex and byteIndex refer TkTextBTree tree, to. */
+    const TkText *textPtr,	/* Client that lineIndex and byteIndex refer to, can be NULL. */
+    int lineIndex,		/* Index of desired line (0 means first line of text). */
+    int byteIndex,		/* Byte index of desired character. */
+    TkTextIndex *indexPtr)	/* Structure to fill in. */
+{
+    TkTextSegment *segPtr;
+    TkTextSection *sectionPtr;
+    TkTextLine *linePtr;
+    int index, nextIndex;
+
+    TkTextIndexClear2(indexPtr, (TkText *) textPtr, tree);
+
+    if (lineIndex < 0) {
+	TkTextIndexSetupToStartOfText(indexPtr, (TkText *) textPtr, tree);
+	return indexPtr;
+    }
+
+    if (!(linePtr = TkBTreeFindLine(tree, textPtr, lineIndex))) {
+	TkTextIndexSetupToEndOfText(indexPtr, (TkText *) textPtr, tree);
+	return indexPtr;
+    }
+
+    if (byteIndex < 0) {
+	byteIndex = 0;
+    }
+
+    if (textPtr) {
+	if (textPtr->startMarker != textPtr->sharedTextPtr->startMarker
+		&& textPtr->startMarker->sectionPtr->linePtr == linePtr) {
+	    int startByteIndex;
+
+	    TkTextIndexSetSegment(indexPtr, textPtr->startMarker);
+	    startByteIndex = FindStartByteIndex(indexPtr);
+	    if (byteIndex <= startByteIndex) {
+		return indexPtr;
+	    }
+	}
+	if (textPtr->endMarker != textPtr->sharedTextPtr->endMarker
+		&& textPtr->endMarker->sectionPtr->linePtr == linePtr) {
+	    int endByteIndex;
+
+	    TkTextIndexSetSegment(indexPtr, textPtr->endMarker);
+	    endByteIndex = FindEndByteIndex(indexPtr);
+	    if (endByteIndex <= byteIndex) {
+		return indexPtr;
+	    }
+	}
+    }
+
+    indexPtr->priv.linePtr = linePtr;
+
+    if (byteIndex == 0) {
+	/* this is catching a frequent case */
+	TkTextIndexSetByteIndex(indexPtr, 0);
+	return indexPtr;
+    }
+
+    if (byteIndex >= linePtr->size) {
+	/*
+	 * Use the index of the last character in the line. Since the last
+	 * character on the line is guaranteed to be a '\n', we can back
+	 * up one byte.
+	 *
+	 * Note that it is already guaranteed that we do not exceed the position
+	 * of the end marker.
+	 */
+	TkTextIndexSetByteIndex(indexPtr, linePtr->size - 1);
+	return indexPtr;
+    }
+
+    indexPtr->priv.byteIndex = byteIndex;
+    index = 0;
+
+    sectionPtr = linePtr->segPtr->sectionPtr;
+    while ((nextIndex = index + sectionPtr->size) <= byteIndex) {
+	index = nextIndex;
+	sectionPtr = sectionPtr->nextPtr;
+	assert(sectionPtr);
+    }
+
+    segPtr = sectionPtr->segPtr;
+    while ((nextIndex = index + segPtr->size) < byteIndex) {
+	index = nextIndex;
+	segPtr = segPtr->nextPtr;
+	assert(segPtr);
+    }
+
+    /*
+     * Verify that the index points to a valid character boundary.
+     */
+
+    if (segPtr->typePtr == &tkTextCharType && byteIndex > index && index + segPtr->size > byteIndex) {
+	const char *p = segPtr->body.chars + (byteIndex - index);
+
+	/*
+	 * Prevent UTF-8 character from being split up by ensuring that byteIndex
+	 * falls on a character boundary. If index falls in the middle of a UTF-8
+	 * character, it will be adjusted to the end of that UTF-8 character.
+	 */
+
+	while ((*p & 0xc0) == 0x80) {
+	    ++p;
+	    indexPtr->priv.byteIndex += 1;
+	}
+    }
+
+    return indexPtr;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextMakeCharIndex --
+ *
+ *	Given a line index and a character index, look things up in the B-tree
+ *	and fill in a TkTextIndex structure.
+ *
+ * Results:
+ *	The structure at *indexPtr is filled in with information about the
+ *	character at lineIndex and charIndex (or the closest existing
+ *	character, if the specified one doesn't exist), and indexPtr is
+ *	returned as result.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+static unsigned
+CountCharsInSeg(
+    const TkTextSegment *segPtr)
+{
+    assert(segPtr->typePtr == &tkTextCharType);
+    return Tcl_NumUtfChars(segPtr->body.chars, segPtr->size);
+}
+
+TkTextIndex *
+TkTextMakeCharIndex(
+    TkTextBTree tree,		/* Tree that lineIndex and charIndex refer to. */
+    TkText *textPtr,		/* Client that lineIndex and charIndex refer to, can be NULL. */
+    int lineIndex,		/* Index of desired line (0 means first line of text). */
+    int charIndex,		/* Index of desired character. */
+    TkTextIndex *indexPtr)	/* Structure to fill in. */
+{
+    TkTextSegment *segPtr, *lastPtr;
+    TkTextLine *linePtr;
+    char *p, *start, *end;
+    int index, offset;
+
+    TkTextIndexClear2(indexPtr, textPtr, tree);
+
+    if (lineIndex < 0) {
+	TkTextIndexSetupToStartOfText(indexPtr, textPtr, tree);
+	return indexPtr;
+    }
+
+    if (!(linePtr = TkBTreeFindLine(tree, textPtr, lineIndex))) {
+	TkTextIndexSetupToEndOfText(indexPtr, textPtr, tree);
+	return indexPtr;
+    }
+
+    indexPtr->priv.linePtr = linePtr;
+
+    if (charIndex >= linePtr->size - 1) {
+	/* this is catching a frequent case */
+	TkTextIndexSetToLastChar(indexPtr);
+	return indexPtr;
+    }
+
+    if (charIndex <= 0) {
+	/* this is catching a frequent case */
+	TkTextIndexSetToStartOfLine(indexPtr);
+	return indexPtr;
+    }
+
+    if (textPtr && textPtr->endMarker->sectionPtr->linePtr == linePtr) {
+	lastPtr = textPtr->endMarker;
+    } else {
+	lastPtr = NULL;
+    }
+
+    if (!textPtr
+	    || textPtr->startMarker == TkBTreeGetShared(indexPtr->tree)->startMarker
+	    || linePtr != textPtr->startMarker->sectionPtr->linePtr) {
+	segPtr = linePtr->segPtr;
+	index = 0;
+    } else {
+	TkTextSegment *startPtr;
+
+	/*
+	 * We have to skip some segments not belonging to this peer.
+	 */
+
+	TkTextIndexSetSegment(indexPtr, textPtr->startMarker);
+	startPtr = TkTextIndexGetFirstSegment(indexPtr, NULL);
+
+	for (segPtr = linePtr->segPtr; segPtr != startPtr; segPtr = segPtr->nextPtr) {
+	    if (segPtr->typePtr == &tkTextCharType) {
+		charIndex -= CountCharsInSeg(segPtr);
+	    } else {
+		assert(segPtr->size <= 1);
+		charIndex -= segPtr->size;
+	    }
+	    if (charIndex <= 0) {
+		return indexPtr;
+	    }
+	}
+
+	index = TkTextIndexGetByteIndex(indexPtr);
+	indexPtr->priv.segPtr = NULL;
+    }
+
+    /*
+     * Verify that the index is within the range of the line. If not, just use
+     * the index of the last character in the line.
+     */
+
+    while (segPtr != lastPtr) {
+	if (segPtr->tagInfoPtr) {
+	    if (segPtr->typePtr == &tkTextCharType) {
+		int ch;
+
+		/*
+		 * Turn character offset into a byte offset.
+		 */
+
+		start = segPtr->body.chars;
+		end = start + segPtr->size;
+
+		for (p = start; p < end; p += offset) {
+		    if (charIndex == 0) {
+			indexPtr->priv.byteIndex = index;
+			return indexPtr;
+		    }
+		    charIndex -= 1;
+		    offset = TkUtfToUniChar(p, &ch);
+		    index += offset;
+		}
+	    } else if (charIndex < segPtr->size) {
+		indexPtr->priv.byteIndex = index;
+		return indexPtr;
+	    } else {
+		assert(segPtr->size == 1);
+		charIndex -= 1;
+		index += 1;
+	    }
+	}
+	if (!(segPtr = segPtr->nextPtr)) {
+	    /*
+	     * Use the index of the last character in the line.
+	     */
+	    TkTextIndexSetToLastChar(indexPtr);
+	    return indexPtr;
+	}
+    }
+
+    indexPtr->priv.byteIndex = index;
+    return indexPtr;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * IndexToSeg --
+ *
+ *	Given an index, this function returns the segment and offset within
+ *	segment for the index.
+ *
+ * Results:
+ *	The return value is a pointer to the segment referred to by indexPtr;
+ *	this will always be a segment with non-zero size. The variable at
+ *	*offsetPtr is set to hold the integer offset within the segment of the
+ *	character given by indexPtr.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+static TkTextSegment *
+IndexToSeg(
+    const TkTextIndex *indexPtr,/* Text index. */
+    int *offsetPtr)		/* Where to store offset within segment, or NULL if offset isn't
+    				 * wanted. */
+{
+    TkTextSection *sectionPtr;
+    TkTextSegment *segPtr;
+    TkTextLine *linePtr;
+    int index;
+
+    assert(indexPtr->priv.byteIndex >= 0);
+    assert(indexPtr->priv.byteIndex < indexPtr->priv.linePtr->size);
+
+    index = indexPtr->priv.byteIndex;
+    linePtr = indexPtr->priv.linePtr;
+
+    /*
+     * Speed up a frequent use case.
+     */
+
+    if (index == 0) {
+	segPtr = linePtr->segPtr;
+	while (segPtr->size == 0) {
+	    segPtr = segPtr->nextPtr;
+	}
+	if (offsetPtr) {
+	    *offsetPtr = 0;
+	}
+	return segPtr;
+    }
+
+    /*
+     * Speed up a frequent use case.
+     */
+
+    if (index == linePtr->size - 1) {
+	assert(linePtr->lastPtr->typePtr == &tkTextCharType);
+	if (offsetPtr) {
+	    *offsetPtr = linePtr->lastPtr->size - 1;
+	}
+	return linePtr->lastPtr;
+    }
+
+    /*
+     * Now we iterate through the section an segment structure until we reach the
+     * wanted byte index.
+     */
+
+    sectionPtr = linePtr->segPtr->sectionPtr;
+    for ( ; index >= sectionPtr->size; sectionPtr = sectionPtr->nextPtr) {
+	index -= sectionPtr->size;
+	assert(sectionPtr->nextPtr);
+    }
+    for (segPtr = sectionPtr->segPtr; index >= segPtr->size; segPtr = segPtr->nextPtr) {
+	index -= segPtr->size;
+	assert(segPtr->nextPtr);
+    }
+    assert(segPtr->size > 0);
+
+    if (offsetPtr) {
+	*offsetPtr = index;
+    }
+    return segPtr;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * SegToIndex --
+ *
+ *	Given a segment pointer, this function returns the offset of the
+ *	segment within its line.
+ *
+ *	This function assumes that we want the index to the current line,
+ *	and not the index from the start of the logical line.
+ *
+ * Results:
+ *	The return value is the offset (within its line) of the first
+ *	character in segPtr.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+static int
+SegToIndex(
+    const TkTextLine *linePtr,
+    const TkTextSegment *segPtr)/* Segment whose offset is desired. */
+{
+    const TkTextSection *sectionPtr;
+    const TkTextSegment *segPtr2;
+    int offset;
+
+    assert(segPtr->sectionPtr); /* otherwise not linked */
+    assert(segPtr->sectionPtr->linePtr == linePtr);
+
+    sectionPtr = linePtr->segPtr->sectionPtr; /* first segment in line */
+
+    /*
+     * Speed up frequent use cases.
+     */
+
+    if (segPtr == sectionPtr->segPtr) {
+	return 0;
+    }
+
+    if (segPtr == linePtr->lastPtr) {
+	return linePtr->size - segPtr->size;
+    }
+
+    /*
+     * Now we iterate through the section an segment structure until we reach the
+     * given segment.
+     */
+
+    offset = 0;
+
+    for ( ; sectionPtr != segPtr->sectionPtr; sectionPtr = sectionPtr->nextPtr) {
+	offset += sectionPtr->size;
+	assert(sectionPtr->nextPtr);
+    }
+    for (segPtr2 = segPtr->sectionPtr->segPtr; segPtr2 != segPtr; segPtr2 = segPtr2->nextPtr) {
+	offset += segPtr2->size;
+	assert(segPtr2->nextPtr);
+    }
+
+    return offset;
+}
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextSegToIndex --
+ *
+ *	Given a segment pointer, this function returns the offset of the
+ *	segment within its line.
+ *
+ *	This function assumes that we want the index to the current line,
+ *	and not the index from the start of the logical line.
+ *
+ * Results:
+ *	The return value is the offset (within its line) of the first
+ *	character in segPtr.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+int
+TkTextSegToIndex(
+    const TkTextSegment *segPtr)/* Segment whose offset is desired. */
+{
+    return SegToIndex(segPtr->sectionPtr->linePtr, segPtr);
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextGetIndex --
+ *
+ *	Given a string, return the index that is described.
+ *
+ * Results:
+ *	The return value is a standard Tcl return result. If TCL_OK is
+ *	returned, then everything went well and the index at *indexPtr is
+ *	filled in; otherwise TCL_ERROR is returned and an error message is
+ *	left in the interp's result.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+int
+TkTextGetIndex(
+    Tcl_Interp *interp,		/* Use this for error reporting. */
+    TkText *textPtr,		/* Information about text widget. */
+    const char *string,		/* Textual description of position. */
+    TkTextIndex *indexPtr)	/* Index structure to fill in. */
+{
+    assert(textPtr);
+    return GetIndex(interp, textPtr->sharedTextPtr, textPtr, string, indexPtr) ? TCL_OK : TCL_ERROR;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * GetIndex --
+ *
+ *	Given a string, return the index that is described.
+ *
+ * Results:
+ *	If 'true' is returned, then everything went well and the index at
+ *	*indexPtr is filled in; otherwise 'false' is returned and an error
+ *	message is left in the interp's result.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+static unsigned
+SkipSegments(
+    TkTextSegment *startMarkPtr)
+{
+    TkTextSegment *segPtr = startMarkPtr->sectionPtr->linePtr->segPtr;
+    unsigned charIndex = 0;
+
+    /* Skip chars not belonging to this text widget. */
+
+    for ( ; segPtr != startMarkPtr; segPtr = segPtr->nextPtr) {
+	if (segPtr->tagInfoPtr) {
+	    charIndex += (segPtr->typePtr == &tkTextCharType) ? CountCharsInSeg(segPtr) : 1;
+	}
+    }
+
+    return charIndex;
+}
+
+static bool
+GetIndex(
+    Tcl_Interp *interp,		/* Use this for error reporting. */
+    TkSharedText *sharedTextPtr,/* Pointer to shared resource. */
+    TkText *textPtr,		/* Information about text widget. */
+    const char *string,		/* Textual description of position. */
+    TkTextIndex *indexPtr)	/* Index structure to fill in. */
+{
+    char *p, *end, *endOfBase;
+    TkTextIndex first, last;
+    char c;
+    const char *cp;
+    char *myString;
+    Tcl_DString copy;
+    bool tagFound;
+    bool skipMark;
+    bool result;
+
+    assert(textPtr);
+    assert(sharedTextPtr);
+
+    /*
+     * The documentation about indices says:
+     *
+     *	The base for an index must have one of the following forms:
+     *
+     *		<line.<char>
+     *		@<x>,<y>
+     *		begin
+     *		end
+     *		<mark>
+     *		<tag>.first
+     *		<tag>.last
+     *		<pathName>
+     *		<imageName>
+     *
+     * Furthermore the documentation says:
+     *
+     *	If the base could match more than one of the above forms, such as a mark and imageName
+     *	both having the same value, then the form earlier in the above list takes precedence. 
+     */
+
+#if BEGIN_DOES_NOT_BELONG_TO_BASE
+    /*
+     *------------------------------------------------
+     * Stage 0: for portability reasons keyword "begin" has the lowest
+     * precedence (but this should be corrected in a future version).
+     *------------------------------------------------
+     */
+
+    if (string[0] == 'b' && strncmp(string, "begin", 5)) {
+	if (TkTextMarkNameToIndex(textPtr, string, indexPtr)
+		|| TkTextWindowIndex(textPtr, string, indexPtr)
+		|| TkTextImageIndex(textPtr, string, indexPtr)) {
+	    return true;
+	}
+    }
+#endif /* BEGIN_DOES_NOT_BELONG_TO_BASE */
+
+    /*
+     *------------------------------------------------
+     * Stage 1: start by parsing the base index.
+     *------------------------------------------------
+     */
+
+    TkTextIndexClear(indexPtr, textPtr);
+
+    /*
+     * First look for the form "tag.first" or "tag.last" where "tag" is the
+     * name of a valid tag. Try to use up as much as possible of the string in
+     * this check (strrchr instead of strchr below). Doing the check now, and
+     * in this way, allows tag names to include funny characters like "@" or
+     * "+1c".
+     */
+
+    Tcl_DStringInit(&copy);
+    myString = Tcl_DStringAppend(&copy, string, -1);
+    p = strrchr(myString, '.');
+    skipMark = false;
+
+    if (p) {
+	TkTextSearch search;
+	TkTextTag *tagPtr;
+	Tcl_HashEntry *hPtr = NULL;
+	const char *tagName;
+	bool wantLast;
+
+	if (p[1] == 'f' && strncmp(p + 1, "first", 5) == 0) {
+	    wantLast = false;
+	    endOfBase = p + 6;
+	} else if (p[1] == 'l' && strncmp(p + 1, "last", 4) == 0) {
+	    wantLast = true;
+	    endOfBase = p + 5;
+	} else {
+	    goto tryxy;
+	}
+
+	/*
+	 * Marks have a higher precedence than tag.first or tag.last, so we will
+	 * search for marks before proceeding with tags.
+	 */
+
+	if (TkTextMarkNameToIndex(textPtr, string, indexPtr)) {
+	    Tcl_DStringFree(&copy);
+	    return true;
+	}
+
+	skipMark = true;
+	tagPtr = NULL;
+	tagName = myString;
+	if (p - tagName == 3 && strncmp(tagName, "sel", 3) == 0) {
+	    /*
+	     * Special case for sel tag which is not stored in the hash table.
+	     */
+	    tagPtr = textPtr->selTagPtr;
+	} else {
+	    *p = '\0';
+	    hPtr = Tcl_FindHashEntry(&sharedTextPtr->tagTable, tagName);
+	    *p = '.';
+	    if (hPtr) {
+		tagPtr = Tcl_GetHashValue(hPtr);
+	    }
+	}
+
+	if (!tagPtr) {
+	    goto tryxy;
+	}
+
+	TkTextIndexSetupToStartOfText(&first, textPtr, sharedTextPtr->tree);
+	TkTextIndexSetupToEndOfText(&last, textPtr, sharedTextPtr->tree);
+	if (wantLast) {
+	    TkBTreeStartSearchBack(&last, &first, tagPtr, &search, SEARCH_EITHER_TAGON_TAGOFF);
+	    tagFound = TkBTreePrevTag(&search);
+	} else {
+	    TkBTreeStartSearch(&first, &last, tagPtr, &search, SEARCH_NEXT_TAGON);
+	    tagFound = TkBTreeNextTag(&search);
+	}
+	if (!tagFound) {
+	    if (tagPtr == textPtr->selTagPtr) {
+		tagName = "sel";
+	    } else if (hPtr) {
+		tagName = Tcl_GetHashKey(&sharedTextPtr->tagTable, hPtr);
+	    }
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		    "text doesn't contain any characters tagged with \"%s\"", tagName));
+	    Tcl_SetErrorCode(interp, "TK", "LOOKUP", "TEXT_INDEX", tagName, NULL);
+	    Tcl_DStringFree(&copy);
+	    return false;
+	}
+	*indexPtr = search.curIndex;
+	goto gotBase;
+    }
+
+  tryxy:
+    if (string[0] == '@') {
+	/*
+	 * Find character at a given x,y location in the window.
+	 */
+
+	int x, y;
+
+	cp = string + 1;
+	if (*cp == 'f' && strncmp(cp, "first,", 6) == 0) {
+	    x = TkTextGetFirstXPixel(textPtr);
+	    end = (char *) cp + 5;
+	} else if (*cp == 'l' && strncmp(cp, "last,", 5) == 0) {
+	    x = TkTextGetLastXPixel(textPtr);
+	    end = (char *) cp + 4;
+	} else {
+	    x = strtol(cp, &end, 0);
+	    if (end == cp || *end != ',') {
+		goto noBaseFound;
+	    }
+	}
+	cp = end + 1;
+	if (*cp == 'f' && strcmp(cp, "first") == 0) {
+	    y = TkTextGetFirstYPixel(textPtr);
+	    end += 6;
+	} else if (*cp == 'l' && strcmp(cp, "last") == 0) {
+	    y = TkTextGetLastYPixel(textPtr);
+	    end += 5;
+	} else {
+	    y = strtol(cp, &end, 0);
+	    if (end == cp) {
+		goto noBaseFound;
+	    }
+	}
+	TkTextPixelIndex(textPtr, x, y, indexPtr, NULL);
+	endOfBase = end;
+	goto gotBase;
+    }
+
+    if (isdigit(string[0]) || string[0] == '-') {
+	int lineIndex, charIndex;
+
+	/*
+	 * Base is identified with line and character indices.
+	 */
+
+	lineIndex = strtol(string, &end, 0) - 1;
+	if (end == string || *end != '.') {
+	    goto noBaseFound;
+	}
+	p = end + 1;
+	if (*p == 'e' && strncmp(p, "end", 3) == 0) {
+	    charIndex = INT_MAX;
+	    endOfBase = p + 3;
+	} else if (*p == 'b' && strncmp(p, "begin", 5) == 0) {
+	    charIndex = 0;
+	    endOfBase = p + 5;
+	} else {
+	    charIndex = strtol(p, &end, 0);
+	    if (end == p) {
+		goto noBaseFound;
+	    }
+	    endOfBase = end;
+	}
+	if (lineIndex == 0 && textPtr->startMarker != sharedTextPtr->startMarker) {
+	    charIndex += SkipSegments(textPtr->startMarker);
+	}
+	TkTextMakeCharIndex(sharedTextPtr->tree, textPtr, lineIndex, charIndex, indexPtr);
+	goto gotBase;
+    }
+
+    for (p = myString; *p != 0; ++p) {
+	if (isspace(*p) || *p == '+' || *p == '-') {
+	    break;
+	}
+    }
+    endOfBase = p;
+    if (string[0] == '.') {
+	/*
+	 * See if the base position is the name of an embedded window.
+	 */
+
+	c = *endOfBase;
+	*endOfBase = '\0';
+	result = TkTextWindowIndex(textPtr, myString, indexPtr);
+	*endOfBase = c;
+	if (result) {
+	    goto gotBase;
+	}
+    }
+    if (string[0] == 'b' && endOfBase - myString == 5 && strncmp(string, "begin", 5) == 0) {
+	/*
+	 * Base position is start of text.
+	 */
+
+	TkTextIndexSetupToStartOfText(indexPtr, textPtr, sharedTextPtr->tree);
+	goto gotBase;
+    }
+    if (string[0] == 'e' && endOfBase - myString == 3 && strncmp(string, "end", 3) == 0) {
+	/*
+	 * Base position is end of text.
+	 */
+
+	TkTextIndexSetupToEndOfText(indexPtr, textPtr, sharedTextPtr->tree);
+	goto gotBase;
+    }
+    
+    /*
+     * See if the base position is the name of a mark.
+     */
+
+    c = *endOfBase;
+    *endOfBase = '\0';
+    result = TkTextMarkNameToIndex(textPtr, myString, indexPtr);
+    if (result) {
+	*endOfBase = c;
+	goto gotBase;
+    }
+
+    /*
+     * See if the base position is the name of an embedded image.
+     */
+
+    result = TkTextImageIndex(textPtr, myString, indexPtr);
+    *endOfBase = c;
+    if (result) {
+	goto gotBase;
+    }
+
+  noBaseFound:
+    if ((!skipMark && TkTextMarkNameToIndex(textPtr, string, indexPtr))
+	    || TkTextWindowIndex(textPtr, string, indexPtr)
+	    || TkTextImageIndex(textPtr, string, indexPtr)) {
+	Tcl_DStringFree(&copy);
+	return true;
+    }
+
+    Tcl_DStringFree(&copy);
+    Tcl_ResetResult(interp);
+    Tcl_SetObjResult(interp, Tcl_ObjPrintf("bad text index \"%s\"", string));
+    Tcl_SetErrorCode(interp, "TK", "TEXT", "BAD_INDEX", NULL);
+    return false;
+
+    /*
+     *-------------------------------------------------------------------
+     * Stage 2: process zero or more modifiers. Each modifier is either a
+     * keyword like "wordend" or "linestart", or it has the form "op count
+     * units" where op is + or -, count is a number, and units is "chars" or
+     * "lines".
+     *-------------------------------------------------------------------
+     */
+
+  gotBase:
+    cp = endOfBase;
+
+    while (true) {
+	while (isspace(*cp)) {
+	    cp++;
+	}
+	if (*cp == '\0') {
+	    break;
+	}
+	if (*cp == '+' || *cp == '-') {
+	    cp = ForwBack(textPtr, cp, indexPtr);
+	} else {
+	    cp = StartEnd(textPtr, cp, indexPtr);
+	}
+	if (!cp) {
+	    goto noBaseFound;
+	}
+    }
+
+    Tcl_DStringFree(&copy);
+    return true;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextIndexPrint --
+ *
+ *	This function generates a string description of an index, suitable for
+ *	reading in again later.
+ *
+ * Results:
+ *	The characters pointed to by string are modified. Returns the number
+ *	of characters in the string.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+int
+TkTextIndexPrint(
+    const TkSharedText *sharedTextPtr,
+    				/* Pointer to shared resource. */
+    const TkText *textPtr,	/* Information about text widget, can be NULL. */
+    const TkTextIndex *indexPtr,/* Pointer to index. */
+    char *string)		/* Place to store the position. Must have at least TK_POS_CHARS
+    				 * characters. */
+{
+    const TkTextSegment *segPtr;
+    const TkTextLine *linePtr;
+    const TkTextSegment *startMarker;
+    int charIndex;
+
+    assert(sharedTextPtr);
+    assert(indexPtr);
+    assert(string);
+    assert(CheckLine(indexPtr, indexPtr->priv.linePtr));
+    assert(CheckByteIndex(indexPtr, indexPtr->priv.linePtr, -1));
+
+    charIndex = 0;
+    linePtr = indexPtr->priv.linePtr;
+    startMarker = textPtr ? textPtr->startMarker : sharedTextPtr->startMarker;
+    segPtr = (linePtr == startMarker->sectionPtr->linePtr) ? startMarker : linePtr->segPtr;
+
+    /*
+     * Too bad that we cannot use the section structure here.
+     *
+     * The user of the Tk text widget is encouraged to work with marks,
+     * in this way the expensive mappings between char indices and byte
+     * indices can be avoided.
+     */
+
+    if (indexPtr->priv.segPtr && !indexPtr->priv.isCharSegment) {
+	TkTextSegment *lastPtr = indexPtr->priv.segPtr;
+
+	assert(indexPtr->priv.segPtr->typePtr);
+
+	while (lastPtr->size == 0) {
+	    lastPtr = lastPtr->nextPtr;
+	}
+
+	for ( ; segPtr != lastPtr; segPtr = segPtr->nextPtr) {
+	    if (segPtr->typePtr == &tkTextCharType) {
+		charIndex += CountCharsInSeg(segPtr);
+	    } else {
+		assert(segPtr->size <= 1);
+		charIndex += segPtr->size;
+	    }
+	    assert(segPtr->nextPtr);
+	}
+    } else {
+	int numBytes = TkTextIndexGetByteIndex(indexPtr);
+
+	if (segPtr == startMarker && startMarker != sharedTextPtr->startMarker) {
+	    numBytes -= TkTextSegToIndex(startMarker);
+	}
+
+	assert(numBytes >= 0);
+	assert(numBytes < linePtr->size);
+
+	for ( ; numBytes > segPtr->size; segPtr = segPtr->nextPtr) {
+	    if (segPtr->typePtr == &tkTextCharType) {
+		charIndex += CountCharsInSeg(segPtr);
+	    } else {
+		assert(segPtr->size <= 1);
+		charIndex += segPtr->size;
+	    }
+	    numBytes -= segPtr->size;
+	    assert(segPtr->nextPtr);
+	}
+
+	if (numBytes) {
+	    if (segPtr->typePtr == &tkTextCharType) {
+		charIndex += Tcl_NumUtfChars(segPtr->body.chars, numBytes);
+	    } else {
+		assert(segPtr->size <= 1);
+		charIndex += numBytes;
+	    }
+	}
+    }
+
+    return snprintf(string, TK_POS_CHARS, "%d.%d",
+	    TkBTreeLinesTo(indexPtr->tree, textPtr, linePtr, NULL) + 1, charIndex);
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * ForwBack --
+ *
+ *	This function handles +/- modifiers for indices to adjust the index
+ *	forwards or backwards.
+ *
+ * Results:
+ *	If the modifier in string is successfully parsed then the return value
+ *	is the address of the first character after the modifier, and
+ *	*indexPtr is updated to reflect the modifier. If there is a syntax
+ *	error in the modifier then NULL is returned.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+static const char *
+ForwBack(
+    TkText *textPtr,		/* Information about text widget. */
+    const char *string,		/* String to parse for additional info about
+				 * modifier (count and units). Points to "+"
+				 * or "-" that starts modifier. */
+    TkTextIndex *indexPtr)	/* Index to update as specified in string. */
+{
+    const char *p, *units;
+    char *end;
+    int count, lineIndex, modifier;
+    size_t length;
+
+    assert(textPtr);
+
+    /*
+     * Get the count (how many units forward or backward).
+     */
+
+    p = string + 1;
+    while (isspace(*p)) {
+	p++;
+    }
+    count = strtol(p, &end, 0);
+    if (end == p) {
+	return NULL;
+    }
+    p = end;
+    while (isspace(*p)) {
+	p++;
+    }
+
+    /*
+     * Find the end of this modifier (next space or + or - character), then
+     * check if there is a textual 'display' or 'any' modifier. These
+     * modifiers can be their own word (in which case they can be abbreviated)
+     * or they can follow on to the actual unit in a single word (in which
+     * case no abbreviation is allowed). So, 'display lines', 'd lines',
+     * 'displaylin' are all ok, but 'dline' is not.
+     */
+
+    units = p;
+    while (*p != '\0' && !isspace(*p) && *p != '+' && *p != '-') {
+	p++;
+    }
+    length = p - units;
+    if (*units == 'd' && strncmp(units, "display", MIN(length, 7)) == 0) {
+	modifier = TKINDEX_DISPLAY;
+	if (length > 7) {
+	    p -= (length - 7);
+	}
+    } else if (*units == 'a' && strncmp(units, "any", MIN(length, 3)) == 0) {
+	modifier = TKINDEX_CHAR;
+	if (length > 3) {
+	    p -= (length - 3);
+	}
+    } else {
+	modifier = TKINDEX_NONE;
+    }
+
+    /*
+     * If we had a modifier, which we interpreted ok, so now forward to the
+     * actual units.
+     */
+
+    if (modifier != TKINDEX_NONE) {
+	while (isspace(*p)) {
+	    p++;
+	}
+	units = p;
+	while (*p != '\0' && !isspace(*p) && *p != '+' && *p != '-') {
+	    p++;
+	}
+	length = p - units;
+    }
+
+    /*
+     * Finally parse the units.
+     */
+
+    if (*units == 'c' && strncmp(units, "chars", length) == 0) {
+	TkTextCountType type;
+
+	if (modifier == TKINDEX_DISPLAY) {
+	    type = COUNT_DISPLAY_CHARS;
+	} else { /* if (modifier == TKINDEX_NONE) */
+	    assert(modifier == TKINDEX_NONE || modifier == TKINDEX_CHAR);
+
+	    /*
+	     * The following is incompatible to 8.4 (and prior versions), but I think that
+	     * now it's the time to eliminate this known issue:
+	     *
+	     *    Before Tk 8.5, the widget used the string chars to refer to index positions
+	     *    (which included characters, embedded windows and embedded images). As of Tk 8.5
+	     *    the text widget deals separately and correctly with chars and indices. For
+	     *    backwards compatibility, however, the index modifiers +N chars and -N chars
+	     *    continue to refer to indices. One must use any of the full forms +N any chars
+	     *    or -N any chars etc. to refer to actual character indices. This confusion may
+	     *    be fixed in a future release by making the widget correctly interpret +N chars
+	     *    as a synonym for +N any chars.
+	     *
+	     * This confusion is fixed now, we will interpret "+N chars" as a synonym for
+	     * +N any chars.
+	     */
+
+	    type = COUNT_CHARS;
+	}
+
+	if (*string == '+') {
+	    TkTextIndexForwChars(textPtr, indexPtr, count, indexPtr, type);
+	} else {
+	    TkTextIndexBackChars(textPtr, indexPtr, count, indexPtr, type);
+	}
+    } else if (*units == 'i' && strncmp(units, "indices", length) == 0) {
+	TkTextCountType type;
+
+	if (modifier == TKINDEX_DISPLAY) {
+	    type = COUNT_DISPLAY_INDICES;
+	} else {
+	    type = COUNT_INDICES;
+	}
+
+	if (*string == '+') {
+	    TkTextIndexForwChars(textPtr, indexPtr, count, indexPtr, type);
+	} else {
+	    TkTextIndexBackChars(textPtr, indexPtr, count, indexPtr, type);
+	}
+    } else if (*units == 'l' && strncmp(units, "lines", length) == 0) {
+	if (modifier == TKINDEX_DISPLAY) {
+	    /*
+	     * Find the appropriate pixel offset of the current position
+	     * within its display line. This also has the side-effect of
+	     * moving indexPtr, but that doesn't matter since we will do it
+	     * again below.
+	     *
+	     * Then find the right display line, and finally calculated the
+	     * index we want in that display line, based on the original pixel
+	     * offset.
+	     */
+
+	    int xOffset;
+	    bool forward;
+
+	    /*
+	     * Go forward to the first non-elided index.
+	     */
+
+	    if (TkTextIsElided(indexPtr)) {
+		TkTextSkipElidedRegion(indexPtr);
+	    }
+
+	    if (count == 0) {
+		return p;
+	    }
+
+	    /*
+	     * Unlike the Forw/BackChars code, the display line code is
+	     * sensitive to whether we are genuinely going forwards or
+	     * backwards. So, we need to determine that. This is important in
+	     * the case where we have "+ -3 displaylines", for example.
+	     */
+
+	    forward = (count < 0) == (*string == '-');
+	    count = abs(count);
+	    if (!forward) {
+		count = -count;
+	    }
+
+	    TkTextFindDisplayIndex(textPtr, indexPtr, count, &xOffset);
+
+	    /*
+	     * This call assumes indexPtr is the beginning of a display line
+	     * and moves it to the 'xOffset' position of that line, which is
+	     * just what we want.
+	     */
+
+	    TkTextIndexOfX(textPtr, xOffset, indexPtr);
+
+	    /*
+	     * We must skip any elided range.
+	     */
+
+	    if (TkTextIsElided(indexPtr)) {
+		TkTextSkipElidedRegion(indexPtr);
+	    }
+	} else {
+	    lineIndex = TkBTreeLinesTo(indexPtr->tree, textPtr, indexPtr->priv.linePtr, NULL);
+	    if (*string == '+') {
+		lineIndex += count;
+	    } else {
+		lineIndex -= count;
+
+		/*
+		 * The check below retains the character position, even if the
+		 * line runs off the start of the file. Without it, the
+		 * character position will get reset to 0 by TkTextMakeIndex.
+		 */
+
+		if (lineIndex < 0) {
+		    lineIndex = 0;
+		}
+	    }
+
+	    /*
+	     * This doesn't work quite right if using a proportional font or
+	     * UTF-8 characters with varying numbers of bytes, or if there are
+	     * embedded windows, images, etc. The cursor will bop around,
+	     * keeping a constant number of bytes (not characters) from the
+	     * left edge (but making sure not to split any UTF-8 characters),
+	     * regardless of the x-position the index corresponds to. The
+	     * proper way to do this is to get the x-position of the index and
+	     * then pick the character at the same x-position in the new line.
+	     */
+
+	    if (textPtr->startMarker != textPtr->sharedTextPtr->startMarker) {
+		indexPtr->priv.byteIndex += TkTextSegToIndex(textPtr->startMarker);
+	    }
+	    TkTextMakeByteIndex(indexPtr->tree, textPtr, lineIndex, indexPtr->priv.byteIndex, indexPtr);
+	}
+    } else {
+	return NULL;
+    }
+    return p;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextIndexForwBytes --
+ *
+ *	Given an index for a text widget, this function creates a new index
+ *	that points "byteCount" bytes ahead of the source index.
+ *
+ * Results:
+ *	*dstPtr is modified to refer to the character "count" bytes after
+ *	srcPtr, or to the last character in the TkText if there aren't "byteCount"
+ *	bytes left.
+ *
+ *	In this latter case, the function returns '1' to indicate that not all
+ *	of 'byteCount' could be used.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+int
+TkTextIndexForwBytes(
+    const TkText *textPtr,	/* Overall information about text widget, can be NULL. */
+    const TkTextIndex *srcPtr,	/* Source index. */
+    int byteCount,		/* How many bytes forward to move. May be negative. */
+    TkTextIndex *dstPtr)	/* Destination index: gets modified. */
+{
+    TkTextLine *linePtr;
+    int byteIndex;
+
+    if (byteCount == 0) {
+	if (dstPtr != srcPtr) {
+	    *dstPtr = *srcPtr;
+	}
+	return 0;
+    }
+
+    if (byteCount < 0) {
+	TkTextIndexBackBytes(textPtr, srcPtr, -byteCount, dstPtr);
+	return 0;
+    }
+
+    if (dstPtr != srcPtr) {
+	*dstPtr = *srcPtr;
+    }
+
+    TkTextIndexToByteIndex(dstPtr);
+    linePtr = TkTextIndexGetLine(dstPtr);
+
+    if (textPtr) {
+	if (linePtr == TkBTreeGetLastLine(textPtr)) {
+	    return 1;
+	}
+	if (textPtr->endMarker->sectionPtr->linePtr == linePtr) {
+	    /*
+	     * Special case: line contains end marker.
+	     */
+
+	    int lineLength = SegToIndex(linePtr, textPtr->endMarker);
+
+	    if ((byteIndex = (dstPtr->priv.byteIndex += byteCount)) > lineLength) {
+		assert(linePtr->nextPtr);
+		TkTextIndexSetByteIndex2(dstPtr, linePtr->nextPtr, 0);
+	    }
+	    return byteIndex <= lineLength ? 0 : 1;
+	}
+    } else if (!linePtr->nextPtr) {
+	return 1;
+    }
+
+    if ((byteIndex = dstPtr->priv.byteIndex + byteCount) > linePtr->size) {
+	DEBUG(TkTextIndex index = *srcPtr);
+	bool rc = TkBTreeMoveForward(dstPtr, byteCount);
+	assert(!rc || TkTextIndexCountBytes(&index, dstPtr) == byteCount);
+	return rc ? 0 : 1;
+    }
+
+    if (byteIndex == linePtr->size) {
+	assert(linePtr->nextPtr);
+	TkTextIndexSetByteIndex2(dstPtr, linePtr->nextPtr, 0);
+    } else {
+	TkTextIndexSetByteIndex(dstPtr, byteIndex);
+    }
+
+    return 0;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextIndexForwChars --
+ *
+ *	Given an index for a text widget, this function creates a new index
+ *	that points "count" items of type given by "type" ahead of the source
+ *	index. "count" can be zero, which is useful in the case where one
+ *	wishes to move forward by display (non-elided) chars or indices or one
+ *	wishes to move forward by chars, skipping any intervening indices. In
+ *	this case dstPtr will point to the first acceptable index which is
+ *	encountered.
+ *
+ * Results:
+ *	*dstPtr is modified to refer to the character "count" items after
+ *	srcPtr, or to the last character in the TkText if there aren't
+ *	sufficient items left in the widget.
+ *
+ *	This function returns whether the resulting index is different from
+ *	source index.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexForwChars(
+    const TkText *textPtr,	/* Overall information about text widget, can be NULL. */
+    const TkTextIndex *srcPtr,	/* Source index. */
+    int charCount,		/* How many characters forward to move. May be negative. */
+    TkTextIndex *dstPtr,	/* Destination index: gets modified. */
+    TkTextCountType type)	/* The type of item to count */
+{
+    TkTextLine *linePtr;
+    TkTextSegment *segPtr;
+    TkTextSegment *endPtr;
+    TkSharedText *sharedTextPtr;
+    int byteOffset;
+    bool checkElided;
+    bool trimmed;
+    bool skipSpaces;
+
+    if (charCount < 0) {
+	return TkTextIndexBackChars(textPtr, srcPtr, -charCount, dstPtr, type);
+    }
+
+    if (dstPtr != srcPtr) {
+	*dstPtr = *srcPtr;
+    }
+
+    if (TkTextIndexIsEndOfText(dstPtr)) {
+	return false;
+    }
+
+    sharedTextPtr = TkTextIndexGetShared(srcPtr);
+    checkElided = !!(type & COUNT_DISPLAY) && TkBTreeHaveElidedSegments(sharedTextPtr);
+
+    if (checkElided && TkTextIsElided(dstPtr) && !TkTextSkipElidedRegion(dstPtr)) {
+	return false;
+    }
+
+    if (charCount == 0) {
+	return false;
+    }
+
+    assert(dstPtr->priv.byteIndex <= FindEndByteIndex(dstPtr));
+
+    /*
+     * Find seg that contains src byteIndex. Move forward specified number of chars.
+     */
+
+    segPtr = TkTextIndexGetFirstSegment(dstPtr, &byteOffset);
+    endPtr = textPtr ? textPtr->endMarker : sharedTextPtr->endMarker;
+    TkTextIndexToByteIndex(dstPtr);
+    trimmed = textPtr && textPtr->spaceMode == TEXT_SPACEMODE_TRIM && !!(type & COUNT_DISPLAY);
+    skipSpaces = false;
+
+    while (true) {
+	/*
+	 * Go through each segment in line looking for specified character index.
+	 */
+
+	for ( ; segPtr; segPtr = segPtr->nextPtr) {
+	    if (segPtr->tagInfoPtr) {
+		if (segPtr->typePtr == &tkTextCharType) {
+		    const char *start = segPtr->body.chars + byteOffset;
+		    const char *end = segPtr->body.chars + segPtr->size;
+		    const char *p = start;
+		    int ch, n;
+
+		    for (p = start; p < end; p += n) {
+			if (charCount <= 0) {
+			    if (skipSpaces) {
+				while (*p == ' ') {
+				    ++p;
+				}
+				if (p == end) {
+				    break;
+				}
+			    }
+			    dstPtr->priv.byteIndex += (p - start);
+			    goto forwardCharDone;
+			}
+			n = TkUtfToUniChar(p, &ch);
+			if (ch == ' ') {
+			    if (!skipSpaces) {
+				skipSpaces = trimmed;
+				charCount -= 1;
+			    }
+			} else {
+			    skipSpaces = false;
+			    charCount -= (type & COUNT_INDICES) ? n : 1;
+			}
+		    }
+		} else if (type & COUNT_INDICES) {
+		    assert(byteOffset == 0);
+		    assert(segPtr->size <= 1);
+		    if (charCount < segPtr->size) {
+			dstPtr->priv.byteIndex += charCount;
+			dstPtr->priv.segPtr = segPtr;
+			dstPtr->priv.isCharSegment = false;
+			goto forwardCharDone;
+		    }
+		    charCount -= segPtr->size;
+		}
+		dstPtr->priv.byteIndex += segPtr->size - byteOffset;
+		byteOffset = 0;
+	    } else if (checkElided && segPtr->typePtr == &tkTextBranchType) {
+		TkTextIndexSetSegment(dstPtr, segPtr = segPtr->body.branch.nextPtr);
+		if (TkTextIndexRestrictToEndRange(dstPtr) >= 0) {
+		    goto forwardCharDone;
+		}
+		TkTextIndexToByteIndex(dstPtr);
+	    } else if (segPtr == endPtr) {
+		if (charCount > 0) {
+		    TkTextIndexSetupToEndOfText(dstPtr, (TkText *) textPtr, srcPtr->tree);
+		}
+		goto forwardCharDone;
+	    }
+	}
+
+	/*
+	 * Go to the next line. If we are at the end of the text item, back up
+	 * one byte (for the terminal '\n' character) and return that index.
+	 */
+
+	if (!(linePtr = TkBTreeNextLine(textPtr, dstPtr->priv.linePtr))) {
+	    TkTextIndexSetToLastChar(dstPtr);
+	    goto forwardCharDone;
+	}
+	dstPtr->priv.linePtr = linePtr;
+	dstPtr->priv.byteIndex = 0;
+	dstPtr->priv.lineNo = -1;
+	dstPtr->priv.lineNoRel = -1;
+	segPtr = linePtr->segPtr;
+    }
+
+  forwardCharDone:
+    dstPtr->stateEpoch = TkBTreeEpoch(dstPtr->tree);
+    return true;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextSkipElidedRegion --
+ *
+ *	Given an index for a text widget, this function returns an index with
+ *	the position of first un-elided character, or end of text, if the first
+ *	un-elided character is beyond of this text widget. This functions assumes
+ *	that the text position specified with incoming index is elided.
+ *
+ * Results:
+ *	*indexPtr is modified to refer to the first un-elided character. This
+ *	functions returns 'false' iff we reach the end of the text (belonging to
+ *	this widget).
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+bool
+TkTextSkipElidedRegion(
+    TkTextIndex *indexPtr)
+{
+    TkTextSegment *segPtr;
+
+    assert(indexPtr->textPtr);
+    assert(TkTextIsElided(indexPtr));
+
+    segPtr = TkBTreeFindEndOfElidedRange(indexPtr->textPtr->sharedTextPtr,
+	    indexPtr->textPtr, TkTextIndexGetContentSegment(indexPtr, NULL));
+    TkTextIndexSetSegment(indexPtr, segPtr);
+    return !TkTextIndexIsEndOfText(indexPtr);
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextIndexCountBytes --
+ *
+ *	Given a pair of indices in a text widget, this function counts how
+ *	many bytes are between the two indices. The two indices must be
+ *	ordered.
+ *
+ * Results:
+ *	The number of bytes in the given range.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+unsigned
+TkTextIndexCountBytes(
+    const TkTextIndex *indexPtr1,	/* Index describing location of character from which to count. */
+    const TkTextIndex *indexPtr2)	/* Index describing location of last character at which to
+    					 * stop the count. */
+{
+    int byteCount;
+    TkTextLine *linePtr;
+
+    assert(TkTextIndexCompare(indexPtr1, indexPtr2) <= 0);
+
+    if (indexPtr1->priv.linePtr == indexPtr2->priv.linePtr) {
+        return TkTextIndexGetByteIndex(indexPtr2) - TkTextIndexGetByteIndex(indexPtr1);
+    }
+
+    /*
+     * indexPtr2 is on a line strictly after the line containing indexPtr1.
+     * Add up:
+     *   bytes between indexPtr1 and end of its line
+     *   bytes in lines strictly between indexPtr1 and indexPtr2
+     *   bytes between start of the indexPtr2 line and indexPtr2
+     */
+
+    linePtr = indexPtr1->priv.linePtr;
+    byteCount = linePtr->size - TkTextIndexGetByteIndex(indexPtr1);
+    byteCount += TkTextIndexGetByteIndex(indexPtr2);
+    byteCount += TkBTreeCountSize(indexPtr1->tree, NULL, linePtr->nextPtr, indexPtr2->priv.linePtr);
+    return byteCount;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextIndexGetChar --
+ *
+ *	Return the character at given index.
+ *
+ * Results:
+ *	The character at given index.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+Tcl_UniChar
+TkTextIndexGetChar(
+    const TkTextIndex *indexPtr)/* Index describing location of character. */
+{
+    TkTextSegment *segPtr;
+    int byteOffset;
+    int ch;
+
+    segPtr = TkTextIndexGetContentSegment(indexPtr, &byteOffset);
+    TkUtfToUniChar(segPtr->body.chars + byteOffset, &ch);
+    return ch;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextIndexCount --
+ *
+ *	Given an ordered pair of indices in a text widget, this function
+ *	counts how many characters (not bytes) are between the two indices.
+ *
+ *	It is illegal to call this function with unordered indices.
+ *
+ *	Note that 'textPtr' is only used if we need to check for elided
+ *	attributes, i.e. if type is COUNT_DISPLAY_INDICES or
+ *	COUNT_DISPLAY_CHARS.
+ *
+ *	NOTE: here COUNT_INDICES is also counting chars in text segments.
+ *
+ * Results:
+ *	The number of characters in the given range, which meet the
+ *	appropriate 'type' attributes.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+unsigned
+TkTextIndexCount(
+    const TkText *textPtr,	/* Overall information about text widget. */
+    const TkTextIndex *indexPtr1,
+				/* Index describing location of character from which to count. */
+    const TkTextIndex *indexPtr2,
+				/* Index describing location of last character at which to stop
+				 * the count. */
+    TkTextCountType type)	/* The kind of indices to count. */
+{
+    TkTextLine *linePtr;
+    TkTextIndex index;
+    TkTextSegment *segPtr, *lastPtr;
+    int byteOffset, maxBytes;
+    unsigned count;
+    bool checkElided;
+
+    assert(textPtr);
+    assert(TkTextIndexCompare(indexPtr1, indexPtr2) <= 0);
+
+    checkElided = !!(type & COUNT_DISPLAY) && TkBTreeHaveElidedSegments(textPtr->sharedTextPtr);
+    index = *indexPtr1;
+
+    if (checkElided
+	    && TkTextIsElided(&index)
+	    && (!TkTextSkipElidedRegion(&index) || TkTextIndexCompare(&index, indexPtr2) >= 0)) {
+	return 0;
+    }
+
+    /*
+     * Find seg that contains src index, and remember how many bytes not to count in the given segment.
+     */
+
+    segPtr = TkTextIndexGetContentSegment(&index, &byteOffset);
+    lastPtr = TkTextIndexGetContentSegment(indexPtr2, &maxBytes);
+    linePtr = index.priv.linePtr;
+    count = 0;
+
+    if (byteOffset > 0) {
+	if (segPtr->tagInfoPtr) {
+	    if (segPtr->typePtr == &tkTextCharType) {
+		if (type & (COUNT_INDICES|COUNT_TEXT)) {
+		    count += Tcl_NumUtfChars(segPtr->body.chars + byteOffset,
+			    (segPtr == lastPtr ? maxBytes : segPtr->size) - byteOffset);
+		}
+	    } else if (segPtr->typePtr == &tkTextHyphenType) {
+		if (type & (COUNT_HYPHENS|COUNT_INDICES)) {
+		    count += 1;
+		}
+	    } else if (type & COUNT_INDICES) {
+		assert(segPtr->size == 1);
+		count += 1;
+	    }
+	}
+	if (segPtr == lastPtr) {
+	    return count;
+	}
+	segPtr = segPtr->nextPtr;
+    }
+
+    if (maxBytes > 0 && (!checkElided || !TkTextSegmentIsElided(textPtr, lastPtr))) {
+	if (lastPtr->typePtr == &tkTextCharType) {
+	    if (type & (COUNT_TEXT|COUNT_INDICES)) {
+		count += Tcl_NumUtfChars(lastPtr->body.chars, maxBytes);
+	    }
+	} else if (lastPtr->typePtr == &tkTextHyphenType) {
+	    if (type & (COUNT_HYPHENS|COUNT_INDICES)) {
+		count += 1;
+	    }
+	} else if (type & COUNT_INDICES) {
+	    assert(segPtr->size <= 1);
+	    count += 1;
+	}
+    }
+
+    while (true) {
+	/*
+	 * Go through each segment in line adding up the number of characters.
+	 */
+
+	for ( ; segPtr; segPtr = segPtr->nextPtr) {
+	    if (segPtr == lastPtr) {
+		return count;
+	    }
+	    if (segPtr->tagInfoPtr) {
+		if (segPtr->typePtr == &tkTextCharType) {
+		    if (type & (COUNT_TEXT|COUNT_INDICES)) {
+			count += CountCharsInSeg(segPtr);
+		    }
+		} else if (segPtr->typePtr == &tkTextHyphenType) {
+		    if (type & (COUNT_HYPHENS|COUNT_INDICES)) {
+			count += CountCharsInSeg(segPtr);
+		    }
+		} else if (type & COUNT_INDICES) {
+		    assert(segPtr->size == 1);
+		    count += 1;
+		}
+	    } else if (checkElided && segPtr->typePtr == &tkTextBranchType) {
+		TkTextIndexSetSegment(&index, segPtr = segPtr->body.branch.nextPtr);
+		if (TkTextIndexCompare(&index, indexPtr2) >= 0) {
+		    return count;
+		}
+		linePtr = TkTextIndexGetLine(&index);
+	    }
+	}
+
+	/*
+	 * Go to the next line.
+	 */
+
+	linePtr = TkBTreeNextLine(textPtr, linePtr);
+	assert(linePtr);
+	segPtr = linePtr->segPtr;
+    }
+
+    return 0; /* never reached */
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextIndexBackBytes --
+ *
+ *	Given an index for a text widget, this function creates a new index
+ *	that points "count" bytes earlier than the source index.
+ *
+ * Results:
+ *	*dstPtr is modified to refer to the character "count" bytes before
+ *	srcPtr, or to the first character in the TkText if there aren't
+ *	"count" bytes earlier than srcPtr.
+ *
+ *	Returns 1 if we couldn't use all of 'byteCount' because we have run
+ *	into the beginning or end of the text, and zero otherwise.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+/*
+ * NOTE: This function has external linkage, so we cannot change the return
+ * type to 'bool'.
+ */
+
+int
+TkTextIndexBackBytes(
+    const TkText *textPtr,	/* Overall information about text widget, can be NULL. */
+    const TkTextIndex *srcPtr,	/* Source index. */
+    int byteCount,		/* How many bytes backward to move. May be negative. */
+    TkTextIndex *dstPtr)	/* Destination index: gets modified. */
+{
+    TkTextLine *linePtr;
+    int byteIndex;
+
+    if (byteCount == 0) {
+	if (dstPtr != srcPtr) {
+	    *dstPtr = *srcPtr;
+	}
+	return 0;
+    }
+
+    if (byteCount < 0) {
+	return TkTextIndexForwBytes(textPtr, srcPtr, -byteCount, dstPtr);
+    }
+
+    if (dstPtr != srcPtr) {
+	*dstPtr = *srcPtr;
+    }
+    byteIndex = TkTextIndexGetByteIndex(dstPtr);
+    linePtr = TkTextIndexGetLine(dstPtr);
+
+    if (textPtr
+	    && linePtr == textPtr->startMarker->sectionPtr->linePtr
+	    && textPtr->startMarker != textPtr->sharedTextPtr->startMarker) {
+	/*
+	 * Special case: this is the first line, and we have to consider the start marker.
+	 */
+	
+	if ((byteIndex -= byteCount) < SegToIndex(linePtr, textPtr->startMarker)) {
+	    TkTextIndexSetupToStartOfText(dstPtr, (TkText *) textPtr, textPtr->sharedTextPtr->tree);
+	    return 1;
+	}
+
+	TkTextIndexSetByteIndex(dstPtr, byteIndex);
+	return 0;
+    }
+
+    if (byteCount > byteIndex + 1) {
+	DEBUG(TkTextIndex index = *srcPtr);
+	bool rc = TkBTreeMoveBackward(dstPtr, byteCount);
+	assert(!rc || TkTextIndexCountBytes(dstPtr, &index) == byteCount);
+	return rc ? 0 : 1;
+    }
+
+    if ((byteIndex -= byteCount) >= 0) {
+	TkTextIndexSetByteIndex(dstPtr, byteIndex);
+	return 0;
+    }
+
+    /*
+     * Move back one line in the text. If we run off the beginning
+     * then just return the first character in the text widget.
+     */
+
+    if (!(linePtr = TkBTreePrevLine(textPtr, linePtr))) {
+	TkTextIndexSetToStartOfLine(dstPtr);
+	return 1;
+    }
+
+    TkTextIndexSetToLastChar2(dstPtr, linePtr);
+    return 0;
+}
+
+/*
+ *---------------------------------------------------------------------------
+ *
+ * TkTextIndexBackChars --
+ *
+ *	Given an index for a text widget, this function creates a new index
+ *	that points "count" items of type given by "type" earlier than the
+ *	source index. "count" can be zero, which is useful in the case where
+ *	one wishes to move backward by display (non-elided) chars or indices
+ *	or one wishes to move backward by chars, skipping any intervening
+ *	indices. In this case the returned index *dstPtr will point just
+ *	_after_ the first acceptable index which is encountered.
+ *
+ * Results:
+ *	*dstPtr is modified to refer to the character "count" items before
+ *	srcPtr, or to the first index in the window if there aren't sufficient
+ *	items earlier than srcPtr.
+ *
+ *	This function returns whether the resulting index is different from
+ *	source index.
+ *
+ * Side effects:
+ *	None.
+ *
+ *---------------------------------------------------------------------------
+ */
+
+bool
+TkTextIndexBackChars(
+    const TkText *textPtr,	/* Overall information about text widget, can be NULL. */
+    const TkTextIndex *srcPtr,	/* Source index. */
+    int charCount,		/* How many characters backward to move. May be negative. */
+    TkTextIndex *dstPtr,	/* Destination index: gets modified. */
+    TkTextCountType type)	/* The type of item to count */
+{
+    TkSharedText *sharedTextPtr;
+    TkTextSegment *segPtr;
+    TkTextSegment *startPtr;
+    TkTextLine *linePtr;
+    int segSize;
+    bool checkElided;
+    bool trimmed;
+    bool skipSpaces;
+    int byteIndex;
+
+    assert(textPtr || !(type & COUNT_DISPLAY));
+
+    if (charCount < 0) {
+	return TkTextIndexForwChars(textPtr, srcPtr, -charCount, dstPtr, type);
+    }
+
+    if (dstPtr != srcPtr) {
+	*dstPtr = *srcPtr;
+    }
+
+    if (charCount == 0) {
+	return false;
+    }
+
+    sharedTextPtr = TkTextIndexGetShared(srcPtr);
+    checkElided = !!(type & COUNT_DISPLAY) && TkBTreeHaveElidedSegments(textPtr->sharedTextPtr);
+
+    if (checkElided && TkTextIsElided(dstPtr) && !TkTextSkipElidedRegion(dstPtr)) {
+	return false;
+    }
+
+    if (TkTextIndexIsStartOfLine(dstPtr) && !TkBTreePrevLine(textPtr, dstPtr->priv.linePtr)) {
+	return false;
+    }
+
+    if (textPtr && textPtr->endMarker != sharedTextPtr->endMarker) {
+	linePtr = TkBTreeGetLastLine(textPtr);
+
+	if (dstPtr->priv.linePtr == linePtr && linePtr != textPtr->endMarker->sectionPtr->linePtr) {
+	    /*
+	     * Special case: we are at start of last line, but this is not the end line.
+	     */
+
+	    if (--charCount == 0) {
+		byteIndex = TkTextSegToIndex(textPtr->endMarker);
+		dstPtr->priv.linePtr = textPtr->endMarker->sectionPtr->linePtr;
+		dstPtr->priv.segPtr = NULL;
+		dstPtr->priv.lineNo = dstPtr->priv.lineNoRel = -1;
+		goto backwardCharDone;
+	    }
+	    TkTextIndexSetSegment(dstPtr, textPtr->endMarker);
+	}
+    }
+
+    /*
+     * Move backward specified number of chars.
+     */
+
+    segPtr = TkTextIndexGetFirstSegment(dstPtr, &segSize);
+    startPtr = textPtr ? textPtr->startMarker : sharedTextPtr->startMarker;
+    byteIndex = TkTextIndexGetByteIndex(dstPtr);
+    dstPtr->priv.segPtr = NULL;
+
+    /*
+     * Now segPtr points to the segment containing the starting index.
+     */
+
+    trimmed = textPtr && textPtr->spaceMode == TEXT_SPACEMODE_TRIM && !!(type & COUNT_DISPLAY);
+    skipSpaces = false;
+
+    while (true) {
+	/*
+	 * If we do need to pay attention to the visibility of
+	 * characters/indices, check that first. If the current segment isn't
+	 * visible, then we simply continue the loop.
+	 */
+
+	if (segPtr->tagInfoPtr) {
+	    if (segPtr->typePtr == &tkTextCharType) {
+		const char *start = segPtr->body.chars;
+		const char *end = segPtr->body.chars + segSize;
+		const char *p = end;
+
+		while (true) {
+		    const char *q;
+
+		    if (charCount <= 0) {
+			if (skipSpaces) {
+			    while (p > start && p[-1] == ' ') {
+				--p;
+			    }
+			    if (p == start) {
+				break;
+			    }
+			}
+			byteIndex -= (end - p);
+			goto backwardCharDone;
+		    }
+		    if (p == start) {
+			break;
+		    }
+		    p = Tcl_UtfPrev(q = p, start);
+		    if (*p == ' ') {
+			if (!skipSpaces) {
+			    skipSpaces = trimmed;
+			    charCount -= 1;
+			}
+		    } else {
+			skipSpaces = false;
+			charCount -= (type & COUNT_INDICES) ? q - p : 1;
+		    }
+		}
+	    } else if (type & COUNT_INDICES) {
+		assert(segPtr->size <= 1);
+		if (charCount <= segSize) {
+		    byteIndex -= charCount;
+		    dstPtr->priv.segPtr = segPtr;
+		    dstPtr->priv.isCharSegment = false;
+		    goto backwardCharDone;
+		}
+		charCount -= segSize;
+	    }
+	} else if (checkElided && segPtr->typePtr == &tkTextLinkType) {
+	    TkTextIndexSetSegment(dstPtr, segPtr = segPtr->body.link.prevPtr);
+	    dstPtr->priv.segPtr = segPtr;
+	    dstPtr->priv.isCharSegment = false;
+	    if (TkTextIndexRestrictToStartRange(dstPtr) <= 0) {
+		dstPtr->stateEpoch = TkBTreeEpoch(dstPtr->tree);
+		return true;
+	    }
+	    TkTextIndexToByteIndex(dstPtr);
+	    byteIndex = TkTextIndexGetByteIndex(dstPtr);
+	} else if (segPtr == startPtr) {
+	    TkTextIndexSetSegment(dstPtr, segPtr = startPtr);
+	    byteIndex = TkTextIndexGetByteIndex(dstPtr);
+	    goto backwardCharDone;
+	}
+
+	/*
+	 * Move back into previous segment.
+	 */
+
+	if (!(segPtr = segPtr->prevPtr)) {
+	    /*
+	     * Move back to previous line
+	     */
+
+	    linePtr = TkBTreePrevLine(textPtr, dstPtr->priv.linePtr);
+	    assert(linePtr);
+
+	    dstPtr->priv.linePtr = linePtr;
+	    dstPtr->priv.lineNo = -1;
+	    dstPtr->priv.lineNoRel = -1;
+	    byteIndex = linePtr->size;
+	    segPtr = linePtr->lastPtr;
+	} else {
+	    byteIndex -= segSize;
+	}
+
+	segSize = segPtr->size;
+    }
+
+  backwardCharDone:
+    dstPtr->stateEpoch = TkBTreeEpoch(dstPtr->tree);
+    dstPtr->priv.byteIndex = byteIndex;
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * StartEnd --
+ *
+ *	This function handles modifiers like "wordstart" and "lineend" to
+ *	adjust indices forwards or backwards.
+ *
+ * Results:
+ *	If the modifier is successfully parsed then the return value is the
+ *	address of the first character after the modifier, and *indexPtr is
+ *	updated to reflect the modifier. If there is a syntax error in the
+ *	modifier then NULL is returned.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static const char *
+StartEnd(
+    TkText *textPtr,		/* Information about text widget. */
+    const char *string,		/* String to parse for additional info about modifier (count and units).
+    				 * Points to first character of modifier word. */
+    TkTextIndex *indexPtr)	/* Index to modify based on string. */
+{
+    const char *p;
+    size_t length;
+    TkTextSegment *segPtr;
+    int modifier;
+    int mode;
+
+    assert(textPtr);
+
+    /*
+     * Find the end of the modifier word.
+     */
+
+    for (p = string; isalnum(*p); ++p) {
+	/* Empty loop body. */
+    }
+    length = p - string;
+
+    if (*string == 'd' && strncmp(string, "display", MIN(length, 7)) == 0) {
+	modifier = TKINDEX_DISPLAY;
+	mode = COUNT_DISPLAY_INDICES;
+	if (length > 7) {
+	    p -= (length - 7);
+	}
+    } else if (*string == 'a' && strncmp(string, "any", MIN(length, 3)) == 0) {
+	modifier = TKINDEX_CHAR;
+	mode = COUNT_CHARS;
+	if (length > 3) {
+	    p -= (length - 3);
+	}
+    } else {
+	modifier = TKINDEX_NONE;
+	mode = COUNT_INDICES;
+    }
+
+    /*
+     * If we had a modifier, which we interpreted ok, so now forward to the actual units.
+     */
+
+    if (modifier != TKINDEX_NONE) {
+	while (isspace(*p)) {
+	    ++p;
+	}
+	string = p;
+	while (*p && !isspace(*p) && *p != '+' && *p != '-') {
+	    ++p;
+	}
+	length = p - string;
+    }
+
+    if (*string == 'l' && strncmp(string, "lineend", length) == 0 && length >= 5) {
+	if (modifier == TKINDEX_DISPLAY) {
+	    TkTextFindDisplayLineStartEnd(textPtr, indexPtr, DISP_LINE_END);
+	} else {
+	    TkTextIndexSetToLastChar(indexPtr);
+	}
+    } else if (*string == 'l' && strncmp(string, "linestart", length) == 0 && length >= 5) {
+	if (modifier == TKINDEX_DISPLAY) {
+	    TkTextFindDisplayLineStartEnd(textPtr, indexPtr, DISP_LINE_START);
+	} else {
+	    TkTextIndexSetToStartOfLine(indexPtr);
+	}
+    } else if (*string == 'w' && strncmp(string, "wordend", length) == 0 && length >= 5) {
+	int firstChar = 1;
+	int offset;
+
+	/*
+	 * If the current character isn't part of a word then just move
+	 * forward one character. Otherwise move forward until finding a
+	 * character that isn't part of a word and stop there.
+	 */
+
+	if (modifier == TKINDEX_DISPLAY) {
+	    TkTextIndexForwChars(textPtr, indexPtr, 0, indexPtr, COUNT_DISPLAY_INDICES);
+	}
+	segPtr = TkTextIndexGetContentSegment(indexPtr, &offset);
+	while (true) {
+	    int chSize = 1;
+
+	    if (segPtr->typePtr == &tkTextCharType) {
+		int ch;
+
+		chSize = TkUtfToUniChar(segPtr->body.chars + offset, &ch);
+		if (!Tcl_UniCharIsWordChar(ch)) {
+		    break;
+		}
+		firstChar = 0;
+	    }
+	    offset += chSize;
+	    indexPtr->priv.byteIndex += chSize;
+	    if (offset >= segPtr->size) {
+		do {
+		    segPtr = segPtr->nextPtr;
+		} while (segPtr->size == 0);
+		offset = 0;
+	    }
+	}
+	if (firstChar) {
+	    TkTextIndexForwChars(textPtr, indexPtr, 1, indexPtr, mode);
+	}
+    } else if (*string == 'w' && strncmp(string, "wordstart", length) == 0 && length >= 5) {
+	int firstChar = 1;
+	int offset;
+
+	if (modifier == TKINDEX_DISPLAY) {
+	    /*
+	     * Skip elided region.
+	     */
+	    TkTextIndexForwChars(textPtr, indexPtr, 0, indexPtr, COUNT_DISPLAY_INDICES);
+	}
+
+	/*
+	 * Starting with the current character, look for one that's not part
+	 * of a word and keep moving backward until you find one. Then if the
+	 * character found wasn't the first one, move forward again one
+	 * position.
+	 */
+
+	segPtr = TkTextIndexGetContentSegment(indexPtr, &offset);
+	while (true) {
+	    int chSize = 1;
+
+	    if (segPtr->typePtr == &tkTextCharType) {
+		int ch;
+
+		TkUtfToUniChar(segPtr->body.chars + offset, &ch);
+		if (!Tcl_UniCharIsWordChar(ch)) {
+		    break;
+		}
+		if (offset > 0) {
+		    const char *prevPtr = Tcl_UtfPrev(segPtr->body.chars + offset, segPtr->body.chars);
+		    chSize = segPtr->body.chars + offset - prevPtr;
+		}
+		firstChar = 0;
+	    }
+            if (offset == 0) {
+		TkTextIndexBackChars(textPtr, indexPtr, 1, indexPtr, mode);
+		segPtr = TkTextIndexGetContentSegment(indexPtr, &offset);
+
+		if (offset < chSize && indexPtr->priv.byteIndex == 0) {
+		    return p;
+		}
+            } else if ((indexPtr->priv.byteIndex -= chSize) == 0) {
+		return p;
+	    } else if ((offset -= chSize) < 0) {
+		assert(indexPtr->priv.byteIndex > 0);
+		do {
+		    segPtr = segPtr->prevPtr;
+		    assert(segPtr);
+		} while (segPtr->size == 0);
+		offset = 0;
+	    }
+	}
+
+	if (!firstChar) {
+	    TkTextIndexForwChars(textPtr, indexPtr, 1, indexPtr, mode);
+	}
+    } else {
+	p = NULL;
+    }
+
+    return p;
+}
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: src/tktext/tkTextLineBreak.c
===================================================================
--- src/tktext/tkTextLineBreak.c	(revision 0)
+++ src/tktext/tkTextLineBreak.c	(working copy)
@@ -0,0 +1,988 @@
+/*
+ * tkTextLineBreak.c --
+ *
+ *	This module provides line break computation for line wrapping.
+ *	It uses the library "libunibreak" (from Wu Yongwei) for the
+ *	computation, but only if available (currently only UNIX), and if
+ *	the language support is enabled, otherwise our own line break
+ *	algorithm is used (it's a simplified version of the recommendation
+ *	at http://www.unicode.org/reports/tr14/tr14-26.html).
+ *
+ *	The alternative is the use of ICU library (http://site.icu-project.org/),
+ *	instead of libunibreak, but this would require to support a very
+ *	complex interface of a dynamic load library, with other words, we
+ *	would need dozens of functions pointers. This is not really a drawback,
+ *	and probably the ICU library is the better choice, but I think that a
+ *	change to the ICU library is reasonable only if the Tcl/Tk developer team
+ *	is deciding to use this library also for complete Unicode support (character
+ *	conversion, for instance).
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkText.h"
+
+#include <ctype.h>
+#include <assert.h>
+
+#ifndef MAX
+# define MAX(a,b) (((int) a) < ((int) b) ? b : a)
+#endif
+
+
+typedef void (*ComputeBreakLocationsFunc)(
+    const unsigned char *text, size_t len, const char *lang, char *brks);
+
+static void ComputeBreakLocations(
+    const unsigned char *text, size_t len, const char *lang, char *brks);
+
+static ComputeBreakLocationsFunc libLinebreakFunc = ComputeBreakLocations;
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetLineBreakFunc --
+ *
+ *	Return the appropriate line break function. If argument 'lang'
+ *	is NULL, then our own line break alorithm will be used (fast,
+ *	but a bit simple). If 'lang' is not NULL, then this function
+ *	tries to load the library "libunibreak" (currently only UNIX).
+ *	If the load succeeds, then set_linebreaks_utf8 will be returned,
+ *	otherwise ComputeBreakLocations will be returned.
+ *
+ *	Note that "libunibreak" has language specific support, but
+ *	currently only for zh, ja, and ko. Nethertheless any non-NULL
+ *	value for 'lang' tries to use this library.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The "libunibreak" library may be loaded, if available.
+ *
+ *----------------------------------------------------------------------
+ */
+
+#ifdef __UNIX__
+
+static int
+LoadFile(
+    Tcl_Interp *interp,
+    Tcl_Obj *pathPtr,
+    Tcl_LoadHandle *handle,
+    char const **symbols,
+    void **funcs)
+{
+    /* Keep backward compatibility to 8.5 */
+# if TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION == 5
+    return Tcl_FSLoadFile(interp, pathPtr, symbols[0], symbols[1],
+	    (void *) &funcs[0], (void *) &funcs[1], handle, NULL);
+# else
+    return Tcl_LoadFile(interp, pathPtr, symbols, TCL_LOAD_GLOBAL, funcs, handle);
+# endif
+}
+
+static void
+LoadLibUnibreak(
+    Tcl_Interp *interp)
+{
+    typedef void *VoidP;
+    typedef void (*InitFunc)();
+
+    static char const *Symbols[3] = {
+	"init_linebreak",
+	"set_linebreaks_utf8",
+	NULL
+    };
+
+    VoidP Funcs[sizeof(Symbols)/sizeof(Symbols[0])];
+    Tcl_LoadHandle handle;
+    Tcl_Obj *pathPtr = Tcl_NewStringObj("libunibreak.so.1", -1);
+    bool rc;
+
+    Tcl_IncrRefCount(pathPtr);
+    rc = LoadFile(interp, pathPtr, &handle, Symbols, Funcs);
+    if (rc != TCL_OK) {
+	/*
+	 * We couldn't find "libunibreak.so.1", so try the predecessor "liblinebreak.so.2".
+	 */
+
+	Tcl_ResetResult(interp);
+	Tcl_DecrRefCount(pathPtr);
+	pathPtr = Tcl_NewStringObj("liblinebreak.so.2", -1);
+	rc = LoadFile(interp, pathPtr, &handle, Symbols, Funcs);
+    }
+    if (rc == TCL_OK) {
+	((InitFunc) Funcs[0])();
+	libLinebreakFunc = Funcs[1];
+    } else {
+	Tcl_ResetResult(interp);
+    }
+    Tcl_DecrRefCount(pathPtr);
+}
+
+#endif /* __UNIX__ */
+
+static ComputeBreakLocationsFunc
+GetLineBreakFunc(
+    Tcl_Interp *interp,
+    char const *lang)
+{
+#ifdef __UNIX__
+    if (lang) {
+	static bool loaded = false;
+
+	if (!loaded) {
+	    LoadLibUnibreak(interp);
+	}
+    }
+#endif
+    return libLinebreakFunc;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextComputeBreakLocations --
+ *
+ *	Compute break locations in UTF-8 text. This function expects
+ *	a nul-terminated string (this mean that the character at position
+ *	'len' must be NUL). Thus it is also required that the break buffer
+ *	'brks' has at least size 'len+1'. If 'lang' is not NULL, then the
+ *	external library linunibreak will be used for the line break
+ *	computation, but only if this library is loadable, otherwise the
+ *	internal algorithm will be used.
+ *
+ * Results:
+ *	The computed break locations. This function returns 'true' if
+ *	the external linebreak library has been used for the computation,
+ *	otherwise 'false' will be returned.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextComputeBreakLocations(
+    Tcl_Interp *interp,
+    const char *text,	/* must be nul-terminated */
+    unsigned len,	/* without trailing nul byte */
+    const char *lang,	/* can be NULL */
+    char *brks)
+{
+    ComputeBreakLocationsFunc func;
+    int lastBreakablePos = -1;
+    unsigned i;
+
+    assert(text);
+    assert(brks);
+    assert(text[len] == '\0');
+    assert(!lang || (isalpha(lang[0]) && isalpha(lang[1]) && !lang[2]));
+
+    func = GetLineBreakFunc(interp, lang);
+
+    /*
+     * The algorithm don't give us a break value for the last character if we do
+     * not include the final nul char into the computation.
+     */
+
+    len += 1;
+    (*func)((const unsigned char *) text, len, lang, brks);
+    len -= 1;
+
+    for (i = 0; i < len; ++i) {
+	switch (brks[i]) {
+	case LINEBREAK_MUSTBREAK:
+	    break;
+	case LINEBREAK_ALLOWBREAK:
+	    if (text[i] == '-') {
+		if (brks[i] == LINEBREAK_ALLOWBREAK) {
+		    /*
+		     * Fix the problem with the contextual hyphen-minus sign, the implementation of
+		     * libunibreak has (possibly) forgotten this case.
+		     *
+		     * The hyphen-minus (U+002D) needs special context treatment. For simplicity we
+		     * will only check whether we have two preceding, and two succeeding letters.
+		     * TODO: Is there a better method for the decision?
+		     */
+
+		    const char *r = text + i;
+		    const char *p, *q, *s;
+		    Tcl_UniChar uc;
+		    bool allow = false;
+
+		    q = Tcl_UtfPrev(r, text);
+		    if (q != r) {
+			Tcl_UtfToUniChar(q, &uc);
+			if (Tcl_UniCharIsAlpha(uc)) {
+			    p = Tcl_UtfPrev(q, text);
+			    if (p != q) {
+				Tcl_UtfToUniChar(p, &uc);
+				if (Tcl_UniCharIsAlpha(uc)) {
+				    s = r + 1;
+				    s += Tcl_UtfToUniChar(s, &uc);
+				    if (Tcl_UniCharIsAlpha(uc)) {
+					Tcl_UtfToUniChar(s, &uc);
+					if (Tcl_UniCharIsAlpha(uc)) {
+					    allow = true;
+					}
+				    }
+				}
+			    }
+			}
+		    }
+
+		    if (!allow) {
+			brks[i] = LINEBREAK_NOBREAK;
+		    }
+		}
+	    } else if (text[i] == '/' && i > 8) {
+		/*
+		 * Ignore the breaking chance if there is a chance immediately before:
+		 * no break inside "c/o", and no break after "http://" in a long line
+		 * (a suggestion from Wu Yongwei).
+		 */
+
+		if (lastBreakablePos >= i - 2
+			|| (i > 40 && lastBreakablePos >= i - 7 && text[i - 1] == '/')) {
+		    continue;
+		}
+
+		/*
+		 * Special rule to treat Unix paths more nicely (a suggestion from Wu Yongwei).
+		 */
+
+		if (i < len - 1 && text[i + 1] != ' ' && text[i - 1] == ' ') {
+		    lastBreakablePos = i - 1;
+		    continue;
+		}
+	    }
+	    lastBreakablePos = i;
+	    break;
+        case LINEBREAK_INSIDEACHAR:
+	    break;
+	}
+    }
+
+    return func != ComputeBreakLocations;
+}
+
+/*
+ * The following is implementing the recommendations at
+ * http://www.unicode.org/reports/tr14/tr14-26.html, but simplified -
+ * no language specific support, not all the rules (especially no
+ * combining marks), and mostly restricted to Latin-1 and relevant
+ * letters not belonging to specific languages. For a more sophisticated
+ * line break algorithm the library "libunibreak" (from Wu Yongwei)
+ * should be used.
+ */
+
+typedef enum {
+    /* Note that CR, LF, and NL will be interpreted as BK, so only BK is used. */
+    AI, AL, B2, BA, BB, BK, CL, CP, EX, GL, HY, IN, IS, NS, NU, OP, PO, PR, QU, SP, SY, WJ, ZW
+} LBClass;
+
+#define __ AI
+
+/*
+ * Changes in table below (different from Unicode recommendation):
+ *
+ * 0a: CB -> BK	(LINE FEED)
+ * 0d: CR -> BK (CARRIAGE RETURN)
+ * 0e: XX -> BK (SHIFT OUT)
+ * 23: AL -> IN (NUMBER SIGN)
+ * 26: AL -> BB (AMPERSAND)
+ * 3d: AL -> GL (EQUALS SIGN)
+ * 60: CM -> AL (GRAVE ACCENT)
+ */
+
+static const char Table_0000[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, BA, BK, BK, BK, BK, BK, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ SP, EX, QU, IN, PR, PO, BB, QU, OP, CP, AL, PR, IS, HY, IS, SY, /* 20 - 2f */
+/* 3 */ NU, NU, NU, NU, NU, NU, NU, NU, NU, NU, IS, IS, AL, GL, AL, EX, /* 30 - 3f */
+/* 4 */ AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, /* 40 - 4f */
+/* 5 */ AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, OP, PR, CP, AL, AL, /* 50 - 5f */
+/* 6 */ AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, /* 60 - 6f */
+/* 7 */ AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, OP, BA, CL, AL, __, /* 70 - 7f */
+/* 8 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 80 - 8f */
+/* 9 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 90 - 9f */
+/* a */ GL, OP, PO, PR, PR, PR, AL, AL, AL, AL, __, QU, __, __, AL, AL, /* a0 - af */
+/* b */ PO, PR, AL, AL, BB, __, AL, AL, AL, AL, __, __, AL, AL, AL, OP, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+/*
+ * Changes in table below (different from Unicode recommendation):
+ *
+ * e2 80 89: BA -> WJ (THIN SPACE)
+ * e2 80 0a: BA -> WJ (HAIR SPACE)
+ */
+
+static const char Table_E280[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ BA, BA, BA, BA, BA, BA, BA, GL, BA, __, __, ZW, __, __, __, __, /* 80 - 8f */
+/* 9 */ BA, AL, BA, BA, B2, AL, AL, AL, QU, QU, OP, QU, QU, QU, OP, QU, /* 90 - 9f */
+/* a */ AL, AL, AL, AL, IN, IN, IN, BA, BK, BK, __, __, __, __, __, GL, /* a0 - af */
+/* b */ PO, PO, PO, PO, PO, PO, PO, PO, AL, QU, QU, AL, NS, NS, AL, AL, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_E281[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ AL, AL, AL, AL, IS, OP, CL, NS, NS, NS, AL, AL, AL, AL, AL, AL, /* 80 - 8f */
+/* 9 */ AL, AL, __, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, __, /* 90 - 9f */
+/* a */ WJ, AL, AL, AL, AL, __, __, __, __, __, __, __, __, __, __, __, /* a0 - af */
+/* b */ __, __, __, __, __, __, __, __, __, __, __, __, __, OP, CL, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_E282[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, __, __, __, __, __, __, __, __, __, __, __, __, CL, CL, __, /* 80 - 8f */
+/* 9 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 90 - 9f */
+/* a */ PR, PR, PR, PR, PR, PR, PR, PO, PR, PR, PR, PR, PR, PR, PR, PR, /* a0 - af */
+/* b */ PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_E28C[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, __, __, __, __, __, __, __, OP, CL, OP, CL, __, __, __, __, /* 80 - 8f */
+/* 9 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 90 - 9f */
+/* a */ __, __, __, __, __, __, __, __, __, OP, CL, __, __, __, __, __, /* a0 - af */
+/* b */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_E29D[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 80 - 8f */
+/* 9 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 90 - 9f */
+/* a */ __, __, __, __, __, __, __, __, OP, CL, OP, CL, OP, CL, OP, CL, /* a0 - af */
+/* b */ OP, CL, OP, CL, OP, CL, __, __, __, __, __, __, __, __, __, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_E29F[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, __, __, __, __, OP, CL, __, __, __, __, __, __, __, __, __, /* 80 - 8f */
+/* 9 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 90 - 9f */
+/* a */ __, __, __, __, __, __, OP, CL, OP, CL, OP, CL, OP, CL, OP, CL, /* a0 - af */
+/* b */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_E2A6[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, __, __, OP, CL, OP, CL, OP, CL, OP, CL, OP, CL, OP, CL, OP, /* 80 - 8f */
+/* 9 */ CL, OP, CL, OP, CL, OP, CL, OP, CL, __, __, __, __, __, __, __, /* 90 - 9f */
+/* a */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* a0 - af */
+/* b */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_E2A7[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 80 - 8f */
+/* 9 */ __, __, __, __, __, __, __, __, OP, CL, OP, CL, __, __, __, __, /* 90 - 9f */
+/* a */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* a0 - af */
+/* b */ __, __, __, __, __, __, __, __, __, __, __, __, OP, CL, __, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_E2B8[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ AL, AL, QU, QU, QU, QU, AL, AL, AL, QU, QU, AL, QU, QU, AL, AL, /* 80 - 8f */
+/* 9 */ AL, AL, AL, AL, AL, AL, AL, AL, OP, AL, AL, AL, QU, QU, AL, AL, /* 90 - 9f */
+/* a */ QU, QU, OP, CL, OP, CL, OP, CL, OP, CL, AL, AL, AL, AL, AL, __, /* a0 - af */
+/* b */ AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, B2, B2, AL, AL, AL, AL, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_E380[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, CL, CL, AL, __, NS, __, __, OP, CL, OP, CL, OP, CL, OP, CL, /* 80 - 8f */
+/* 9 */ OP, CL, __, __, OP, CL, OP, CL, OP, CL, OP, CL, NS, OP, CL, CL, /* 90 - 9f */
+/* a */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* a0 - af */
+/* b */ AL, __, __, __, __, __, __, __, __, __, __, NS, NS, AL, __, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_EFB8[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 80 - 8f */
+/* 9 */ IS, CL, CL, IS, IS, AL, AL, OP, CL, IN, __, __, __, __, __, __, /* 90 - 9f */
+/* a */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* a0 - af */
+/* b */ AL, AL, AL, AL, AL, OP, CL, OP, CL, OP, CL, OP, CL, OP, CL, OP, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_EFB9[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ CL, OP, CL, OP, CL, AL, AL, OP, CL, AL, AL, AL, AL, AL, AL, AL, /* 80 - 8f */
+/* 9 */ CL, CL, CL, __, NS, NS, AL, AL, B2, OP, CL, OP, CL, OP, CL, AL, /* 90 - 9f */
+/* a */ AL, AL, __, B2, __, __, __, __, AL, PR, PO, AL, __, __, __, __, /* a0 - af */
+/* b */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_EFBC[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, AL, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, EX, AL, AL, PR, PO, AL, AL, OP, CL, AL, __, CL, B2, CL, AL, /* 80 - 8f */
+/* 9 */ NU, NU, NU, NU, NU, NU, NU, NU, NU, NU, NS, NS, __, __, __, EX, /* 90 - 9f */
+/* a */ AL, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* a0 - af */
+/* b */ __, __, __, __, __, __, __, __, __, __, __, OP, AL, CL, __, __, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+static const char Table_EFBD[256] = {
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+/* 0 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 00 - 0f */
+/* 1 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 10 - 1f */
+/* 2 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 20 - 2f */
+/* 3 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 30 - 3f */
+/* 4 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 40 - 4f */
+/* 5 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 50 - 5f */
+/* 6 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 60 - 6f */
+/* 7 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 70 - 7f */
+/* 8 */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* 80 - 8f */
+/* 9 */ __, __, __, __, __, __, __, __, __, __, __, OP, __, CL, __, OP, /* 90 - 9f */
+/* a */ CL, CL, OP, CL, CL, AL, __, __, __, __, __, __, __, __, __, __, /* a0 - af */
+/* b */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, WJ, /* b0 - bf */
+/* c */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* c0 - cf */
+/* d */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* d0 - df */
+/* e */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* e0 - ef */
+/* f */ __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, /* f0 - ff */
+/*      00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f */
+};
+
+#undef __
+
+#define PROHIBITED	LINEBREAK_NOBREAK
+#define DIRECT		LINEBREAK_ALLOWBREAK
+#define INDIRECT	((char) (~LINEBREAK_NOBREAK & ~LINEBREAK_ALLOWBREAK & 0x7f))
+
+#define X PROHIBITED	/* B ^ A === B SP*  A */
+#define i INDIRECT	/* B % A === B  A and B SP+  A */
+#define _ DIRECT	/* B  A */
+
+/* Note that BK, SP will no be used for lookup. */
+static const char BrkPairTable[23][23] = {
+/*        AI AL B2 BA BB BK CL CP EX GL HY IN IS NS NU OP PO PR QU SP SY WJ ZW */
+/* AI */ { X, X, _, i, _, _, X, X, X, i, i, i, X, i, i, i, _, _, i, _, X, X, X }, /* AI */
+/* AL */ { i, i, _, i, _, _, X, X, X, i, i, i, X, i, i, i, _, _, i, _, X, X, X }, /* AL */
+/* B2 */ { _, _, _, i, _, _, X, X, X, i, i, _, X, i, _, _, _, _, i, _, X, X, X }, /* B2 */
+/* BA */ { _, _, _, i, _, _, X, X, X, i, i, _, X, i, _, _, _, _, i, _, X, X, X }, /* BA */
+/* BB */ { i, i, i, i, i, _, X, X, X, _, i, i, X, i, i, i, i, i, i, _, X, X, X }, /* BB */
+/* BK */ { _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ }, /* BK */
+/* CL */ { _, _, _, i, _, _, X, X, X, i, i, _, X, X, _, _, i, i, i, _, X, X, X }, /* CL */
+/* CP */ { i, i, _, i, _, _, X, X, X, i, i, _, X, X, i, _, i, i, i, _, X, X, X }, /* CP */
+/* EX */ { _, _, _, i, _, _, X, X, X, i, i, _, X, i, _, _, _, _, i, _, X, X, X }, /* EX */
+/* GL */ { i, i, i, i, i, _, X, X, X, i, i, i, X, i, i, i, i, i, i, _, X, X, X }, /* GL */
+/* HY */ { _, _, _, i, _, _, X, X, X, _, i, _, X, i, i, _, _, _, i, _, X, X, X }, /* HY */
+/* IN */ { _, _, _, i, _, _, X, X, X, i, i, i, X, i, _, _, _, _, i, _, X, X, X }, /* IN */
+/* IS */ { i, i, _, i, _, _, X, X, X, i, i, _, X, i, i, _, _, _, i, _, X, X, X }, /* IS */
+/* NS */ { _, _, _, i, _, _, X, X, X, i, i, _, X, i, _, _, _, _, i, _, X, X, X }, /* NS */
+/* NU */ { i, i, _, i, _, _, X, X, X, i, i, i, X, i, i, i, i, i, i, _, X, X, X }, /* NU */
+/* OP */ { X, X, X, X, X, _, X, X, X, X, X, X, X, X, X, X, X, X, X, _, X, X, X }, /* OP */
+/* PO */ { i, i, _, i, _, _, X, X, X, i, i, _, X, i, i, i, _, _, i, _, X, X, X }, /* PO */
+/* PR */ { _, i, _, i, _, _, X, X, X, i, i, _, X, i, i, i, _, _, i, _, X, X, X }, /* PR */
+/* QU */ { i, i, i, i, i, _, X, X, X, i, i, i, X, i, i, X, i, i, i, _, X, X, X }, /* QU */
+/* SP */ { _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ }, /* SP */
+/* SY */ { _, _, _, i, _, _, X, X, X, i, i, _, X, i, i, _, _, _, i, _, X, X, X }, /* SY */
+/* WJ */ { i, i, i, i, i, _, X, X, X, i, i, i, X, i, i, i, i, i, i, _, X, X, X }, /* WJ */
+/* ZW */ { _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, X }, /* ZW */
+/*        AI AL B2 BA BB BK CL CP EX GL HY IN IS NS NU OP PO PR QU SP SY WJ ZW */
+};
+
+#undef _
+#undef i
+#undef X
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ComputeBreakLocations --
+ *
+ *	Compute break locations in UTF-8 text. This function is doing
+ *	the same as set_linebreaks_utf8 (from "libunibreak"), but this
+ *	function is using a simplified line break algorithm, although
+ *	it is following the recommendations at
+ *	http://www.unicode.org/reports/tr14/tr14-26.html.
+ *
+ *	Note that this functions expects that the whole line will be
+ *	parsed at once. This interface corresponds to the interface
+ *	of the linebreak library. Of course, such a design is a bit
+ *	unluckily.
+ *
+ * Results:
+ *	The computed break locations, in 'brks'. This array must be as
+ *	large as the input length (specified by 'len').
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+ComputeBreakLocations(
+    const unsigned char *text,
+    size_t len,
+    const char *lang,
+    char *brks)
+{
+    size_t i;
+    size_t nbytes;
+    size_t nletters;
+    size_t brkIndex;
+    LBClass cls;
+    LBClass prevCls;
+
+    if (len == 0) {
+	return;
+    }
+
+    i = 0;
+    nletters = 0;
+    brkIndex = 0;
+    cls = BK;
+    prevCls = WJ;
+    brks[len - 1] = LINEBREAK_MUSTBREAK;
+
+    while (i < len) {
+	unsigned char ch;
+	LBClass pcls;
+
+	ch = text[i];
+
+	if (ch < 0x80) {
+	    pcls = Table_0000[ch];
+	    nbytes = 1;
+	} else if ((ch & 0xe0) == 0xc0) {
+	    pcls = AI;
+	    switch (ch) {
+	    case 0xc2:
+		switch (UCHAR(text[i + 1])) {
+		case 0x85: pcls = BK; break; /* NL */
+		case 0xac: pcls = AL; break;
+		case 0xad: pcls = BA; break;
+		case 0xb1: pcls = AL; break;
+		case 0xbb: pcls = QU; break;
+		}
+		break;
+	    case 0xc3:
+	    case 0xc4:
+	    case 0xc5:
+	    case 0xc6:
+	    case 0xc7:
+	    case 0xc8:
+	    case 0xc9:
+		ch = text[i + 1];
+		if (0x80 <= ch && ch <= 0xbf) {
+		    pcls = AL;
+		}
+		break;
+	    case 0xca:
+		ch = text[i + 1];
+		if (0x80 <= ch && ch <= 0xaf) {
+		    pcls = AL;
+		}
+		break;
+	    case 0xcb:
+		switch (UCHAR(text[i + 1])) {
+		case 0x88: /* fallthru */
+		case 0x8c: /* fallthru */
+		case 0x9f: pcls = BB; break;
+		}
+		break;
+	    case 0xcd:
+		if (UCHAR(text[i + 1]) == 0x8f) {
+		    pcls = GL;
+		}
+		break;
+	    case 0xd7:
+		if (UCHAR(text[i + 1]) == 0x86) {
+		    pcls = EX;
+		}
+		break;
+	    case 0xdf:
+		if (UCHAR(text[i + 1]) == 0xb8) {
+		    pcls = IS;
+		}
+		break;
+	    }
+	    nbytes = 2;
+	    brks[i] = LINEBREAK_INSIDEACHAR;
+	} else if ((ch & 0xf0) == 0xe0) {
+	    pcls = AI;
+	    switch (ch) {
+		case 0xe2:
+		    switch (UCHAR(text[i + 1])) {
+		    case 0x80: pcls = Table_E280[UCHAR(text[i + 2])]; break;
+		    case 0x81: pcls = Table_E281[UCHAR(text[i + 2])]; break;
+		    case 0x82: pcls = Table_E282[UCHAR(text[i + 2])]; break;
+		    case 0x8c: pcls = Table_E28C[UCHAR(text[i + 2])]; break;
+		    case 0x9d: pcls = Table_E29D[UCHAR(text[i + 2])]; break;
+		    case 0x9f: pcls = Table_E29F[UCHAR(text[i + 2])]; break;
+		    case 0xa6: pcls = Table_E2A6[UCHAR(text[i + 2])]; break;
+		    case 0xa7: pcls = Table_E2A7[UCHAR(text[i + 2])]; break;
+		    case 0xb8: pcls = Table_E2B8[UCHAR(text[i + 2])]; break;
+		    case 0x84:
+			switch (UCHAR(text[i + 2])) {
+			    case 0x83: /* fallthru */
+			    case 0x89: pcls = PO; break;
+			    case 0x96: pcls = PR; break;
+			}
+			break;
+		    case 0x88:
+			switch (UCHAR(text[i + 2])) {
+			    case 0x92: /* fallthru */
+			    case 0x93: pcls = PR; break;
+			}
+			break;
+		    case 0xb9:
+			switch (UCHAR(text[i + 2])) {
+			    case 0x80: pcls = B2; break;
+			    case 0x81: pcls = AL; break;
+			    case 0x82: pcls = OP; break;
+			}
+			break;
+		    }
+		    break;
+		case 0xe3:
+		    if (UCHAR(text[i + 1]) == 0x80) {
+			pcls = Table_E380[UCHAR(text[i + 2])];
+		    }
+		    break;
+		case 0xef:
+		    switch (UCHAR(text[i + 1])) {
+		    case 0xb8: pcls = Table_EFB8[UCHAR(text[i + 2])]; break;
+		    case 0xb9: pcls = Table_EFB9[UCHAR(text[i + 2])]; break;
+		    case 0xbc: pcls = Table_EFBC[UCHAR(text[i + 2])]; break;
+		    case 0xbd: pcls = Table_EFBD[UCHAR(text[i + 2])]; break;
+		    case 0xb4:
+			switch (UCHAR(text[i + 2])) {
+			    case 0xbe: pcls = CL; break;
+			    case 0xbf: pcls = OP; break;
+			}
+			break;
+		    case 0xbb:
+			if (UCHAR(text[i + 2]) == 0xbf) {
+			    pcls = WJ; /* ZWNBSP (deprecated word joiner) */
+			}
+			break;
+		    case 0xbf:
+			switch (UCHAR(text[i + 2])) {
+			    case 0xa0: pcls = PO; break;
+			    case 0xa1: /* fallthru */
+			    case 0xa5: /* fallthru */
+			    case 0xa6: pcls = PR; break;
+			}
+			break;
+		    }
+		    break;
+	    }
+	    nbytes = 3;
+	    brks[i + 0] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 1] = LINEBREAK_INSIDEACHAR;
+	} else if ((ch & 0xf8) == 0xf0) {
+	    pcls = AI;
+	    nbytes = 4;
+	    brks[i + 0] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 1] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 2] = LINEBREAK_INSIDEACHAR;
+#if TCL_UTF_MAX > 4
+	/*
+	 * NOTE: For any reason newer TCL versions will allow > 4 bytes. I cannot
+	 * understand this decision, this is not conform to UTF-8 standard.
+	 * Moreover this decision is introducing severe compatibility problems.
+	 */
+	} else if ((ch & 0xf8) == 0xf8) {
+	    pcls = AI;
+	    nbytes = 5;
+	    brks[i + 0] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 1] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 2] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 3] = LINEBREAK_INSIDEACHAR;
+# if TCL_UTF_MAX > 5
+	} else if ((ch & 0xf8) == 0xfe) {
+	    pcls = AI;
+	    nbytes = 6;
+	    brks[i + 0] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 1] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 2] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 3] = LINEBREAK_INSIDEACHAR;
+	    brks[i + 4] = LINEBREAK_INSIDEACHAR;
+# endif /*  TCL_UTF_MAX > 5 */
+#endif  /*  TCL_UTF_MAX > 4 */
+	} else {
+	    /*
+	     * This fallback is required, because ths current character conversion
+	     * algorithm in Tcl library is producing overlong sequences (a violation
+	     * of the UTF-8 standard). This observation has been reported to the
+	     * Tcl/Tk team, but the response was ignorance.
+	     */
+
+	    int k;
+	    const char *p = (const char *) text + i;
+
+	    pcls = AI;
+	    nbytes = Tcl_UtfNext(p) - p;
+	    for (k = 0; k < nbytes; ++k) {
+		brks[i + k] = LINEBREAK_INSIDEACHAR;
+	    }
+	}
+
+	if (i == 0) {
+	    if ((cls = pcls) == SP) {
+		/* treat SP at start of input as if it followed a WJ */
+		prevCls = cls = WJ;
+	    }
+	} else {
+	    switch (pcls) {
+	    case BK:
+		brks[i - 1] = LINEBREAK_NOBREAK;
+		brks[i] = LINEBREAK_MUSTBREAK;
+		prevCls = WJ;
+		return;
+	    case SP:
+		/* handle spaces explicitly; do not update cls */
+		if (i > 0) {
+		    brks[i - 1] = LINEBREAK_NOBREAK;
+		    prevCls = SP;
+		} else {
+		    prevCls = WJ;
+		}
+		nletters = 0;
+		break;
+	    case HY: {
+		char brk = BrkPairTable[cls][HY];
+
+	    	/*
+		 * The hyphen-minus (U+002D) needs special context treatment. For simplicity we
+		 * will only check whether we have two preceding, and two succeeding letters.
+		 * TODO: Is there a better method for the decision?
+		 */
+
+		brks[i - 1] = LINEBREAK_NOBREAK;
+		cls = pcls;
+
+		if (brk == INDIRECT) {
+		    prevCls = pcls;
+		} else {
+		    prevCls = WJ;
+
+		    if (brk == LINEBREAK_ALLOWBREAK && nletters >= 2) {
+			brkIndex = i - 1;
+		    }
+		}
+		nletters = 0;
+	    	break;
+	    }
+	    default: {
+		char brk = BrkPairTable[cls][pcls];
+
+		if (brk == INDIRECT) {
+		    brk = (prevCls == SP) ? LINEBREAK_ALLOWBREAK : LINEBREAK_NOBREAK;
+		    prevCls = pcls;
+		} else {
+		    prevCls = WJ;
+		}
+		brks[i - 1] = brk;
+		cls = pcls;
+
+		if (pcls == AL) {
+		    nletters += 1;
+
+		    if (brkIndex && nletters >= 2) {
+			brks[brkIndex] = LINEBREAK_ALLOWBREAK;
+			brkIndex = 0;
+		    }
+		} else {
+		    nletters = 0;
+		}
+		break;
+	    }
+	    }
+	}
+
+	i += nbytes;
+    }
+}
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 105
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: src/tktext/tkTextMark.c
===================================================================
--- src/tktext/tkTextMark.c	(revision 0)
+++ src/tktext/tkTextMark.c	(working copy)
@@ -0,0 +1,2826 @@
+/*
+ * tkTextMark.c --
+ *
+ *	This file contains the functions that implement marks for text
+ *	widgets.
+ *
+ * Copyright (c) 1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkInt.h"
+#include "tkText.h"
+#include "tk3d.h"
+#include <inttypes.h>
+#include <assert.h>
+
+#ifndef MAX
+# define MAX(a,b) ((a) < (b) ? b : a)
+#endif
+#ifndef MIN
+# define MIN(a,b) ((a) < (b) ? a : b)
+#endif
+
+#if NDEBUG
+# define DEBUG(expr)
+#else
+# define DEBUG(expr) expr
+#endif
+
+/*
+ * Forward references for functions defined in this file:
+ */
+
+static void		InsertUndisplayProc(TkText *textPtr, TkTextDispChunk *chunkPtr);
+static bool		MarkDeleteProc(TkTextBTree tree, TkTextSegment *segPtr, int flags);
+static Tcl_Obj *	MarkInspectProc(const TkSharedText *textPtr, const TkTextSegment *segPtr);
+static void		MarkRestoreProc(TkTextSegment *segPtr);
+static void		MarkCheckProc(const TkSharedText *sharedTextPtr, const TkTextSegment *segPtr);
+static int		MarkLayoutProc(const TkTextIndex *indexPtr,
+			    TkTextSegment *segPtr, int offset, int maxX,
+			    int maxChars, bool noCharsYet, TkWrapMode wrapMode,
+			    TkTextSpaceMode spaceMode, TkTextDispChunk *chunkPtr);
+static int		MarkFindNext(Tcl_Interp *interp, TkText *textPtr, const char *markName,
+			    bool forward);
+static void		ChangeGravity(TkSharedText *sharedTextPtr, TkText *textPtr,
+			    TkTextSegment *markPtr, const Tk_SegType *newTypePtr,
+			    TkTextUndoInfo *redoInfo);
+static struct TkTextSegment *SetMark(struct TkText *textPtr, const char *name,
+			    const Tk_SegType *typePtr, struct TkTextIndex *indexPtr);
+static void		UnsetMark(TkSharedText *sharedTextPtr, TkTextSegment *markPtr,
+			    TkTextUndoInfo *redoInfo);
+static void		ReactivateMark(TkSharedText *sharedTextPtr, TkTextSegment *markPtr);
+
+static const TkTextDispChunkProcs layoutInsertProcs = {
+    TEXT_DISP_CURSOR,		/* type */
+    TkTextInsertDisplayProc,	/* displayProc */
+    InsertUndisplayProc,	/* undisplayProc */
+    NULL,	                /* measureProc */
+    NULL,		        /* bboxProc */
+};
+/*
+ * We need some private undo/redo stuff.
+ */
+
+static void UndoToggleGravityPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void UndoSetMarkPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void RedoSetMarkPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void UndoMoveMarkPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void UndoToggleGravityDestroy(TkSharedText *, TkTextUndoToken *, bool);
+static void UndoSetMarkDestroy(TkSharedText *, TkTextUndoToken *, bool);
+static void RedoSetMarkDestroy(TkSharedText *, TkTextUndoToken *, bool);
+static void UndoMoveMarkDestroy(TkSharedText *, TkTextUndoToken *, bool);
+static void UndoMarkGetRange(const TkSharedText *, const TkTextUndoToken *,
+	TkTextIndex *, TkTextIndex *);
+static void RedoSetMarkGetRange(const TkSharedText *, const TkTextUndoToken *,
+	TkTextIndex *, TkTextIndex *);
+static void RedoMoveMarkGetRange(const TkSharedText *, const TkTextUndoToken *,
+	TkTextIndex *, TkTextIndex *);
+static Tcl_Obj *UndoToggleGravityGetCommand(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *UndoSetMarkGetCommand(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *UndoToggleGravityInspect(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *UndoSetMarkInspect(const TkSharedText *, const TkTextUndoToken *);
+
+static const Tk_UndoType undoTokenToggleGravityType = {
+    TK_TEXT_UNDO_MARK_GRAVITY,	/* action */
+    UndoToggleGravityGetCommand,/* commandProc */
+    UndoToggleGravityPerform,	/* undoProc */
+    UndoToggleGravityDestroy,	/* destroyProc */
+    UndoMarkGetRange,		/* rangeProc */
+    UndoToggleGravityInspect	/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenToggleGravityType = {
+    TK_TEXT_REDO_MARK_GRAVITY,	/* action */
+    UndoToggleGravityGetCommand,/* commandProc */
+    UndoToggleGravityPerform,	/* undoProc */
+    UndoToggleGravityDestroy,	/* destroyProc */
+    UndoMarkGetRange,		/* rangeProc */
+    UndoToggleGravityInspect	/* inspectProc */
+};
+
+static const Tk_UndoType undoTokenSetMarkType = {
+    TK_TEXT_UNDO_MARK_SET,	/* action */
+    UndoSetMarkGetCommand,	/* commandProc */
+    UndoSetMarkPerform,		/* undoProc */
+    UndoSetMarkDestroy,		/* destroyProc */
+    UndoMarkGetRange,		/* rangeProc */
+    UndoSetMarkInspect		/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenSetMarkType = {
+    TK_TEXT_REDO_MARK_SET,	/* action */
+    UndoSetMarkGetCommand,	/* commandProc */
+    RedoSetMarkPerform,		/* undoProc */
+    RedoSetMarkDestroy,		/* destroyProc */
+    RedoSetMarkGetRange,	/* rangeProc */
+    UndoSetMarkInspect		/* inspectProc */
+};
+
+static const Tk_UndoType undoTokenMoveMarkType = {
+    TK_TEXT_UNDO_MARK_MOVE,	/* action */
+    UndoSetMarkGetCommand,	/* commandProc */
+    UndoMoveMarkPerform,	/* undoProc */
+    UndoMoveMarkDestroy,	/* destroyProc */
+    RedoMoveMarkGetRange,	/* rangeProc */
+    UndoSetMarkInspect		/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenMoveMarkType = {
+    TK_TEXT_REDO_MARK_MOVE,	/* action */
+    UndoSetMarkGetCommand,	/* commandProc */
+    UndoMoveMarkPerform,	/* undoProc */
+    UndoMoveMarkDestroy,	/* destroyProc */
+    RedoMoveMarkGetRange,	/* rangeProc */
+    UndoSetMarkInspect		/* inspectProc */
+};
+
+typedef struct UndoTokenToggleMark {
+    const Tk_UndoType *undoType;
+    TkTextSegment *markPtr;
+} UndoTokenToggleMark;
+
+typedef struct UndoTokenToggleIndex {
+    const Tk_UndoType *undoType;
+    TkTextSegment *markPtr;
+} UndoTokenToggleIndex;
+
+/* derivation of UndoTokenToggleMark */
+typedef struct UndoTokenToggleGravity {
+    const Tk_UndoType *undoType;
+    TkTextSegment *markPtr;
+} UndoTokenToggleGravity;
+
+/* derivation of UndoTokenToggleMark */
+typedef struct UndoTokenSetMark {
+    const Tk_UndoType *undoType;
+    TkTextSegment *markPtr;
+} UndoTokenSetMark;
+
+/* derivation of UndoTokenSetMark */
+typedef struct RedoTokenSetMark {
+    const Tk_UndoType *undoType;
+    TkTextSegment *markPtr;
+    TkTextUndoIndex index;
+} RedoTokenSetMark;
+
+/* derivation of UndoTokenSetMark */
+typedef struct UndoTokenMoveMark {
+    const Tk_UndoType *undoType;
+    TkTextSegment *markPtr;
+    TkTextUndoIndex index;
+} UndoTokenMoveMark;
+
+/*
+ * The following structures declare the "mark" segment types. There are
+ * actually two types for marks, one with left gravity and one with right
+ * gravity. They are identical except for their gravity property.
+ */
+
+const Tk_SegType tkTextRightMarkType = {
+    "mark",		/* name */
+    SEG_GROUP_MARK,	/* group */
+    GRAVITY_RIGHT,	/* gravity */
+    MarkDeleteProc,	/* deleteProc */
+    MarkRestoreProc,	/* restoreProc */
+    MarkLayoutProc,	/* layoutProc */
+    MarkCheckProc,	/* checkProc */
+    MarkInspectProc	/* inspectProc */
+};
+
+const Tk_SegType tkTextLeftMarkType = {
+    "mark",		/* name */
+    SEG_GROUP_MARK,	/* group */
+    GRAVITY_LEFT,	/* gravity */
+    MarkDeleteProc,	/* deleteProc */
+    MarkRestoreProc,	/* restoreProc */
+    MarkLayoutProc,	/* layoutProc */
+    MarkCheckProc,	/* checkProc */
+    MarkInspectProc	/* inspectProc */
+};
+
+/*
+ * Pointer to int, for some portable pointer hacks - it's guaranteed that
+ * 'uintptr_t' and 'void *' are convertible in both directions (C99 7.18.1.4).
+ */
+
+typedef union {
+    void *ptr;
+    uintptr_t flag;
+} __ptr_to_int;
+
+#define MARK_POINTER(ptr)	(((__ptr_to_int *) &ptr)->flag |= (uintptr_t) 1)
+#define UNMARK_POINTER(ptr)	(((__ptr_to_int *) &ptr)->flag &= ~(uintptr_t) 1)
+#define POINTER_IS_MARKED(ptr)	(((__ptr_to_int *) &ptr)->flag & (uintptr_t) 1)
+
+#define IS_PRESERVED(seg)	POINTER_IS_MARKED(seg->body.mark.ptr)
+#define MAKE_PRESERVED(seg)	MARK_POINTER(seg->body.mark.ptr)
+
+#define GET_POINTER(ptr)	((void *) (((__ptr_to_int *) &ptr)->flag & ~(uintptr_t) 1))
+
+#define GET_NAME(seg)		((char *) GET_POINTER(seg->body.mark.ptr))
+#define GET_HPTR(seg)		((Tcl_HashEntry *) seg->body.mark.ptr)
+#define PTR_TO_INT(ptr)		((uintptr_t) ptr)
+
+#if !NDEBUG
+
+# undef GET_HPTR
+# undef GET_NAME
+
+static Tcl_HashEntry *GET_HPTR(const TkTextSegment *markPtr)
+{ assert(!IS_PRESERVED(markPtr)); return (Tcl_HashEntry *) markPtr->body.mark.ptr; }
+
+static char *GET_NAME(const TkTextSegment *markPtr)
+{ assert(IS_PRESERVED(markPtr)); return (char *) GET_POINTER(markPtr->body.mark.ptr); }
+
+#endif /* !NDEBUG */
+
+DEBUG_ALLOC(extern unsigned tkTextCountNewSegment);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroySegment);
+DEBUG_ALLOC(extern unsigned tkTextCountNewUndoToken);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroyUndoToken);
+
+/*
+ * Some functions for the undo/redo mechanism.
+ */
+
+static Tcl_Obj *
+AppendName(
+    Tcl_Obj *objPtr,
+    const TkSharedText *sharedTextPtr,
+    const TkTextSegment *markPtr)
+{
+    const char *name;
+
+    if (IS_PRESERVED(markPtr)) {
+	name = GET_NAME(markPtr);
+    } else {
+	name = TkTextMarkName(sharedTextPtr, NULL, markPtr);
+    }
+    assert(name);
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(name, -1));
+    return objPtr;
+}
+
+static Tcl_Obj *
+UndoToggleGravityGetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("mark", -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("gravity", -1));
+    return objPtr;
+}
+
+static Tcl_Obj *
+UndoToggleGravityInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenToggleGravity *token = (const UndoTokenToggleGravity *) item;
+    return AppendName(UndoToggleGravityGetCommand(sharedTextPtr, item), sharedTextPtr, token->markPtr);
+}
+
+static void
+UndoToggleGravityPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    UndoTokenToggleGravity *token = (UndoTokenToggleGravity *) undoInfo->token;
+    const Tk_SegType *newTypePtr;
+    const Tk_SegType *oldTypePtr;
+
+    assert(!token->markPtr->body.mark.changePtr);
+
+    oldTypePtr = token->markPtr->typePtr;
+    newTypePtr = (oldTypePtr == &tkTextRightMarkType) ? &tkTextLeftMarkType : &tkTextRightMarkType;
+    ChangeGravity(sharedTextPtr, NULL, token->markPtr, newTypePtr, NULL);
+
+    if (redoInfo) {
+	redoInfo->token = undoInfo->token;
+	redoInfo->token->undoType = isRedo ? &undoTokenToggleGravityType : &redoTokenToggleGravityType;
+    }
+}
+
+static void
+UndoToggleGravityDestroy(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *item,
+    bool reused)
+{
+    assert(!((UndoTokenToggleGravity *) item)->markPtr->body.mark.changePtr);
+
+    if (!reused) {
+	UndoTokenToggleGravity *token = (UndoTokenToggleGravity *) item;
+	MarkDeleteProc(sharedTextPtr->tree, token->markPtr, DELETE_MARKS);
+    }
+}
+
+static void
+UndoMoveMarkPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    UndoTokenMoveMark *token = (UndoTokenMoveMark *) undoInfo->token;
+    TkTextUndoIndex index = token->index;
+
+    assert(!token->markPtr->body.mark.changePtr);
+
+    if (redoInfo) {
+	TkBTreeMakeUndoIndex(sharedTextPtr, token->markPtr, &index);
+	token->index = index;
+	redoInfo->token = undoInfo->token;
+	redoInfo->token->undoType = isRedo ? &undoTokenMoveMarkType : &redoTokenMoveMarkType;
+    }
+ 
+    TkBTreeUnlinkSegment(sharedTextPtr, token->markPtr);
+    TkBTreeReInsertSegment(sharedTextPtr, &index, token->markPtr);
+}
+
+static void
+UndoMoveMarkDestroy(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *item,
+    bool reused)
+{
+    assert(!((UndoTokenMoveMark *) item)->markPtr->body.mark.changePtr);
+
+    if (!reused) {
+	UndoTokenMoveMark *token = (UndoTokenMoveMark *) item;
+	MarkDeleteProc(sharedTextPtr->tree, token->markPtr, DELETE_MARKS);
+    }
+}
+
+static Tcl_Obj *
+UndoSetMarkGetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenSetMark *token = (const UndoTokenSetMark *) item;
+    const char *operation = POINTER_IS_MARKED(token->markPtr) ? "unset" : "set";
+    Tcl_Obj *objPtr = Tcl_NewObj();
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("mark", -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(operation, -1));
+    return objPtr;
+}
+
+static Tcl_Obj *
+UndoSetMarkInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenSetMark *token = (const UndoTokenSetMark *) item;
+    const TkTextSegment *markPtr = GET_POINTER(token->markPtr);
+    Tcl_Obj *objPtr = UndoSetMarkGetCommand(sharedTextPtr, item);
+
+    objPtr = AppendName(objPtr, sharedTextPtr, markPtr);
+
+    if (!POINTER_IS_MARKED(token->markPtr)) {
+	const char *gravity = (markPtr->typePtr == &tkTextLeftMarkType) ? "left" : "right";
+	Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(gravity, -1));
+    }
+
+    return objPtr;
+}
+
+static void
+UndoSetMarkPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    const UndoTokenSetMark *token = (const UndoTokenSetMark *) undoInfo->token;
+    TkTextSegment *markPtr = GET_POINTER(token->markPtr);
+
+    assert(!markPtr->body.mark.changePtr);
+    UnsetMark(sharedTextPtr, markPtr, redoInfo);
+    if (redoInfo && !isRedo) {
+	UNMARK_POINTER(((RedoTokenSetMark *) redoInfo->token)->markPtr);
+    }
+}
+
+static void
+UndoSetMarkDestroy(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *item,
+    bool reused)
+{
+    UndoTokenSetMark *token = (UndoTokenSetMark *) item;
+    TkTextSegment *markPtr = GET_POINTER(token->markPtr);
+
+    assert(!reused);
+    assert(!markPtr->body.mark.changePtr);
+
+    MarkDeleteProc(sharedTextPtr->tree, markPtr, DELETE_PRESERVE);
+}
+
+static void
+RedoSetMarkPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    RedoTokenSetMark *token = (RedoTokenSetMark *) undoInfo->token;
+    TkTextSegment *markPtr = GET_POINTER(token->markPtr);
+
+    assert(!markPtr->body.mark.changePtr);
+    assert(TkTextIsNormalMark(markPtr));
+
+    if (IS_PRESERVED(markPtr)) {
+	ReactivateMark(sharedTextPtr, markPtr);
+    }
+
+    TkBTreeReInsertSegment(sharedTextPtr, &token->index, markPtr);
+    markPtr->refCount += 1;
+
+    if (redoInfo) {
+	UndoTokenSetMark *redoToken;
+
+	redoToken = malloc(sizeof(UndoTokenSetMark));
+	redoToken->markPtr = token->markPtr;
+	redoToken->undoType = &undoTokenSetMarkType;
+	redoInfo->token = (TkTextUndoToken *) redoToken;
+	DEBUG_ALLOC(tkTextCountNewUndoToken++);
+	markPtr->refCount += 1;
+    }
+}
+
+static void
+RedoSetMarkDestroy(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *item,
+    bool reused)
+{
+    RedoTokenSetMark *token = (RedoTokenSetMark *) item;
+    TkTextSegment *markPtr = GET_POINTER(token->markPtr);
+
+    assert(!reused);
+    assert(!markPtr->body.mark.changePtr);
+    MarkDeleteProc(sharedTextPtr->tree, markPtr, DELETE_MARKS);
+}
+
+static void
+UndoMarkGetRange(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item,
+    TkTextIndex *startIndex,
+    TkTextIndex *endIndex)
+{
+    const UndoTokenToggleMark *token = (UndoTokenToggleMark *) item;
+
+    TkTextIndexClear2(startIndex, NULL, sharedTextPtr->tree);
+    TkTextIndexSetSegment(startIndex, GET_POINTER(token->markPtr));
+    *endIndex = *startIndex;
+}
+
+static void
+RedoSetMarkGetRange(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item,
+    TkTextIndex *startIndex,
+    TkTextIndex *endIndex)
+{
+    RedoTokenSetMark *token = (RedoTokenSetMark *) item;
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->index, startIndex);
+    *endIndex = *startIndex;
+}
+
+static void
+RedoMoveMarkGetRange(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item,
+    TkTextIndex *startIndex,
+    TkTextIndex *endIndex)
+{
+    UndoTokenMoveMark *token = (UndoTokenMoveMark *) item;
+    TkTextSegment *markPtr = GET_POINTER(token->markPtr);
+
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->index, startIndex);
+    TkTextIndexClear2(endIndex, NULL, sharedTextPtr->tree);
+    TkTextIndexSetSegment(endIndex, markPtr);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextMarkCmd --
+ *
+ *	This function is invoked to process the "mark" options of the widget
+ *	command for text widgets. See the user documentation for details on
+ *	what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+SetResultNoMarkNamed(Tcl_Interp *interp, const char *name) {
+    Tcl_SetObjResult(interp, Tcl_ObjPrintf("there is no mark named \"%s\"", name));
+    Tcl_SetErrorCode(interp, "TK", "LOOKUP", "TEXT_MARK", name, NULL);
+    return TCL_ERROR;
+}
+
+int
+TkTextMarkCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already parsed this command
+    				 * enough to know that objv[1] is "mark". */
+{
+    Tcl_HashEntry *hPtr;
+    TkTextSegment *markPtr;
+    Tcl_HashSearch search;
+    TkTextIndex index;
+    const Tk_SegType *newTypePtr;
+    int optionIndex;
+    static const char *const markOptionStrings[] = {
+	"compare", "exists", "generate", "gravity", "names", "next", "previous",
+	"set", "unset", NULL
+    };
+    enum markOptions {
+	MARK_COMPARE, MARK_EXISTS, MARK_GENERATE, MARK_GRAVITY, MARK_NAMES, MARK_NEXT, MARK_PREVIOUS,
+	MARK_SET, MARK_UNSET
+    };
+
+    if (objc < 3) {
+	Tcl_WrongNumArgs(interp, 2, objv, "option ?arg arg ...?");
+	return TCL_ERROR;
+    }
+
+    if (Tcl_GetIndexFromObjStruct(interp, objv[2], markOptionStrings,
+	    sizeof(char *), "mark option", 0, &optionIndex) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    switch ((enum markOptions) optionIndex) {
+    case MARK_COMPARE: {
+	TkTextSegment *markPtr1, *markPtr2;
+	int relation, value;
+
+	if (objc != 5) {
+	    Tcl_WrongNumArgs(interp, 2, objv, "markName1 op markName2");
+	    return TCL_ERROR;
+	}
+	if (!(markPtr1 = TkTextFindMark(textPtr, Tcl_GetString(objv[2])))) {
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf("bad comparison operand \"%s\": "
+		    "must be an existing mark", Tcl_GetString(objv[2])));
+	    Tcl_SetErrorCode(interp, "TK", "VALUE", "MARK_COMPARISON", NULL);
+	    return TCL_ERROR;
+	}
+	if (!(markPtr2 = TkTextFindMark(textPtr, Tcl_GetString(objv[4])))) {
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf("bad comparison operand \"%s\": "
+		    "must be an existing mark", Tcl_GetString(objv[4])));
+	    Tcl_SetErrorCode(interp, "TK", "VALUE", "MARK_COMPARISON", NULL);
+	    return TCL_ERROR;
+	}
+
+	if (markPtr1 == markPtr2) {
+	    relation = 0;
+	} else {
+	    TkTextIndex index1, index2;
+
+	    TkTextIndexClear(&index1, textPtr);
+	    TkTextIndexClear(&index2, textPtr);
+	    TkTextIndexSetSegment(&index1, markPtr1);
+	    TkTextIndexSetSegment(&index2, markPtr2);
+	    relation = TkTextIndexCompare(&index1, &index2);
+
+	    if (relation == 0) {
+		TkTextSegment *segPtr = markPtr1->nextPtr;
+
+		while (segPtr && segPtr != markPtr2 && segPtr->size == 0) {
+		    segPtr = segPtr->nextPtr;
+		}
+		relation = (segPtr == markPtr2) ? -1 : +1;
+	    }
+	}
+
+	value = TkTextTestRelation(interp, relation, Tcl_GetString(objv[3]));
+	if (value == -1) {
+	    return TCL_ERROR;
+	}
+	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(value));
+	break;
+    }
+    case MARK_EXISTS: {
+	if (objc != 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "markName");
+	    return TCL_ERROR;
+	}
+	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(!!TkTextFindMark(textPtr, Tcl_GetString(objv[3]))));
+	break;
+    }
+    case MARK_GENERATE: {
+	TkTextSegment *markPtr;
+	TkTextIndex index;
+	char uniqName[100];
+
+	TkTextIndexClear(&index, textPtr);
+	TkTextIndexSetSegment(&index, textPtr->startMarker);
+	/* ensure fixed length (depending on pointer size) */
+	snprintf(uniqName, sizeof(uniqName),
+#ifdef TCL_WIDE_INT_IS_LONG
+	    "##ID##0x%016"PRIx64"##0x%016"PRIx64"##%08u##", /* we're on a real 64-bit system */
+	    (uint64_t) textPtr, (uint64_t) textPtr->sharedTextPtr, ++textPtr->uniqueIdCounter);
+#else /* ifndef TCL_WIDE_INT_IS_LONG */
+	    "##ID##0x%08"PRIx32"##0x%08"PRIx32"##%08u##",   /* we're on a 32-bit system */
+	    (uint32_t) textPtr, (uint32_t) textPtr->sharedTextPtr, ++textPtr->uniqueIdCounter);
+#endif /* TCL_WIDE_INT_IS_LONG */
+	assert(!TkTextFindMark(textPtr, uniqName));
+    	markPtr = TkTextMakeMark(textPtr, uniqName);
+    	markPtr->privateMarkFlag = true;
+	textPtr->sharedTextPtr->numMarks -= 1; /* take back counting */
+	textPtr->sharedTextPtr->numPrivateMarks += 1;
+	TkBTreeLinkSegment(textPtr->sharedTextPtr, markPtr, &index);
+	Tcl_SetObjResult(textPtr->interp, Tcl_NewStringObj(uniqName, -1));
+	break;
+    }
+    case MARK_GRAVITY: {
+	int length;
+	const char *str;
+
+	if (objc < 4 || objc > 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "markName ?gravity?");
+	    return TCL_ERROR;
+	}
+	str = Tcl_GetStringFromObj(objv[3], &length);
+	if (strcmp(str, "insert") == 0) {
+	    markPtr = textPtr->insertMarkPtr;
+	} else if (strcmp(str, "current") == 0) {
+	    markPtr = textPtr->currentMarkPtr;
+	} else {
+	    if (!(hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->markTable, str))) {
+		return SetResultNoMarkNamed(interp, Tcl_GetString(objv[3]));
+	    }
+	    markPtr = Tcl_GetHashValue(hPtr);
+	}
+	if (objc == 4) {
+	    const char *typeStr;
+	    typeStr = markPtr->typePtr == &tkTextRightMarkType ? "right" : "left";
+	    Tcl_SetObjResult(interp, Tcl_NewStringObj(typeStr, -1));
+	    return TCL_OK;
+	}
+	str = Tcl_GetStringFromObj(objv[4],&length);
+	if (strncmp(str, "left", length) == 0) {
+	    newTypePtr = &tkTextLeftMarkType;
+	} else if (strncmp(str, "right", length) == 0) {
+	    newTypePtr = &tkTextRightMarkType;
+	} else {
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		    "bad mark gravity \"%s\": must be left or right", str));
+	    Tcl_SetErrorCode(interp, "TK", "VALUE", "MARK_GRAVITY", NULL);
+	    return TCL_ERROR;
+	}
+	/*
+	 * We have to force the re-insertion of the mark when steadyMarks is not enabled.
+	 */
+
+	if (markPtr->typePtr != newTypePtr || !textPtr->sharedTextPtr->steadyMarks) {
+	    TkTextUndoInfo undoInfo;
+	    TkTextUndoInfo *undoInfoPtr = NULL;
+
+	    if (textPtr->sharedTextPtr->steadyMarks
+		    && TkTextIsNormalMark(markPtr)
+		    && !TkTextUndoUndoStackIsFull(textPtr->sharedTextPtr->undoStack)) {
+		undoInfoPtr = &undoInfo;
+	    }
+	    ChangeGravity(textPtr->sharedTextPtr, textPtr, markPtr, newTypePtr, undoInfoPtr);
+	}
+	break;
+    }
+    case MARK_NAMES: {
+	Tcl_Obj *resultObj;
+
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	    return TCL_ERROR;
+	}
+
+	resultObj = Tcl_NewObj();
+	Tcl_ListObjAppendElement(NULL, resultObj, Tcl_NewStringObj("insert", -1));
+	Tcl_ListObjAppendElement(NULL, resultObj, Tcl_NewStringObj("current", -1));
+
+	for (hPtr = Tcl_FirstHashEntry(&textPtr->sharedTextPtr->markTable, &search);
+		hPtr;
+		hPtr = Tcl_NextHashEntry(&search)) {
+	    TkTextSegment *markPtr = Tcl_GetHashValue(hPtr);
+
+	    if (!markPtr->privateMarkFlag && !markPtr->startEndMarkFlag) {
+		Tcl_ListObjAppendElement(NULL, resultObj, Tcl_NewStringObj(
+			Tcl_GetHashKey(&textPtr->sharedTextPtr->markTable, hPtr), -1));
+	    }
+	}
+
+	Tcl_SetObjResult(interp, resultObj);
+	break;
+    }
+    case MARK_NEXT:
+	if (objc != 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "index");
+	    return TCL_ERROR;
+	}
+	return MarkFindNext(interp, textPtr, Tcl_GetString(objv[3]), true);
+    case MARK_PREVIOUS:
+	if (objc != 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "index");
+	    return TCL_ERROR;
+	}
+	return MarkFindNext(interp, textPtr, Tcl_GetString(objv[3]), false);
+    case MARK_SET: {
+	const Tk_SegType *typePtr = NULL;
+	const char *name;
+
+	if (objc != 5 && objc != 6) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "markName index ?direction?");
+	    return TCL_ERROR;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[4], &index)) {
+	    return TCL_ERROR;
+	}
+	if (objc == 6) {
+	    const char *direction = Tcl_GetString(objv[5]);
+
+	    if (strcmp(direction, "left") == 0) {
+		typePtr = &tkTextLeftMarkType;
+	    } else if (strcmp(direction, "right") == 0) {
+		typePtr = &tkTextRightMarkType;
+	    } else {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+			"bad mark gravity \"%s\": must be left or right", direction));
+		Tcl_SetErrorCode(interp, "TK", "VALUE", "MARK_GRAVITY", NULL);
+		return TCL_ERROR;
+	    }
+	}
+
+	name = Tcl_GetString(objv[3]);
+
+#if BEGIN_DOES_NOT_BELONG_TO_BASE
+
+	if (*name == 'b' && strcmp(name, "begin") == 0) {
+	    static bool printWarning = true;
+
+	    if (printWarning) {
+		fprintf(stderr, "\"begin\" is a reserved index identifier and shouldn't "
+			"be used for mark names anymore.\n");
+		printWarning = false;
+	    }
+	}
+
+#else /* if !BEGIN_DOES_NOT_BELONG_TO_BASE */
+
+	/*
+	 * TODO:
+	 * Probably we should print a warning if the mark name is matching any of the
+	 * following forms:
+	 *	- "begin"|"end"
+	 *	- <integer> "." (<integer>|"begin"|"end")
+	 *	- "@" (<integer>|"first"|"last") "," (<integer>|"first"|"last")
+	 *	- "##ID##" .*
+	 */
+
+#endif /* BEGIN_DOES_NOT_BELONG_TO_BASE */
+
+	if (!SetMark(textPtr, name, typePtr, &index)) {
+	    Tcl_Obj *msgPtr;
+
+	    if (strcmp(name, "insert") == 0) {
+		return TCL_OK; /* the "watch" command did destroy the widget */
+	    }
+	    msgPtr = Tcl_ObjPrintf("\"%s\" is an expired generated mark", name);
+	    Tcl_SetObjResult(interp, msgPtr);
+	    Tcl_SetErrorCode(interp, "TK", "SET", "TEXT_MARK", name, NULL);
+	    return TCL_ERROR;
+	}
+	break;
+    }
+    case MARK_UNSET: {
+	TkTextUndoInfo undoInfo;
+	TkTextUndoInfo *undoInfoPtr = NULL;
+	int i;
+
+	if (textPtr->sharedTextPtr->steadyMarks
+		&& !TkTextUndoUndoStackIsFull(textPtr->sharedTextPtr->undoStack)) {
+	    undoInfoPtr = &undoInfo;
+	}
+
+	for (i = 3; i < objc; i++) {
+	    if ((hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->markTable, Tcl_GetString(objv[i])))) {
+		TkTextSegment *markPtr = Tcl_GetHashValue(hPtr);
+
+		if (TkTextIsPrivateMark(markPtr)) {
+		    UnsetMark(textPtr->sharedTextPtr, markPtr, NULL);
+		} else if (!TkTextIsSpecialMark(markPtr)) {
+		    UnsetMark(textPtr->sharedTextPtr, markPtr, undoInfoPtr);
+		    if (undoInfoPtr && undoInfo.token) {
+			TkTextPushUndoToken(textPtr->sharedTextPtr, undoInfo.token, 0);
+		    }
+		}
+	    }
+	}
+	break;
+    }
+    }
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextFindMark --
+ *
+ *	Return mark segment of given name, if exisiting.
+ *
+ * Results:
+ *	The mark with this name, or NULL if not existing.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextSegment *
+TkTextFindMark(
+    const TkText *textPtr,
+    const char *name)
+{
+    Tcl_HashEntry *hPtr;
+
+    assert(textPtr);
+    assert(name);
+
+    switch (name[0]) {
+    case 'i':
+	if (strcmp(name, "insert") == 0) {
+	    return textPtr->insertMarkPtr;
+	}
+	break;
+    case 'c':
+	if (strcmp(name, "current") == 0) {
+	    return textPtr->currentMarkPtr;
+	}
+	break;
+    }
+    hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->markTable, name);
+    return hPtr ? Tcl_GetHashValue(hPtr) : NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ReactivateMark --
+ *
+ *	Reactivate a preserved mark.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Allocates some memory for hash table entry, and release memory
+ *	of preserved name.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+ReactivateMark(
+    TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    TkTextSegment *markPtr)		/* Reactivate this mark. */
+{
+    Tcl_HashEntry *hPtr;
+    char *name;
+    bool isNew;
+
+    assert(IS_PRESERVED(markPtr));
+
+    name = GET_NAME(markPtr);
+    hPtr = Tcl_CreateHashEntry(&sharedTextPtr->markTable, name, (int *) &isNew);
+    assert(isNew);
+    free(name);
+    Tcl_SetHashValue(hPtr, markPtr);
+    markPtr->body.mark.ptr = PTR_TO_INT(hPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextFreeMarks --
+ *
+ *	Free all used marks, also the hash table for marks will be
+ *	destroyed. But do not free private marks if 'retainPrivateMarks'
+ *	is true, in this case a new hash table will be built, only
+ *	with the remaining private marks.
+ *
+ * Results:
+ *	If 'retainPrivateMarks' is false, then return NULL. Otherwise
+ *	the chain of retained private marks will be returned.
+ *
+ * Side effects:
+ *	Free some memory, the old hash table for marks will be destroyed,
+ *	and a new one will be created if 'retainPrivateMarks' is true.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextSegment *
+TkTextFreeMarks(
+    TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    bool retainPrivateMarks)		/* Priate marks will be retained? */
+{
+    Tcl_HashSearch search;
+    Tcl_HashEntry *hPtr = Tcl_FirstHashEntry(&sharedTextPtr->markTable, &search);
+    TkTextSegment *chainPtr = NULL;
+
+    for ( ; hPtr; hPtr = Tcl_NextHashEntry(&search)) {
+	TkTextSegment *markPtr = Tcl_GetHashValue(hPtr);
+
+	if (!retainPrivateMarks || !TkTextIsPrivateMark(markPtr)) {
+	    MarkDeleteProc(sharedTextPtr->tree, markPtr, DELETE_CLEANUP);
+	} else {
+	    const char *name = Tcl_GetHashKey(&sharedTextPtr->markTable, hPtr);
+	    char *dup;
+
+	    MarkDeleteProc(sharedTextPtr->tree, markPtr, 0);
+	    markPtr->nextPtr = NULL;
+	    markPtr->prevPtr = NULL;
+	    markPtr->sectionPtr = NULL;
+	    markPtr->nextPtr = chainPtr;
+	    dup = malloc(strlen(name) + 1);
+	    markPtr->body.mark.ptr = PTR_TO_INT(strcpy(dup, name));
+	    MAKE_PRESERVED(markPtr);
+	    chainPtr = markPtr;
+	}
+    }
+
+    Tcl_DeleteHashTable(&sharedTextPtr->markTable);
+    sharedTextPtr->numMarks = 0;
+
+    if (retainPrivateMarks) {
+	TkTextSegment *markPtr;
+
+	Tcl_InitHashTable(&sharedTextPtr->markTable, TCL_STRING_KEYS);
+
+	for (markPtr = chainPtr; markPtr; markPtr = markPtr->nextPtr) {
+	    ReactivateMark(sharedTextPtr, markPtr);
+	    markPtr->refCount += 1;
+	}
+    } else {
+	sharedTextPtr->numPrivateMarks = 0;
+    }
+
+    return chainPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextUpdateCurrentMark --
+ *
+ *	If a position change of the "current" mark has been postponed
+ *	we will do now the update.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The "current" mark will change the position.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextUpdateCurrentMark(
+    TkSharedText *sharedTextPtr)	/* Shared text resource. */
+{
+    TkText *tPtr;
+
+    assert(sharedTextPtr->haveToSetCurrentMark);
+
+    sharedTextPtr->haveToSetCurrentMark = false;
+
+    for (tPtr = sharedTextPtr->peers; tPtr; tPtr = tPtr->next) {
+	if (tPtr->haveToSetCurrentMark) {
+	    tPtr->haveToSetCurrentMark = false;
+	    TkBTreeUnlinkSegment(sharedTextPtr, tPtr->currentMarkPtr);
+	    TkBTreeLinkSegment(sharedTextPtr, tPtr->currentMarkPtr, &tPtr->currentMarkIndex);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextMakeStartEndMark --
+ *
+ *	Make (allocate) a new start/end mark.
+ *
+ * Results:
+ *	The return value is a pointer to the new mark.
+ *
+ * Side effects:
+ *	A new mark is created.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextSegment *
+TkTextMakeStartEndMark(
+    TkText *textPtr,		/* can be NULL */
+    Tk_SegType const *typePtr)
+{
+    TkTextSegment *markPtr = TkTextMakeMark(NULL, NULL);
+
+    assert(typePtr == &tkTextLeftMarkType || typePtr == &tkTextRightMarkType);
+
+    markPtr->typePtr = typePtr;
+    markPtr->startEndMarkFlag = true;
+    markPtr->privateMarkFlag = true;
+    markPtr->body.mark.textPtr = textPtr;
+    return markPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextMakeMark --
+ *
+ *	Make (allocate) a new mark, the gravity default to right.
+ *
+ * Results:
+ *	The return value is a pointer to the new mark.
+ *
+ * Side effects:
+ *	A new mark is created.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextSegment *
+MakeMark(
+    TkText *textPtr)		/* Text widget in which to create mark. */
+{
+    TkTextSegment *markPtr;
+
+    markPtr = memset(malloc(SEG_SIZE(TkTextMark)), 0, SEG_SIZE(TkTextMark));
+    markPtr->typePtr = &tkTextRightMarkType;
+    markPtr->refCount = 1;
+    markPtr->body.mark.textPtr = textPtr;
+    DEBUG_ALLOC(tkTextCountNewSegment++);
+    return markPtr;
+}
+
+TkTextSegment *
+TkTextMakeMark(
+    TkText *textPtr,		/* Text widget in which to create mark, can be NULL. */
+    const char *name)		/* Name of this mark, can be NULL. */
+{
+    TkTextSegment *markPtr;
+    Tcl_HashEntry *hPtr;
+    bool isNew;
+
+    assert(!name || textPtr);
+    assert(!name || strcmp(name, "insert") != 0);
+    assert(!name || strcmp(name, "current") != 0);
+
+    if (!name) {
+	return MakeMark(textPtr);
+    }
+
+    hPtr = Tcl_CreateHashEntry(&textPtr->sharedTextPtr->markTable, name, (int *) &isNew);
+
+    if (isNew) {
+	markPtr = MakeMark(textPtr);
+	markPtr->body.mark.ptr = PTR_TO_INT(hPtr);
+	Tcl_SetHashValue(hPtr, markPtr);
+	textPtr->sharedTextPtr->numMarks += 1;
+    } else {
+	markPtr = Tcl_GetHashValue(hPtr);
+    }
+
+    return markPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextMakeNewMark --
+ *
+ *	Make (allocate) a new mark, the gravity default to right. This
+ *	function will return NULL if the mark name already exists.
+ *
+ * Results:
+ *	The return value is a pointer to the new mark, and will be NULL
+ *	if the mark already exists.
+ *
+ * Side effects:
+ *	A new mark is created.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextSegment *
+TkTextMakeNewMark(
+    TkText *textPtr,		/* Text widget in which to create mark. */
+    const char *name)		/* Name of this mark. */
+{
+    TkTextSegment *markPtr;
+    Tcl_HashEntry *hPtr;
+    bool isNew;
+
+    assert(textPtr);
+    assert(name);
+
+    hPtr = Tcl_CreateHashEntry(&textPtr->sharedTextPtr->markTable, name, (int *) &isNew);
+
+    if (!isNew) {
+	return NULL;
+    }
+
+    markPtr = MakeMark(textPtr);
+    markPtr->body.mark.ptr = PTR_TO_INT(hPtr);
+    Tcl_SetHashValue(hPtr, markPtr);
+    textPtr->sharedTextPtr->numMarks += 1;
+
+    return markPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ChangeGravity --
+ *
+ *	Change the gravity of a given mark.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Reset the type pointer of the mark, and set the undo information.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextMarkChange *
+MakeChangeItem(
+    TkSharedText *sharedTextPtr,
+    TkTextSegment *markPtr)
+{
+    TkTextMarkChange *changePtr = markPtr->body.mark.changePtr;
+
+    assert(TkTextIsNormalMark(markPtr));
+
+    if (!changePtr) {
+	if (sharedTextPtr->undoMarkListCount == sharedTextPtr->undoMarkListSize) {
+	    sharedTextPtr->undoMarkListSize = MAX(20, 2*sharedTextPtr->undoMarkListSize);
+	    sharedTextPtr->undoMarkList = realloc(sharedTextPtr->undoMarkList,
+		    sharedTextPtr->undoMarkListSize * sizeof(sharedTextPtr->undoMarkList[0]));
+	}
+	changePtr = &sharedTextPtr->undoMarkList[sharedTextPtr->undoMarkListCount++];
+	memset(changePtr, 0, sizeof(*changePtr));
+	markPtr->body.mark.changePtr = changePtr;
+	(changePtr->markPtr = markPtr)->refCount += 1;
+    }
+
+    return changePtr;
+}
+
+static TkTextUndoToken *
+MakeUndoToggleGravity(
+    TkSharedText *sharedTextPtr,
+    TkTextSegment *markPtr,
+    const Tk_SegType *oldTypePtr)
+{
+    assert(TkTextIsNormalMark(markPtr));
+
+    sharedTextPtr->undoStackEvent = true;
+
+    if (!markPtr->body.mark.changePtr
+	    || (!markPtr->body.mark.changePtr->setMark
+		&& !markPtr->body.mark.changePtr->toggleGravity)) {
+	TkTextMarkChange *changePtr = MakeChangeItem(sharedTextPtr, markPtr);
+	UndoTokenToggleGravity *token;
+
+	token = memset(malloc(sizeof(UndoTokenToggleGravity)), 0, sizeof(UndoTokenToggleGravity));
+	token->undoType = &undoTokenToggleGravityType;
+	(token->markPtr = markPtr)->refCount += 1;
+	DEBUG_ALLOC(tkTextCountNewUndoToken++);
+	changePtr->toggleGravity = (TkTextUndoToken *) token;
+	changePtr->savedMarkType = oldTypePtr;
+	sharedTextPtr->lastUndoTokenType = -1;
+	return (TkTextUndoToken *) token;
+    }
+
+    return NULL;
+}
+
+static void
+ChangeGravity(
+    TkSharedText *sharedTextPtr,	/* Shared text resource. */
+    TkText *textPtr,			/* The text widget, can be NULL. */
+    TkTextSegment *markPtr,		/* Change toggle of this mark. */
+    const Tk_SegType *newTypePtr,	/* This is the new toggle type. */
+    TkTextUndoInfo *undoInfo)		/* Undo information, can be NULL */
+{
+    const Tk_SegType *oldTypePtr;
+    bool isNormalMark;
+
+    assert(markPtr);
+    assert(markPtr->typePtr->group == SEG_GROUP_MARK);
+    assert(sharedTextPtr);
+    assert(!undoInfo || TkTextIsNormalMark(markPtr));
+
+    oldTypePtr = markPtr->typePtr;
+    markPtr->typePtr = newTypePtr;
+    isNormalMark = TkTextIsNormalMark(markPtr);
+
+    if (!sharedTextPtr->steadyMarks) {
+	if (!textPtr || markPtr != textPtr->insertMarkPtr) {
+	    /*
+	     * We must re-insert the mark, the old rules of gravity may force
+	     * a shuffle of the existing marks.
+	     */
+
+	    TkTextIndex index;
+
+	    if (textPtr) {
+		TkTextIndexClear(&index, textPtr);
+	    } else {
+		TkTextIndexClear2(&index, NULL, sharedTextPtr->tree);
+	    }
+	    TkTextIndexSetSegment(&index, markPtr);
+	    TkTextIndexToByteIndex(&index);
+	    TkBTreeUnlinkSegment(sharedTextPtr, markPtr);
+	    TkBTreeLinkSegment(sharedTextPtr, markPtr, &index);
+	}
+
+	if (isNormalMark) {
+	    TkTextUpdateAlteredFlag(sharedTextPtr);
+	}
+    }
+
+    if (undoInfo && isNormalMark) {
+	undoInfo->token = MakeUndoToggleGravity(sharedTextPtr, markPtr, oldTypePtr);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UnsetMark --
+ *
+ *	Unset given mark.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Free some memory, and add a token to the undo/redo stack.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+UnsetMark(
+    TkSharedText *sharedTextPtr,
+    TkTextSegment *markPtr,
+    TkTextUndoInfo *redoInfo)
+{
+    int flags = DELETE_CLEANUP;
+
+    assert(markPtr);
+    assert(markPtr->typePtr->group == SEG_GROUP_MARK);
+    assert(!TkTextIsSpecialMark(markPtr));
+    assert(!TkTextIsPrivateMark(markPtr) || !redoInfo);
+
+    if (redoInfo) {
+	RedoTokenSetMark *token;
+	TkTextMarkChange *changePtr;
+
+	if ((changePtr = markPtr->body.mark.changePtr)) {
+	    if (changePtr->toggleGravity) {
+		TkTextUndoPushItem(sharedTextPtr->undoStack, changePtr->toggleGravity, 0);
+		changePtr->toggleGravity = NULL;
+	    }
+	    if (changePtr->moveMark) {
+		free(changePtr->moveMark);
+		changePtr->moveMark = NULL;
+		DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+		assert(markPtr->refCount > 1);
+		markPtr->refCount -= 1;
+	    }
+	    if (changePtr->setMark) {
+		free(changePtr->setMark);
+		changePtr->setMark = NULL;
+		DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+		assert(markPtr->refCount > 1);
+		markPtr->refCount -= 1;
+	    }
+	}
+
+	memset(redoInfo, 0, sizeof(*redoInfo));
+	token = malloc(sizeof(RedoTokenSetMark));
+	token->undoType = &redoTokenSetMarkType;
+	markPtr->refCount += 1;
+	token->markPtr = markPtr;
+	MARK_POINTER(token->markPtr);
+	TkBTreeMakeUndoIndex(sharedTextPtr, markPtr, &token->index);
+	DEBUG_ALLOC(tkTextCountNewUndoToken++);
+	redoInfo->token = (TkTextUndoToken *) token;
+	redoInfo->byteSize = 0;
+	flags = DELETE_PRESERVE;
+    }
+
+    sharedTextPtr->undoStackEvent = true;
+    sharedTextPtr->lastUndoTokenType = -1;
+    TkBTreeUnlinkSegment(sharedTextPtr, markPtr);
+    MarkDeleteProc(sharedTextPtr->tree, markPtr, flags);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TriggerWatchCursor --
+ *
+ *	Trigger the watch command for movements of the insert cursor.
+ *
+ * Results:
+ *	Returns 'false' if the referenced widget has been destroyed, otherwise
+ *	'true' will be returned.
+ *
+ * Side effects:
+ *	It might happen that the receiver of the "watch" command is destroying the widget.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+TriggerWatchCursor(
+    TkText *textPtr,
+    const TkTextIndex *oldCursorIndexPtr,
+    const TkTextIndex *newCursorIndexPtr)	/* NULL is allowed. */
+{
+    TkTextIndex index, newIndex;
+    char idx[2][TK_POS_CHARS];
+    TkTextTag *tagPtr;
+    TkTextTag *tagArrayBuffer[32];
+    TkTextTag **tagArrayPtr;
+    unsigned tagArraySize;
+    unsigned numTags, i;
+    Tcl_DString buf;
+    bool rc;
+
+    assert(oldCursorIndexPtr);
+    assert(!TkTextIndexIsEmpty(oldCursorIndexPtr));
+    assert(!newCursorIndexPtr || !TkTextIndexIsEmpty(newCursorIndexPtr));
+
+    if (!newCursorIndexPtr) {
+	TkTextIndexClear(&newIndex, textPtr);
+	TkTextIndexSetSegment(&newIndex, textPtr->insertMarkPtr);
+	newCursorIndexPtr = &newIndex;
+    }
+
+    if (TkTextIndexIsEqual(oldCursorIndexPtr, newCursorIndexPtr)) {
+	return true;
+    }
+
+    Tcl_DStringInit(&buf);
+    if (TkTextIndexIsEmpty(oldCursorIndexPtr)) {
+	idx[0][0] = '\0';
+    } else {
+	TkTextPrintIndex(textPtr, oldCursorIndexPtr, idx[0]);
+    }
+    TkTextPrintIndex(textPtr, newCursorIndexPtr, idx[1]);
+    if (textPtr->insertMarkPtr->typePtr == &tkTextLeftMarkType) {
+	index = *newCursorIndexPtr;
+    } else {
+	TkTextIndexBackChars(textPtr, newCursorIndexPtr, 1, &index, COUNT_INDICES);
+    }
+
+    numTags = 0;
+    tagArrayPtr = tagArrayBuffer;
+    tagArraySize = sizeof(tagArrayBuffer)/sizeof(tagArrayBuffer[0]);
+    tagPtr = TkBTreeGetTags(&index);
+    for ( ; tagPtr; tagPtr = tagPtr->nextPtr) {
+	if (numTags == tagArraySize) {
+	    tagArraySize *= 2;
+	    tagArrayPtr = realloc(tagArrayPtr == tagArrayBuffer ? NULL : tagArrayPtr, tagArraySize);
+	}
+	tagArrayPtr[numTags++] = tagPtr;
+    }
+    TkTextSortTags(numTags, tagArrayPtr);
+    for (i = 0; i < numTags; ++i) {
+	Tcl_DStringAppendElement(&buf, tagArrayPtr[i]->name);
+    }
+    if (tagArrayPtr != tagArrayBuffer) {
+	free(tagArrayPtr);
+    }
+
+    rc = TkTextTriggerWatchCmd(textPtr, "cursor", idx[0], idx[1], Tcl_DStringValue(&buf), false);
+    Tcl_DStringFree(&buf);
+    return rc;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextReleaseUndoMarkTokens --
+ *
+ *	Release retained undo tokens for mark operations.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Free some memory.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextReleaseUndoMarkTokens(
+    TkSharedText *sharedTextPtr,
+    TkTextMarkChange *changePtr)
+{
+    assert(sharedTextPtr);
+    assert(changePtr);
+
+    if (!changePtr->markPtr) {
+	return; /* already released */
+    }
+
+    assert(changePtr->markPtr->body.mark.changePtr);
+
+    if (changePtr->toggleGravity) {
+	free(changePtr->toggleGravity);
+	changePtr->toggleGravity = NULL;
+	DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	assert(changePtr->markPtr->refCount > 1);
+	changePtr->markPtr->refCount -= 1;
+    }
+    if (changePtr->moveMark) {
+	free(changePtr->moveMark);
+	changePtr->moveMark = NULL;
+	DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	assert(changePtr->markPtr->refCount > 1);
+	changePtr->markPtr->refCount -= 1;
+    }
+    if (changePtr->setMark) {
+	free(changePtr->setMark);
+	changePtr->setMark = NULL;
+	DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	assert(changePtr->markPtr->refCount > 1);
+	changePtr->markPtr->refCount -= 1;
+    }
+
+    assert(changePtr->markPtr->refCount > 1);
+    changePtr->markPtr->refCount -= 1;
+    changePtr->markPtr->body.mark.changePtr = NULL;
+    changePtr->markPtr = NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextPushUndoMarkTokens --
+ *
+ *	Push retained undo tokens for mark operations onto the undo stack.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Same as TkTextUndoPushItem.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextPushUndoMarkTokens(
+    TkSharedText *sharedTextPtr,
+    TkTextMarkChange *changePtr)
+{
+    assert(sharedTextPtr);
+    assert(sharedTextPtr->undoStack);
+    assert(changePtr);
+    assert(changePtr->markPtr);
+    assert(changePtr->markPtr->body.mark.changePtr == changePtr);
+
+    if (changePtr->toggleGravity) {
+	UndoTokenToggleGravity *token = (UndoTokenToggleGravity *) changePtr->toggleGravity;
+
+	if (changePtr->savedMarkType != token->markPtr->typePtr) {
+	    TkTextUndoPushItem(sharedTextPtr->undoStack, (TkTextUndoToken *) token, 0);
+	} else {
+	    free(token);
+	    DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	    assert(changePtr->markPtr->refCount > 1);
+	    changePtr->markPtr->refCount -= 1;
+	}
+	changePtr->toggleGravity = NULL;
+    }
+    if (changePtr->moveMark) {
+	TkTextUndoPushItem(sharedTextPtr->undoStack, changePtr->moveMark, 0);
+	changePtr->moveMark = NULL;
+    }
+    if (changePtr->setMark) {
+	TkTextUndoPushItem(sharedTextPtr->undoStack, changePtr->setMark, 0);
+	changePtr->setMark = NULL;
+    }
+
+    assert(changePtr->markPtr->refCount > 1);
+    changePtr->markPtr->refCount -= 1;
+    changePtr->markPtr->body.mark.changePtr = NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextSetMark -- SetMark --
+ *
+ *	Set a mark to a particular position, creating a new mark if one
+ *	doesn't already exist.
+ *
+ *	Take care when setting the "insert" mark. In this case it might
+ *	happen that the receiver of the "watch" command is destroying the
+ *	widget. In this case this function will return NULL (otherwise
+ *	this function will always return non-NULL in case of setting the
+ *	"insert" mark).
+ *
+ *	The footprint of this function is public, so we cannot extend it
+ *	without changing tkIntDecls.h, and I will not touch this file. So
+ *	I gave parameter 'name' an additional flag: if this parameter is
+ *	marked, then it's a private mark.
+ *
+ * Results:
+ *	The return value is a pointer to the mark that was just set.
+ *
+ * Side effects:
+ *	A new mark is created, or an existing mark is moved.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextSegment *
+SetMark(
+    TkText *textPtr,		/* Text widget in which to create mark. */
+    const char *name,		/* Name of mark to set. */
+    const Tk_SegType *typePtr,	/* Sepcifies the gravity, either tkTextLeftMarkType,
+    				 * tkTextRightMarkType, or NULL. */
+    TkTextIndex *indexPtr)	/* Where to set mark. */
+{
+    Tcl_HashEntry *hPtr = NULL;
+    TkSharedText *sharedTextPtr;
+    TkTextSegment *markPtr;
+    TkTextIndex oldIndex;
+    TkTextUndoIndex undoIndex;
+    bool pushUndoToken;
+    bool widgetSpecific;
+    const Tk_SegType *oldTypePtr = NULL;
+
+    assert(textPtr);
+    assert(indexPtr->textPtr == textPtr);
+
+    widgetSpecific = false;
+    markPtr = NULL;
+
+    switch (*name) {
+    case 'i':
+	if (strcmp(name, "insert") == 0) {
+	    widgetSpecific = true;
+	    markPtr = textPtr->insertMarkPtr;
+	    if (TkTextIsElided(indexPtr)) {
+		TkTextSkipElidedRegion(indexPtr);
+	    }
+	}
+	break;
+    case 'c':
+	if (strcmp(name, "current") == 0) {
+	    widgetSpecific = true;
+	    markPtr = textPtr->currentMarkPtr;
+	}
+	break;
+    }
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+    TkTextIndexClear(&oldIndex, textPtr);
+
+    if (!widgetSpecific) {
+	int dummy;
+	hPtr = Tcl_CreateHashEntry(&sharedTextPtr->markTable, name, &dummy);
+	markPtr = Tcl_GetHashValue(hPtr);
+    }
+
+    if (!markPtr) {
+	if (name[0] == '#' && name[1] == '#' && name[2] == 'I') {
+#ifdef TCL_WIDE_INT_IS_LONG
+	    static const int length = 32 + 2*sizeof(uint64_t);
+#else /* ifndef TCL_WIDE_INT_IS_LONG */
+	    static const int length = 32 + 2*sizeof(uint32_t);
+#endif /* TCL_WIDE_INT_IS_LONG */
+
+	    void *sPtr, *tPtr;
+	    unsigned num;
+
+	    if (strlen(name) == length && sscanf(name, "##ID##%p##%p##%u##", &sPtr, &tPtr, &num) == 3) {
+		assert(hPtr);
+		Tcl_DeleteHashEntry(hPtr);
+		return NULL; /* this is an expired generated mark */
+	    }
+	}
+
+	markPtr = MakeMark(textPtr);
+
+	if (widgetSpecific) {
+	    /*
+	     * This is a special mark.
+	     */
+	    if (*name == 'i') { /* "insert" */
+		textPtr->insertMarkPtr = markPtr;
+		markPtr->insertMarkFlag = true;
+	    } else { /* "current" */
+		textPtr->currentMarkPtr = markPtr;
+		markPtr->currentMarkFlag = true;
+	    }
+	    pushUndoToken = false;
+	} else {
+	    markPtr->body.mark.ptr = PTR_TO_INT(hPtr);
+	    markPtr->normalMarkFlag = true;
+	    Tcl_SetHashValue(hPtr, markPtr);
+	    pushUndoToken = sharedTextPtr->steadyMarks && sharedTextPtr->undoStack;
+	    textPtr->sharedTextPtr->numMarks += 1;
+	}
+    } else {
+	const TkTextSegment *segPtr;
+
+	TkTextMarkSegToIndex(textPtr, markPtr, &oldIndex);
+
+	if (markPtr == textPtr->insertMarkPtr && TkTextIndexIsEndOfText(indexPtr)) {
+	    /*
+	     * The index is outside of visible text, so backup one char.
+	     */
+	    TkTextIndexBackChars(textPtr, indexPtr, 1, indexPtr, COUNT_INDICES);
+	}
+
+	if (!sharedTextPtr->steadyMarks
+		&& (!typePtr || typePtr == markPtr->typePtr)
+		&& TkTextIndexIsEqual(&oldIndex, indexPtr)) {
+	    return markPtr; /* this mark did not change the position */
+	}
+
+	TkTextIndexToByteIndex(&oldIndex);
+	pushUndoToken = sharedTextPtr->steadyMarks
+		&& sharedTextPtr->undoStack
+		&& TkTextIsNormalMark(markPtr);
+
+	/*
+	 * If this is the insertion point that's being moved, be sure to force
+	 * a display update at the old position. Also, don't let the insertion
+	 * cursor be after the final newline of the file.
+	 */
+
+	if (markPtr == textPtr->insertMarkPtr) {
+	    TkTextIndex index2;
+
+	    TkTextIndexToByteIndex(indexPtr);
+
+	    if (textPtr->state == TK_TEXT_STATE_NORMAL) {
+		/*
+		 * Test whether cursor is inside the actual range.
+		 */
+		if (TkTextIndexRestrictToStartRange(&oldIndex) >= 0
+			&& TkTextIndexRestrictToEndRange(&oldIndex) <= 0
+			&& TkTextIndexForwChars(textPtr, &oldIndex, 1, &index2, COUNT_INDICES)) {
+		    /*
+		     * While we wish to redisplay, no heights have changed, so no need
+		     * to call TkTextInvalidateLineMetrics.
+		     */
+
+		    TkTextChanged(NULL, textPtr, &oldIndex, &index2);
+		}
+	    }
+	} else if (markPtr == textPtr->currentMarkPtr) {
+	    textPtr->haveToSetCurrentMark = false;
+	} else if (pushUndoToken) {
+	    TkBTreeMakeUndoIndex(sharedTextPtr, markPtr, &undoIndex);
+	}
+
+	if ((segPtr = TkTextIndexGetSegment(indexPtr)) == markPtr) {
+	    return markPtr;
+	}
+
+	if (segPtr && segPtr->size > 1) {
+	    /* because TkBTreeUnlinkSegment may invalidate this index */
+	    TkTextIndexToByteIndex(indexPtr);
+	}
+
+	TkBTreeUnlinkSegment(sharedTextPtr, markPtr);
+    }
+
+    if (typePtr && typePtr != markPtr->typePtr) {
+	oldTypePtr = markPtr->typePtr;
+	markPtr->typePtr = typePtr;
+    }
+
+    /* this function will also update 'sectionPtr' */
+    TkBTreeLinkSegment(sharedTextPtr, markPtr, indexPtr);
+
+    if (pushUndoToken) {
+	TkTextMarkChange *changePtr;
+
+	changePtr = MakeChangeItem(sharedTextPtr, markPtr);
+
+	if (!changePtr->setMark && !changePtr->moveMark) {
+	    if (TkTextIndexIsEmpty(&oldIndex)) {
+		UndoTokenSetMark *token;
+
+		token = malloc(sizeof(UndoTokenSetMark));
+		token->undoType = &undoTokenSetMarkType;
+		(token->markPtr = markPtr)->refCount += 1;
+		DEBUG_ALLOC(tkTextCountNewUndoToken++);
+		changePtr->setMark = (TkTextUndoToken *) token;
+		sharedTextPtr->undoStackEvent = true;
+		sharedTextPtr->lastUndoTokenType = -1;
+		oldTypePtr = NULL;
+	    } else {
+		UndoTokenMoveMark *token;
+
+		token = malloc(sizeof(UndoTokenMoveMark));
+		token->undoType = &undoTokenMoveMarkType;
+		(token->markPtr = markPtr)->refCount += 1;
+		token->index = undoIndex;
+		DEBUG_ALLOC(tkTextCountNewUndoToken++);
+		changePtr->moveMark = (TkTextUndoToken *) token;
+		sharedTextPtr->undoStackEvent = true;
+		sharedTextPtr->lastUndoTokenType = -1;
+	    }
+	}
+
+	if (oldTypePtr) {
+	    MakeUndoToggleGravity(sharedTextPtr, markPtr, oldTypePtr);
+	}
+    }
+
+    if (sharedTextPtr->steadyMarks && TkTextIsNormalMark(markPtr)) {
+	TkTextUpdateAlteredFlag(sharedTextPtr);
+    }
+
+    if (textPtr->state == TK_TEXT_STATE_NORMAL) {
+	/*
+	 * If the mark is the insertion cursor, then update the screen at the mark's new location.
+	 */
+
+	if (markPtr == textPtr->insertMarkPtr) {
+	    TkTextIndex index2;
+
+	    TkTextIndexForwChars(textPtr, indexPtr, 1, &index2, COUNT_INDICES);
+
+	    /*
+	     * While we wish to redisplay, no heights have changed, so no need to
+	     * call TkTextInvalidateLineMetrics.
+	     */
+
+	    /* TODO: this is very inefficient, it would be more appopriate to trigger
+	     * a special cursor redraw function (see DisplayDLine in tkTextDisp).
+	     * Instead of inserting a cursor chunk (not needed) we want to overlay
+	     * with a cursor. This would speed up cursor movement.
+	     */
+	    TkTextChanged(NULL, textPtr, indexPtr, &index2);
+
+	    /*
+	     * Finally trigger the "watch" command for the "insert" cursor,
+	     * this must be the last action.
+	     */
+
+	    if (textPtr->watchCmd && !TriggerWatchCursor(textPtr, &oldIndex, indexPtr)) {
+		return NULL; /* the receiver did destroy the widget */
+	    }
+	}
+    }
+
+    return markPtr;
+}
+
+TkTextSegment *
+TkTextSetMark(
+    TkText *textPtr,		/* Text widget in which to create mark. */
+    const char *name,		/* Name of mark to set. */
+    TkTextIndex *indexPtr)	/* Where to set mark. */
+{
+    return SetMark(textPtr, name, NULL, indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextUnsetMark --
+ *
+ *	Unset (delete) given mark.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	A mark will be deleted.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextUnsetMark(
+    TkText *textPtr,		/* Text widget in which to create mark. */
+    TkTextSegment *markPtr)	/* Delete this mark. */
+{
+    TkTextUndoInfo undoInfo;
+    TkTextUndoInfo *undoInfoPtr = NULL;
+    bool isNormalMark = TkTextIsNormalMark(markPtr);
+
+    assert(TkTextIsNormalMark(markPtr));
+
+    if (isNormalMark
+	    && textPtr->sharedTextPtr->steadyMarks
+	    && !TkTextUndoUndoStackIsFull(textPtr->sharedTextPtr->undoStack)) {
+	undoInfoPtr = &undoInfo;
+    }
+    UnsetMark(textPtr->sharedTextPtr, markPtr, undoInfoPtr);
+    if (isNormalMark) {
+	if (undoInfoPtr && undoInfo.token) {
+	    TkTextPushUndoToken(textPtr->sharedTextPtr, undoInfo.token, 0);
+	}
+	if (textPtr->sharedTextPtr->steadyMarks) {
+	    TkTextUpdateAlteredFlag(textPtr->sharedTextPtr);
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextSaveCursorIndex --
+ *
+ *	Save the current position of the insert cursor, but only if
+ *	it is not yet saved. Use this function only if a trigger of
+ *	the "watch" command is wanted in case of cursor movement.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextSaveCursorIndex(
+    TkText *textPtr)
+{
+    if (TkTextIndexIsEmpty(&textPtr->insertIndex)) {
+	TkTextIndexSetSegment(&textPtr->insertIndex, textPtr->insertMarkPtr);
+	TkTextIndexSave(&textPtr->insertIndex);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextTriggerWatchCursor --
+ *
+ *	Trigger the watch command for movements of the insert cursor.
+ *
+ * Results:
+ *	Returns 'false' if the referenced widget has been destroyed, otherwise
+ *	'true' will be returned.
+ *
+ * Side effects:
+ *	It might happen that the receiver of the "watch" command is destroying the widget.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextTriggerWatchCursor(
+    TkText *textPtr)
+{
+    assert(textPtr->watchCmd);
+
+    if (TkTextIndexIsEmpty(&textPtr->insertIndex)) {
+	return true;
+    }
+
+    TkTextIndexRebuild(&textPtr->insertIndex);
+    return TriggerWatchCursor(textPtr, &textPtr->insertIndex, NULL);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextMarkSegToIndex --
+ *
+ *	Given a segment that is a mark, create an index that refers to the
+ *	next text character (or other text segment with non-zero size) after
+ *	the mark.
+ *
+ * Results:
+ *	*IndexPtr is filled in with index information.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+void
+TkTextMarkSegToIndex(
+    TkText *textPtr,		/* Text widget containing mark, can be NULL. */
+    TkTextSegment *markPtr,	/* Mark segment. */
+    TkTextIndex *indexPtr)	/* Index information gets stored here.  */
+{
+    assert(textPtr);
+    assert(markPtr);
+    assert(markPtr->sectionPtr); /* otherwise not linked */
+
+    TkTextIndexClear(indexPtr, textPtr);
+    /* disable range checks, because here it's is allowed that the index is out of range. */
+    DEBUG(indexPtr->discardConsistencyCheck = true);
+    TkTextIndexSetSegment(indexPtr, markPtr);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextMarkNameToIndex --
+ *
+ *	Given the name of a mark, return an index corresponding to the mark
+ *	name.
+ *
+ * Results:
+ *	The return value is 'true' if "name" exists as a mark in the text
+ *	widget and is located within its -start/-end range. In this
+ *	case *indexPtr is filled in with the next segment who is after the
+ *	mark whose size is non-zero. 'false' is returned if the mark
+ *	doesn't exist in the text widget, or if it is out of its -start/
+ *	-end range. In this latter case *indexPtr still contains valid
+ *	information, in particular TkTextMarkNameToIndex called with the
+ *	"insert" or "current" mark name may return TCL_ERROR, but *indexPtr
+ *	contains the correct index of this mark before -start or after
+ *	-end.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+MarkToIndex(
+    TkText *textPtr,		/* Text widget containing mark. */
+    TkTextSegment *markPtr,	/* Pointer to mark segment. */
+    TkTextIndex *indexPtr)	/* Index information gets stored here. */
+{
+    TkTextIndex index;
+
+    assert(textPtr);
+    TkTextMarkSegToIndex(textPtr, markPtr, indexPtr);
+    indexPtr->textPtr = textPtr;
+
+    /*
+     * If indexPtr refers to somewhere outside the -start/-end range
+     * limits of the widget, error out since the mark indeed is not
+     * reachable from this text widget (it may be reachable from a peer)
+     * (bug 1630271).
+     */
+
+    if (textPtr->startMarker != textPtr->sharedTextPtr->startMarker) {
+	TkTextIndexClear(&index, textPtr);
+	TkTextIndexSetSegment(&index, textPtr->startMarker);
+	if (TkTextIndexCompare(indexPtr, &index) < 0) {
+	    return false;
+	}
+    }
+    if (textPtr->endMarker != textPtr->sharedTextPtr->endMarker) {
+	if (TkTextIndexGetLine(indexPtr) == textPtr->endMarker->sectionPtr->linePtr) {
+	    TkTextIndexClear(&index, textPtr);
+	    TkTextIndexSetSegment(&index, textPtr->endMarker);
+	} else {
+	    TkTextIndexSetupToEndOfText(&index, textPtr, indexPtr->tree);
+	}
+	if (TkTextIndexCompare(indexPtr, &index) > 0) {
+	    return false;
+	}
+    }
+
+    return true;
+}
+
+bool
+TkTextMarkNameToIndex(
+    TkText *textPtr,		/* Text widget containing mark. */
+    const char *name,		/* Name of mark. */
+    TkTextIndex *indexPtr)	/* Index information gets stored here. */
+{
+    TkTextSegment *segPtr;
+
+    assert(textPtr);
+
+    if (strcmp(name, "insert") == 0) {
+	segPtr = textPtr->insertMarkPtr;
+    } else if (strcmp(name, "current") == 0) {
+	segPtr = textPtr->currentMarkPtr;
+    } else {
+	Tcl_HashEntry *hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->markTable, name);
+
+	if (hPtr == NULL) {
+	    return false;
+	}
+	segPtr = Tcl_GetHashValue(hPtr);
+    }
+
+    return MarkToIndex(textPtr, segPtr, indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextInspectUndoMarkItem --
+ *
+ *	Inspect retained undo token.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory is allocated for the result.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextInspectUndoMarkItem(
+    const TkSharedText *sharedTextPtr,
+    const TkTextMarkChange *changePtr,
+    Tcl_Obj* objPtr)
+{
+    assert(changePtr);
+
+    if (changePtr->setMark) {
+	Tcl_ListObjAppendElement(NULL, objPtr,
+		changePtr->setMark->undoType->inspectProc(sharedTextPtr, changePtr->setMark));
+    }
+    if (changePtr->moveMark) {
+	Tcl_ListObjAppendElement(NULL, objPtr,
+		changePtr->moveMark->undoType->inspectProc(sharedTextPtr, changePtr->moveMark));
+    }
+    if (changePtr->toggleGravity) {
+	Tcl_ListObjAppendElement(NULL, objPtr,
+		changePtr->toggleGravity->undoType->inspectProc(sharedTextPtr,
+		changePtr->toggleGravity));
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MarkInspectProc --
+ *
+ *	This function is invoked to build the information for
+ *	"inspect".
+ *
+ * Results:
+ *	Return a TCL object containing the information for
+ *	"inspect".
+ *
+ * Side effects:
+ *	Storage is allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+MarkInspectProc(
+    const TkSharedText *sharedTextPtr,
+    const TkTextSegment *segPtr)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    const char *gravity = (segPtr->typePtr == &tkTextLeftMarkType) ? "left" : "right";
+    const char *name;
+
+    assert(!TkTextIsPrivateMark(segPtr));
+    assert(!IS_PRESERVED(segPtr));
+
+    name = TkTextMarkName(sharedTextPtr, NULL, segPtr);
+    assert(name);
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(gravity, -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(name, -1));
+    return objPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MarkDeleteProc --
+ *
+ *	This function is invoked by the text B-tree code whenever a mark lies
+ *	in a range being deleted.
+ *
+ * Results:
+ *	Returns false to indicate that deletion has been rejected. Otherwise, if
+ *	deletion has been done (virtually) because DELETE_MARKS is set, true
+ *	will be returned. If the reference count of this segment is not going
+ *	to zero then this segment will be preserved for undo.
+ *
+ * Side effects:
+ *	None when this functions returns false (even if the whole tree is being
+ *	deleted we don't free up the mark; it will be done elsewhere). But
+ *	if a deletion has been done the hash entry of this mark will be
+ *	removed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+MarkDeleteProc(
+    TkTextBTree tree,
+    TkTextSegment *segPtr,	/* Segment being deleted. */
+    int flags)			/* The deletion flags. */
+{
+    TkSharedText *sharedTextPtr;
+
+    assert(segPtr->refCount > 0);
+
+    if (TkTextIsSpecialMark(segPtr)) {
+	return false;
+    }
+
+    assert(segPtr->refCount > 0);
+
+    if (TkTextIsPrivateMark(segPtr)) {
+	if (!(flags & (DELETE_CLEANUP))) {
+	    return false;
+	}
+	if (--segPtr->refCount == 0) {
+	    if (segPtr->body.mark.ptr) {
+		Tcl_DeleteHashEntry(GET_HPTR(segPtr));
+		segPtr->body.mark.textPtr->sharedTextPtr->numPrivateMarks -= 1;
+	    }
+	    FREE_SEGMENT(segPtr);
+	    DEBUG_ALLOC(tkTextCountDestroySegment++);
+	}
+	return true;
+    }
+
+    if (!(flags & (DELETE_MARKS|DELETE_PRESERVE|DELETE_CLEANUP|TREE_GONE))) {
+	return false;
+    }
+
+    assert(segPtr->body.mark.ptr);
+    assert(segPtr->body.mark.textPtr);
+
+    sharedTextPtr = segPtr->body.mark.textPtr->sharedTextPtr;
+
+    if (segPtr->body.mark.changePtr) {
+	unsigned index;
+
+	index = segPtr->body.mark.changePtr - sharedTextPtr->undoMarkList;
+	TkTextReleaseUndoMarkTokens(sharedTextPtr, segPtr->body.mark.changePtr);
+	memmove(sharedTextPtr->undoMarkList + index, sharedTextPtr->undoMarkList + index + 1,
+		--sharedTextPtr->undoMarkListCount - index);
+    }
+
+    if (--segPtr->refCount == 0) {
+	if (IS_PRESERVED(segPtr)) {
+	    free(GET_NAME(segPtr));
+	} else {
+	    sharedTextPtr->numMarks -= 1;
+	    Tcl_DeleteHashEntry(GET_HPTR(segPtr));
+	}
+	FREE_SEGMENT(segPtr);
+	DEBUG_ALLOC(tkTextCountDestroySegment++);
+    } else if ((flags & DELETE_PRESERVE) && !IS_PRESERVED(segPtr)) {
+	Tcl_HashEntry *hPtr;
+	const char *name;
+	unsigned size;
+
+	name = Tcl_GetHashKey(&sharedTextPtr->markTable, hPtr = GET_HPTR(segPtr));
+	size = strlen(name) + 1;
+	segPtr->body.mark.ptr = PTR_TO_INT(memcpy(malloc(size), name, size));
+	MAKE_PRESERVED(segPtr);
+	Tcl_DeleteHashEntry(hPtr);
+	sharedTextPtr->numMarks -= 1;
+    }
+
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MarkRestoreProc --
+ *
+ *	This function is called when a mark segment will be resused
+ *	from the undo chain.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The name of the mark will be freed, and the mark will be
+ *	re-entered into the hash table.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+MarkRestoreProc(
+    TkTextSegment *segPtr)	/* Segment to restore. */
+{
+    assert(TkTextIsNormalMark(segPtr));
+
+    if (IS_PRESERVED(segPtr)) {
+	TkSharedText *sharedTextPtr = segPtr->body.mark.textPtr->sharedTextPtr;
+	Tcl_HashEntry *hPtr;
+	int isNew;
+
+	hPtr = Tcl_CreateHashEntry(&sharedTextPtr->markTable, GET_NAME(segPtr), &isNew);
+	assert(isNew);
+	Tcl_SetHashValue(hPtr, segPtr);
+	free(GET_NAME(segPtr));
+	segPtr->body.mark.ptr = PTR_TO_INT(hPtr);
+	sharedTextPtr->numMarks += 1;
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MarkCheckProc --
+ *
+ *	This function is invoked by the B-tree code to perform consistency
+ *	checks on mark segments.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The function panics if it detects anything wrong with
+ *	the mark.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+MarkCheckProc(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextSegment *markPtr)	/* Segment to check. */
+{
+    if (!markPtr->nextPtr) {
+	Tcl_Panic("MarkCheckProc: mark is last segment in line");
+    }
+    if (markPtr->size != 0) {
+	Tcl_Panic("MarkCheckProc: mark has size %d", markPtr->size);
+    }
+    if (!markPtr->insertMarkFlag
+	    && !markPtr->currentMarkFlag
+	    && !markPtr->privateMarkFlag
+	    && !markPtr->normalMarkFlag) {
+	Tcl_Panic("MarkCheckProc: mark is not specialized");
+    }
+    if (markPtr->insertMarkFlag +
+	    markPtr->currentMarkFlag +
+	    markPtr->privateMarkFlag +
+	    markPtr->normalMarkFlag > 1) {
+	Tcl_Panic("MarkCheckProc: mark has more than one specialization");
+    }
+    if (markPtr->startEndMarkFlag && !markPtr->privateMarkFlag) {
+	Tcl_Panic("MarkCheckProc: start/end marks have to be private");
+    }
+
+    if (markPtr->body.mark.changePtr) {
+	/*
+	 * Private marks and special marks will not have undo/redo data.
+	 */
+
+	if (TkTextIsSpecialOrPrivateMark(markPtr)) {
+	    Tcl_Panic("MarkCheckProc: private/special marks should not have undo/redo data");
+	}
+    }
+
+    /*
+     * The special marks ("insert", "current") are not in the hash table,
+     * the same with the start/end markers.
+     */
+
+    if (markPtr->body.mark.ptr) {
+	void *hPtr;
+
+	if (IS_PRESERVED(markPtr)) {
+	    Tcl_Panic("MarkCheckProc: detected preserved mark outside of the undo chain");
+	}
+
+	hPtr = Tcl_GetHashKey(&sharedTextPtr->markTable, (Tcl_HashEntry *) markPtr->body.mark.ptr);
+	if (!hPtr) {
+	    Tcl_Panic("MarkCheckProc: couldn't find hash table entry for mark");
+	}
+    }
+
+    if (markPtr->startEndMarkFlag) {
+	if (markPtr->typePtr == &tkTextLeftMarkType) {
+	    if (markPtr->prevPtr
+		    && markPtr->prevPtr->typePtr->group == SEG_GROUP_MARK
+		    && (!markPtr->prevPtr->startEndMarkFlag
+			|| markPtr->prevPtr->typePtr != &tkTextLeftMarkType)) {
+		Tcl_Panic("MarkCheckProc: start marker must be leftmost mark");
+	    }
+	} else {
+	    if (markPtr->nextPtr
+		    && markPtr->nextPtr->typePtr->group == SEG_GROUP_MARK
+		    && (!markPtr->nextPtr->startEndMarkFlag
+			|| markPtr->nextPtr->typePtr != &tkTextRightMarkType)) {
+		Tcl_Panic("MarkCheckProc: end marker must be rightmost mark");
+	    }
+	}
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MarkLayoutProc --
+ *
+ *	This function is the "layoutProc" for mark segments.
+ *
+ * Results:
+ *	If the mark isn't the insertion cursor then the return value is -1 to
+ *	indicate that this segment shouldn't be displayed. If the mark is the
+ *	insertion character then 1 is returned and the chunkPtr structure is
+ *	filled in.
+ *
+ * Side effects:
+ *	None, except for filling in chunkPtr.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+MarkLayoutProc(
+    const TkTextIndex *indexPtr,/* Identifies first character in chunk. */
+    TkTextSegment *segPtr,	/* Segment corresponding to indexPtr. */
+    int offset,			/* Offset within segPtr corresponding to indexPtr (always 0). */
+    int maxX,			/* Chunk must not occupy pixels at this position or higher. */
+    int maxChars,		/* Chunk must not include more than this many characters. */
+    bool noCharsYet,		/* 'true' means no characters have been assigned to this line yet. */
+    TkWrapMode wrapMode,	/* Not used. */
+    TkTextSpaceMode spaceMode,	/* Not used. */
+    TkTextDispChunk *chunkPtr)	/* Structure to fill in with information about this chunk. The x
+    				 * field has already been set by the caller. */
+{
+    TkText *textPtr = indexPtr->textPtr;
+
+    assert(indexPtr->textPtr);
+
+    if (segPtr != textPtr->insertMarkPtr) {
+	return -1;
+    }
+
+    chunkPtr->layoutProcs = &layoutInsertProcs;
+    chunkPtr->numBytes = 0;
+    chunkPtr->minAscent = 0;
+    chunkPtr->minDescent = 0;
+    chunkPtr->minHeight = 0;
+    chunkPtr->width = 0;
+
+    /*
+     * Note: can't break a line after the insertion cursor: this prevents the
+     * insertion cursor from being stranded at the end of a line.
+     */
+
+    chunkPtr->breakIndex = -1;
+    chunkPtr->clientData = textPtr;
+    return 1;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextDrawBlockCursor --
+ *
+ *	This function returns whether a block will be drawn, which covers
+ *	characters.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+bool
+TkTextDrawBlockCursor(
+    TkText *textPtr)		/* The current text widget. */
+{
+    if (textPtr->blockCursorType) {
+	if (textPtr->flags & HAVE_FOCUS) {
+	    if ((textPtr->flags & INSERT_ON) || textPtr->selBorder == textPtr->insertBorder) {
+		return true;
+	    }
+	} else if (textPtr->insertUnfocussed == TK_TEXT_INSERT_NOFOCUS_SOLID) {
+	    return true;
+	}
+    }
+    return false;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextGetCursorWidth --
+ *
+ *	This function computes the cursor dimensions.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+unsigned
+TkTextGetCursorWidth(
+    TkText *textPtr,		/* The current text widget. */
+    int *x,			/* Shift x coordinate, can be NULL. */
+    int *offs)			/* Offset in x-direction, can be NULL. */
+{
+    TkTextIndex index;
+    int ix = 0, iy = 0, iw = 0, ih = 0;
+    int charWidth = 0;
+
+    if (offs) {
+	*offs = -(textPtr->insertWidth/2);
+    }
+
+    if (textPtr->blockCursorType) {
+	TkTextMarkSegToIndex(textPtr, textPtr->insertMarkPtr, &index);
+	TkTextIndexBbox(textPtr, &index, &ix, &iy, &iw, &ih, &charWidth);
+
+	/*
+	 * Don't draw the full lengh of a tab, in this case we are drawing
+	 * a cursor at the right boundary with a standard with.
+	 */
+
+	if (TkTextIndexGetChar(&index) == '\t') {
+	    if (x) { *x += charWidth; }
+	    charWidth = MIN(textPtr->charWidth, charWidth);
+	    if (x) { *x -= charWidth; }
+	}
+    }
+
+    return charWidth + textPtr->insertWidth;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextInsertDisplayProc --
+ *
+ *	This function is called to display the insertion cursor.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Graphics are drawn.
+ *
+ *--------------------------------------------------------------
+ */
+
+void
+TkTextInsertDisplayProc(
+    TkText *textPtr,		/* The current text widget. */
+    TkTextDispChunk *chunkPtr,	/* Chunk that is to be drawn. */
+    int x,			/* X-position in dst at which to draw this chunk (may differ
+    				 * from the x-position in the chunk because of scrolling). */
+    int y,			/* Y-position at which to draw this chunk in dst (x-position
+    				 * is in the chunk itself). */
+    int height,			/* Total height of line. */
+    int baseline,		/* Offset of baseline from y. */
+    Display *display,		/* Display to use for drawing. */
+    Drawable dst,		/* Pixmap or window in which to draw chunk. */
+    int screenY)		/* Y-coordinate in text window that corresponds to y. */
+{
+    int halfWidth = textPtr->insertWidth/2;
+    int width = TkTextGetCursorWidth(textPtr, &x, NULL);
+    int rightSideWidth = width + halfWidth - textPtr->insertWidth;
+
+    if ((x + rightSideWidth) < 0) {
+	/*
+	 * The insertion cursor is off-screen. Indicate caret at 0,0 and return.
+	 */
+
+	Tk_SetCaretPos(textPtr->tkwin, 0, 0, height);
+	return;
+    }
+
+    x -= halfWidth;
+
+    Tk_SetCaretPos(textPtr->tkwin, x, screenY, height);
+
+    if (POINTER_IS_MARKED(chunkPtr)) {
+	/*
+	 * HACK: We are drawing into a tailored pixmap, because Tk has no clipping;
+	 * see DisplayDLine().
+	 */
+	
+	x = y = 0;
+    }
+
+    /*
+     * As a special hack to keep the cursor visible on mono displays (or
+     * anywhere else that the selection and insertion cursors have the same
+     * color) write the default background in the cursor area (instead of
+     * nothing) when the cursor isn't on. Otherwise the selection might hide
+     * the cursor.
+     */
+
+    if (textPtr->flags & HAVE_FOCUS) {
+	if (textPtr->flags & INSERT_ON) {
+	    Tk_Fill3DRectangle(textPtr->tkwin, dst, textPtr->insertBorder, x, y,
+		    width, height, textPtr->insertBorderWidth, TK_RELIEF_RAISED);
+	} else if (textPtr->selBorder == textPtr->insertBorder) {
+	    Tk_Fill3DRectangle(textPtr->tkwin, dst, textPtr->border, x, y,
+		    width, height, 0, TK_RELIEF_FLAT);
+	}
+    } else if (textPtr->insertUnfocussed == TK_TEXT_INSERT_NOFOCUS_HOLLOW) {
+	if (textPtr->insertBorderWidth < 1) {
+	    /*
+	     * Hack to work around the fact that a "solid" border always paints in black.
+	     */
+
+	    TkBorder *borderPtr = (TkBorder *) textPtr->insertBorder;
+
+	    XDrawRectangle(Tk_Display(textPtr->tkwin), dst, borderPtr->bgGC, x, y,
+		    width - 1, height - 1);
+	} else {
+	    Tk_Draw3DRectangle(textPtr->tkwin, dst, textPtr->insertBorder, x, y,
+		    width, height, textPtr->insertBorderWidth, TK_RELIEF_RAISED);
+	}
+    } else if (textPtr->insertUnfocussed == TK_TEXT_INSERT_NOFOCUS_SOLID) {
+	Tk_Fill3DRectangle(textPtr->tkwin, dst, textPtr->insertBorder, x, y,
+		width, height, textPtr->insertBorderWidth, TK_RELIEF_RAISED);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * InsertUndisplayProc --
+ *
+ *	This function is called when the insertion cursor is no longer at a
+ *	visible point on the display. It does nothing right now.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+InsertUndisplayProc(
+    TkText *textPtr,		/* Overall information about text widget. */
+    TkTextDispChunk *chunkPtr)	/* Chunk that is about to be freed. */
+{
+    chunkPtr->clientData = NULL;
+    return;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MarkFindNext --
+ *
+ *	This function searches forward for the next mark.
+ *
+ * Results:
+ *	A standard Tcl result, which is a mark name or an empty string.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+MarkFindNext(
+    Tcl_Interp *interp,		/* For error reporting */
+    TkText *textPtr,		/* The widget */
+    const char *string,		/* The starting index or mark name */
+    bool forward)		/* Search forward. */
+{
+    TkTextIndex index;
+    Tcl_HashEntry *hPtr;
+    TkTextSegment *segPtr;
+    TkTextLine *linePtr;
+
+    assert(textPtr);
+
+    if (TkTextIsDeadPeer(textPtr)) {
+	return TCL_OK;
+    }
+
+    if (strcmp(string, "insert") == 0) {
+	segPtr = textPtr->insertMarkPtr;
+	linePtr = segPtr->sectionPtr->linePtr;
+	segPtr = forward ? segPtr->nextPtr : segPtr->prevPtr;
+    } else if (strcmp(string, "current") == 0) {
+	segPtr = textPtr->currentMarkPtr;
+	linePtr = segPtr->sectionPtr->linePtr;
+	segPtr = forward ? segPtr->nextPtr : segPtr->prevPtr;
+    } else {
+	if ((hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->markTable, string))) {
+	    /*
+	     * If given a mark name, return the next/prev mark in the list of segments, even
+	     * if it happens to be at the same character position.
+	     */
+
+	    segPtr = Tcl_GetHashValue(hPtr);
+	    if (!MarkToIndex(textPtr, segPtr, &index)) {
+		return SetResultNoMarkNamed(interp, string);
+	    }
+	    linePtr = segPtr->sectionPtr->linePtr;
+	    segPtr = forward ? segPtr->nextPtr : segPtr->prevPtr;
+	} else {
+	    /*
+	     * For non-mark name indices we want to return any marks that are
+	     * right at the index, when searching forward, otherwise we do not
+	     * return any marks that are right at the index.
+	     */
+
+	    if (TkTextGetIndex(interp, textPtr, string, &index) != TCL_OK) {
+		return TCL_ERROR;
+	    }
+	    segPtr = TkTextIndexGetFirstSegment(&index, NULL);
+	    linePtr = segPtr->sectionPtr->linePtr;
+
+	    if (!forward) {
+		while (segPtr && segPtr->size == 0) {
+		    segPtr = segPtr->prevPtr;
+		}
+	    }
+	}
+    }
+
+    if (forward) {
+	TkTextSegment *lastPtr = textPtr->endMarker;
+
+	/*
+	 * Ensure that we can reach 'lastPtr'.
+	 */
+
+	while (lastPtr->size == 0) {
+	    lastPtr = lastPtr->nextPtr;
+	}
+
+	while (true) {
+	    /*
+	     * 'segPtr' points at the first possible candidate, or NULL if we ran
+	     * off the end of the line.
+	     */
+
+	    for ( ; segPtr; segPtr = segPtr->nextPtr) {
+		if (segPtr == lastPtr) {
+		    return TCL_OK;
+		}
+		if (TkTextIsNormalOrSpecialMark(segPtr)) {
+		    const char *name = TkTextMarkName(textPtr->sharedTextPtr, textPtr, segPtr);
+
+		    if (name) {
+			Tcl_SetObjResult(interp, Tcl_NewStringObj(name, -1));
+			return TCL_OK;
+		    }
+
+		    /*
+		     * It's a special mark not belonging to this widget, so ignore it.
+		     */
+		}
+	    }
+
+	    if (!(linePtr = linePtr->nextPtr)) {
+		return TCL_OK;
+	    }
+	    segPtr = linePtr->segPtr;
+	}
+    } else {
+	TkTextSegment *firstPtr = textPtr->startMarker;
+
+	/*
+	 * Ensure that we can reach 'firstPtr'.
+	 */
+
+	while (firstPtr->prevPtr && firstPtr->prevPtr->size == 0) {
+	    firstPtr = firstPtr->prevPtr;
+	}
+
+	while (true) {
+	    /*
+	     * 'segPtr' points at the first possible candidate, or NULL if we ran
+	     * off the start of the line.
+	     */
+
+	    for ( ; segPtr; segPtr = segPtr->prevPtr) {
+		if (segPtr == firstPtr) {
+		    return TCL_OK;
+		}
+		if (TkTextIsNormalOrSpecialMark(segPtr)) {
+		    const char *name = TkTextMarkName(textPtr->sharedTextPtr, textPtr, segPtr);
+
+		    if (name) {
+			Tcl_SetObjResult(interp, Tcl_NewStringObj(name, -1));
+			return TCL_OK;
+		    }
+
+		    /*
+		     * It's a special mark not belonging to this widget, so ignore it.
+		     */
+		}
+	    }
+
+	    if (!(linePtr = linePtr->prevPtr)) {
+		return TCL_OK;
+	    }
+	    segPtr = linePtr->lastPtr;
+	}
+    }
+
+    return TCL_OK; /* never reached */
+}
+
+/*
+ * ------------------------------------------------------------------------
+ *
+ * TkTextMarkName --
+ *
+ *	Returns the name of the mark that is the given text segment, or NULL
+ *	if it is unnamed (i.e., a widget-specific mark that isn't "current" or
+ *	"insert").
+ *
+ * Results:
+ *	The name of the mark, or NULL.
+ *
+ * Side effects:
+ *	None.
+ *
+ * ------------------------------------------------------------------------
+ */
+
+const char *
+TkTextMarkName(
+    const TkSharedText *sharedTextPtr,
+    const TkText *textPtr,		/* can be NULL */
+    const TkTextSegment *markPtr)
+{
+    assert(!IS_PRESERVED(markPtr));
+
+    if (markPtr->insertMarkFlag) {
+	return !textPtr || textPtr == markPtr->body.mark.textPtr ? "insert" : NULL;
+    }
+    if (markPtr->currentMarkFlag) {
+	return !textPtr || textPtr == markPtr->body.mark.textPtr ? "current" : NULL;
+    }
+    if (!markPtr->body.mark.ptr) {
+	return NULL;
+    }
+    return Tcl_GetHashKey(&sharedTextPtr->markTable, (Tcl_HashEntry *) markPtr->body.mark.ptr);
+}
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 105
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: src/tktext/tkTextPriv.h
===================================================================
--- src/tktext/tkTextPriv.h	(revision 0)
+++ src/tktext/tkTextPriv.h	(working copy)
@@ -0,0 +1,970 @@
+/*
+ * tkTextPriv.h --
+ *
+ *	Private implementation for text widget.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKTEXT
+# error "do not include this private header file"
+#endif
+
+
+#ifndef _TKTEXTPRIV
+#define _TKTEXTPRIV
+
+/*
+ * The following struct is private for TkTextBTree.c, but we want fast access to
+ * the internal content.
+ *
+ * The data structure below defines an entire B-tree. Since text widgets are
+ * the only current B-tree clients, 'clients' and 'numPixelReferences' are
+ * identical.
+ */
+
+struct TkBTreeNodePixelInfo;
+
+struct TkTextMyBTree {
+    struct Node *rootPtr;
+				/* Pointer to root of B-tree. */
+    unsigned clients;		/* Number of clients of this B-tree. */
+    unsigned numPixelReferences;
+				/* Number of clients of this B-tree which care about pixel heights. */
+    struct TkBTreeNodePixelInfo *pixelInfoBuffer;
+    				/* Buffer of size numPixelReferences used for recomputation of pixel
+    				 * information. */
+    unsigned stateEpoch;	/* Updated each time any aspect of the B-tree changes. */
+    TkSharedText *sharedTextPtr;/* Used to find tagTable in consistency checking code, and to access
+    				 * list of all B-tree clients. */
+};
+
+#endif /* _TKTEXTPRIV */
+
+#ifdef _TK_NEED_IMPLEMENTATION
+
+#include <assert.h>
+
+#if __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIsSpecialMark --
+ *
+ *	Test whether this is a special mark: "insert", or "current".
+ *
+ * Results:
+ *	Whether this is a special mark.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+bool
+TkTextIsSpecialMark(
+    const TkTextSegment *segPtr)
+{
+    assert(segPtr);
+    return !!(segPtr->insertMarkFlag | segPtr->currentMarkFlag);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIsPrivateMark --
+ *
+ *	Test whether this is a private mark, not visible with "inspect"
+ *	or "dump". These kind of marks will be used in library/text.tcl.
+ *	Furthemore in practice it is guaranteed that this mark has a
+ *	unique name.
+ *
+ * Results:
+ *	Whether this is a private mark.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+bool
+TkTextIsPrivateMark(
+    const TkTextSegment *segPtr)
+{
+    assert(segPtr);
+    return segPtr->privateMarkFlag;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIsNormalMark --
+ *
+ *	Test whether this is a mark, and it is neither special, nor
+ *	private, nor a start/end marker.
+ *
+ * Results:
+ *	Whether this is a normal mark.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+bool
+TkTextIsNormalMark(
+    const TkTextSegment *segPtr)
+{
+    assert(segPtr);
+    return segPtr->normalMarkFlag;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIsStartEndMarker --
+ *
+ *	Test whether this is a start/end marker. This must not be a mark,
+ *	it can also be a break segment.
+ *
+ * Results:
+ *	Whether this is a start/end marker.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+bool
+TkTextIsStartEndMarker(
+    const TkTextSegment *segPtr)
+{
+    assert(segPtr);
+    return segPtr->startEndMarkFlag;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIsStableMark --
+ *
+ *	Test whether this is a mark, and it is neither special, nor
+ *	private. Note that also a break segment is interpreted as
+ *	a stable mark.
+ *
+ * Results:
+ *	Whether this is a stable mark.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+bool
+TkTextIsStableMark(
+    const TkTextSegment *segPtr)
+{
+    return TkTextIsStartEndMarker(segPtr) || TkTextIsNormalMark(segPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIsSpecialOrPrivateMark --
+ *
+ *	Test whether this is a special mark, or a private mark.
+ *
+ * Results:
+ *	Whether this is a special or private mark.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+bool
+TkTextIsSpecialOrPrivateMark(
+    const TkTextSegment *segPtr)
+{
+    assert(segPtr);
+    return !!(segPtr->privateMarkFlag | segPtr->insertMarkFlag | segPtr->currentMarkFlag);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIsNormalOrSpecialMark --
+ *
+ *	Test whether this is a normal mark, or a special mark.
+ *
+ * Results:
+ *	Whether this is a normal or special mark.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+bool
+TkTextIsNormalOrSpecialMark(
+    const TkTextSegment *segPtr)
+{
+    return TkTextIsNormalMark(segPtr) || TkTextIsSpecialMark(segPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIsDeadPeer --
+ *
+ *	Test whether given widget is dead, this means that the start
+ *	index is on last line. If it is dead, then this peer will not
+ *	have an insert mark.
+ *
+ * Results:
+ *	Returns whether given peer is dead.
+ *
+ * Side effects:
+ *	None
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+bool
+TkTextIsDeadPeer(
+    const TkText *textPtr)
+{
+    return !textPtr->startMarker->sectionPtr->linePtr->nextPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeLinePixelInfo --
+ *
+ *	Return widget pixel information for specified line.
+ *
+ * Results:
+ *	The pixel information of this line for specified widget.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkTextPixelInfo *
+TkBTreeLinePixelInfo(
+    const TkText *textPtr,
+    TkTextLine *linePtr)
+{
+    assert(textPtr);
+    assert(textPtr->pixelReference >= 0);
+    assert(linePtr);
+
+    return linePtr->pixelInfo + textPtr->pixelReference;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeGetStartLine --
+ *
+ *	This function returns the first line for this text widget.
+ *
+ * Results:
+ *	The first line in this widget.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkTextLine *
+TkBTreeGetStartLine(
+    const TkText *textPtr)
+{
+    assert(textPtr);
+    return textPtr->startMarker->sectionPtr->linePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeGetLastLine --
+ *
+ *	This function returns the last line for this text widget.
+ *
+ * Results:
+ *	The last line in this widget.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkTextLine *
+TkBTreeGetLastLine(
+    const TkText *textPtr)
+{
+    TkTextLine *endLine;
+
+    assert(textPtr);
+    endLine = textPtr->endMarker->sectionPtr->linePtr;
+    return endLine->nextPtr ? endLine->nextPtr : endLine;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeGetShared --
+ *
+ *	Get the shared resource for given tree.
+ *
+ * Results:
+ *	The shared resource.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkSharedText *
+TkBTreeGetShared(
+    TkTextBTree tree)		/* Return shared resource of this tree. */
+{
+    return ((struct TkTextMyBTree *) tree)->sharedTextPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeIncrEpoch --
+ *
+ *	Increment the epoch of the tree.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Increment the epoch number.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+unsigned
+TkBTreeIncrEpoch(
+    TkTextBTree tree)		/* Tree to increment epoch. */
+{
+    return ((struct TkTextMyBTree *) tree)->stateEpoch += 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeEpoch --
+ *
+ *	Return the epoch for the B-tree. This number is incremented any time
+ *	anything changes in the tree.
+ *
+ * Results:
+ *	The epoch number.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+unsigned
+TkBTreeEpoch(
+    TkTextBTree tree)		/* Tree to get epoch for. */
+{
+    return ((struct TkTextMyBTree *) tree)->stateEpoch;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeGetRoot --
+ *
+ *	Return the root node of the B-Tree.
+ *
+ * Results:
+ *	The root node of the B-Tree.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+struct Node *
+TkBTreeGetRoot(
+    TkTextBTree tree)		/* Tree to get root node for. */
+{
+    return ((struct TkTextMyBTree *) tree)->rootPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeNextLine --
+ *
+ *	Given an existing line in a B-tree, this function locates the next
+ *	line in the B-tree, regarding the end line of this widget.
+ *	B-tree.
+ *
+ * Results:
+ *	The return value is a pointer to the line that immediately follows
+ *	linePtr, or NULL if there is no such line.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkTextLine *
+TkBTreeNextLine(
+    const TkText *textPtr,	/* Next line in the context of this client, can be NULL. */
+    TkTextLine *linePtr)	/* Pointer to existing line in B-tree. */
+{
+    return textPtr && linePtr == TkBTreeGetLastLine(textPtr) ? NULL : linePtr->nextPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreePrevLine --
+ *
+ *	Given an existing line in a B-tree, this function locates the previous
+ *	line in the B-tree, regarding the start line of this widget.
+ *
+ * Results:
+ *	The return value is a pointer to the line that immediately preceeds
+ *	linePtr, or NULL if there is no such line.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkTextLine *
+TkBTreePrevLine(
+    const TkText *textPtr,	/* Relative to this client of the B-tree, can be NULL. */
+    TkTextLine *linePtr)	/* Pointer to existing line in B-tree. */
+{
+    return textPtr && linePtr == TkBTreeGetStartLine(textPtr) ? NULL : linePtr->prevPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreePrevLogicalLine --
+ *
+ *	Given a line, this function is searching for the previous logical line,
+ *	which don't has a predecessing line with elided newline. If the search
+ *	reaches the start of the text, then the first line will be returned,
+ *	even if it's not a logical line (the latter can only happen in peers
+ *	with restricted ranges).
+ *
+ * Results:
+ *	The return value is the previous logical line, in most cases this
+ *	will be simply the previous line.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkTextLine *
+TkBTreePrevLogicalLine(
+    const TkSharedText* sharedTextPtr,
+    const TkText *textPtr,	/* can be NULL */
+    TkTextLine *linePtr)
+{
+    assert(linePtr);
+    assert(linePtr != (textPtr ?
+	    TkBTreeGetStartLine(textPtr) : sharedTextPtr->startMarker->sectionPtr->linePtr));
+
+    return TkBTreeGetLogicalLine(sharedTextPtr, textPtr, linePtr->prevPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeCountLines --
+ *
+ *	This function counts the number of lines inside a given range.
+ *
+ * Results:
+ *	The return value is the number of lines inside a given range.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+unsigned
+TkBTreeCountLines(
+    const TkTextBTree tree,
+    const TkTextLine *linePtr1,	/* Start counting at this line. */
+    const TkTextLine *linePtr2)	/* Stop counting at this line (don't count this line). */
+{
+    assert(TkBTreeLinesTo(tree, NULL, linePtr1, NULL) <= TkBTreeLinesTo(tree, NULL, linePtr2, NULL));
+
+    if (linePtr1 == linePtr2) {
+	return 0; /* this is catching a frequent case */
+    }
+    if (linePtr1->nextPtr == linePtr2) {
+	return 1; /* this is catching a frequent case */
+    }
+
+    return TkBTreeLinesTo(tree, NULL, linePtr2, NULL) - TkBTreeLinesTo(tree, NULL, linePtr1, NULL);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetPeer --
+ *
+ *	Set this index to the start of the line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+void
+TkTextIndexSetPeer(
+    TkTextIndex *indexPtr,
+    TkText *textPtr)
+{
+    assert(indexPtr->tree);
+    
+    indexPtr->textPtr = textPtr;
+    indexPtr->priv.lineNoRel = -1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexGetShared --
+ *
+ *	Get the shared resource of this index.
+ *
+ * Results:
+ *	The shared resource.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkSharedText *
+TkTextIndexGetShared(
+    const TkTextIndex *indexPtr)
+{
+    assert(indexPtr);
+    assert(indexPtr->tree);
+    return TkBTreeGetShared(indexPtr->tree);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeGetTags --
+ *
+ *	Return information about all of the tags that are associated with a
+ *	particular character in a B-tree of text.
+ *
+ * Results:
+ *      The return value is the root of the tag chain, containing all tags
+ *	associated with the character at the position given by linePtr and ch.
+ *	If there are no tags at the given character then a NULL pointer is
+ *	returned.
+ *
+ * Side effects:
+ *	The attribute nextPtr of TkTextTag will be modified for any tag.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkTextTag *
+TkBTreeGetTags(
+    const TkTextIndex *indexPtr)/* Indicates a particular position in the B-tree. */
+{
+    const TkTextSegment *segPtr = TkTextIndexGetContentSegment(indexPtr, NULL);
+    return TkBTreeGetSegmentTags(TkTextIndexGetShared(indexPtr), segPtr, indexPtr->textPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexGetLine --
+ *
+ *	Get the line pointer of this index.
+ *
+ * Results:
+ *	The line pointer.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkTextLine *
+TkTextIndexGetLine(
+    const TkTextIndex *indexPtr)/* Indicates a particular position in the B-tree. */
+{
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+
+    return indexPtr->priv.linePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetToLastChar2 --
+ *
+ *	Set the new line pointer, and set this index to one before the
+ *	end of the line.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+void
+TkTextIndexSetToLastChar2(
+    TkTextIndex *indexPtr,	/* Pointer to index. */
+    TkTextLine *linePtr)	/* Pointer to line. */
+{
+    assert(indexPtr->tree);
+    assert(linePtr);
+    assert(linePtr->parentPtr); /* expired? */
+
+    indexPtr->priv.linePtr = linePtr;
+    indexPtr->priv.lineNo = -1;
+    indexPtr->priv.lineNoRel = -1;
+    TkTextIndexSetToLastChar(indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexGetSegment --
+ *
+ *	Get the pointer to stored segment.
+ *
+ * Results:
+ *	Pointer to the stored segment, this can be NULL.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+TkTextSegment *
+TkTextIndexGetSegment(
+    const TkTextIndex *indexPtr)/* Pointer to index. */
+{
+    TkTextSegment *segPtr;
+
+    assert(indexPtr->tree);
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+
+    segPtr = indexPtr->priv.segPtr;
+
+    if (!segPtr
+	    || (indexPtr->priv.isCharSegment
+		&& TkBTreeEpoch(indexPtr->tree) != indexPtr->stateEpoch)) {
+	return NULL;
+    }
+
+    assert(!segPtr || segPtr->typePtr);    /* expired? */
+    assert(!segPtr || segPtr->sectionPtr); /* linked? */
+    assert(!segPtr || segPtr->sectionPtr->linePtr == indexPtr->priv.linePtr);
+
+    return segPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSave --
+ *
+ *	Makes the index robust, so that it can be rebuild after modifications.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+void
+TkTextIndexSave(
+    TkTextIndex *indexPtr)
+{
+    TkTextIndexGetLineNumber(indexPtr, indexPtr->textPtr);
+    TkTextIndexGetByteIndex(indexPtr);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSameLines --
+ *
+ *	Test whether both given indicies are referring the same line.
+ *
+ * Results:
+ *	Return true if both indices are referring the same line, otherwise
+ *	false will be returned.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+bool
+TkTextIndexSameLines(
+    const TkTextIndex *indexPtr1,	/* Pointer to index. */
+    const TkTextIndex *indexPtr2)	/* Pointer to index. */
+{
+    assert(indexPtr1->priv.linePtr);
+    assert(indexPtr2->priv.linePtr);
+    assert(indexPtr1->priv.linePtr->parentPtr); /* expired? */
+    assert(indexPtr2->priv.linePtr->parentPtr); /* expired? */
+
+    return indexPtr1->priv.linePtr == indexPtr2->priv.linePtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetEpoch --
+ *
+ *	Update epoch of given index, don't clear the segment pointer.
+ *	Use this function with care, it must be ensured that the
+ *	segment pointer is still valid.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+void
+TkTextIndexUpdateEpoch(
+    TkTextIndex *indexPtr,
+    unsigned epoch)
+{
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+
+    indexPtr->stateEpoch = epoch;
+    indexPtr->priv.lineNo = -1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexInvalidate --
+ *
+ *	Clear position attributes: segPtr, and byteIndex.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The given index will be in an invalid state, the TkIndexGet*
+ *	functions cannot be used.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+void
+TkTextIndexInvalidate(
+    TkTextIndex *indexPtr)	/* Pointer to index. */
+{
+    indexPtr->priv.segPtr = NULL;
+    indexPtr->priv.byteIndex = -1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextIndexSetEpoch --
+ *
+ *	Set epoch of given index, and clear the segment pointer if
+ *	the new epoch is different from last epoch.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+void
+TkTextIndexSetEpoch(
+    TkTextIndex *indexPtr,
+    unsigned epoch)
+{
+    assert(indexPtr->priv.linePtr);
+    assert(indexPtr->priv.linePtr->parentPtr); /* expired? */
+
+    if (indexPtr->stateEpoch != epoch) {
+	indexPtr->stateEpoch = epoch;
+	indexPtr->priv.segPtr = NULL;
+	indexPtr->priv.lineNo = -1;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkBTreeGetNumberOfDisplayLines --
+ *
+ *	Return the current number of display lines. This is the number
+ *	of lines known by the B-Tree (not the number of lines known
+ *	by the display stuff).
+ *
+ *	We are including the implementation into this private header file,
+ *	because it uses some facts only known by the display stuff.
+ *
+ * Results:
+ *	Returns the current number of display lines (known by B-Tree).
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+int
+TkBTreeGetNumberOfDisplayLines(
+    const TkTextPixelInfo *pixelInfo)
+{
+    const TkTextDispLineInfo *dispLineInfo;
+
+    if (pixelInfo->height == 0) {
+	return 0;
+    }
+    if (!(dispLineInfo = pixelInfo->dispLineInfo)) {
+	return 1;
+    }
+    if (pixelInfo->epoch & 0x80000000) {
+	/*
+	 * This will return the old number of display lines, because the
+	 * computation of the corresponding logical line is currently in
+	 * progress, and unfinished.
+	 */
+	return dispLineInfo->entry[dispLineInfo->numDispLines].pixels;
+    }
+    return dispLineInfo->numDispLines;
+}
+
+#if TCL_UTF_MAX <= 4 && TK_MAJOR_VERSION == 8 && TK_MINOR_VERSION < 7
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkUtfToUniChar --
+ *
+ *	Only needed for backporting, see source of version 8.7 about
+ *	this function.
+ *
+ *	IMO this function is only a bad hack, Tcl should provide the
+ *	appropriate functionality.
+ *
+ *----------------------------------------------------------------------
+ */
+
+inline
+int
+TkUtfToUniChar(const char *src, int *chPtr)
+{
+    Tcl_UniChar ch;
+    int result = Tcl_UtfToUniChar(src, &ch);
+    *chPtr = ch;
+    return result;
+}
+
+#endif /* end of backport for 8.6/8.5 */
+
+#undef _TK_NEED_IMPLEMENTATION
+#endif /* _TK_NEED_IMPLEMENTATION */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkTextTag.c
===================================================================
--- src/tktext/tkTextTag.c	(revision 0)
+++ src/tktext/tkTextTag.c	(working copy)
@@ -0,0 +1,3294 @@
+/*
+ * tkTextTag.c --
+ *
+ *	This module implements the "tag" subcommand of the widget command for
+ *	text widgets, plus most of the other high-level functions related to
+ *	tags.
+ *
+ * Copyright (c) 1992-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "default.h"
+#include "tkInt.h"
+#include "tkText.h"
+#include "tkTextUndo.h"
+#include "tkTextTagSet.h"
+#include "tkBitField.h"
+#include <assert.h>
+#include <stdlib.h>
+
+#ifndef MAX
+# define MAX(a,b) (((int) a) < ((int) b) ? b : a)
+#endif
+
+#if NDEBUG
+# define DEBUG(expr)
+#else
+# define DEBUG(expr) expr
+#endif
+
+/*
+ * Support of tk8.5.
+ */
+#ifdef CONST
+# undef CONST
+#endif
+#if TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION == 5
+# define CONST
+#else
+# define CONST const
+#endif
+
+/*
+ * The 'TkWrapMode' enum in tkText.h is used to define a type for the -wrap
+ * option of tags in a Text widget. These values are used as indices into the
+ * string table below. Tags are allowed an empty wrap value, but the widget as
+ * a whole is not.
+ */
+
+static const char *CONST wrapStrings[] = {
+    "char", "none", "word", "", NULL
+};
+
+/*
+ * The 'TkTextSpaceMode' enum in tkText.h is used to define a type for the -spacing
+ * option of tags in a Text widget. These values are used as indices into the
+ * string table below. Tags are allowed an empty wrap value, but the widget as
+ * a whole is not.
+ */
+
+static const char *const spaceModeStrings[] = {
+    "none", "exact", "trim", NULL
+};
+
+/*
+ * The 'TkTextTabStyle' enum in tkText.h is used to define a type for the
+ * -tabstyle option of the Text widget. These values are used as indices into
+ * the string table below. Tags are allowed an empty wrap value, but the
+ * widget as a whole is not.
+ */
+
+static const char *CONST tabStyleStrings[] = {
+    "tabular", "wordprocessor", "", NULL
+};
+
+static const Tk_OptionSpec tagOptionSpecs[] = {
+    {TK_OPTION_BORDER, "-background", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, border), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_BITMAP, "-bgstipple", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, bgStipple), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_PIXELS, "-borderwidth", NULL, NULL,
+	"0", Tk_Offset(TkTextTag, borderWidthPtr), Tk_Offset(TkTextTag, borderWidth),
+	TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT, 0, 0},
+    {TK_OPTION_STRING, "-elide", NULL, NULL,
+	"0", -1, Tk_Offset(TkTextTag, elideString),
+	TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT, 0, 0},
+    {TK_OPTION_COLOR, "-eolcolor", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, eolColor), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_BITMAP, "-fgstipple", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, fgStipple), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_FONT, "-font", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, tkfont), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_COLOR, "-foreground", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, fgColor), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_COLOR, "-hyphencolor", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, hyphenColor), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-hyphenrules", NULL, NULL,
+	NULL, Tk_Offset(TkTextTag, hyphenRulesPtr), -1, TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-indentbackground", NULL, NULL,
+	"0", -1, Tk_Offset(TkTextTag, indentBgString),
+	TK_OPTION_DONT_SET_DEFAULT|TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-justify", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, justifyString), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-lang", NULL, NULL,
+	NULL, Tk_Offset(TkTextTag, langPtr), -1, TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-lmargin1", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, lMargin1String), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-lmargin2", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, lMargin2String), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_BORDER, "-lmargincolor", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, lMarginColor), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-offset", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, offsetString), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-overstrike", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, overstrikeString), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_COLOR, "-overstrikecolor", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, overstrikeColor), TK_OPTION_NULL_OK, 0, 0},
+#if SUPPORT_DEPRECATED_TAG_OPTIONS
+    {TK_OPTION_COLOR, "-overstrikefg", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, overstrikeColor), TK_OPTION_NULL_OK, 0,
+	TK_TEXT_DEPRECATED_OVERSTRIKE_FG},
+#endif /* SUPPORT_DEPRECATED_TAG_OPTIONS */
+    {TK_OPTION_STRING, "-relief", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, reliefString), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-rmargin", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, rMarginString), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_BORDER, "-rmargincolor", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, rMarginColor), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_BORDER, "-selectbackground", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, selBorder), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_COLOR, "-selectforeground", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, selFgColor), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-spacing1", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, spacing1String), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-spacing2", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, spacing2String), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-spacing3", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, spacing3String), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING, "-tabs", NULL, NULL,
+	NULL, Tk_Offset(TkTextTag, tabStringPtr), -1, TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_STRING_TABLE, "-tabstyle", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, tabStyle), TK_OPTION_NULL_OK, tabStyleStrings, 0},
+    {TK_OPTION_STRING, "-underline", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, underlineString), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_COLOR, "-underlinecolor", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, underlineColor), TK_OPTION_NULL_OK, 0, 0},
+#if SUPPORT_DEPRECATED_TAG_OPTIONS
+    {TK_OPTION_COLOR, "-underlinefg", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, underlineColor), TK_OPTION_NULL_OK, 0,
+	TK_TEXT_DEPRECATED_UNDERLINE_FG},
+#endif /* SUPPORT_DEPRECATED_TAG_OPTIONS */
+    {TK_OPTION_BOOLEAN, "-undo", NULL, NULL,
+	"1", -1, Tk_Offset(TkTextTag, undo), 0, 0, 0},
+    {TK_OPTION_STRING_TABLE, "-wrap", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextTag, wrapMode), TK_OPTION_NULL_OK, wrapStrings, 0},
+    {TK_OPTION_END, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0}
+};
+
+DEBUG_ALLOC(extern unsigned tkTextCountNewTag);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroyTag);
+DEBUG_ALLOC(extern unsigned tkTextCountNewUndoToken);
+DEBUG_ALLOC(extern unsigned tkTextCountDestroyUndoToken);
+
+/*
+ * Forward declarations for functions defined later in this file:
+ */
+
+static bool		ChangeTagPriority(TkSharedText *sharedTextPtr, TkTextTag *tagPtr,
+			    unsigned newPriority, bool undo);
+static void		TagBindEvent(TkText *textPtr, XEvent *eventPtr,
+			    unsigned numTags, TkTextTag **tagArrayPtr);
+static bool		TagAddRemove(TkText *textPtr, const TkTextIndex *index1Ptr,
+			    const TkTextIndex *index2Ptr, TkTextTag *tagPtr, bool add);
+static void		FindTags(Tcl_Interp *interp, TkText *textPtr, const TkTextSegment *segPtr,
+			    bool discardSelection);
+static void		AppendTags(Tcl_Interp *interp, unsigned numTags, TkTextTag **tagArray);
+static void		GrabSelection(TkText *textPtr, const TkTextTag *tagPtr, bool add);
+static TkTextTag *	FindTag(Tcl_Interp *interp, const TkText *textPtr, Tcl_Obj *tagName);
+static int		EnumerateTags(Tcl_Interp *interp, TkText *textPtr, int objc,
+			    Tcl_Obj *const *objv);
+
+/*
+ * We need some private undo/redo stuff.
+ */
+
+static void UndoChangeTagPriorityPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static Tcl_Obj *UndoChangeTagPriorityGetCommand(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *UndoChangeTagPriorityInspect(const TkSharedText *, const TkTextUndoToken *);
+
+static const Tk_UndoType undoTokenTagPriorityType = {
+    TK_TEXT_UNDO_TAG_PRIORITY,		/* action */
+    UndoChangeTagPriorityGetCommand,	/* commandProc */
+    UndoChangeTagPriorityPerform,	/* undoProc */
+    NULL,				/* destroyProc */
+    NULL,				/* rangeProc */
+    UndoChangeTagPriorityInspect	/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenTagPriorityType = {
+    TK_TEXT_REDO_TAG_PRIORITY,		/* action */
+    UndoChangeTagPriorityGetCommand,	/* commandProc */
+    UndoChangeTagPriorityPerform,	/* undoProc */
+    NULL,				/* destroyProc */
+    NULL,				/* rangeProc */
+    UndoChangeTagPriorityInspect	/* inspectProc */
+};
+
+typedef struct UndoTokenTagPriority {
+    const Tk_UndoType *undoType;
+    TkTextTag *tagPtr;
+    uint32_t priority;
+} UndoTokenTagPriority;
+
+static Tcl_Obj *
+UndoChangeTagPriorityGetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenTagPriority *token = (const UndoTokenTagPriority *) item;
+    Tcl_Obj *objPtr = Tcl_NewObj();
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("tag", -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("priority", -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(token->tagPtr->name, -1));
+    return objPtr;
+}
+
+static Tcl_Obj *
+UndoChangeTagPriorityInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenTagPriority *token = (const UndoTokenTagPriority *) item;
+    Tcl_Obj *objPtr = UndoChangeTagPriorityGetCommand(sharedTextPtr, item);
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj(token->priority));
+    return objPtr;
+}
+
+static void
+UndoChangeTagPriorityPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    UndoTokenTagPriority *token = (UndoTokenTagPriority *) undoInfo->token;
+    unsigned oldPriority = token->tagPtr->priority;
+
+    ChangeTagPriority(sharedTextPtr, token->tagPtr, token->priority, true);
+
+    if (redoInfo) {
+	redoInfo->token = undoInfo->token;
+	redoInfo->token->undoType = &redoTokenTagPriorityType;
+	token->priority = oldPriority;
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextTagCmd --
+ *
+ *	This function is invoked to process the "tag" options of the widget
+ *	command for text widgets. See the user documentation for details on
+ *	what it does.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+int
+TkTextTagCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already parsed this command
+    				 * enough to know that objv[1] is "tag". */
+{
+    static const char *const tagOptionStrings[] = {
+	"add", "bind", "cget", "clear", "configure", "delete", "findnext", "findprev",
+	"getrange", "lower", "names", "nextrange", "prevrange", "raise", "ranges",
+	"remove", NULL
+    };
+    enum tagOptions {
+	TAG_ADD, TAG_BIND, TAG_CGET, TAG_CLEAR, TAG_CONFIGURE, TAG_DELETE, TAG_FINDNEXT, TAG_FINDPREV,
+	TAG_GETRANGE, TAG_LOWER, TAG_NAMES, TAG_NEXTRANGE, TAG_PREVRANGE, TAG_RAISE, TAG_RANGES,
+	TAG_REMOVE
+    };
+    int optionIndex, i;
+    TkTextTag *tagPtr;
+    TkTextIndex index1, index2;
+    TkSharedText *sharedTextPtr;
+
+    if (objc < 3) {
+	Tcl_WrongNumArgs(interp, 2, objv, "option ?arg arg ...?");
+	return TCL_ERROR;
+    }
+    if (Tcl_GetIndexFromObjStruct(interp, objv[2], tagOptionStrings, sizeof(char *),
+	    "tag option", 0, &optionIndex) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    sharedTextPtr = textPtr->sharedTextPtr;
+
+    switch ((enum tagOptions)optionIndex) {
+    case TAG_ADD:
+    case TAG_REMOVE: {
+	bool addTag;
+	bool anyChanges = false;
+
+	addTag = ((enum tagOptions) optionIndex) == TAG_ADD;
+	if (objc < 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName index1 ?index2 index1 index2 ...?");
+	    return TCL_ERROR;
+	}
+	tagPtr = TkTextCreateTag(textPtr, Tcl_GetString(objv[3]), NULL);
+	if (tagPtr->elide) {
+	    /*
+	     * Indices are potentially obsolete after adding or removing
+	     * elided character ranges, especially indices having "display"
+	     * or "any" submodifier, therefore increase the epoch.
+	     */
+	    TkBTreeIncrEpoch(sharedTextPtr->tree);
+	}
+	for (i = 4; i < objc; i += 2) {
+	    if (!TkTextGetIndexFromObj(interp, textPtr, objv[i], &index1)) {
+		return TCL_ERROR;
+	    }
+	    if (objc > i + 1) {
+		if (!TkTextGetIndexFromObj(interp, textPtr, objv[i + 1], &index2)) {
+		    return TCL_ERROR;
+		}
+		if (TkTextIndexCompare(&index1, &index2) >= 0) {
+		    continue;
+		}
+	    } else {
+		TkTextIndexForwChars(textPtr, &index1, 1, &index2, COUNT_INDICES);
+	    }
+	    if (TagAddRemove(textPtr, &index1, &index2, tagPtr, addTag)) {
+		anyChanges = true;
+	    }
+	}
+	if (anyChanges) {
+	    if (tagPtr == textPtr->selTagPtr) {
+		GrabSelection(textPtr, tagPtr, addTag);
+	    }
+	    if (tagPtr->undo) {
+		TkTextUpdateAlteredFlag(sharedTextPtr);
+	    }
+	    /* still need to trigger enter/leave events on tags that have changed */
+	    TkTextEventuallyRepick(textPtr);
+	}
+	break;
+    }
+    case TAG_BIND:
+	if (objc < 4 || objc > 6) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName ?sequence? ?command?");
+	    return TCL_ERROR;
+	}
+	tagPtr = TkTextCreateTag(textPtr, Tcl_GetString(objv[3]), NULL);
+	return TkTextBindEvent(interp, objc - 4, objv + 4, sharedTextPtr,
+		&sharedTextPtr->tagBindingTable, tagPtr->name);
+    case TAG_CGET:
+	if (objc != 5) {
+	    Tcl_WrongNumArgs(interp, 1, objv, "tag cget tagName option");
+	    return TCL_ERROR;
+	} else {
+	    Tcl_Obj *objPtr;
+
+	    if (!(tagPtr = FindTag(interp, textPtr, objv[3]))) {
+		return TCL_ERROR;
+	    }
+	    objPtr = Tk_GetOptionValue(interp, (char *) tagPtr,
+		    tagPtr->optionTable, objv[4], textPtr->tkwin);
+	    if (!objPtr) {
+		return TCL_ERROR;
+	    }
+	    Tcl_SetObjResult(interp, objPtr);
+	    return TCL_OK;
+	}
+	break;
+    case TAG_CLEAR: {
+	bool discardSelection;
+	unsigned epoch, countTags;
+	TkTextTag **arrayPtr;
+	bool anyChanges;
+	int arg;
+
+	if (objc < 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "?-discardselection? index1 ?index2 index1 index2 ...?");
+	    return TCL_ERROR;
+	}
+
+	arg = 3;
+
+	if (objc > 4 && *Tcl_GetString(objv[arg]) == '-') {
+	    if (strcmp(Tcl_GetString(objv[arg++]), "-discardselection") == 0) {
+		discardSelection = true;
+	    } else {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+			"bad option \"%s\": must be -discardselection", Tcl_GetString(objv[3])));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "BAD_OPTION", NULL);
+		return TCL_ERROR;
+	    }
+	}
+
+	discardSelection = false;
+	epoch = TkBTreeEpoch(sharedTextPtr->tree);
+	arrayPtr = malloc(sharedTextPtr->numEnabledTags * sizeof(TkTextTag *));
+	countTags = 0;
+	anyChanges = false;
+
+	for (i = arg; i < objc; i += 2) {
+	    TkTextIndex index1, index2;
+	    TkTextTag *tagPtr;
+
+	    if (!TkTextGetIndexFromObj(interp, textPtr, objv[i], &index1)) {
+		return TCL_ERROR;
+	    }
+
+	    if (objc > i + 1) {
+		if (!TkTextGetIndexFromObj(interp, textPtr, objv[i + 1], &index2)) {
+		    return TCL_ERROR;
+		}
+		if (TkTextIndexCompare(&index1, &index2) >= 0) {
+		    continue;
+		}
+	    } else {
+		TkTextIndexForwChars(textPtr, &index1, 1, &index2, COUNT_INDICES);
+	    }
+
+	    if (!discardSelection) {
+		TkTextClearSelection(sharedTextPtr, &index1, &index2);
+	    }
+
+	    if ((tagPtr = TkTextClearTags(sharedTextPtr, textPtr, &index1, &index2, discardSelection))) {
+		for ( ; tagPtr; tagPtr = tagPtr->nextPtr) {
+		    if (tagPtr->epoch != epoch) {
+			tagPtr->epoch = epoch;
+			arrayPtr[countTags++] = tagPtr;
+
+			if (tagPtr == textPtr->selTagPtr) {
+			    GrabSelection(textPtr, tagPtr, false);
+			}
+			if (tagPtr->undo) {
+			    anyChanges = true;
+			}
+		    }
+		}
+	    }
+	}
+
+	if (anyChanges) {
+	    TkTextUpdateAlteredFlag(sharedTextPtr);
+	}
+	AppendTags(interp, countTags, arrayPtr);
+	free(arrayPtr);
+	break;
+    }
+    case TAG_CONFIGURE:
+	if (objc < 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName ?option? ?value? ?option value ...?");
+	    return TCL_ERROR;
+	}
+	return TkConfigureTag(interp, textPtr, Tcl_GetString(objv[3]), objc - 4, objv + 4);
+    case TAG_DELETE: {
+	Tcl_HashEntry *hPtr;
+	bool anyChanges = false;
+
+	if (objc < 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName ?tagName ...?");
+	    return TCL_ERROR;
+	}
+	for (i = 3; i < objc; i++) {
+	    if (!(hPtr = Tcl_FindHashEntry(&sharedTextPtr->tagTable, Tcl_GetString(objv[i])))) {
+		/*
+		 * Either this tag doesn't exist or it's the 'sel' tag (which is not in
+		 * the hash table). Either way we don't want to delete it.
+		 */
+
+		continue;
+	    }
+	    tagPtr = Tcl_GetHashValue(hPtr);
+	    assert(tagPtr != textPtr->selTagPtr);
+	    if (TkTextDeleteTag(textPtr, tagPtr, hPtr) && tagPtr->undo) {
+		anyChanges = true;
+	    }
+	}
+	if (anyChanges) {
+	    TkTextUpdateAlteredFlag(sharedTextPtr);
+	}
+	break;
+    }
+    case TAG_FINDNEXT: {
+	TkTextSegment *segPtr;
+	const TkBitField *selTags = NULL;
+
+	if (objc != 4 && objc != 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "?-discardselection? index");
+	    return TCL_ERROR;
+	}
+	if (objc == 5) {
+	    if (strcmp(Tcl_GetString(objv[3]), "-discardselection") == 0) {
+		selTags = sharedTextPtr->selectionTags;
+	    } else {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+			"bad option \"%s\": must be -discardselection", Tcl_GetString(objv[3])));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "BAD_OPTION", NULL);
+		return TCL_ERROR;
+	    }
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[objc - 1], &index1)) {
+	    return TCL_ERROR;
+	}
+	TkTextIndexSetupToEndOfText(&index2, textPtr, sharedTextPtr->tree);
+	if ((segPtr = TkBTreeFindNextTagged(&index1, &index2, selTags))) {
+	    TkTextIndex index;
+	    char buf[TK_POS_CHARS];
+
+	    TkTextIndexClear(&index, textPtr);
+	    TkTextIndexSetSegment(&index, segPtr);
+	    TkTextPrintIndex(textPtr, &index, buf);
+	    Tcl_AppendElement(interp, buf);
+	}
+	break;
+    }
+    case TAG_FINDPREV: {
+	bool discardSelection = false;
+	TkTextSegment *segPtr;
+
+	if (objc != 4 && objc != 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "-discardselection? index");
+	    return TCL_ERROR;
+	}
+	if (objc == 5) {
+	    if (strcmp(Tcl_GetString(objv[3]), "-discardselection") == 0) {
+		discardSelection = true;
+	    } else {
+		Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+			"bad option \"%s\": must be -discardselection", Tcl_GetString(objv[3])));
+		Tcl_SetErrorCode(interp, "TK", "TEXT", "BAD_OPTION", NULL);
+		return TCL_ERROR;
+	    }
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[objc - 1], &index1)) {
+	    return TCL_ERROR;
+	}
+	TkTextIndexSetupToStartOfText(&index2, textPtr, sharedTextPtr->tree);
+	if ((segPtr = TkBTreeFindPrevTagged(&index1, &index2, discardSelection))) {
+	    TkTextIndex index;
+	    char buf[TK_POS_CHARS];
+
+	    TkTextIndexClear(&index, textPtr);
+	    TkTextIndexSetSegment(&index, segPtr);
+	    TkTextPrintIndex(textPtr, &index, buf);
+	    Tcl_AppendElement(interp, buf);
+	}
+	break;
+    }
+    case TAG_GETRANGE: {
+	TkTextIndex index1, index2;
+
+	if (objc != 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName index");
+	    return TCL_ERROR;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[4], &index1)) {
+	    return TCL_ERROR;
+	}
+	if (!(tagPtr = FindTag(interp, textPtr, objv[3]))) {
+	    return TCL_ERROR;
+	}
+	if (tagPtr->rootPtr && TkBTreeCharTagged(&index1, tagPtr)) {
+	    char buf[2][TK_POS_CHARS];
+	    TkTextSearch tSearch;
+
+	    TkTextIndexForwChars(textPtr, &index1, 1, &index1, COUNT_INDICES);
+	    TkTextIndexSetupToEndOfText(&index2, textPtr, sharedTextPtr->tree);
+	    TkBTreeStartSearch(&index1, &index2, tagPtr, &tSearch, SEARCH_EITHER_TAGON_TAGOFF);
+	    TkBTreeNextTag(&tSearch);
+	    assert(tSearch.segPtr); /* last search must not fail */
+	    assert(!tSearch.tagon); /* must be tagoff */
+	    TkTextPrintIndex(textPtr, &tSearch.curIndex, buf[1]);
+
+	    TkTextIndexSetupToStartOfText(&index2, textPtr, sharedTextPtr->tree);
+	    TkBTreeStartSearchBack(&index1, &index2, tagPtr, &tSearch, SEARCH_NEXT_TAGON);
+	    TkBTreePrevTag(&tSearch);
+	    assert(tSearch.segPtr); /* last search must not fail */
+	    TkTextPrintIndex(textPtr, &tSearch.curIndex, buf[0]);
+
+	    Tcl_AppendElement(interp, buf[0]);
+	    Tcl_AppendElement(interp, buf[1]);
+	}
+	break;
+    }
+    case TAG_LOWER: {
+	TkTextTag *tagPtr2;
+	unsigned newPriority;
+
+	if (objc != 4 && objc != 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName ?belowThis?");
+	    return TCL_ERROR;
+	}
+	if (!(tagPtr = FindTag(interp, textPtr, objv[3]))) {
+	    return TCL_ERROR;
+	}
+	if (objc == 5) {
+	    if (!(tagPtr2 = FindTag(interp, textPtr, objv[4]))) {
+		return TCL_ERROR;
+	    }
+	    newPriority = tagPtr2->priority;
+	    if (tagPtr->priority < tagPtr2->priority) {
+		newPriority -= 1;
+	    }
+	} else {
+	    newPriority = 0;
+	}
+	if (ChangeTagPriority(sharedTextPtr, tagPtr, newPriority, true) && tagPtr->rootPtr) {
+	    if (tagPtr->undo) {
+		TkTextUpdateAlteredFlag(sharedTextPtr);
+	    }
+
+	    /*
+	     * If this is the 'sel' tag, then we don't actually need to call this for all peers.
+	     *
+	     * TODO: The current implementation is sloppy, we need only to refresh the ranges
+	     * with actual changes, and not all the ranges of this tag.
+	     */
+
+	    TkTextRedrawTag(tagPtr == textPtr->selTagPtr ? NULL : sharedTextPtr,
+		    textPtr, NULL, NULL, tagPtr, false);
+	}
+	break;
+    }
+    case TAG_NAMES:
+    	return EnumerateTags(interp, textPtr, objc, objv);
+	/* not reached */
+    case TAG_NEXTRANGE: {
+	TkTextSearch tSearch;
+	char position[TK_POS_CHARS];
+	Tcl_Obj *resultObj;
+
+	if (objc != 5 && objc != 6) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName index1 ?index2?");
+	    return TCL_ERROR;
+	}
+	if (!(tagPtr = FindTag(NULL, textPtr, objv[3])) || !tagPtr->rootPtr) {
+	    return TCL_OK;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[4], &index1)) {
+	    return TCL_ERROR;
+	}
+	if (objc == 5) {
+	    TkTextIndexSetupToEndOfText(&index2, textPtr, sharedTextPtr->tree);
+	} else if (!TkTextGetIndexFromObj(interp, textPtr, objv[5], &index2)) {
+	    return TCL_ERROR;
+	}
+
+	TkBTreeStartSearch(&index1, &index2, tagPtr, &tSearch, SEARCH_NEXT_TAGON);
+	if (TkBTreeNextTag(&tSearch)) {
+	    assert(TkTextIndexCompare(&tSearch.curIndex, &index1) >= 0);
+	    assert(TkTextIndexCompare(&tSearch.curIndex, &index2) < 0);
+	    if (TkTextIndexIsEqual(&index1, &tSearch.curIndex)) {
+		TkTextIndex oneBack;
+
+		/*
+		 * The first character is tagged. See if there is an on-toggle just
+		 * before the character. If not, then skip to the end of this tagged range.
+		 */
+
+		if (TkTextIndexBackChars(textPtr, &index1, 1, &oneBack, COUNT_DISPLAY_INDICES)
+			&& TkBTreeCharTagged(&oneBack, tagPtr)
+			&& (!TkBTreeNextTag(&tSearch) || !TkBTreeNextTag(&tSearch))) {
+		    return TCL_OK;
+		}
+		assert(TkTextIndexCompare(&tSearch.curIndex, &index2) < 0);
+	    }
+	    resultObj = Tcl_NewObj();
+	    TkTextPrintIndex(textPtr, &tSearch.curIndex, position);
+	    Tcl_ListObjAppendElement(NULL, resultObj, Tcl_NewStringObj(position, -1));
+	    TkBTreeLiftSearch(&tSearch); /* we need tagoff even if outside of the range */
+	    TkBTreeNextTag(&tSearch);    /* cannot fail */
+	    assert(tSearch.segPtr);      /* proof last assumption */
+	    TkTextPrintIndex(textPtr, &tSearch.curIndex, position);
+	    Tcl_ListObjAppendElement(NULL, resultObj, Tcl_NewStringObj(position, -1));
+	    Tcl_SetObjResult(interp, resultObj);
+	}
+	break;
+    }
+    case TAG_PREVRANGE: {
+	TkTextSearch tSearch;
+	char position1[TK_POS_CHARS];
+	char position2[TK_POS_CHARS];
+	Tcl_Obj *resultObj;
+
+	if (objc != 5 && objc != 6) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName index1 ?index2?");
+	    return TCL_ERROR;
+	}
+	if (!(tagPtr = FindTag(NULL, textPtr, objv[3])) || !tagPtr->rootPtr) {
+	    return TCL_OK;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[4], &index1)) {
+	    return TCL_ERROR;
+	}
+	if (objc == 5) {
+	    TkTextIndexSetupToStartOfText(&index2, textPtr, sharedTextPtr->tree);
+	} else if (!TkTextGetIndexFromObj(interp, textPtr, objv[5], &index2)) {
+	    return TCL_ERROR;
+	}
+
+	TkBTreeStartSearchBack(&index1, &index2, tagPtr, &tSearch, SEARCH_EITHER_TAGON_TAGOFF);
+
+	if (TkBTreePrevTag(&tSearch)) {
+	    assert(TkTextIndexCompare(&tSearch.curIndex, &index1) < 0);
+	    assert(TkTextIndexCompare(&tSearch.curIndex, &index2) >= 0);
+	    index1 = tSearch.curIndex;
+	    if (tSearch.tagon) {
+		TkTextIndex end;
+
+		/*
+		 * We've found tagon. Now search forward for tagoff.
+		 */
+
+		TkTextPrintIndex(textPtr, &index1, position1);
+		TkTextIndexSetupToEndOfText(&end, textPtr, sharedTextPtr->tree);
+		TkTextIndexForwChars(textPtr, &index1, 1, &index1, COUNT_INDICES);
+		TkBTreeStartSearch(&index1, &end, tagPtr, &tSearch, SEARCH_EITHER_TAGON_TAGOFF);
+		TkBTreeNextTag(&tSearch); /* cannot fail */
+		assert(tSearch.segPtr);   /* proof last assumption */
+		assert(!tSearch.tagon);   /* must be tagoff */
+		TkTextPrintIndex(textPtr, &tSearch.curIndex, position2);
+	    } else {
+		/*
+		 * We've found tagoff. Now search backwards for tagon.
+		 */
+
+		if (!TkBTreePrevTag(&tSearch)) {
+		    return TCL_OK;
+		}
+		assert(TkTextIndexCompare(&tSearch.curIndex, &index2) >= 0);
+		TkTextPrintIndex(textPtr, &tSearch.curIndex, position1);
+		TkTextPrintIndex(textPtr, &index1, position2);
+	    }
+	    resultObj = Tcl_NewObj();
+	    Tcl_ListObjAppendElement(NULL, resultObj, Tcl_NewStringObj(position1, -1));
+	    Tcl_ListObjAppendElement(NULL, resultObj, Tcl_NewStringObj(position2, -1));
+	    Tcl_SetObjResult(interp, resultObj);
+	}
+	break;
+    }
+    case TAG_RAISE: {
+	TkTextTag *tagPtr2;
+	unsigned newPriority;
+
+	if (objc != 4 && objc != 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName ?aboveThis?");
+	    return TCL_ERROR;
+	}
+	if (!(tagPtr = FindTag(interp, textPtr, objv[3]))) {
+	    return TCL_ERROR;
+	}
+	if (objc == 5) {
+	    if (!(tagPtr2 = FindTag(interp, textPtr, objv[4]))) {
+		return TCL_ERROR;
+	    }
+	    newPriority = tagPtr2->priority;
+	    if (tagPtr->priority > tagPtr2->priority) {
+		newPriority += 1;
+	    }
+	} else {
+	    newPriority = sharedTextPtr->numEnabledTags - 1;
+	}
+	if (ChangeTagPriority(sharedTextPtr, tagPtr, newPriority, true) && tagPtr->rootPtr) {
+	    if (tagPtr->undo) {
+		TkTextUpdateAlteredFlag(sharedTextPtr);
+	    }
+
+	    /*
+	     * If this is the 'sel' tag, then we don't actually need to call this for all peers.
+	     *
+	     * TODO: The current implementation is sloppy, we need only to refresh the ranges
+	     * with actual changes, and not all the ranges of this tag.
+	     */
+
+	    TkTextRedrawTag(tagPtr == textPtr->selTagPtr ? NULL : sharedTextPtr,
+		    textPtr, NULL, NULL, tagPtr, false);
+	}
+	break;
+    }
+    case TAG_RANGES: {
+	TkTextIndex first, last;
+	TkTextSearch tSearch;
+	Tcl_Obj *listObj = Tcl_NewObj();
+	DEBUG(bool found = false);
+
+	if (objc != 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "tagName");
+	    return TCL_ERROR;
+	}
+	if ((tagPtr = FindTag(NULL, textPtr, objv[3])) && tagPtr->rootPtr) {
+	    TkTextIndexSetupToStartOfText(&first, textPtr, sharedTextPtr->tree);
+	    TkTextIndexSetupToEndOfText(&last, textPtr, sharedTextPtr->tree);
+	    TkBTreeStartSearch(&first, &last, tagPtr, &tSearch, SEARCH_NEXT_TAGON);
+	    while (TkBTreeNextTag(&tSearch)) {
+		Tcl_ListObjAppendElement(NULL, listObj, TkTextNewIndexObj(&tSearch.curIndex));
+		DEBUG(found = true);
+	    }
+	    assert(!found || !tSearch.tagon); /* search must find end of text */
+	    Tcl_SetObjResult(interp, listObj);
+	}
+	break;
+    }
+    }
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextClearTags --
+ *
+ *	Clear the selection in specified range.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	See TkBTreeTag and TkTextSelectionEvent for side effects.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextClearSelection(
+    TkSharedText *sharedTextPtr,
+    const TkTextIndex *indexPtr1,
+    const TkTextIndex *indexPtr2)
+{
+    TkText *textPtr;
+
+    for (textPtr = sharedTextPtr->peers; textPtr; textPtr = textPtr->next) {
+	if (TkBTreeTag(sharedTextPtr, textPtr, indexPtr1, indexPtr2, textPtr->selTagPtr,
+		false, NULL, TkTextRedrawTag)) {
+	    if (!textPtr->abortSelections) {
+		/*
+		 * Send an event that the selection changed. This is equivalent to:
+		 *	 event generate $textWidget <<Selection>>
+		 */
+
+		TkTextSelectionEvent(textPtr); /* <<Selection>> will be received after deletion */
+		textPtr->abortSelections = true;
+	    }
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextClearTags --
+ *
+ *	Turn all tags off inside a given range.
+ *
+ * Results:
+ *	Whether any tag has been removed.
+ *
+ * Side effects:
+ *	See TkBTreeClearTags and TkTextPushUndoToken for side effects.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextTag *
+TkTextClearTags(
+    TkSharedText *sharedTextPtr,
+    TkText *textPtr,
+    const TkTextIndex *indexPtr1,
+    const TkTextIndex *indexPtr2,
+    bool discardSelection)
+{
+    TkTextTag *tagPtr;
+    TkTextUndoInfo undoInfo;
+    TkTextUndoInfo *undoInfoPtr;
+
+    undoInfoPtr = TkTextUndoStackIsFull(sharedTextPtr->undoStack) ? NULL : &undoInfo;
+    tagPtr = TkBTreeClearTags(sharedTextPtr, textPtr, indexPtr1, indexPtr2, undoInfoPtr,
+	    discardSelection, TkTextRedrawTag);
+    if (tagPtr && undoInfoPtr && undoInfo.token) {
+	TkTextPushUndoToken(sharedTextPtr, undoInfo.token, undoInfo.byteSize);
+    }
+    return tagPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextUpdateTagDisplayFlags --
+ *
+ *	Update the display flags 'affectsDisplay' and 'affectsDisplayGeometry',
+ *	according to the current attributes of the given tag.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The flags 'affectsDisplay' and 'affectsDisplayGeometry' may change.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextUpdateTagDisplayFlags(
+    TkTextTag *tagPtr)
+{
+    tagPtr->affectsDisplay = false;
+    tagPtr->affectsDisplayGeometry = false;
+
+    if (tagPtr->elideString
+	    || tagPtr->tkfont != None
+	    || tagPtr->justifyString
+	    || tagPtr->lMargin1String
+	    || tagPtr->lMargin2String
+	    || tagPtr->offsetString
+	    || tagPtr->rMarginString
+	    || tagPtr->spacing1String
+	    || tagPtr->spacing2String
+	    || tagPtr->spacing3String
+	    || tagPtr->tabStringPtr
+	    || tagPtr->tabStyle != TK_TEXT_TABSTYLE_NONE
+	    || tagPtr->wrapMode != TEXT_WRAPMODE_NULL) {
+	tagPtr->affectsDisplay = true;
+	tagPtr->affectsDisplayGeometry = true;
+    } else if (tagPtr->border
+	    || tagPtr->selBorder
+	    || tagPtr->reliefString
+	    || tagPtr->bgStipple != None
+	    || tagPtr->indentBgString
+	    || tagPtr->fgColor
+	    || tagPtr->selFgColor
+	    || tagPtr->fgStipple != None
+	    || tagPtr->eolColor
+	    || tagPtr->hyphenColor
+	    || tagPtr->overstrikeString
+	    || tagPtr->overstrikeColor
+	    || tagPtr->underlineString
+	    || tagPtr->underlineColor
+	    || tagPtr->lMarginColor
+	    || tagPtr->rMarginColor) {
+	tagPtr->affectsDisplay = true;
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkConfigureTag --
+ *
+ *	This function is called to process an objv/objc list, plus the Tk
+ *	option database, in order to configure (or reconfigure) a text tag.
+ *
+ * Results:
+ *	Any of the standard Tcl return values.
+ *
+ * Side effects:
+ *	A new tag will be created if required, otherwise an existing tag
+ *	will be modified.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkConfigureTag(
+    Tcl_Interp *interp,		/* Current interpreter. */
+    TkText *textPtr,		/* Info about overall widget. */
+    char const *tagName,	/* Name of affected tag. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Remaining argument objects. */
+{
+    int mask = 0;
+    bool newTag;
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    TkTextTag *tagPtr = TkTextCreateTag(textPtr, tagName, &newTag);
+    const char *elideString = tagPtr->elideString;
+    bool elide = tagPtr->elide;
+    bool undo = tagPtr->undo;
+    bool affectsDisplay = tagPtr->affectsDisplay;
+    bool affectsLineHeight = false;
+
+    if (objc <= 1) {
+	Tcl_Obj *objPtr = Tk_GetOptionInfo(interp, (char *) tagPtr, tagPtr->optionTable,
+		objc == 1 ? objv[0] : NULL, textPtr->tkwin);
+
+	if (!objPtr) {
+	    return TCL_ERROR;
+	}
+	Tcl_SetObjResult(interp, objPtr);
+	return TCL_OK;
+    }
+
+    if (Tk_SetOptions(interp, (char *) tagPtr, tagPtr->optionTable,
+	    objc, objv, textPtr->tkwin, NULL, &mask) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+#if SUPPORT_DEPRECATED_TAG_OPTIONS
+
+    if (mask & (TK_TEXT_DEPRECATED_OVERSTRIKE_FG|TK_TEXT_DEPRECATED_UNDERLINE_FG)) {
+	static bool warnAboutOverstrikeFg = true;
+	static bool warnAboutUnderlineFg = true;
+
+	if (mask & TK_TEXT_DEPRECATED_OVERSTRIKE_FG) {
+	    if (warnAboutOverstrikeFg) {
+		fprintf(stderr, "Tag option \"-overstrikefg\" is deprecated, please use option "
+			"\"-overstrikecolor\"\n");
+		warnAboutOverstrikeFg = false;
+	    }
+	}
+	if (mask & TK_TEXT_DEPRECATED_UNDERLINE_FG) {
+	    if (warnAboutUnderlineFg) {
+		fprintf(stderr, "Tag option \"-underlinefg\" is deprecated, please use option "
+			"\"-underlinecolor\"\n");
+		warnAboutUnderlineFg = false;
+	    }
+	}
+    }
+
+#endif /* SUPPORT_DEPRECATED_TAG_OPTIONS */
+
+    /*
+      Some of the configuration options, like -underline and -justify, require
+     * additional translation (this is needed because we need to distinguish a
+     * particular value of an option from "unspecified").
+     */
+
+    if (tagPtr->borderWidth < 0) {
+	tagPtr->borderWidth = 0;
+    }
+    if (tagPtr->langPtr) {
+	if (!TkTextTestLangCode(interp, tagPtr->langPtr)) {
+	    return TCL_ERROR;
+	}
+	memcpy(tagPtr->lang, Tcl_GetString(tagPtr->langPtr), 3);
+    } else {
+	memset(tagPtr->lang, 0, 3);
+    }
+    if (tagPtr->indentBgString) {
+	if (Tcl_GetBoolean(interp, tagPtr->indentBgString, (int *) &tagPtr->indentBg) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+    }
+    if (tagPtr->reliefString) {
+	if (Tk_GetRelief(interp, tagPtr->reliefString, &tagPtr->relief) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+    }
+    if (tagPtr->justifyString) {
+	const char *identifier = NULL;
+        int j = -1;
+
+	/*
+	 * Tk_Justify only knows "left", "right", and "center", so we have to parse by ourself.
+	 */
+
+        switch (*tagPtr->justifyString) {
+	case 'l': identifier = "left";   j = TK_TEXT_JUSTIFY_LEFT;   break;
+	case 'r': identifier = "right";  j = TK_TEXT_JUSTIFY_RIGHT;  break;
+	case 'f': identifier = "full";   j = TK_TEXT_JUSTIFY_FULL;   break;
+	case 'c': identifier = "center"; j = TK_TEXT_JUSTIFY_CENTER; break;
+        }
+        if (j == -1 || strcmp(tagPtr->justifyString, identifier) != 0) {
+            Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+                    "bad justification \"%s\": must be left, right, full, or center",
+                    tagPtr->justifyString));
+            Tcl_SetErrorCode(interp, "TK", "VALUE", "JUSTIFY", NULL);
+	    return TCL_ERROR;
+	}
+        tagPtr->justify = j;
+    }
+    if (tagPtr->lMargin1String) {
+	if (Tk_GetPixels(interp, textPtr->tkwin,
+		tagPtr->lMargin1String, &tagPtr->lMargin1) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+    }
+    if (tagPtr->lMargin2String) {
+	if (Tk_GetPixels(interp, textPtr->tkwin,
+		tagPtr->lMargin2String, &tagPtr->lMargin2) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+    }
+    if (tagPtr->offsetString) {
+	if (Tk_GetPixels(interp, textPtr->tkwin, tagPtr->offsetString,
+		&tagPtr->offset) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+    }
+    if (tagPtr->overstrikeString) {
+	if (Tcl_GetBoolean(interp, tagPtr->overstrikeString, (int *) &tagPtr->overstrike) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+    }
+    if (tagPtr->rMarginString) {
+	if (Tk_GetPixels(interp, textPtr->tkwin,
+		tagPtr->rMarginString, &tagPtr->rMargin) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+    }
+    if (tagPtr->spacing1String) {
+	if (Tk_GetPixels(interp, textPtr->tkwin,
+		tagPtr->spacing1String, &tagPtr->spacing1) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	if (tagPtr->spacing1 < 0) {
+	    tagPtr->spacing1 = 0;
+	}
+    }
+    if (tagPtr->spacing2String) {
+	if (Tk_GetPixels(interp, textPtr->tkwin,
+		tagPtr->spacing2String, &tagPtr->spacing2) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	if (tagPtr->spacing2 < 0) {
+	    tagPtr->spacing2 = 0;
+	}
+    }
+    if (tagPtr->spacing3String) {
+	if (Tk_GetPixels(interp, textPtr->tkwin,
+		tagPtr->spacing3String, &tagPtr->spacing3) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	if (tagPtr->spacing3 < 0) {
+	    tagPtr->spacing3 = 0;
+	}
+    }
+    if (tagPtr->tabArrayPtr) {
+	free(tagPtr->tabArrayPtr);
+	tagPtr->tabArrayPtr = NULL;
+    }
+    if (tagPtr->tabStringPtr) {
+	if (!(tagPtr->tabArrayPtr = TkTextGetTabs(interp, textPtr, tagPtr->tabStringPtr))) {
+	    return TCL_ERROR;
+	}
+    }
+    if (tagPtr->hyphenRulesPtr) {
+	int oldHyphenRules = tagPtr->hyphenRules;
+
+	if (TkTextParseHyphenRules(textPtr, tagPtr->hyphenRulesPtr, &tagPtr->hyphenRules) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	if (oldHyphenRules != tagPtr->hyphenRules && textPtr->hyphenate) {
+	    affectsDisplay = true;
+	}
+    }
+    if (tagPtr->underlineString) {
+	if (Tcl_GetBoolean(interp, tagPtr->underlineString, (int *) &tagPtr->underline) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+    }
+    if (tagPtr->elideString) {
+	if (!elideString) {
+	    sharedTextPtr->numElisionTags += 1;
+	}
+
+	if (TkBitTest(sharedTextPtr->selectionTags, tagPtr->index)) {
+	    /*
+	     * It's not allowed to set the elide attribute of the special selection tag
+	     * to 'true' (this would cause errors, because this case is not implemented).
+	     */
+
+	    free(tagPtr->elideString);
+	    tagPtr->elideString = NULL;
+	    tagPtr->elide = false;
+            Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+                    "not allowed to set elide option of selection tag \"%s\"", tagPtr->name));
+            Tcl_SetErrorCode(interp, "TK", "VALUE", "ELIDE", NULL);
+	    return TCL_ERROR;
+	}
+
+	if (Tcl_GetBoolean(interp, tagPtr->elideString, (int *) &tagPtr->elide) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+
+	/*
+	 * Indices are potentially obsolete after changing -elide,
+	 * especially those computed with "display" or "any"
+	 * submodifier, therefore increase the epoch.
+	 */
+
+	TkBTreeIncrEpoch(sharedTextPtr->tree);
+    } else {
+	if (elideString) {
+	    sharedTextPtr->numElisionTags -= 1;
+	}
+	tagPtr->elide = false;
+    }
+    if (tagPtr->undo != undo) {
+	TkBitPut(sharedTextPtr->dontUndoTags, tagPtr->index, !tagPtr->undo);
+    }
+
+    /*
+     * If the "sel" tag was changed, be sure to mirror information
+     * from the tag back into the text widget record. NOTE: we don't
+     * have to free up information in the widget record before
+     * overwriting it, because it was mirrored in the tag and hence
+     * freed when the tag field was overwritten.
+     */
+
+    if (tagPtr == textPtr->selTagPtr) {
+	textPtr->selBorder = tagPtr->selBorder ? tagPtr->selBorder : tagPtr->border;
+	textPtr->selBorderWidth = tagPtr->borderWidth;
+	textPtr->selBorderWidthPtr = tagPtr->borderWidthPtr;
+	textPtr->selFgColorPtr = tagPtr->selFgColor ? tagPtr->selFgColor : tagPtr->fgColor;
+    }
+
+    TkTextUpdateTagDisplayFlags(tagPtr);
+    if (tagPtr->affectsDisplay) {
+	affectsDisplay = true;
+    }
+    if (tagPtr->tkfont != None && tagPtr->tkfont != textPtr->tkfont) {
+	Tk_FontMetrics fm;
+
+	Tk_GetFontMetrics(tagPtr->tkfont, &fm);
+	if (MAX(1, fm.linespace) != textPtr->lineHeight) {
+	    affectsLineHeight = true;
+	}
+    }
+
+    TkBitPut(sharedTextPtr->elisionTags, tagPtr->index, !!tagPtr->elideString);
+    TkBitPut(sharedTextPtr->affectDisplayTags, tagPtr->index, tagPtr->affectsDisplay);
+    TkBitPut(sharedTextPtr->notAffectDisplayTags, tagPtr->index, !tagPtr->affectsDisplay);
+    TkBitPut(sharedTextPtr->affectGeometryTags, tagPtr->index, tagPtr->affectsDisplayGeometry);
+    TkBitPut(sharedTextPtr->affectLineHeightTags, tagPtr->index, affectsLineHeight);
+
+    if (!TkBitTest(sharedTextPtr->selectionTags, tagPtr->index)) {
+	TkBitPut(sharedTextPtr->affectDisplayNonSelTags, tagPtr->index, tagPtr->affectsDisplay);
+	TkBitPut(sharedTextPtr->affectGeometryNonSelTags, tagPtr->index,
+		tagPtr->affectsDisplayGeometry);
+    }
+
+    if (!tagPtr->elideString != !elideString || (tagPtr->elideString && elide != tagPtr->elide)) {
+	/*
+	 * Eventually we have to insert/remove branches and links according to
+	 * the elide information of this tag.
+	 */
+
+	TkBTreeUpdateElideInfo(textPtr, tagPtr);
+    }
+
+    if (!newTag && affectsDisplay) {
+	/*
+	 * This line is not necessary if this is a new tag, since it can't possibly have
+	 * been applied to anything yet.
+	 *
+	 * If this is the 'sel' tag, then we don't need to call this for all peers, unless
+	 * we actually want to synchronize sel-style changes across the peers.
+	 */
+
+	TkTextRedrawTag(sharedTextPtr, NULL, NULL, NULL, tagPtr, false);
+    }
+
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextFontHeightChanged --
+ *
+ *	The font height of the text widget has changed, so we have to update
+ *	textPtr->affectLineHeightTags accordingly.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	textPtr->affectLineHeightTags will be updated.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextFontHeightChanged(
+    TkText *textPtr)		/* Info about overall widget. */
+{
+    Tcl_HashSearch search;
+    Tcl_HashEntry *hPtr = NULL;
+    TkBitField *affectLineHeightTags = textPtr->sharedTextPtr->affectLineHeightTags;
+
+    TkBitClear(affectLineHeightTags);
+
+    for (hPtr = Tcl_FirstHashEntry(&textPtr->sharedTextPtr->tagTable, &search);
+	    hPtr;
+	    hPtr = Tcl_NextHashEntry(&search)) {
+	const TkTextTag *tagPtr = Tcl_GetHashValue(hPtr);
+
+	if (tagPtr->tkfont != None && tagPtr->tkfont != textPtr->tkfont) {
+	    Tk_FontMetrics fm;
+
+	    Tk_GetFontMetrics(tagPtr->tkfont, &fm);
+	    if (MAX(1, fm.linespace) != textPtr->lineHeight) {
+		TkBitSet(affectLineHeightTags, tagPtr->index);
+	    }
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * AppendTags --
+ *
+ *	This function is appending the given array of tags to the interpreter.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Results will be appended to the interpreter.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+AppendTags(
+    Tcl_Interp *interp,		/* Current interpreter. */
+    unsigned numTags,		/* Size of array. */
+    TkTextTag **tagArray)	/* Array of tag pointer, some pointer may be NULL. */
+{
+    unsigned i;
+    Tcl_Obj *listObj;
+
+    if (numTags == 0) {
+	return;
+    }
+
+    TkTextSortTags(numTags, tagArray);
+    listObj = Tcl_NewObj();
+
+    for (i = 0; i < numTags; ++i) {
+	if (tagArray[i]) {
+	    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj(tagArray[i]->name, -1));
+	}
+    }
+    Tcl_SetObjResult(interp, listObj);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FindTags --
+ *
+ *	This function is appending the tags from given char segment to the
+ *	interpreter.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Results will be appended to the interpreter.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+FindTags(
+    Tcl_Interp *interp,		/* Current interpreter. */
+    TkText *textPtr,		/* Info about overall widget. */
+    const TkTextSegment *segPtr,/* Tags from this segment. */
+    bool discardSelection)	/* "sel" tag will be discarded? */
+{
+    TkTextTag *tagPtr;
+    TkTextTag **tagArray;
+    unsigned count;
+
+    assert(segPtr);
+
+    tagArray = malloc(textPtr->sharedTextPtr->numEnabledTags * sizeof(TkTextTag *));
+    tagPtr = TkBTreeGetSegmentTags(textPtr->sharedTextPtr, segPtr, textPtr);
+
+    for (count = 0; tagPtr; tagPtr = tagPtr->nextPtr) {
+	if (!discardSelection || tagPtr != textPtr->selTagPtr) {
+	    tagArray[count++] = tagPtr;
+	}
+    }
+
+    AppendTags(interp, count, tagArray);
+    free(tagArray);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextTagChangedUndoRedo --
+ *
+ *	This function is called when any tag range has been changed during
+ *	an undo/redo operation.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	See TkTextRedrawTag, and TkTextGrabSelection.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextTagChangedUndoRedo(
+    const TkSharedText *sharedTextPtr,
+    TkText *textPtr,
+    const TkTextIndex *indexPtr1,
+    const TkTextIndex *indexPtr2,
+    const TkTextTag *tagPtr,
+    bool affectsDisplayGeometry)
+{
+    if (!TkTextRedrawTag(sharedTextPtr, textPtr, indexPtr1, indexPtr2, tagPtr, affectsDisplayGeometry)) {
+	return false;
+    }
+    if (tagPtr && tagPtr->textPtr) {
+	assert(tagPtr == textPtr->selTagPtr);
+	GrabSelection(tagPtr->textPtr, tagPtr, TkTextTestTag(indexPtr1, tagPtr));
+    }
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * GrabSelection --
+ * 	Grab the selection if we're supposed to export it and don't already
+ * 	have it.
+ *
+ * 	Also, invalidate partially-completed selection retrievals. We only
+ *	need to check whether the tag is "sel" for this textPtr (not for
+ *	other peer widget's "sel" tags) because we cannot reach this code
+ *	path with a different widget's "sel" tag.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Some text segments may be modified.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+GrabSelection(
+    TkText *textPtr,		/* Info about overall widget. */
+    const TkTextTag *tagPtr,	/* Tag which has been modified. */
+    bool add)			/* 'true' means that we have added this tag;
+				 * 'false' means we have removed this tag. */
+{
+    assert(tagPtr == textPtr->selTagPtr);
+
+    /*
+     * Send an event that the selection changed. This is
+     * equivalent to:
+     *	   event generate $textWidget <<Selection>>
+     */
+
+    TkTextSelectionEvent(textPtr);
+
+    if (add && textPtr->exportSelection && !(textPtr->flags & GOT_SELECTION)) {
+	Tk_OwnSelection(textPtr->tkwin, XA_PRIMARY, TkTextLostSelection, textPtr);
+	textPtr->flags |= GOT_SELECTION;
+    }
+    textPtr->abortSelections = true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TagAddRemove --
+ *	This functions adds or removes a tag (or all tags) from the characters
+ *	between given index range.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Some text segments may be modified.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+UndoTagOperation(
+    const TkSharedText *sharedTextPtr,
+    const TkTextTag *tagPtr)
+{
+    return sharedTextPtr->undoStack && (!tagPtr || tagPtr->undo);
+}
+
+static bool
+TagAddRemove(
+    TkText *textPtr,		/* Info about overall widget. */
+    const TkTextIndex *index1Ptr,
+				/* Indicates first character in range. */
+    const TkTextIndex *index2Ptr,
+				/* Indicates character just after the last one in range. */
+    TkTextTag *tagPtr,		/* Tag to add or remove. */
+    bool add)			/* 'true' means add tag to the given range of characters;
+				 * 'false' means remove the tag from the range. */
+{
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    TkTextUndoInfo *undoInfoPtr;
+    TkTextUndoInfo undoInfo;
+
+    assert(!sharedTextPtr->undoStack || !TkTextUndoIsPerformingUndo(sharedTextPtr->undoStack));
+    assert(!sharedTextPtr->undoStack || !TkTextUndoIsPerformingRedo(sharedTextPtr->undoStack));
+
+    if (!add && !tagPtr->rootPtr) {
+	return false; /* no change possible */
+    }
+
+    undoInfoPtr = UndoTagOperation(sharedTextPtr, tagPtr) ? &undoInfo : NULL;
+
+    if (!TkBTreeTag(sharedTextPtr, textPtr, index1Ptr, index2Ptr, tagPtr, add,
+	    undoInfoPtr, TkTextRedrawTag)) {
+	return false;
+    }
+
+    if (undoInfoPtr) {
+	if (undoInfo.token) {
+	    tagPtr->refCount += 1;
+	    TkTextUndoPushItem(sharedTextPtr->undoStack, undoInfo.token, undoInfo.byteSize);
+	}
+	sharedTextPtr->undoStackEvent = true;
+    }
+
+    return true;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextBindEvent --
+ *
+ *	Bind events to the specified resource name.
+ *
+ * Results:
+ *	Any of the standard Tcl return values.
+ *
+ * Side effects:
+ *	A new entry in the binding table will be inserted, or an exisiting
+ *	entry will be deleted.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TkTextBindEvent(
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[],	/* Remaining argument objects. */
+    TkSharedText *sharedTextPtr,/* Shared text resource. */
+    Tk_BindingTable *bindingTablePtr,
+    				/* Pointer to binding table. */
+    const char *name)		/* Name of the resource (tag, or image) */
+{
+    static const unsigned motionMask = ButtonMotionMask|Button1MotionMask
+		|Button2MotionMask|Button3MotionMask|Button4MotionMask
+		|Button5MotionMask|PointerMotionMask;
+
+    /*
+     * Make a binding table if the widget doesn't already have one.
+     */
+
+    if (!*bindingTablePtr) {
+	*bindingTablePtr = Tk_CreateBindingTable(interp);
+    }
+
+    if (objc == 2) {
+	bool append = false;
+	unsigned mask;
+	const char *eventString = Tcl_GetString(objv[0]);
+	const char *fifth = Tcl_GetString(objv[1]);
+
+	if (fifth[0] == '\0') {
+	    return Tk_DeleteBinding(interp, *bindingTablePtr, (ClientData) name, eventString);
+	}
+	if (fifth[0] == '+') {
+	    fifth += 1;
+	    append = true;
+	}
+	mask = Tk_CreateBinding(interp, *bindingTablePtr, (ClientData) name, eventString, fifth, append);
+	if (mask == 0) {
+	    return TCL_ERROR;
+	}
+	if (mask & motionMask) {
+	    /*
+	     * TODO: It would be better to count tags with motion mask, but this silly
+	     * binding protocol does not provide any function which helps to detect when
+	     * bindings with motion masks will be deleted. So we cannot do more than
+	     * to detect whether any motion mask has ever been set. This has an effect
+	     * on TkTextPickCurrent, this function will be considerably faster if
+	     * 'numMotionEventBindings' is zero, because in latter case only traversals
+	     * between display chunks will be considered. We assume that the use of a
+	     * motion mask is rather seldom, normally only the Enter/Leave events are
+	     * of interest.
+	     */
+	    sharedTextPtr->numMotionEventBindings = 1;
+	}
+	if (mask & (unsigned) ~(motionMask|ButtonPressMask|ButtonReleaseMask|EnterWindowMask
+		|LeaveWindowMask|KeyPressMask|KeyReleaseMask|VirtualEventMask)) {
+	    Tk_DeleteBinding(interp, *bindingTablePtr, (ClientData) name, eventString);
+	    Tcl_ResetResult(interp);
+	    Tcl_SetObjResult(interp, Tcl_NewStringObj(
+		    "requested illegal events; only key, button, motion,"
+		    " enter, leave, and virtual events may be used", -1));
+	    Tcl_SetErrorCode(interp, "TK", "TEXT", "TAG_BIND_EVENT",NULL);
+	    return TCL_ERROR;
+	}
+    } else if (objc == 1) {
+	const char *command;
+
+	command = Tk_GetBinding(interp, *bindingTablePtr, (ClientData) name, Tcl_GetString(objv[0]));
+	if (!command) {
+	    const char *string = Tcl_GetString(Tcl_GetObjResult(interp));
+
+	    /*
+	     * Ignore missing binding errors. This is a special hack that relies on the
+	     * error message returned by FindSequence in tkBind.c.
+	     */
+
+	    if (string[0] != '\0') {
+		return TCL_ERROR;
+	    }
+	    Tcl_ResetResult(interp);
+	} else {
+	    Tcl_SetObjResult(interp, Tcl_NewStringObj(command, -1));
+	}
+    } else {
+	Tk_GetAllBindings(interp, *bindingTablePtr, (ClientData) name);
+    }
+
+    return TCL_OK;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextCreateTag --
+ *
+ *	Find the record describing a tag within a given text widget, creating
+ *	a new record if one doesn't already exist.
+ *
+ * Results:
+ *	The return value is a pointer to the TkTextTag record for tagName.
+ *
+ * Side effects:
+ *	A new tag record is created if there isn't one already defined for
+ *	tagName.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static void
+MarkIndex(
+    TkSharedText *sharedTextPtr,
+    TkTextTag *tagPtr,
+    bool set)
+{
+    if (set && tagPtr->index >= TkBitSize(sharedTextPtr->usedTags)) {
+	sharedTextPtr->tagInfoSize = TkBitAdjustSize(tagPtr->index + 1);
+    }
+
+    TkBitPut(sharedTextPtr->usedTags, tagPtr->index, set);
+    assert((!sharedTextPtr->tagLookup[tagPtr->index]) == set);
+    sharedTextPtr->tagLookup[tagPtr->index] = set ? tagPtr : NULL;
+}
+
+TkTextTag *
+TkTextCreateTag(
+    TkText *textPtr,		/* Widget in which tag is being used. */
+    const char *tagName,	/* Name of desired tag. */
+    bool *newTag)		/* If non-NULL, then return true if new, or false if already exists. */
+{
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    TkTextTag *tagPtr;
+    Tcl_HashEntry *hPtr = NULL;
+    bool isNew, isSelTag;
+    const char *name;
+    unsigned index;
+
+    isSelTag = (strcmp(tagName, "sel") == 0);
+
+    if (isSelTag) {
+	if (textPtr->selTagPtr) {
+	    if (newTag) {
+		*newTag = false;
+	    }
+	    return textPtr->selTagPtr;
+	}
+	if (newTag) {
+	    *newTag = true;
+	}
+	name = "sel";
+    } else {
+	hPtr = Tcl_CreateHashEntry(&sharedTextPtr->tagTable, tagName, (int *) &isNew);
+	if (newTag) {
+	    *newTag = isNew;
+	}
+	if (!isNew) {
+	    return Tcl_GetHashValue(hPtr);
+	}
+	name = Tcl_GetHashKey(&sharedTextPtr->tagTable, hPtr);
+    }
+
+    if ((index = TkBitFindFirstNot(sharedTextPtr->usedTags)) == TK_BIT_NPOS) {
+	unsigned oldSize = TkBitSize(sharedTextPtr->usedTags);
+	unsigned newSize = TkBitAdjustSize((index = oldSize) + 1);
+
+	sharedTextPtr->usedTags = TkBitResize(sharedTextPtr->usedTags, newSize);
+	sharedTextPtr->elisionTags = TkBitResize(sharedTextPtr->elisionTags, newSize);
+	sharedTextPtr->selectionTags = TkBitResize(sharedTextPtr->selectionTags, newSize);
+	sharedTextPtr->dontUndoTags = TkBitResize(sharedTextPtr->dontUndoTags, newSize);
+	sharedTextPtr->affectDisplayTags = TkBitResize(sharedTextPtr->affectDisplayTags, newSize);
+	sharedTextPtr->notAffectDisplayTags = TkBitResize(sharedTextPtr->notAffectDisplayTags, newSize);
+	sharedTextPtr->affectDisplayNonSelTags = TkBitResize(
+		sharedTextPtr->affectDisplayNonSelTags, newSize);
+	sharedTextPtr->affectGeometryTags = TkBitResize( sharedTextPtr->affectGeometryTags, newSize);
+	sharedTextPtr->affectGeometryNonSelTags = TkBitResize(
+		sharedTextPtr->affectGeometryNonSelTags, newSize);
+	sharedTextPtr->affectLineHeightTags = TkBitResize(sharedTextPtr->affectLineHeightTags, newSize);
+	sharedTextPtr->tagLookup = realloc(sharedTextPtr->tagLookup, newSize * sizeof(TkTextTag *));
+	DEBUG(memset(sharedTextPtr->tagLookup + oldSize, 0, (newSize - oldSize) * sizeof(TkTextTag *)));
+    }
+
+    if (sharedTextPtr->tagInfoSize <= index) {
+	sharedTextPtr->tagInfoSize = TkBitAdjustSize(index + 1);
+    }
+
+    /*
+     * No existing entry. Create a new one, initialize it, and add a pointer
+     * to it to the hash table entry.
+     */
+
+    tagPtr = memset(malloc(sizeof(TkTextTag)), 0, sizeof(TkTextTag));
+    tagPtr->name = name;
+    tagPtr->index = index;
+    tagPtr->priority = textPtr->sharedTextPtr->numEnabledTags;
+    tagPtr->relief = TK_RELIEF_FLAT;
+    tagPtr->bgStipple = None;
+    tagPtr->fgStipple = None;
+    tagPtr->justify = TK_TEXT_JUSTIFY_LEFT;
+    tagPtr->tabStyle = TK_TEXT_TABSTYLE_NONE;
+    tagPtr->wrapMode = TEXT_WRAPMODE_NULL;
+    tagPtr->undo = !isSelTag;
+    tagPtr->sharedTextPtr = sharedTextPtr;
+    tagPtr->undoTagListIndex = -1;
+    tagPtr->refCount = 1;
+    DEBUG_ALLOC(tkTextCountNewTag++);
+
+    textPtr->sharedTextPtr->numTags += 1;
+    textPtr->sharedTextPtr->numEnabledTags += 1;
+    if (isSelTag) {
+	tagPtr->textPtr = textPtr;
+	textPtr->refCount += 1;
+	TkBitSet(sharedTextPtr->selectionTags, index);
+	TkBitSet(sharedTextPtr->dontUndoTags, index);
+    } else {
+	CLANG_ASSERT(hPtr);
+	Tcl_SetHashValue(hPtr, tagPtr);
+    }
+    tagPtr->optionTable = Tk_CreateOptionTable(textPtr->interp, tagOptionSpecs);
+    MarkIndex(sharedTextPtr, tagPtr, true);
+    return tagPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextFindTag --
+ *
+ *	See if tag is defined for a given widget.
+ *
+ * Results:
+ *	If tagName is defined in textPtr, a pointer to its TkTextTag structure
+ *	is returned. Otherwise NULL is returned.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+TkTextTag *
+TkTextFindTag(
+    const TkText *textPtr,	/* Widget in which tag is being used. */
+    const char *tagName)	/* Name of desired tag. */
+{
+    Tcl_HashEntry *hPtr;
+
+    assert(textPtr);
+    assert(tagName);
+
+    if (strcmp(tagName, "sel") == 0) {
+	return textPtr->selTagPtr;
+    }
+    hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->tagTable, tagName);
+    if (hPtr) {
+	return Tcl_GetHashValue(hPtr);
+    }
+    return NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * FindTag --
+ *
+ *	See if tag is defined for a given widget.
+ *
+ * Results:
+ *	If tagName is defined in textPtr, a pointer to its TkTextTag structure
+ *	is returned. Otherwise NULL is returned and an error message is
+ *	recorded in the interp's result unless interp is NULL.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static TkTextTag *
+FindTag(
+    Tcl_Interp *interp,		/* Interpreter to use for error message; if NULL, then don't record
+    				 * an error message. */
+    const TkText *textPtr,	/* Widget in which tag is being used. */
+    Tcl_Obj *tagName)		/* Name of desired tag. */
+{
+    const char *name = Tcl_GetString(tagName);
+    TkTextTag *tagPtr = TkTextFindTag(textPtr, name);
+
+    if (!tagPtr && interp) {
+	Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		"tag \"%s\" isn't defined in text widget", name));
+	Tcl_SetErrorCode(interp, "TK", "LOOKUP", "TEXT_TAG", name, NULL);
+    }
+
+    return tagPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextEnableTag --
+ *
+ *	If this tag is disabled, then re-enable it.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextEnableTag(
+    TkSharedText *sharedTextPtr,/* Shared text resource. */
+    TkTextTag *tagPtr)		/* Tag being deleted. */
+{
+    if (tagPtr->isDisabled) {
+	tagPtr->isDisabled = false;
+	MarkIndex(sharedTextPtr, tagPtr, true);
+	sharedTextPtr->numEnabledTags += 1;
+	ChangeTagPriority(sharedTextPtr, tagPtr, tagPtr->savedPriority, false);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextReleaseTag --
+ *
+ *	Delete this tag if the reference counter is going to zero, in this
+ *	case clean up the tag structure itself. This requires that the given
+ *	tag is not in use.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory and other resources are freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextReleaseTag(
+    TkSharedText *sharedTextPtr,/* Shared text resource. */
+    TkTextTag *tagPtr,		/* Tag being deleted. */
+    Tcl_HashEntry *hPtr)	/* Pointer into hash table, can be NULL. */
+{
+    assert(tagPtr->refCount > 1 || !tagPtr->rootPtr);
+
+    if (--tagPtr->refCount > 0) {
+	return;
+    }
+
+    assert(!tagPtr->recentTagAddRemoveToken);
+    assert(!tagPtr->recentChangePriorityToken);
+
+    MarkIndex(sharedTextPtr, tagPtr, false);
+    sharedTextPtr->numTags -= 1;
+
+    if (!hPtr) {
+	hPtr = Tcl_FindHashEntry(&sharedTextPtr->tagTable, tagPtr->name);
+    }
+    if (hPtr) {
+	Tcl_DeleteHashEntry(hPtr);
+    } else {
+	assert(strcmp(tagPtr->name, "sel") == 0);
+    }
+
+    /*
+     * Let Tk do most of the hard work for us.
+     */
+
+    Tk_FreeConfigOptions((char *) tagPtr, tagPtr->optionTable, sharedTextPtr->peers->tkwin);
+
+    /*
+     * This associated information is managed by us.
+     */
+
+    if (tagPtr->tabArrayPtr) {
+	free(tagPtr->tabArrayPtr);
+    }
+
+    if (sharedTextPtr->tagBindingTable) {
+	Tk_DeleteAllBindings(sharedTextPtr->tagBindingTable, (ClientData) tagPtr->name);
+    }
+
+    /*
+     * If this tag is widget-specific (peer widgets) then clean up the
+     * refCount it holds.
+     */
+
+    if (tagPtr->textPtr) {
+	if (--((TkText *) tagPtr->textPtr)->refCount == 0) {
+	    free(tagPtr->textPtr);
+	}
+	tagPtr->textPtr = NULL;
+    }
+
+    /*
+     * Finally free the tag's memory.
+     */
+
+    free(tagPtr);
+    DEBUG_ALLOC(tkTextCountDestroyTag++);
+}
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextDeleteTag --
+ *
+ *	This function is called to carry out most actions associated with the
+ *	'tag delete' sub-command. It will remove all evidence of the tag from
+ *	the B-tree, and then clean up the tag structure itself.
+ *
+ *	The only actions this doesn't carry out it to check if the deletion of
+ *	the tag requires something to be re-displayed, and to remove the tag
+ *	from the tagTable (hash table) if that is necessary (i.e. if it's not
+ *	the 'sel' tag). It is expected that the caller carry out both of these
+ *	actions.
+ *
+ * Results:
+ *	Returns whether this tag was used in current text content.
+ *
+ * Side effects:
+ *	Memory and other resources are freed, the B-tree is manipulated.
+ *
+ *----------------------------------------------------------------------
+ */
+
+bool
+TkTextDeleteTag(
+    TkText *textPtr,		/* Info about overall widget. */
+    TkTextTag *tagPtr,		/* Tag being deleted. */
+    Tcl_HashEntry *hPtr)	/* Pointer into hash table, can be NULL (but only for "sel"). */
+{
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    bool used;
+    unsigned i;
+
+    assert(!sharedTextPtr->undoStack || !TkTextUndoIsPerformingUndo(sharedTextPtr->undoStack));
+    assert(!sharedTextPtr->undoStack || !TkTextUndoIsPerformingRedo(sharedTextPtr->undoStack));
+    assert(hPtr || strcmp(tagPtr->name, "sel") == 0);
+
+    used = !!tagPtr->rootPtr;
+
+    if (used) {
+	TkTextUndoInfo undoInfo;
+	TkTextUndoInfo *undoInfoPtr;
+	TkTextIndex startIndex;
+	TkTextIndex index[2];
+	TkTextSearch tSearch;
+	bool useUndo = !!(textPtr->flags & DESTROYED) && UndoTagOperation(sharedTextPtr, tagPtr);
+
+	undoInfoPtr = useUndo ? &undoInfo : NULL;
+
+	TkTextIndexSetupToStartOfText(&index[0], NULL, sharedTextPtr->tree);
+	TkTextIndexSetupToEndOfText(&index[1], NULL, sharedTextPtr->tree);
+
+	TkBTreeStartSearch(&index[0], &index[1], tagPtr, &tSearch, SEARCH_NEXT_TAGON);
+	TkBTreeNextTag(&tSearch);
+	assert(tSearch.segPtr); /* last search must not fail */
+	startIndex = tSearch.curIndex;
+
+	TkBTreeStartSearchBack(&index[1], &index[0], tagPtr, &tSearch, SEARCH_EITHER_TAGON_TAGOFF);
+	TkBTreePrevTag(&tSearch);
+	assert(tSearch.segPtr); /* last search must not fail */
+	assert(!tSearch.tagon); /* we must find tagoff */
+
+	TkBTreeTag(textPtr->sharedTextPtr, textPtr, &startIndex, &tSearch.curIndex,
+		tagPtr, false, undoInfoPtr, TkTextRedrawTag);
+
+	if (undoInfoPtr && undoInfoPtr->token) {
+	    tagPtr->refCount += 1;
+	    TkTextUndoPushItem(sharedTextPtr->undoStack, undoInfo.token, undoInfo.byteSize);
+	}
+    }
+
+    assert(!tagPtr->rootPtr);
+
+    if (!(textPtr->flags & DESTROYED) && tagPtr == textPtr->selTagPtr) {
+	/*
+	 * Send an event that the selection changed. This is equivalent to:
+	 *	event generate $textWidget <<Selection>>
+	 */
+
+	TkTextSelectionEvent(textPtr);
+    }
+
+    /*
+     * Update the tag priorities to reflect the deletion of this tag.
+     */
+
+    tagPtr->savedPriority = tagPtr->priority;
+    ChangeTagPriority(sharedTextPtr, tagPtr, sharedTextPtr->numEnabledTags - 1, false);
+    sharedTextPtr->numEnabledTags -= 1;
+
+    /*
+     * Make sure this tag isn't referenced from the 'current' tag array.
+     */
+
+    for (i = 0; i < textPtr->numCurTags; ++i) {
+	if (textPtr->curTagArrayPtr[i] == tagPtr) {
+	    memmove(textPtr->curTagArrayPtr + i,
+		    textPtr->curTagArrayPtr + i + 1,
+		    (textPtr->numCurTags - i - 1)*sizeof(textPtr->curTagArrayPtr[0]));
+	    textPtr->numCurTags -= 1;
+	    DEBUG(textPtr->curTagArrayPtr[textPtr->numCurTags] = NULL);
+	    break;
+	}
+    }
+
+    /*
+     * Handle the retained undo tokens.
+     */
+
+    if (tagPtr->undoTagListIndex >= 0) {
+	if (sharedTextPtr->undoStack) {
+	    TkTextPushUndoTagTokens(sharedTextPtr, tagPtr);
+	} else {
+	    TkTextReleaseUndoTagToken(sharedTextPtr, tagPtr);
+	}
+    }
+
+    tagPtr->isDisabled = true;
+    TkTextReleaseTag(sharedTextPtr, tagPtr, hPtr);
+    return used;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextFreeAllTags --
+ *
+ *	This function is called when all tags are deleted to free up the memory
+ *	and other resources associated with tags.
+ *
+ *	Note that this function is not freeing the indices
+ *	('sharedTextPtr->usedTags', 'sharedTextPtr->elisionTags'), but both
+ *	sets will be cleared.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory and other resources are freed.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextFreeAllTags(
+    TkText *textPtr)		/* Info about overall widget. */
+{
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    Tcl_HashSearch search;
+    Tcl_HashEntry *hPtr;
+
+    for (hPtr = Tcl_FirstHashEntry(&sharedTextPtr->tagTable, &search);
+	    hPtr;
+	    hPtr = Tcl_NextHashEntry(&search)) {
+	TkTextTag *tagPtr = Tcl_GetHashValue(hPtr);
+
+	assert(tagPtr->refCount == 1);
+
+	/*
+	 * Let Tk do most of the hard work for us.
+	 */
+
+	Tk_FreeConfigOptions((char *) tagPtr, tagPtr->optionTable, textPtr->tkwin);
+
+	/*
+	 * This associated information is managed by us.
+	 */
+
+	if (tagPtr->tabArrayPtr) {
+	    free(tagPtr->tabArrayPtr);
+	}
+
+	if (tagPtr->undoTagListIndex >= 0) {
+	    TkTextReleaseUndoTagToken(sharedTextPtr, tagPtr);
+	}
+
+	/*
+	 * If this tag is widget-specific (peer widgets) then clean up the
+	 * refCount it holds.
+	 */
+
+	if (tagPtr->textPtr) {
+	    assert(textPtr == tagPtr->textPtr);
+	    if (--textPtr->refCount == 0) {
+		free(textPtr);
+	    }
+	    tagPtr->textPtr = NULL;
+	}
+
+	/*
+	 * Finally free the tag's memory.
+	 */
+
+	free(tagPtr);
+	DEBUG_ALLOC(tkTextCountDestroyTag++);
+    }
+
+    textPtr->numCurTags = 0;
+    TkBitClear(sharedTextPtr->usedTags);
+    TkBitClear(sharedTextPtr->elisionTags);
+    TkBitClear(sharedTextPtr->affectDisplayTags);
+    TkBitClear(sharedTextPtr->notAffectDisplayTags);
+    TkBitClear(sharedTextPtr->affectDisplayNonSelTags);
+    TkBitClear(sharedTextPtr->affectGeometryTags);
+    TkBitClear(sharedTextPtr->affectGeometryNonSelTags);
+    TkBitClear(sharedTextPtr->affectLineHeightTags);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextSortTags --
+ *
+ *	This function sorts an array of tag pointers in increasing order of
+ *	priority, optimizing for the common case where the array is small.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+TagSortProc(
+    const void *first,
+    const void *second)		/* Elements to be compared. */
+{
+    return (*(TkTextTag **) first)->priority - (*(TkTextTag **) second)->priority;
+}
+
+void
+TkTextSortTags(
+    unsigned numTags,		/* Number of tag pointers at *tagArrayPtr. */
+    TkTextTag **tagArrayPtr)	/* Pointer to array of pointers. */
+{
+    unsigned i, j, prio;
+    TkTextTag **tagPtrPtr;
+    TkTextTag **maxPtrPtr;
+    TkTextTag *tmp;
+
+    if (numTags <= 1) {
+	return;
+    }
+    if (numTags <= 20) {
+	for (i = numTags - 1; i > 0; i--, tagArrayPtr++) {
+	    maxPtrPtr = tagPtrPtr = tagArrayPtr;
+	    prio = tagPtrPtr[0]->priority;
+	    for (j = i, tagPtrPtr += 1; j > 0; --j, ++tagPtrPtr) {
+		if (tagPtrPtr[0]->priority < prio) {
+		    prio = tagPtrPtr[0]->priority;
+		    maxPtrPtr = tagPtrPtr;
+		}
+	    }
+	    tmp = *maxPtrPtr;
+	    *maxPtrPtr = *tagArrayPtr;
+	    *tagArrayPtr = tmp;
+	}
+    } else {
+	qsort(tagArrayPtr, numTags, sizeof(TkTextTag *), TagSortProc);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextReleaseUndoTagToken --
+ *
+ *	Release retained undo tokens for tag operations.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Free some memory.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextReleaseUndoTagToken(
+    TkSharedText *sharedTextPtr,
+    TkTextTag *tagPtr)
+{
+    assert(sharedTextPtr);
+
+    if (!tagPtr) {
+	return;
+    }
+
+    assert(tagPtr->undoTagListIndex >= 0);
+    assert(tagPtr->undoTagListIndex < sharedTextPtr->undoTagListCount);
+
+    if (tagPtr->recentTagAddRemoveToken) {
+	free(tagPtr->recentTagAddRemoveToken);
+	DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	tagPtr->recentTagAddRemoveToken = NULL;
+    }
+    if (tagPtr->recentChangePriorityToken) {
+	free(tagPtr->recentChangePriorityToken);
+	DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	tagPtr->recentChangePriorityToken = NULL;
+    }
+
+    sharedTextPtr->undoTagList[tagPtr->undoTagListIndex] = NULL;
+    tagPtr->undoTagListIndex = -1;
+    assert(tagPtr->refCount > 1);
+    tagPtr->refCount -= 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextInspectUndoTagItem --
+ *
+ *	Inspect retained undo token.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Memory is allocated for the result.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextInspectUndoTagItem(
+    const TkSharedText *sharedTextPtr,
+    const TkTextTag *tagPtr,
+    Tcl_Obj* objPtr)
+{
+    if (tagPtr) {
+	if (tagPtr->recentTagAddRemoveToken && !tagPtr->recentTagAddRemoveTokenIsNull) {
+	    Tcl_ListObjAppendElement(NULL, objPtr,
+		    TkBTreeUndoTagInspect(sharedTextPtr, tagPtr->recentTagAddRemoveToken));
+	}
+	if (tagPtr->recentChangePriorityToken) {
+	    Tcl_ListObjAppendElement(NULL, objPtr,
+		    UndoChangeTagPriorityInspect(sharedTextPtr, tagPtr->recentChangePriorityToken));
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextPushUndoTagTokens --
+ *
+ *	Push retained undo tokens for tag operations onto the undo stack.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Same as TkTextUndoPushItem.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextPushUndoTagTokens(
+    TkSharedText *sharedTextPtr,
+    TkTextTag *tagPtr)
+{
+    assert(sharedTextPtr);
+    assert(sharedTextPtr->undoStack);
+
+    if (!tagPtr) {
+	return;
+    }
+
+    assert(tagPtr->undoTagListIndex >= 0);
+    assert(tagPtr->undoTagListIndex < sharedTextPtr->undoTagListCount);
+
+    if (tagPtr->recentTagAddRemoveToken) {
+	if (tagPtr->recentTagAddRemoveTokenIsNull) {
+	    free(tagPtr->recentTagAddRemoveToken);
+	    DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	} else {
+	    TkTextUndoPushItem(sharedTextPtr->undoStack, tagPtr->recentTagAddRemoveToken, 0);
+	    tagPtr->refCount += 1;
+	}
+	tagPtr->recentTagAddRemoveToken = NULL;
+    }
+    if (tagPtr->recentChangePriorityToken) {
+	if (tagPtr->savedPriority != tagPtr->priority) {
+	    TkTextUndoPushItem(sharedTextPtr->undoStack, tagPtr->recentChangePriorityToken, 0);
+	    tagPtr->refCount += 1;
+	} else {
+	    free(tagPtr->recentChangePriorityToken);
+	    DEBUG_ALLOC(tkTextCountDestroyUndoToken++);
+	}
+	tagPtr->recentChangePriorityToken = NULL;
+    }
+
+    sharedTextPtr->undoTagList[tagPtr->undoTagListIndex] = NULL;
+    tagPtr->undoTagListIndex = -1;
+    assert(tagPtr->refCount > 1);
+    tagPtr->refCount -= 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextTagAddRetainedUndo --
+ *
+ *	Add given tag to undo list, because this tag has retained undo
+ *	tokens.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The reference counter of the tag will be incremented.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextTagAddRetainedUndo(
+    TkSharedText *sharedTextPtr,	/* Shared text resource. */
+    TkTextTag *tagPtr)			/* Add this tag to undo list. */
+{
+    assert(sharedTextPtr);
+    assert(tagPtr);
+
+    if (tagPtr->undoTagListIndex >= 0) {
+	return;
+    }
+
+    if (sharedTextPtr->undoTagListCount == sharedTextPtr->undoTagListSize) {
+	sharedTextPtr->undoTagListSize = 2*sharedTextPtr->numEnabledTags;
+	sharedTextPtr->undoTagList = realloc(sharedTextPtr->undoTagList,
+		sharedTextPtr->undoTagListSize * sizeof(sharedTextPtr->undoTagList[0]));
+    }
+    sharedTextPtr->undoTagList[sharedTextPtr->undoTagListCount] = tagPtr;
+    sharedTextPtr->undoStackEvent = true;
+    sharedTextPtr->lastUndoTokenType = -1;
+    tagPtr->undoTagListIndex = sharedTextPtr->undoTagListCount++;
+    tagPtr->refCount += 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextPushTagPriorityUndo --
+ *
+ *	This function is pushing an undo item for setting the priority
+ *	of a mark (raise/lower command).
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Some memory will be allocated, and see TkTextPushUndoToken.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextPushTagPriorityUndo(
+    TkSharedText *sharedTextPtr,
+    TkTextTag *tagPtr,
+    unsigned priority)
+{
+    UndoTokenTagPriority *token;
+
+    token = malloc(sizeof(UndoTokenTagPriority));
+    token->undoType = &undoTokenTagPriorityType;
+    (token->tagPtr = tagPtr)->refCount += 1;
+    token->priority = priority;
+    DEBUG_ALLOC(tkTextCountNewUndoToken++);
+
+    TkTextPushUndoToken(sharedTextPtr, token, 0);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkTextPushTagPriorityRedo --
+ *
+ *	This function is pushing a redo item for setting the priority
+ *	of a mark (raise/lower command).
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Some memory will be allocated, and see TkTextPushRedoToken.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkTextPushTagPriorityRedo(
+    TkSharedText *sharedTextPtr,
+    TkTextTag *tagPtr,
+    unsigned priority)
+{
+    UndoTokenTagPriority *token;
+
+    token = malloc(sizeof(UndoTokenTagPriority));
+    token->undoType = &redoTokenTagPriorityType;
+    (token->tagPtr = tagPtr)->refCount += 1;
+    token->priority = priority;
+    DEBUG_ALLOC(tkTextCountNewUndoToken++);
+
+    TkTextPushRedoToken(sharedTextPtr, token, 0);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ChangeTagPriority --
+ *
+ *	This function changes the priority of a tag by modifying its priority
+ *	and the priorities of other tags that are affected by the change.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Priorities may be changed for some or all of the tags in textPtr. The
+ *	tags will be arranged so that there is exactly one tag at each
+ *	priority level between 0 and textPtr->sharedTextPtr->numEnabledTags-1,
+ *	with tagPtr at priority "newPriority".
+ *
+ *----------------------------------------------------------------------
+ */
+
+static bool
+ChangeTagPriority(
+    TkSharedText *sharedTextPtr,/* Shared text resource. */
+    TkTextTag *tagPtr,		/* Tag whose priority is to be changed. */
+    unsigned newPriority,	/* New priority for tag. */
+    bool undo)			/* Push undo item for this action? */
+{
+    int delta;
+    unsigned low, high;
+    TkTextTag *tagPtr2;
+    Tcl_HashEntry *hPtr;
+    Tcl_HashSearch search;
+    TkText *peer;
+
+    assert(newPriority < sharedTextPtr->numEnabledTags);
+
+    if (newPriority == tagPtr->priority) {
+	return false;
+    }
+
+    if (undo && tagPtr->undo && !TkTextUndoStackIsFull(sharedTextPtr->undoStack)) {
+	UndoTokenTagPriority *token = (UndoTokenTagPriority *) tagPtr->recentChangePriorityToken;
+
+	/*
+	 * Don't push changes of tag priorities immediately onto the undo stack, this
+	 * may blow up the stack. We save this undo token inside the tag, in this way
+	 * only the relevant changes will be pushed as soon as a separator will be
+	 * pushed.
+	 */
+	
+	if (!tagPtr->recentChangePriorityToken) {
+	    tagPtr->savedPriority = tagPtr->priority;
+	    token = malloc(sizeof(UndoTokenTagPriority));
+	    DEBUG_ALLOC(tkTextCountNewUndoToken++);
+	    tagPtr->recentChangePriorityToken = (TkTextUndoToken *) token;
+	    TkTextTagAddRetainedUndo(sharedTextPtr, tagPtr);
+	}
+
+	token->undoType = &undoTokenTagPriorityType;
+	token->tagPtr = tagPtr;
+	token->priority = tagPtr->priority;
+    }
+
+    if (newPriority < tagPtr->priority) {
+	low = newPriority;
+	high = tagPtr->priority - 1;
+	delta = 1;
+    } else {
+	low = tagPtr->priority + 1;
+	high = newPriority;
+	delta = -1;
+    }
+
+    /*
+     * Adjust first the 'sel' tag, then all others from the hash table
+     */
+
+    for (peer = sharedTextPtr->peers; peer; peer = peer->next) {
+	if (low <= peer->selTagPtr->priority && peer->selTagPtr->priority <= high) {
+	    peer->selTagPtr->priority += delta;
+	}
+    }
+
+    for (hPtr = Tcl_FirstHashEntry(&sharedTextPtr->tagTable, &search);
+	    hPtr;
+	    hPtr = Tcl_NextHashEntry(&search)) {
+	tagPtr2 = Tcl_GetHashValue(hPtr);
+	if (low <= tagPtr2->priority && tagPtr2->priority <= high) {
+	    tagPtr2->priority += delta;
+	}
+    }
+
+    tagPtr->priority = newPriority;
+
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextBindProc --
+ *
+ *	This function is invoked by the Tk dispatcher to handle events
+ *	associated with bindings on items.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Depends on the command invoked as part of the binding (if there was
+ *	any).
+ *
+ *--------------------------------------------------------------
+ */
+
+void
+TkTextBindProc(
+    ClientData clientData,	/* Pointer to canvas structure. */
+    XEvent *eventPtr)		/* Pointer to X event that just happened. */
+{
+    enum { AnyButtonMask = Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask };
+
+    TkText *textPtr = clientData;
+    bool repick = false;
+
+    textPtr->refCount += 1;
+
+    /*
+     * This code simulates grabs for mouse buttons by keeping track of whether
+     * a button is pressed and refusing to pick a new current character while
+     * a button is pressed.
+     */
+
+    if (eventPtr->type == ButtonPress) {
+	textPtr->flags |= BUTTON_DOWN;
+    } else if (eventPtr->type == ButtonRelease) {
+	unsigned mask = 0;
+
+	switch (eventPtr->xbutton.button) {
+	    case Button1: mask = Button1Mask; break;
+	    case Button2: mask = Button2Mask; break;
+	    case Button3: mask = Button3Mask; break;
+	    case Button4: mask = Button4Mask; break;
+	    case Button5: mask = Button5Mask; break;
+	}
+	if ((eventPtr->xbutton.state & AnyButtonMask) == mask) {
+	    textPtr->flags &= ~BUTTON_DOWN;
+	    repick = true;
+	}
+    } else if (eventPtr->type == EnterNotify || eventPtr->type == LeaveNotify) {
+	if (eventPtr->xcrossing.state & AnyButtonMask) {
+	    textPtr->flags |= BUTTON_DOWN;
+	} else {
+	    textPtr->flags &= ~BUTTON_DOWN;
+	}
+	TkTextPickCurrent(textPtr, eventPtr);
+	goto done;
+    } else if (eventPtr->type == MotionNotify) {
+	if (eventPtr->xmotion.state & AnyButtonMask) {
+	    textPtr->flags |= BUTTON_DOWN;
+	} else {
+	    textPtr->flags &= ~BUTTON_DOWN;
+	}
+	TkTextPickCurrent(textPtr, eventPtr);
+    }
+    if (!(textPtr->flags & DESTROYED)) {
+	if (textPtr->numCurTags > 0 && textPtr->sharedTextPtr->tagBindingTable) {
+	    TagBindEvent(textPtr, eventPtr, textPtr->numCurTags, textPtr->curTagArrayPtr);
+	}
+	if (textPtr->hoveredImageArrSize && textPtr->sharedTextPtr->imageBindingTable) {
+	    unsigned i;
+
+	    for (i = 0; i < textPtr->hoveredImageArrSize; ++i) {
+		Tk_BindEvent(textPtr->sharedTextPtr->imageBindingTable, eventPtr,
+			textPtr->tkwin, 1, (ClientData *) &textPtr->hoveredImageArr[i]->name);
+	    }
+	}
+    }
+    if (repick) {
+	unsigned oldState;
+
+	oldState = eventPtr->xbutton.state;
+	eventPtr->xbutton.state &= ~(Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);
+	if (!(textPtr->flags & DESTROYED)) {
+	    TkTextPickCurrent(textPtr, eventPtr);
+	}
+	eventPtr->xbutton.state = oldState;
+    }
+
+  done:
+    if (--textPtr->refCount == 0) {
+	free(textPtr);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextPickCurrent --
+ *
+ *	Find the character containing the coordinates in an event and place
+ *	the "current" mark on that character (but the real update of the
+ *	segment will be postponed). If the "current" mark has moved then
+ *	generate a fake leave event on the old current character and a fake
+ *	enter event on the new current character.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The index of the current mark for textPtr may change. If it does,
+ *	then the commands associated with character entry and leave could
+ *	do just about anything. For example, the text widget might be deleted.
+ *	It is up to the caller to protect itself by incrementing the refCount
+ *	of the text widget.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+ImageHitCallback(
+    TkQTreeUid uid,
+    const TkQTreeRect *rect,
+    TkQTreeState *state,
+    TkQTreeClientData arg)
+{
+    TkTextEmbImage **eiListPtr = (TkTextEmbImage **) arg;
+    TkTextEmbImage *eiPtr = (TkTextEmbImage *) uid;
+
+    eiPtr->nextPtr = *eiListPtr;
+    *eiListPtr = eiPtr;
+    return true;
+}
+
+void
+TkTextPickCurrent(
+    TkText *textPtr,		/* Text widget in which to select current character. */
+    XEvent *eventPtr)		/* Event describing location of mouse cursor.
+				 * Must be EnterWindow, LeaveWindow, ButtonRelease, or MotionNotify. */
+{
+    TkTextIndex index;
+    TkTextTag **oldArrayPtr;
+    TkTextTag **newArrayPtr;
+    TkTextTag **copyArrayPtr = NULL; /* prevent compiler warning */
+    TkTextTag *copyArrayBuffer[32];
+    TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    unsigned numOldTags, numNewTags, i, size, epoch;
+    bool sameChunkWithUnchangedTags = false;
+    bool nearby = false;
+    XEvent event;
+
+    /*
+     * If a button is down, then don't do anything at all; we'll be called
+     * again when all buttons are up, and we can repick then. This implements
+     * a form of mouse grabbing.
+     */
+
+    if (textPtr->flags & BUTTON_DOWN) {
+	if ((eventPtr->type != EnterNotify && eventPtr->type != LeaveNotify)
+		|| (eventPtr->xcrossing.mode != NotifyGrab
+		    && eventPtr->xcrossing.mode != NotifyUngrab)) {
+	    return;
+	}
+
+	/*
+	 * Special case: the window is being entered or left because of a
+	 * grab or ungrab. In this case, repick after all. Furthermore,
+	 * clear BUTTON_DOWN to release the simulated grab.
+	 */
+
+	textPtr->flags &= ~BUTTON_DOWN;
+    }
+
+    /*
+     * Save information about this event in the widget in case we have to
+     * synthesize more enter and leave events later (e.g. because a character
+     * was deleted, causing a new character to be underneath the mouse
+     * cursor). Also translate MotionNotify events into EnterNotify events,
+     * since that's what gets reported to event handlers when the current
+     * character changes.
+     */
+
+    if (eventPtr != &textPtr->pickEvent) {
+	if (eventPtr->type == MotionNotify || eventPtr->type == ButtonRelease) {
+	    textPtr->pickEvent.xcrossing.type = EnterNotify;
+	    textPtr->pickEvent.xcrossing.serial = eventPtr->xmotion.serial;
+	    textPtr->pickEvent.xcrossing.send_event = eventPtr->xmotion.send_event;
+	    textPtr->pickEvent.xcrossing.display = eventPtr->xmotion.display;
+	    textPtr->pickEvent.xcrossing.window = eventPtr->xmotion.window;
+	    textPtr->pickEvent.xcrossing.root = eventPtr->xmotion.root;
+	    textPtr->pickEvent.xcrossing.subwindow = None;
+	    textPtr->pickEvent.xcrossing.time = eventPtr->xmotion.time;
+	    textPtr->pickEvent.xcrossing.x = eventPtr->xmotion.x;
+	    textPtr->pickEvent.xcrossing.y = eventPtr->xmotion.y;
+	    textPtr->pickEvent.xcrossing.x_root = eventPtr->xmotion.x_root;
+	    textPtr->pickEvent.xcrossing.y_root = eventPtr->xmotion.y_root;
+	    textPtr->pickEvent.xcrossing.mode = NotifyNormal;
+	    textPtr->pickEvent.xcrossing.detail = NotifyNonlinear;
+	    textPtr->pickEvent.xcrossing.same_screen = eventPtr->xmotion.same_screen;
+	    textPtr->pickEvent.xcrossing.focus = False;
+	    textPtr->pickEvent.xcrossing.state = eventPtr->xmotion.state;
+	} else {
+	    textPtr->pickEvent = *eventPtr;
+	}
+    }
+
+    if (textPtr->dontRepick) {
+	return;
+    }
+
+    /*
+     * Find the new current character, then find and sort all of the tags associated with it.
+     */
+
+    numNewTags = 0;
+    newArrayPtr = NULL;
+
+    if (textPtr->pickEvent.type != LeaveNotify) {
+	sameChunkWithUnchangedTags = TkTextPixelIndex(textPtr,
+		textPtr->pickEvent.xcrossing.x, textPtr->pickEvent.xcrossing.y, &index, &nearby);
+
+	if (textPtr->currNearbyFlag != nearby) {
+	    sameChunkWithUnchangedTags = false;
+	    textPtr->currNearbyFlag = nearby;
+	} else if (nearby) {
+	    sameChunkWithUnchangedTags = true;
+	} else if (eventPtr->type != MotionNotify || sharedTextPtr->numMotionEventBindings > 0) {
+	    sameChunkWithUnchangedTags = false;
+	}
+
+	if (!nearby && !sameChunkWithUnchangedTags) {
+	    TkTextTag *tagPtr = TkBTreeGetTags(&index);
+	    if (tagPtr) {
+		epoch = ++sharedTextPtr->pickEpoch;
+		newArrayPtr = malloc(sharedTextPtr->numEnabledTags * sizeof(newArrayPtr[0]));
+		for (i = 0; i < textPtr->numCurTags; ++i) {
+		    textPtr->curTagArrayPtr[i]->flag = false; /* mark as *not* common */
+		    textPtr->curTagArrayPtr[i]->epoch = epoch;
+		}
+		for ( ; tagPtr; tagPtr = tagPtr->nextPtr) {
+		    newArrayPtr[numNewTags++] = tagPtr;
+		    tagPtr->flag = (tagPtr->epoch == epoch); /* is common? */
+		}
+		TkTextSortTags(numNewTags, newArrayPtr);
+	    }
+	}
+    }
+
+    if (!sameChunkWithUnchangedTags) {
+	/*
+	 * Resort the tags associated with the previous marked character (the
+	 * priorities might have changed), then make a copy of the new tags, and
+	 * compare the old tags to the copy, nullifying any tags that are present
+	 * in both groups (i.e. the tags that haven't changed).
+	 */
+
+	TkTextSortTags(textPtr->numCurTags, textPtr->curTagArrayPtr);
+	if (numNewTags > 0) {
+	    size = numNewTags * sizeof(copyArrayPtr[0]);
+	    if (size < sizeof(copyArrayBuffer)/sizeof(copyArrayBuffer[0])) {
+		copyArrayPtr = copyArrayBuffer;
+	    } else {
+		copyArrayPtr = memcpy(malloc(size), newArrayPtr, size);
+	    }
+	    memcpy(copyArrayPtr, newArrayPtr, size);
+
+	    /*
+	     * Omit common tags. Note that the complexity of this algorithm is linear,
+	     * the complexity of old implementation (wish8.6) was quadratic.
+	     */
+
+	    for (i = 0; i < textPtr->numCurTags; ++i) {
+		if (textPtr->curTagArrayPtr[i]->flag) {
+		    textPtr->curTagArrayPtr[i] = NULL;
+		}
+	    }
+	    for (i = 0; i < numNewTags; ++i) {
+		if (copyArrayPtr[i]->flag) {
+		    copyArrayPtr[i] = NULL;
+		}
+	    }
+	}
+
+	/*
+	 * Invoke the binding system with a LeaveNotify event for all of the tags
+	 * that have gone away. We have to be careful here, because it's possible
+	 * that the binding could do something (like calling tkwait) that
+	 * eventually modifies textPtr->curTagArrayPtr. To avoid problems in
+	 * situations like this, update curTagArrayPtr to its new value before
+	 * invoking any bindings, and don't use it any more here.
+	 */
+
+	numOldTags = textPtr->numCurTags;
+	textPtr->numCurTags = numNewTags;
+	oldArrayPtr = textPtr->curTagArrayPtr;
+	textPtr->curTagArrayPtr = newArrayPtr;
+
+	if (numOldTags > 0) {
+	    if (sharedTextPtr->tagBindingTable && !(textPtr->flags & DESTROYED)) {
+		event = textPtr->pickEvent;
+		event.type = LeaveNotify;
+
+		/*
+		 * Always use a detail of NotifyAncestor. Besides being
+		 * consistent, this avoids problems where the binding code will
+		 * discard NotifyInferior events.
+		 */
+
+		event.xcrossing.detail = NotifyAncestor;
+		TagBindEvent(textPtr, &event, numOldTags, oldArrayPtr);
+	    }
+	    free(oldArrayPtr);
+	}
+    }
+
+    if (textPtr->flags & DESTROYED) {
+	return;
+    }
+
+    /*
+     * Reset the "current" mark (be careful to recompute its location, since
+     * it might have changed during an event binding). Then invoke the binding
+     * system with an EnterNotify event for all of the tags that have just
+     * appeared.
+     */
+
+    TkTextPixelIndex(textPtr, textPtr->pickEvent.xcrossing.x, textPtr->pickEvent.xcrossing.y,
+	    &index, &nearby);
+
+    if (numNewTags > 0) {
+	if (sharedTextPtr->tagBindingTable) {
+	    assert(!nearby);
+	    event = textPtr->pickEvent;
+	    event.type = EnterNotify;
+	    event.xcrossing.detail = NotifyAncestor;
+	    TagBindEvent(textPtr, &event, numNewTags, copyArrayPtr);
+	}
+	if (copyArrayPtr != copyArrayBuffer) {
+	    free(copyArrayPtr);
+	}
+    }
+
+    if (textPtr->flags & DESTROYED) {
+	return;
+    }
+
+    /*
+     * We want to avoid that a cursor movement is constantly splitting and
+     * joining char segments. So we postpone the insertion of the "current"
+     * mark until TextWidgetObjCmd will be executed.
+     */
+
+    textPtr->currentMarkIndex = index;
+    TkTextIndexToByteIndex(&textPtr->currentMarkIndex);
+    textPtr->haveToSetCurrentMark = true;
+    sharedTextPtr->haveToSetCurrentMark = true;
+
+    if (textPtr->imageBboxTree && sharedTextPtr->imageBindingTable) {
+	/*
+	 * Trigger the Enter and Leave events for embedded images.
+	 * It's quite unlikely, but we have to consider that some images are overlapping.
+	 */
+
+	TkTextEmbImage *eiListPtr = NULL, *eiPtr;
+	unsigned countHoveredImages = 0;
+	int dx, dy;
+
+	event = textPtr->pickEvent;
+	switch (event.type) {
+	case EnterNotify: /* fallthru */
+	case LeaveNotify: event.xcrossing.detail = NotifyAncestor; break;
+	case FocusIn:     /* fallthru */
+	case FocusOut:    event.xfocus.detail = NotifyAncestor; break;
+	}
+	TkTextGetViewOffset(textPtr, &dx, &dy);
+	TkQTreeSearch(
+		textPtr->imageBboxTree,
+		eventPtr->xmotion.x + dx,
+		eventPtr->xmotion.y + dy,
+		ImageHitCallback,
+		(TkQTreeClientData) &eiListPtr);
+	for (i = 0; i < textPtr->hoveredImageArrSize; ++i) {
+	    textPtr->hoveredImageArr[i]->hovered = false;
+	}
+	for (eiPtr = eiListPtr; eiPtr; eiPtr = eiPtr->nextPtr, ++countHoveredImages) {
+	    eiPtr->hovered = true;
+	}
+	for (i = 0; i < textPtr->hoveredImageArrSize; ++i) {
+	    eiPtr = textPtr->hoveredImageArr[i];
+	    if (!eiPtr->hovered) {
+		assert(eiPtr->image);
+		event.type = LeaveNotify;
+		Tk_BindEvent(sharedTextPtr->imageBindingTable, &event,
+			textPtr->tkwin, 1, (ClientData *) &eiPtr->name);
+	    }
+	}
+	textPtr->hoveredImageArrSize = 0;
+	if (countHoveredImages > textPtr->hoveredImageArrCapacity) {
+	    textPtr->hoveredImageArrCapacity = MAX(4, 2*textPtr->hoveredImageArrCapacity);
+	    textPtr->hoveredImageArr = realloc(textPtr->hoveredImageArr,
+		textPtr->hoveredImageArrCapacity * sizeof(textPtr->hoveredImageArr[0]));
+	}
+	for (eiPtr = eiListPtr; eiPtr; eiPtr = eiPtr->nextPtr) {
+	    if (eiPtr->hovered) {
+		assert(eiPtr->image);
+		event.type = EnterNotify;
+		event.xcrossing.detail = NotifyAncestor;
+		Tk_BindEvent(sharedTextPtr->imageBindingTable, &event,
+			textPtr->tkwin, 1, (ClientData *) &eiPtr->name);
+		textPtr->hoveredImageArr[textPtr->hoveredImageArrSize++] = eiPtr;
+	    }
+	}
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TagBindEvent --
+ *
+ *	Trigger given events for all tags that match the relevant bindings.
+ *	To handle the "sel" tag correctly in all peer widgets, we must use the
+ *	name of the tags as the binding table element.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Almost anything can be triggered by tag bindings, including deletion
+ *	of the text widget.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+TagBindEvent(
+    TkText *textPtr,		/* Text widget to fire bindings in. */
+    XEvent *eventPtr,		/* What actually happened. */
+    unsigned numTags,		/* Number of relevant tags. */
+    TkTextTag **tagArrayPtr)	/* Array of relevant tags. */
+{
+    const char *nameArrayBuf[10];
+    const char **nameArrPtr;
+    unsigned i;
+
+    /*
+     * Try to avoid allocation unless there are lots of tags.
+     */
+
+    if (numTags > sizeof(nameArrayBuf) / sizeof(nameArrayBuf[0])) {
+	nameArrPtr = malloc(numTags * sizeof(nameArrPtr[0]));
+    } else {
+	nameArrPtr = nameArrayBuf;
+    }
+
+    /*
+     * We use tag names as keys in the hash table. We do this instead of using
+     * the actual tagPtr objects because we want one "sel" tag binding for all
+     * peer widgets, despite the fact that each has its own tagPtr object.
+     */
+
+    for (i = 0; i < numTags; ++i) {
+	TkTextTag *tagPtr = tagArrayPtr[i];
+
+	if (tagPtr) {
+	    nameArrPtr[i] = tagPtr->name;
+	} else {
+	    /*
+	     * Tag has been deleted elsewhere, and therefore nulled out in
+	     * this array. Tk_BindEvent is clever enough to cope with NULLs
+	     * being thrown at it.
+	     */
+
+	    nameArrPtr[i] = NULL;
+	}
+    }
+    Tk_BindEvent(textPtr->sharedTextPtr->tagBindingTable, eventPtr,
+	    textPtr->tkwin, numTags, (ClientData *) nameArrPtr);
+
+    if (nameArrPtr != nameArrayBuf) {
+	free(nameArrPtr);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EnumerateTags --
+ *
+ *	Implements the "tag enumerate" command, see documentation.
+ *
+ * Results:
+ *	A standard Tcl result.
+ *
+ * Side effects:
+ *	Memory is allocated for the result, if needed (standard Tcl result
+ *	side effects).
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkBitField *
+AddBits(
+    TkBitField *dst,		/* can be NULL */
+    const TkBitField *src)
+{
+    if (!dst) {
+	dst = TkBitResize(NULL, TkBitSize(src));
+    }
+    TkBitJoin(dst, src);
+    return dst;
+}
+
+static TkBitField *
+AddComplementBits(
+    TkBitField *dst,		/* can be NULL */
+    const TkBitField *src)
+{
+    if (!dst) {
+	dst = TkBitResize(NULL, TkBitSize(src));
+    }
+    TkBitComplementTo(dst, src);
+    return dst;
+}
+
+static TkBitField *
+AddSet(
+    const TkSharedText *sharedTextPtr,
+    TkBitField *dst,		/* can be NULL */
+    const TkTextTagSet *src)
+{
+    TkBitField *compl = TkTextTagSetToBits(src, TkBitSize(sharedTextPtr->usedTags));
+    
+    dst = AddBits(dst, compl);
+    TkBitDecrRefCount(compl);
+    return dst;
+}
+
+static TkBitField *
+AddComplementSet(
+    const TkSharedText *sharedTextPtr,
+    TkBitField *dst,		/* can be NULL */
+    const TkTextTagSet *src)
+{
+    TkBitField *compl = TkTextTagSetToBits(src, TkBitSize(sharedTextPtr->usedTags));
+    
+    dst = AddComplementBits(dst, compl);
+    TkBitDecrRefCount(compl);
+    return dst;
+}
+
+static int
+EnumerateTags(
+    Tcl_Interp *interp,
+    TkText *textPtr,
+    int objc,
+    Tcl_Obj *const *objv)
+{
+    static const char *const optStrings[] = {
+	"-all", "-discardselection", "-display", "-elide", "-geometry", "-lineheight",
+	"-nodisplay", "-noelide", "-nogeometry", "-nolineheight", "-noselection",
+	"-noundo", "-noused", "-selection", "-undo", "-unused", "-used", NULL
+    };
+    enum opts {
+	ENUM_ALL, ENUM_DISCARD_SELECTION, ENUM_DISPLAY, ENUM_ELIDE, ENUM_GEOEMTRY, ENUM_LINEHEIGHT,
+	ENUM_NO_DISPLAY, ENUM_NO_ELIDE, ENUM_NO_GEOMETRY, ENUM_NO_LINEHEIGHT, ENUM_NO_SELECTION,
+	ENUM_NO_UNDO, ENUM_NO_USED, ENUM_SELECTION, ENUM_UNDO, ENUM_UNUSED, ENUM_USED
+    };
+
+    const TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+    TkBitField *includeBits = NULL;
+    TkBitField *discardBits = NULL;
+    bool discardSelection = false;
+    TkTextTag **arrayPtr;
+    int index, countTags, i;
+
+    for (i = 3; i < objc; ++i) {
+	const char *option = Tcl_GetString(objv[i]);
+
+	if (*option != '-') {
+	    break;
+	}
+
+	if (Tcl_GetIndexFromObjStruct(interp, objv[i], optStrings, sizeof(char *),
+		"tag option", 0, &index) != TCL_OK) {
+	    if (includeBits) { TkBitDecrRefCount(includeBits); }
+	    if (discardBits) { TkBitDecrRefCount(discardBits); }
+	    return TCL_ERROR;
+	}
+
+	switch ((enum opts) index) {
+	case ENUM_ALL:
+	case ENUM_DISCARD_SELECTION:
+	    discardSelection = true;
+	    break;
+	case ENUM_DISPLAY:
+	    includeBits = AddBits(includeBits, sharedTextPtr->affectDisplayTags);
+	    break;
+	case ENUM_ELIDE:
+	    includeBits = AddBits(includeBits, sharedTextPtr->elisionTags);
+	    break;
+	case ENUM_GEOEMTRY:
+	    includeBits = AddBits(includeBits, sharedTextPtr->affectGeometryTags);
+	    break;
+	case ENUM_LINEHEIGHT:
+	    includeBits = AddBits(includeBits, sharedTextPtr->affectLineHeightTags);
+	    break;
+	case ENUM_NO_DISPLAY:
+	    discardBits = AddBits(discardBits, sharedTextPtr->affectDisplayTags);
+	    break;
+	case ENUM_NO_ELIDE:
+	    discardBits = AddBits(discardBits, sharedTextPtr->elisionTags);
+	    break;
+	case ENUM_NO_GEOMETRY:
+	    discardBits = AddBits(discardBits, sharedTextPtr->affectGeometryTags);
+	    break;
+	case ENUM_NO_LINEHEIGHT:
+	    discardBits = AddBits(discardBits, sharedTextPtr->affectLineHeightTags);
+	    break;
+	case ENUM_NO_SELECTION:
+	    discardSelection = true;
+	    break;
+	case ENUM_NO_UNDO:
+	    discardBits = AddComplementBits(discardBits, sharedTextPtr->dontUndoTags);
+	    break;
+	case ENUM_NO_USED:
+	    discardBits = AddComplementSet(sharedTextPtr, discardBits,
+		    TkBTreeRootTagInfo(sharedTextPtr->tree));
+	    break;
+	case ENUM_SELECTION:
+	    includeBits = AddBits(includeBits, sharedTextPtr->selectionTags);
+	    break;
+	case ENUM_UNDO:
+	    includeBits = AddComplementBits(includeBits, sharedTextPtr->dontUndoTags);
+	    break;
+	case ENUM_UNUSED:
+	    includeBits = AddComplementSet(sharedTextPtr, includeBits,
+		    TkBTreeRootTagInfo(sharedTextPtr->tree));
+	    break;
+	case ENUM_USED:
+	    includeBits = AddSet(sharedTextPtr, includeBits, TkBTreeRootTagInfo(sharedTextPtr->tree));
+	    break;
+	}
+    }
+
+    if (objc == i + 1) {
+	TkTextIndex index;
+	TkTextSegment *segPtr;
+	TkTextTagSet *tagInfoPtr;
+
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[i], &index)) {
+	    return TCL_ERROR;
+	}
+
+	segPtr = TkTextIndexGetContentSegment(&index, NULL);
+
+	if (!includeBits && !discardBits) {
+	    FindTags(interp, textPtr, segPtr, discardSelection);
+	    return TCL_OK;
+	}
+
+	TkTextTagSetIncrRefCount(tagInfoPtr = segPtr->tagInfoPtr);
+	if (includeBits) {
+	    tagInfoPtr = TkTextTagSetIntersectBits(tagInfoPtr, includeBits);
+	    TkBitDecrRefCount(includeBits);
+	}
+	includeBits = TkTextTagSetToBits(tagInfoPtr, TkBitSize(sharedTextPtr->usedTags));
+	TkTextTagSetDecrRefCount(tagInfoPtr);
+    } else if (objc > i) {
+	Tcl_WrongNumArgs(interp, 3, objv, "?options? ?index?");
+	return TCL_ERROR;
+    }
+
+    if (discardSelection) {
+	discardBits = AddBits(discardBits, sharedTextPtr->selectionTags);
+    }
+    if (!includeBits) {
+	if (discardBits) {
+	    includeBits = TkBitCopy(sharedTextPtr->usedTags, -1);
+	} else {
+	    TkBitIncrRefCount(includeBits = sharedTextPtr->usedTags);
+	}
+    }
+    if (discardBits) {
+	TkBitRemove(includeBits, discardBits);
+    }
+
+    arrayPtr = malloc(sharedTextPtr->numEnabledTags * sizeof(TkTextTag *));
+    countTags = 0;
+
+    for (i = TkBitFindFirst(includeBits); i != TK_BIT_NPOS; i = TkBitFindNext(includeBits, i)) {
+	arrayPtr[countTags++] = sharedTextPtr->tagLookup[i];
+    }
+
+    AppendTags(interp, countTags, arrayPtr);
+    free(arrayPtr);
+
+    TkBitDecrRefCount(includeBits);
+    if (discardBits) {
+	TkBitDecrRefCount(discardBits);
+    }
+
+    return TCL_OK;
+}
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 105
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: src/tktext/tkTextTagSet.c
===================================================================
--- src/tktext/tkTextTagSet.c	(revision 0)
+++ src/tktext/tkTextTagSet.c	(working copy)
@@ -0,0 +1,1738 @@
+/*
+ * tkTextTagSet.c --
+ *
+ *	This module implements a set for tagging information.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkTextTagSet.h"
+
+#if !(__STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900))
+# define _TK_NEED_IMPLEMENTATION
+# include "tkTextTagSetPriv.h"
+#endif
+
+#if !TK_TEXT_DONT_USE_BITFIELDS
+
+# include <assert.h>
+# include <string.h>
+
+# ifndef MAX
+#  define MAX(a,b) (((int) a) < ((int) b) ? b : a)
+# endif
+
+/*
+ * Don't use expensive checks for speed improvements. But probably these "expensive"
+ * checks aren't so much expensive? This needs more testing for a final decision.
+ */
+#define USE_EXPENSIVE_CHECKS 0
+
+
+static bool IsPowerOf2(unsigned n) { return !(n & (n - 1)); }
+
+
+static unsigned
+NextPowerOf2(
+    unsigned n)
+{
+    --n;
+    n |= n >> 1;
+    n |= n >> 2;
+    n |= n >> 4;
+    n |= n >> 8;
+    n |= n >> 16;
+
+#if !(UINT_MAX <= 4294967295u)
+    /* unsigned is 64 bit wide, this is unusual, but possible */
+    n |= n >> 32;
+#endif
+
+    return ++n;
+}
+
+
+static TkTextTagSet *
+ConvertToBitField(
+    TkTextTagSet *ts,
+    unsigned newSize)
+{
+    TkBitField *bf;
+    assert(ts->base.isSetFlag);
+    assert(ts->base.refCount > 0);
+    bf = TkBitFromSet(&ts->set, newSize);
+    TkIntSetDecrRefCount(&ts->set);
+    return (TkTextTagSet *) bf;
+}
+
+
+static TkTextTagSet *
+ConvertToIntSet(
+    TkTextTagSet *ts)
+{
+    TkIntSet *set;
+    assert(!ts->base.isSetFlag);
+    assert(ts->base.refCount > 0);
+    set = TkIntSetFromBits(&ts->bf);
+    TkBitDecrRefCount(&ts->bf);
+    return (TkTextTagSet *) set;
+}
+
+
+static TkTextTagSet *
+ConvertToEmptySet(
+    TkTextTagSet *ts)
+{
+    if (TkTextTagSetIsEmpty(ts)) {
+	return ts;
+    }
+    if (ts->base.refCount > 1) {
+	ts->base.refCount -= 1;
+	return (TkTextTagSet *) TkBitResize(NULL, 0);
+    }
+    if (ts->base.isSetFlag) {
+	return (TkTextTagSet *) TkIntSetClear(&ts->set);
+    }
+    TkBitClear(&ts->bf);
+    return ts;
+}
+
+
+static TkTextTagSet *
+Convert(
+    TkTextTagSet *ts)
+{
+    if (ts->base.isSetFlag) {
+	TkIntSetType size;
+
+	if (TkIntSetIsEmpty(&ts->set)) {
+	    return ts;
+	}
+
+	size = TkIntSetMax(&ts->set) + 1;
+
+	if (size <= TK_TEXT_SET_MAX_BIT_SIZE) {
+	    if (!IsPowerOf2(size)) {
+		size = NextPowerOf2(size);
+	    }
+	    return ConvertToBitField(ts, size);
+	}
+    } else if (TkBitSize(&ts->bf) > TK_TEXT_SET_MAX_BIT_SIZE) {
+	return ConvertToIntSet(ts);
+    }
+    return ts;
+}
+
+
+static TkBitField *
+MakeBitCopy(
+    TkTextTagSet *ts)
+{
+    assert(ts->base.refCount > 1);
+    assert(!ts->base.isSetFlag);
+
+    ts->base.refCount -= 1;
+    return TkBitCopy(&ts->bf, -1);
+}
+
+
+static TkIntSet *
+MakeIntSetCopy(
+    TkTextTagSet *ts)
+{
+    assert(ts->base.refCount > 1);
+    assert(ts->base.isSetFlag);
+
+    ts->base.refCount -= 1;
+    return TkIntSetCopy(&ts->set);
+}
+
+
+static TkTextTagSet *
+MakeBitCopyIfNeeded(
+    TkTextTagSet *ts)
+{
+    assert(ts->base.refCount > 0);
+    assert(!ts->base.isSetFlag);
+
+    return (TkTextTagSet *) (ts->base.refCount == 1 ? &ts->bf : MakeBitCopy(ts));
+}
+
+
+static TkIntSet *
+MakeIntSetCopyIfNeeded(
+    TkTextTagSet *ts)
+{
+    assert(ts->base.refCount > 0);
+    assert(ts->base.isSetFlag);
+
+    return ts->base.refCount == 1 ? &ts->set : MakeIntSetCopy(ts);
+}
+
+
+static TkIntSet *
+ToIntSet(
+    const TkTextTagSet *set)
+{
+    if (set->base.isSetFlag) {
+	return (TkIntSet *) &set->set;
+    }
+    return (TkIntSet *) TkIntSetFromBits(&((TkTextTagSet *) set)->bf);
+}
+
+
+TkBitField *
+TkTextTagSetToBits(
+    const TkTextTagSet *src,
+    int size)
+{
+    assert(src);
+
+    if (src->base.isSetFlag) {
+	return TkBitFromSet(&src->set, size < 0 ? TkIntSetMax(&src->set) + 1 : size);
+    }
+
+    if (size < 0 || TkBitSize(&src->bf) == size) {
+	((TkTextTagSet *) src)->base.refCount += 1;
+	return (TkBitField *) &src->bf;
+    }
+
+    return TkBitCopy(&src->bf, size);
+}
+
+
+void
+TkTextTagSetDestroy(
+    TkTextTagSet **tsPtr)
+{
+    assert(tsPtr);
+
+    if (*tsPtr) {
+	if ((*tsPtr)->base.isSetFlag) {
+	    TkIntSetDestroy((TkIntSet **) tsPtr);
+	} else {
+	    TkBitDestroy((TkBitField **) tsPtr);
+	}
+    }
+}
+
+
+TkTextTagSet *
+TkTextTagSetResize(
+    TkTextTagSet *ts,
+    unsigned newSize)
+{
+    assert(!ts || TkTextTagSetRefCount(ts) > 0);
+
+    if (!ts) {
+	ts = TkTextTagSetNew(newSize);
+	ts->base.refCount = 1;
+	return ts;
+    }
+    if (ts->base.isSetFlag) {
+	if (newSize <= TK_TEXT_SET_MAX_BIT_SIZE) {
+	    ts = ConvertToBitField(ts, newSize);
+	}
+    } else {
+	if (newSize <= TK_TEXT_SET_MAX_BIT_SIZE) {
+	    ts = (TkTextTagSet *) TkBitResize(&ts->bf, newSize);
+	} else {
+	    ts = ConvertToIntSet(ts);
+	}
+    }
+
+    return ts;
+}
+
+
+bool
+TkTextTagSetIsEqual_(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(ts1);
+    assert(ts2);
+    assert(ts1->base.isSetFlag || ts2->base.isSetFlag);
+
+    if (ts1->base.isSetFlag) {
+	if (ts2->base.isSetFlag) {
+	    return TkIntSetIsEqual(&ts1->set, &ts2->set);
+	}
+	return TkIntSetIsEqualBits(&ts1->set, &ts2->bf);
+    }
+    return TkIntSetIsEqualBits(&ts2->set, &ts1->bf);
+}
+
+
+bool
+TkTextTagSetContains_(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(ts1);
+    assert(ts2);
+    assert(ts1->base.isSetFlag || ts2->base.isSetFlag);
+
+    if (ts1->base.isSetFlag) {
+	if (ts2->base.isSetFlag) {
+	    return TkIntSetContains(&ts1->set, &ts2->set);
+	}
+	return TkIntSetContainsBits(&ts1->set, &ts2->bf);
+    }
+    return TkIntSetIsContainedBits(&ts2->set, &ts1->bf);
+}
+
+
+bool
+TkTextTagSetDisjunctive_(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(ts1);
+    assert(ts2);
+    assert(ts1->base.isSetFlag || ts2->base.isSetFlag);
+
+    if (ts1->base.isSetFlag) {
+	if (ts2->base.isSetFlag) {
+	    return TkIntSetDisjunctive(&ts1->set, &ts2->set);
+	}
+	return TkIntSetDisjunctiveBits(&ts1->set, &ts2->bf);
+    }
+    return TkIntSetDisjunctiveBits(&ts2->set, &ts1->bf);
+}
+
+
+bool
+TkTextTagSetIntersectionIsEqual_(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2,
+    const TkBitField *bf)
+{
+    assert(ts1);
+    assert(ts2);
+    assert(bf);
+    assert(ts1->base.isSetFlag || ts2->base.isSetFlag);
+
+    if (ts1->base.isSetFlag) {
+	if (ts2->base.isSetFlag) {
+	    return TkIntSetIntersectionIsEqual(&ts1->set, &ts2->set, bf);
+	}
+	return TkIntSetIntersectionIsEqualBits(&ts1->set, &ts2->bf, bf);
+    }
+    return TkIntSetIntersectionIsEqualBits(&ts2->set, &ts1->bf, bf);
+}
+
+
+TkTextTagSet *
+TkTextTagSetJoin(
+    TkTextTagSet *dst,
+    const TkTextTagSet *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (src == dst || TkTextTagSetIsEmpty(src)) {
+	return dst;
+    }
+
+    if (TkTextTagSetIsEmpty(dst)) {
+	TkTextTagSetIncrRefCount((TkTextTagSet *) src); /* mutable by definition */
+	TkTextTagSetDecrRefCount(dst);
+	return Convert((TkTextTagSet *) src);
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetContains(src, dst) || TkTextTagSetContains(dst, src)) {
+	return dst;
+    }
+#endif
+
+    if (src->base.isSetFlag | dst->base.isSetFlag) {
+	if (src->base.isSetFlag) {
+	    if (dst->base.isSetFlag) {
+		return (TkTextTagSet *) TkIntSetJoin(&dst->set, &src->set);
+	    }
+	    return (TkTextTagSet *) TkIntSetJoin(&ConvertToIntSet(dst)->set, &src->set);
+	}
+	return (TkTextTagSet *) TkIntSetJoinBits(&dst->set, &src->bf);
+    }
+
+    if (TkBitSize(&dst->bf) < TkBitSize(&src->bf)) {
+	TkTextTagSet *set = dst;
+	dst = (TkTextTagSet *) TkBitCopy(&src->bf, -1);
+	TkBitJoin(&dst->bf, &set->bf);
+	TkBitDecrRefCount(&set->bf);
+	return dst;
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitJoin(&dst->bf, &src->bf);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetJoin2(
+    TkTextTagSet *dst,
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(dst);
+    assert(ts1);
+    assert(ts2);
+
+    if (ts2 == dst || TkTextTagSetIsEmpty(ts2)) {
+	return TkTextTagSetJoin(dst, ts1);
+    }
+    if (ts1 == dst || ts1 == ts2 || TkTextTagSetIsEmpty(ts1)) {
+	return TkTextTagSetJoin(dst, ts2);
+    }
+    if (TkTextTagSetIsEmpty(dst)) {
+	TkTextTagSetIncrRefCount((TkTextTagSet *) ts1); /* mutable by definition */
+	TkTextTagSetDecrRefCount(dst);
+	return TkTextTagSetJoin((TkTextTagSet *) ts1, ts2);
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetContains(ts1, ts2) || TkTextTagSetContains(dst, ts2)) {
+	return TkTextTagSetJoin(dst, ts1);
+    }
+    if (TkTextTagSetContains(ts2, ts1) || TkTextTagSetContains(dst, ts1)) {
+	return TkTextTagSetJoin(dst, ts2);
+    }
+    if (TkTextTagSetContains(ts1, dst)) {
+	TkTextTagSetDecrRefCount(dst);
+	return TkTextTagSetJoin(TkTextTagSetCopy(ts1), ts2);
+    }
+    if (TkTextTagSetContains(ts2, dst)) {
+	TkTextTagSetDecrRefCount(dst);
+	return TkTextTagSetJoin(TkTextTagSetCopy(ts2), ts1);
+    }
+#endif
+
+    if (ts1->base.isSetFlag | ts2->base.isSetFlag | dst->base.isSetFlag) {
+	return TkTextTagSetJoin(TkTextTagSetJoin(dst, ts1), ts2);
+    }
+
+    if (TkBitSize(&ts1->bf) < TkBitSize(&ts2->bf)) {
+	const TkTextTagSet *tmp = ts1;
+	ts1 = ts2;
+	ts2 = tmp;
+    }
+    if (TkBitSize(&dst->bf) < TkBitSize(&ts1->bf)) {
+	TkTextTagSet *set = dst;
+	dst = (TkTextTagSet *) TkBitCopy(&ts1->bf, -1);
+	TkBitJoin2(&dst->bf, &set->bf, &ts2->bf);
+	TkBitDecrRefCount(&set->bf);
+	return dst;
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitJoin2(&dst->bf, &ts1->bf, &ts2->bf);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetIntersect(
+    TkTextTagSet *dst,
+    const TkTextTagSet *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (src == dst || TkTextTagSetIsEmpty(dst)) {
+	return dst;
+    }
+    if (TkTextTagSetIsEmpty(src)) {
+	TkTextTagSetIncrRefCount((TkTextTagSet *) src); /* mutable by definition */
+	TkTextTagSetDecrRefCount(dst);
+	return (TkTextTagSet *) src;
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetContains(dst, src)) {
+	return dst;
+    }
+    if (TkTextTagSetContains(src, dst)) {
+	TkTextTagSetIncrRefCount((TkTextTagSet *) src); /* mutable by definition */
+	TkTextTagSetDecrRefCount(dst);
+	return (TkTextTagSet *) src;
+    }
+#endif
+
+    if (src->base.isSetFlag | dst->base.isSetFlag) {
+	TkBitField *bf, *tmp;
+
+	assert(dst->base.refCount > 0);
+
+	if (src->base.isSetFlag) {
+	    if (dst->base.isSetFlag) {
+		return (TkTextTagSet *) TkIntSetIntersect(&dst->set, &src->set);
+	    }
+
+	    tmp = TkBitFromSet(&src->set, TkBitSize(&dst->bf));
+	    dst = MakeBitCopyIfNeeded(dst);
+	    TkBitIntersect(&dst->bf, tmp);
+	    TkBitDestroy(&tmp);
+	    return dst;
+	}
+
+	bf = TkBitCopy(&src->bf, -1);
+	tmp = TkBitFromSet(&dst->set, TkBitSize(&src->bf));
+	TkBitIntersect(bf, tmp);
+	TkBitDestroy(&tmp);
+	TkIntSetDecrRefCount(&dst->set);
+	return (TkTextTagSet *) bf;
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitIntersect(&dst->bf, &src->bf);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetIntersectBits(
+    TkTextTagSet *dst,
+    const TkBitField *src)
+{
+    assert(src);
+    assert(dst);
+
+    if ((const TkTextTagSet *) src == dst || TkTextTagSetIsEmpty(dst)) {
+	return dst;
+    }
+    if (TkBitNone(src)) {
+	TkTextTagSetIncrRefCount((TkTextTagSet *) src); /* mutable by definition */
+	TkTextTagSetDecrRefCount(dst);
+	return Convert((TkTextTagSet *) src);
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetContainsBits(dst, src)) {
+	return dst;
+    }
+    if (TkTextTagIsContainedInBits(dst, src)) {
+	TkBitIncrRefCount((TkBitField *) src); /* mutable by definition */
+	TkTextTagSetDecrRefCount(dst);
+	return (TkTextTagSet *) src;
+    }
+#endif
+
+    if (dst->base.isSetFlag) {
+	return Convert((TkTextTagSet *) TkIntSetIntersectBits(&dst->set, src));
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitIntersect(&dst->bf, src);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetRemove(
+    TkTextTagSet *dst,
+    const TkTextTagSet *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (TkTextTagSetIsEmpty(src) || TkTextTagSetIsEmpty(dst)) {
+	return dst;
+    }
+    if (src == dst) {
+	return ConvertToEmptySet(dst);
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetContains(src, dst)) {
+	return ConvertToEmptySet(dst);
+    }
+#endif
+
+    if (src->base.isSetFlag | dst->base.isSetFlag) {
+	TkBitField *bf;
+
+	assert(dst->base.refCount > 0);
+
+	if (dst->base.isSetFlag) {
+	    if (src->base.isSetFlag) {
+		return Convert((TkTextTagSet *) TkIntSetRemove(&dst->set, &src->set));
+	    }
+	    return Convert((TkTextTagSet *) TkIntSetRemoveBits(&dst->set, &src->bf));
+	}
+
+	bf = TkBitFromSet(&src->set, TkBitSize(&dst->bf));
+	dst = MakeBitCopyIfNeeded(dst);
+	TkBitRemove(&dst->bf, bf);
+	TkBitDestroy(&bf);
+	return dst;
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitRemove(&dst->bf, &src->bf);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetRemoveBits(
+    TkTextTagSet *dst,
+    const TkBitField *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (TkBitNone(src) || TkTextTagSetIsEmpty(dst)) {
+	return dst;
+    }
+    if ((const TkTextTagSet *) src == dst) {
+	return ConvertToEmptySet(dst);
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetIsContainedBits(dst, src)) {
+	return ConvertToEmptySet(dst);
+    }
+#endif
+
+    if (dst->base.isSetFlag) {
+	return Convert((TkTextTagSet *) TkIntSetRemoveBits(&dst->set, src));
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitRemove(&dst->bf, src);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetComplementTo(
+    TkTextTagSet *dst,
+    const TkTextTagSet *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (src == dst) {
+	return ConvertToEmptySet(dst);
+    }
+    if (TkTextTagSetIsEmpty(src) || TkTextTagSetIsEmpty(dst)) {
+	TkTextTagSetIncrRefCount((TkTextTagSet *) src); /* mutable by definition */
+	TkTextTagSetDecrRefCount(dst);
+	return (TkTextTagSet *) src;
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetContains(dst, src)) {
+	return ConvertToEmptySet(dst);
+    }
+#endif
+
+    if (src->base.isSetFlag | dst->base.isSetFlag) {
+	TkIntSet *set;
+
+	if (dst->base.isSetFlag) {
+	    if (src->base.isSetFlag) {
+		return Convert((TkTextTagSet *) TkIntSetComplementTo(&dst->set, &src->set));
+	    }
+	    return Convert((TkTextTagSet *) TkIntSetComplementToBits(&dst->set, &src->bf));
+	}
+
+	TkIntSetIncrRefCount((TkIntSet *) &src->set);
+	set = TkIntSetRemoveBits((TkIntSet *) &src->set, &dst->bf);
+	TkBitDecrRefCount(&dst->bf);
+	return Convert((TkTextTagSet *) set);
+    }
+
+    if (dst->base.refCount > 1 || TkBitSize(&dst->bf) < TkBitSize(&src->bf)) {
+	TkBitField *bf;
+
+	bf = TkBitCopy(&src->bf, -1);
+	TkBitRemove(bf, &dst->bf);
+	TkBitDecrRefCount(&dst->bf);
+	return (TkTextTagSet *) bf;
+    }
+    TkBitComplementTo(&dst->bf, &src->bf);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetJoinComplementTo(
+    TkTextTagSet *dst,
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(dst);
+    assert(ts1);
+    assert(ts2);
+
+    if (dst == ts2 || TkTextTagSetIsEmpty(ts2)) {
+	return dst;
+    }
+    if (TkTextTagSetIsEmpty(ts1)) {
+	return TkTextTagSetJoin(dst, ts2);
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetContains(dst, ts2) || TkTextTagSetContains(ts1, ts2)) {
+	return dst;
+    }
+    if (TkTextTagSetContains(dst, ts1)) {
+	return TkTextTagSetJoin(dst, ts2);
+    }
+    if (TkTextTagSetContains(ts2, dst)) {
+	TkTextTagSetDecrRefCount(dst);
+	return TkTextTagSetRemove(TkTextTagSetCopy(ts2), ts1);
+    }
+#endif
+
+    if (dst->base.isSetFlag | ts1->base.isSetFlag | ts2->base.isSetFlag) {
+	TkTextTagSet *tmp;
+
+	if (!(dst->base.isSetFlag | ts1->base.isSetFlag)) {
+	    TkBitField *bf2 = TkBitFromSet(&ts2->set, TkBitSize(&ts1->bf));
+
+	    dst = MakeBitCopyIfNeeded(dst);
+	    TkBitJoinComplementTo(&dst->bf, &ts1->bf, bf2);
+	    TkBitDestroy(&bf2);
+	    return dst;
+	}
+
+	tmp = TkTextTagSetRemove(TkTextTagSetCopy(ts2), ts1);
+	dst = TkTextTagSetJoin(dst, tmp);
+	TkTextTagSetDecrRefCount(tmp);
+	return dst;
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitJoinComplementTo(&dst->bf, &ts1->bf, &ts2->bf);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetJoinNonIntersection(
+    TkTextTagSet *dst,
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(dst);
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1 == ts2) {
+	return dst;
+    }
+    if (TkTextTagSetIsEmpty(ts1) && TkTextTagSetIsEmpty(ts2)) {
+	return dst;
+    }
+    if (dst == ts1 || TkTextTagSetIsEmpty(ts1)) {
+	return TkTextTagSetJoin(dst, ts2);
+    }
+    if (dst == ts2 || TkTextTagSetIsEmpty(ts2)) {
+	return TkTextTagSetJoin(dst, ts1);
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetIsEqual(ts1, ts2)) {
+	return dst;
+    }
+    if (TkTextTagSetContains(dst, ts1)) {
+	return TkTextTagSetJoin(dst, ts2);
+    }
+    if (TkTextTagSetContains(dst, ts2)) {
+	return TkTextTagSetJoin(dst, ts1);
+    }
+#endif
+
+    if (dst->base.isSetFlag | ts1->base.isSetFlag | ts2->base.isSetFlag) {
+	TkIntSet *set1, *set2;
+
+	dst = dst->base.isSetFlag ? (TkTextTagSet *) MakeIntSetCopyIfNeeded(dst) : ConvertToIntSet(dst);
+	set1 = ToIntSet(ts1);
+	set2 = ToIntSet(ts2);
+	dst = (TkTextTagSet *) TkIntSetJoinNonIntersection(&dst->set, set1, set2);
+	if (&ts1->set != set1) { TkIntSetDestroy(&set1); }
+	if (&ts2->set != set2) { TkIntSetDestroy(&set2); }
+	return Convert(dst);
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitJoinNonIntersection(&dst->bf, &ts1->bf, &ts2->bf);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetJoin2ComplementToIntersection(
+    TkTextTagSet *dst,
+    const TkTextTagSet *add,
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(dst);
+    assert(add);
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1 == ts2) {
+	return TkTextTagSetJoin(dst, add);
+    }
+    if (TkTextTagSetIsEmpty(ts1)) {
+	return TkTextTagSetJoin2(dst, add, ts2);
+    }
+    if (TkTextTagSetIsEmpty(ts2)) {
+	return TkTextTagSetJoin2(dst, add, ts1);
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetIsEqual(ts1, ts2)) {
+	return TkTextTagSetJoin(dst, add);
+    }
+    if (TkTextTagSetContains(dst, ts1) && TkTextTagSetContains(dst, ts2)) {
+	return TkTextTagSetJoin(dst, add);
+    }
+#endif
+
+    if (dst->base.isSetFlag | add->base.isSetFlag | ts1->base.isSetFlag | ts2->base.isSetFlag) {
+	TkIntSet *set1, *set2, *set3;
+
+	dst = dst->base.isSetFlag ? (TkTextTagSet *) MakeIntSetCopyIfNeeded(dst) : ConvertToIntSet(dst);
+	set1 = ToIntSet(add);
+	set2 = ToIntSet(ts1);
+	set3 = ToIntSet(ts2);
+	dst = (TkTextTagSet *) TkIntSetJoin2ComplementToIntersection(&dst->set, set1, set2, set3);
+	if (&add->set != set1) { TkIntSetDestroy(&set1); }
+	if (&ts1->set != set2) { TkIntSetDestroy(&set2); }
+	if (&ts2->set != set3) { TkIntSetDestroy(&set3); }
+	return dst;
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitJoin2ComplementToIntersection(&dst->bf, &add->bf, &ts1->bf, &ts2->bf);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetJoinOfDifferences(
+    TkTextTagSet *dst,
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(dst);
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1 == ts2) {
+	return TkTextTagSetRemove(dst, ts1);
+    }
+    if (dst == ts1) {
+	TkTextTagSetDecrRefCount(dst);
+	TkTextTagSetIncrRefCount((TkTextTagSet *) ts1); /* mutable due to concept */
+	return TkTextTagSetRemove((TkTextTagSet *) ts1, ts2);
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetIsEqual(ts1, ts2)) {
+	return TkTextTagSetRemove(dst, ts1);
+    }
+    if (TkTextTagSetContains(ts1, dst)) {
+	TkTextTagSetDecrRefCount(dst);
+	TkTextTagSetIncrRefCount(ts1);
+	return TkTextTagSetRemove(ts1, ts2);
+    }
+#endif
+
+    if (dst->base.isSetFlag | ts1->base.isSetFlag | ts2->base.isSetFlag) {
+	TkIntSet *set1, *set2;
+
+	dst = dst->base.isSetFlag ? (TkTextTagSet *) MakeIntSetCopyIfNeeded(dst) : ConvertToIntSet(dst);
+	set1 = ToIntSet(ts1);
+	set2 = ToIntSet(ts2);
+	dst = (TkTextTagSet *) TkIntSetJoinOfDifferences(&dst->set, set1, set2);
+	if (&ts1->set != set1) { TkIntSetDestroy(&set1); }
+	if (&ts2->set != set2) { TkIntSetDestroy(&set2); }
+	return Convert(dst);
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitJoinOfDifferences(&dst->bf, &ts1->bf, &ts2->bf);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetAdd(
+    TkTextTagSet *dst,
+    unsigned n)
+{
+    assert(dst);
+
+    if (dst->base.isSetFlag) {
+	return (TkTextTagSet *) TkIntSetAdd(MakeIntSetCopyIfNeeded(dst), n);
+    }
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitSet(&dst->bf, n);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetErase(
+    TkTextTagSet *dst,
+    unsigned n)
+{
+    assert(dst);
+
+    if (dst->base.isSetFlag) {
+	return (TkTextTagSet *) TkIntSetErase(MakeIntSetCopyIfNeeded(dst), n);
+    }
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitUnset(&dst->bf, n);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetTestAndSet(
+    TkTextTagSet *dst,
+    unsigned n)
+{
+    assert(dst);
+
+    if (dst->base.isSetFlag) {
+	if (dst->base.refCount <= 1) {
+	    return (TkTextTagSet *) TkIntSetTestAndSet(&dst->set, n);
+	}
+	if (TkIntSetTest(&dst->set, n)) {
+	    return NULL;
+	}
+	return (TkTextTagSet *) TkIntSetAdd(MakeIntSetCopy(dst), n);
+    }
+    if (dst->base.refCount <= 1) {
+	return TkBitTestAndSet(&dst->bf, n) ? dst : NULL;
+    }
+    if (TkBitTest(&dst->bf, n)) {
+	return NULL;
+    }
+    dst = (TkTextTagSet *) MakeBitCopy(dst);
+    TkBitSet(&dst->bf, n);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetTestAndUnset(
+    TkTextTagSet *dst,
+    unsigned n)
+{
+    assert(dst);
+
+    if (dst->base.isSetFlag) {
+	if (dst->base.refCount <= 1) {
+	    return (TkTextTagSet *) TkIntSetTestAndUnset(&dst->set, n);
+	}
+	if (!TkIntSetTest(&dst->set, n)) {
+	    return NULL;
+	}
+	return (TkTextTagSet *) TkIntSetErase(MakeIntSetCopy(dst), n);
+    }
+    if (dst->base.refCount <= 1) {
+	return TkBitTestAndUnset(&dst->bf, n) ? dst : NULL;
+    }
+    if (!TkBitTest(&dst->bf, n)) {
+	return NULL;
+    }
+    dst = (TkTextTagSet *) MakeBitCopy(dst);
+    TkBitUnset(&dst->bf, n);
+    return dst;
+}
+
+
+TkTextTagSet *
+TkTextTagSetClear(
+    TkTextTagSet *dst)
+{
+    assert(dst);
+
+    if (dst->base.isSetFlag) {
+	TkIntSetDecrRefCount(&dst->set);
+	return (TkTextTagSet *) TkBitResize(NULL, 0);
+    }
+    return ConvertToEmptySet(dst);
+}
+
+
+unsigned
+TkTextTagSetFindFirstInIntersection(
+    const TkTextTagSet *ts,
+    const TkBitField *bf)
+{
+    unsigned size, i;
+
+    assert(ts);
+    assert(bf);
+
+    if (!ts->base.isSetFlag) {
+	return TkBitFindFirstInIntersection(&ts->bf, bf);
+    }
+
+    if (!TkBitNone(bf)) {
+	size = TkIntSetSize(&ts->set);
+
+	for (i = 0; i < size; ++i) {
+	    TkIntSetType value = TkIntSetAccess(&ts->set, i);
+
+	    if (TkBitTest(bf, value)) {
+		return value;
+	    }
+	}
+    }
+
+    return TK_TEXT_TAG_SET_NPOS;
+}
+
+# if !NDEBUG
+
+void
+TkTextTagSetPrint(
+    const TkTextTagSet *set)
+{
+    if (!set) {
+	printf("<null>\n");
+    } else if (TkTextTagSetIsEmpty(set)) {
+	printf("<empty>\n");
+    } else if (set->base.isSetFlag) {
+	TkIntSetPrint(&set->set);
+    } else {
+	TkBitPrint(&set->bf);
+    }
+}
+
+# endif /* !NDEBUG */
+# if 0
+
+/*
+ * These functions are not needed anymore, but shouldn't be removed, because sometimes
+ * any of these functions might be useful.
+ */
+
+static unsigned
+MaxSize3(
+    const TkTextTagSet *ts1, const TkTextTagSet *ts2, const TkTextTagSet *ts3)
+{
+    return TkBitAdjustSize(MAX(TkTextTagSetRangeSize(ts1),
+	    MAX(TkTextTagSetRangeSize(ts2), TkTextTagSetRangeSize(ts3))));
+}
+
+
+static unsigned
+MaxSize4(
+    const TkTextTagSet *ts1, const TkTextTagSet *ts2,
+    const TkTextTagSet *ts3, const TkTextTagSet *ts4)
+{
+    return TkBitAdjustSize(MAX(TkTextTagSetRangeSize(ts1), MAX(TkTextTagSetRangeSize(ts2),
+	    MAX(TkTextTagSetRangeSize(ts3), TkTextTagSetRangeSize(ts4)))));
+}
+
+
+static TkBitField *
+GetBitField(
+    const TkTextTagSet *ts,
+    int size)
+{
+    assert(size == -1 || size >= TkTextTagSetRangeSize(ts));
+    assert(size == -1 || size == TkBitAdjustSize(size));
+
+    if (ts->base.isSetFlag) {
+	return TkBitFromSet(&ts->set, size);
+    }
+
+    if (size >= 0 && TkBitSize(&ts->bf) != size) {
+	return TkBitCopy(&ts->bf, size);
+    }
+
+    /* mutable due to concept */
+    TkBitIncrRefCount((TkBitField *) &ts->bf);
+    return (TkBitField *) &ts->bf;
+}
+
+
+TkTextTagSet *
+TkTextTagSetInnerJoinDifference(
+    TkTextTagSet *dst,
+    const TkTextTagSet *add,
+    const TkTextTagSet *sub)
+{
+    assert(dst);
+    assert(add);
+    assert(sub);
+
+    /* dst := (dst & add) + (add - sub) */
+
+    if (add == dst) {
+	return dst;
+    }
+    if (TkTextTagSetIsEmpty(add)) {
+	return TkTextTagSetClear(dst);
+    }
+    if (TkTextTagSetIsEqual(add, dst)) {
+	return dst;
+    }
+
+#if USE_EXPENSIVE_CHECKS
+    if (TkTextTagSetContains(dst, add)) {
+	return dst;
+    }
+    if (TkTextTagSetContains(add, dst) || TkTextTagSetContains(dst, sub)) {
+	TkTextTagSetIncrRefCount((TkTextTagSet *) add); /* mutable by definition */
+	TkTextTagSetDecrRefCount(dst);
+	return (TkTextTagSet *) add;
+    }
+    if (TkTextTagSetContains(sub, add) || TkTextTagSetContains(add, sub)) {
+	return TkTextTagSetIntersect(dst, add);
+    }
+#endif
+
+    if (dst->base.isSetFlag | add->base.isSetFlag | sub->base.isSetFlag) {
+	TkIntSet *set1, *set2, *res;
+
+	res = dst->base.isSetFlag ? TkIntSetCopy(&dst->set) : ConvertToIntSet(dst);
+	set1 = ToIntSet(add);
+	set2 = ToIntSet(sub);
+	res = TkIntSetInnerJoinDifference(res, set1, set2);
+	if (&add->set != set1) { TkIntSetDestroy(&set1); }
+	if (&sub->set != set2) { TkIntSetDestroy(&set2); }
+	return (TkTextTagSet *) res;
+    }
+
+    dst = MakeBitCopyIfNeeded(dst);
+    TkBitInnerJoinDifference(&dst->bf, &add->bf, &sub->bf);
+    return dst;
+}
+
+
+bool
+TkTextTagSetInnerJoinDifferenceIsEmpty(
+    const TkTextTagSet *ts,
+    const TkTextTagSet *add,
+    const TkTextTagSet *sub)
+{
+    TkBitField *bf, *bfAdd, *bfSub;
+    bool isEmpty;
+    unsigned n, size;
+
+    assert(ts);
+    assert(add);
+    assert(sub);
+
+    if (ts == add) {
+	return TkTextTagSetIsEmpty(ts);
+    }
+    if ((n = ts->base.isSetFlag + add->base.isSetFlag + sub->base.isSetFlag) == 0) {
+	return TkBitInnerJoinDifferenceIsEmpty(&ts->bf, &add->bf, &sub->bf);
+    }
+    if (n == 3) {
+	return TkIntSetInnerJoinDifferenceIsEmpty(&ts->set, &add->set, &sub->set);
+    }
+    if (TkTextTagSetIsEmpty(add)) {
+	return true;
+    }
+    if (TkTextTagSetIsEqual(ts, add)) {
+	return TkTextTagSetIsEmpty(add);
+    }
+
+    size = MaxSize3(ts, add, sub);
+    bf = GetBitField(ts, size);
+    bfAdd = GetBitField(add, size);
+    bfSub = GetBitField(sub, size);
+    isEmpty = TkBitInnerJoinDifferenceIsEmpty(bf, bfAdd, bfSub);
+    TkBitDecrRefCount(bf);
+    TkBitDecrRefCount(bfAdd);
+    TkBitDecrRefCount(bfSub);
+
+    return isEmpty;
+}
+
+
+bool
+TkTextTagSetIsEqualToDifference(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2,
+    const TkTextTagSet *sub2)
+{
+    TkBitField *bf1, *bf2, *bfSub;
+    bool isEqual;
+    unsigned n, size;
+
+    assert(ts1);
+    assert(ts2);
+    assert(sub2);
+
+    if ((n = ts1->base.isSetFlag + ts2->base.isSetFlag + sub2->base.isSetFlag) == 0) {
+	return TkBitIsEqualToDifference(&ts1->bf, &ts2->bf, &sub2->bf);
+    }
+    if (n == 3) {
+	return TkIntSetIsEqualToDifference(&ts1->set, &ts2->set, &sub2->set);
+    }
+    if (TkTextTagSetIsEmpty(ts2)) {
+	return TkTextTagSetIsEmpty(ts1);
+    }
+    if (TkTextTagSetIsEmpty(ts1)) {
+	return TkTextTagSetContains(sub2, ts2);
+    }
+
+    size = MaxSize3(ts1, ts2, sub2);
+    bf1 = GetBitField(ts1, size);
+    bf2 = GetBitField(ts2, size);
+    bfSub = GetBitField(sub2, size);
+    isEqual = TkBitIsEqualToDifference(bf1, bf2, bfSub);
+    TkBitDecrRefCount(bf1);
+    TkBitDecrRefCount(bf2);
+    TkBitDecrRefCount(bfSub);
+
+    return isEqual;
+}
+
+
+bool
+TkTextTagSetIsEqualToInnerJoin(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2,
+    const TkTextTagSet *add2)
+{
+    TkBitField *bf1, *bf2, *bfAdd;
+    bool isEqual;
+    unsigned n, size;
+
+    assert(ts1);
+    assert(ts2);
+    assert(add2);
+
+    if (ts1 == ts2) {
+	return true;
+    }
+    if ((n = ts1->base.isSetFlag + ts2->base.isSetFlag + add2->base.isSetFlag) == 0) {
+	return TkBitIsEqualToInnerJoin(&ts1->bf, &ts2->bf, &add2->bf);
+    }
+    if (n == 3) {
+	return TkIntSetIsEqualToInnerJoin(&ts1->set, &ts2->set, &add2->set);
+    }
+    if (TkTextTagSetIsEqual(ts2, add2)) {
+	return TkTextTagSetIsEqual(ts1, ts2);
+    }
+    if (TkTextTagSetIsEmpty(ts2)) {
+	return TkTextTagSetIsEmpty(ts1);
+    }
+    if (TkTextTagSetIsEqual(ts1, ts2)) {
+	return true;
+    }
+
+    size = MaxSize3(ts1, ts2, add2);
+    bf1 = GetBitField(ts1, size);
+    bf2 = GetBitField(ts2, size);
+    bfAdd = GetBitField(add2, size);
+    isEqual = TkBitIsEqualToInnerJoin(bf1, bf2, bfAdd);
+    TkBitDecrRefCount(bf1);
+    TkBitDecrRefCount(bf2);
+    TkBitDecrRefCount(bfAdd);
+
+    return isEqual;
+}
+
+
+bool
+TkTextTagSetIsEqualToInnerJoinDifference(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2,
+    const TkTextTagSet *add2,
+    const TkTextTagSet *sub2)
+{
+    TkBitField *bf1, *bf2, *bfAdd, *bfSub;
+    bool isEqual;
+    unsigned n, size;
+
+    assert(ts1);
+    assert(ts2);
+    assert(add2);
+    assert(sub2);
+
+    n = ts1->base.isSetFlag + ts2->base.isSetFlag + add2->base.isSetFlag + sub2->base.isSetFlag;
+
+    if (n == 0) {
+	return TkBitIsEqualToInnerJoinDifference(&ts1->bf, &ts2->bf, &add2->bf, &sub2->bf);
+    }
+    if (n == 4) {
+	return TkIntSetIsEqualToInnerJoinDifference(&ts1->set, &ts2->set, &add2->set, &sub2->set);
+    }
+    if (TkTextTagSetIsEmpty(add2)) {
+	return TkTextTagSetIsEmpty(ts1);
+    }
+    if (TkTextTagSetIsEmpty(sub2)) {
+	return TkTextTagSetIsEqualToInnerJoin(ts1, add2, ts2);
+    }
+
+    size = MaxSize4(ts1, ts2, add2, sub2);
+    bf1 = GetBitField(ts1, size);
+    bf2 = GetBitField(ts2, size);
+    bfAdd = GetBitField(add2, size);
+    bfSub = GetBitField(sub2, size);
+    isEqual = TkBitIsEqualToInnerJoinDifference(bf1, bf2, bfAdd, bfSub);
+    TkBitDecrRefCount(bf1);
+    TkBitDecrRefCount(bf2);
+    TkBitDecrRefCount(bfAdd);
+    TkBitDecrRefCount(bfSub);
+
+    return isEqual;
+}
+
+
+bool
+TkTextTagSetInnerJoinDifferenceIsEqual(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2,
+    const TkTextTagSet *add,
+    const TkTextTagSet *sub)
+{
+    TkBitField *bf1, *bf2, *bfAdd, *bfSub;
+    bool isEqual;
+    unsigned n, size;
+
+    assert(ts1);
+    assert(ts2);
+    assert(add);
+    assert(sub);
+
+    n = ts1->base.isSetFlag + ts2->base.isSetFlag + add->base.isSetFlag + sub->base.isSetFlag;
+
+    if (n == 0) {
+	return TkBitInnerJoinDifferenceIsEqual(&ts1->bf, &ts2->bf, &add->bf, &sub->bf);
+    }
+    if (n == 4) {
+	return TkIntSetInnerJoinDifferenceIsEqual(&ts1->set, &ts2->set, &add->set, &sub->set);
+    }
+    if (TkTextTagSetIsEmpty(add)) {
+	return true;
+    }
+
+    size = MaxSize4(ts1, ts2, add, sub);
+    bf1 = GetBitField(ts1, size);
+    bf2 = GetBitField(ts2, size);
+    bfAdd = GetBitField(add, size);
+    bfSub = GetBitField(sub, size);
+    isEqual = TkBitInnerJoinDifferenceIsEqual(bf1, bf2, bfAdd, bfSub);
+    TkBitDecrRefCount(bf1);
+    TkBitDecrRefCount(bf2);
+    TkBitDecrRefCount(bfAdd);
+    TkBitDecrRefCount(bfSub);
+
+    return isEqual;
+}
+
+# endif /* 0 */
+#else /* integer set only implementation **************************************/
+
+static TkIntSet *
+ConvertToEmptySet(
+    TkIntSet *ts)
+{
+    if (TkIntSetIsEmpty(ts)) {
+	return ts;
+    }
+    if (ts->refCount == 1) {
+	return TkIntSetClear(ts);
+    }
+    ts->refCount -= 1;
+    (ts = TkIntSetNew())->refCount = 1;
+    return ts;
+}
+
+
+static TkIntSet *
+MakeCopyIfNeeded(
+    TkIntSet *ts)
+{
+    assert(ts->refCount > 0);
+
+    if (ts->refCount == 1) {
+	return ts;
+    }
+    ts->refCount -= 1;
+    return TkIntSetCopy(ts);
+}
+
+
+TkBitField *
+TkTextTagSetToBits(
+    const TkTextTagSet *src,
+    int size)
+{
+    assert(src);
+    return TkBitFromSet(&src->set, size < 0 ? TkIntSetMax(&src->set) + 1 : size);
+}
+
+
+TkIntSet *
+TkTextTagSetJoin(
+    TkIntSet *dst,
+    const TkIntSet *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (src == dst || TkIntSetIsEmpty(src)) {
+	return dst;
+    }
+    if (TkIntSetIsEmpty(dst)) {
+	TkIntSetIncrRefCount((TkIntSet *) src); /* mutable by definition */
+	TkIntSetDecrRefCount(dst);
+	return (TkIntSet *) src;
+    }
+    return TkIntSetJoin(MakeCopyIfNeeded(dst), src);
+}
+
+
+TkIntSet *
+TkTextTagSetIntersect(
+    TkIntSet *dst,
+    const TkIntSet *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (src == dst || TkIntSetIsEmpty(dst)) {
+	return dst;
+    }
+    if (TkIntSetIsEmpty(src)) {
+	TkIntSetIncrRefCount((TkIntSet *) src); /* mutable by definition */
+	TkIntSetDecrRefCount(dst);
+	return (TkIntSet *) src;
+    }
+    return TkIntSetIntersect(MakeCopyIfNeeded(dst), src);
+}
+
+
+TkIntSet *
+TkTextTagSetRemove(
+    TkIntSet *dst,
+    const TkIntSet *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (TkIntSetIsEmpty(src) || TkIntSetIsEmpty(dst)) {
+	return dst;
+    }
+    if (src == dst) {
+	return ConvertToEmptySet(dst);
+    }
+    return TkIntSetRemove(MakeCopyIfNeeded(dst), src);
+}
+
+
+TkIntSet *
+TkTextTagSetIntersectBits(
+    TkIntSet *dst,
+    const TkBitField *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (TkIntSetIsEmpty(dst)) {
+	return dst;
+    }
+    if (TkBitNone(src)) {
+	TkIntSetIncrRefCount((TkIntSet *) src); /* mutable by definition */
+	TkIntSetDecrRefCount(dst);
+	return (TkIntSet *) src;
+    }
+    return TkIntSetIntersectBits(MakeCopyIfNeeded(dst), src);
+}
+
+
+TkIntSet *
+TkTextTagSetRemoveBits(
+    TkIntSet *dst,
+    const TkBitField *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (TkBitNone(src) || TkIntSetIsEmpty(dst)) {
+	return dst;
+    }
+    return TkIntSetRemoveBits(MakeCopyIfNeeded(dst), src);
+}
+
+
+TkIntSet *
+TkTextTagSetJoin2(
+    TkIntSet *dst,
+    const TkIntSet *ts1,
+    const TkIntSet *ts2)
+{
+    assert(dst);
+    assert(ts1);
+    assert(ts2);
+
+    if (ts2 == dst || TkIntSetIsEmpty(ts2)) {
+	return TkIntSetJoin(dst, ts1);
+    }
+    if (ts1 == dst || ts1 == ts2 || TkIntSetIsEmpty(ts1)) {
+	return TkIntSetJoin(dst, ts2);
+    }
+    if (TkIntSetIsEmpty(dst)) {
+	TkIntSetIncrRefCount((TkIntSet *) ts1); /* mutable by definition */
+	TkIntSetDecrRefCount(dst);
+	return TkIntSetJoin((TkIntSet *) ts1, ts2);
+    }
+    return TkIntSetJoin2(MakeCopyIfNeeded(dst), ts1, ts2);
+}
+
+
+TkIntSet *
+TkTextTagSetComplementTo(
+    TkIntSet *dst,
+    const TkIntSet *src)
+{
+    assert(src);
+    assert(dst);
+
+    if (src == dst) {
+	return ConvertToEmptySet(dst);
+    }
+    if (TkIntSetIsEmpty(src) || TkIntSetIsEmpty(dst)) {
+	TkIntSetIncrRefCount((TkIntSet *) src); /* mutable by definition */
+	TkIntSetDecrRefCount(dst);
+	return (TkIntSet *) src;
+    }
+    return TkIntSetComplementTo(MakeCopyIfNeeded(dst), src);
+}
+
+
+TkIntSet *
+TkTextTagSetJoinComplementTo(
+    TkIntSet *dst,
+    const TkIntSet *ts1,
+    const TkIntSet *ts2)
+{
+    assert(dst);
+    assert(ts1);
+    assert(ts2);
+
+    if (dst == ts2 || TkIntSetIsEmpty(ts2)) {
+	return dst;
+    }
+    if (TkIntSetIsEmpty(ts1)) {
+	return TkIntSetJoin(dst, ts2);
+    }
+    return TkIntSetJoinComplementTo(MakeCopyIfNeeded(dst), ts1, ts2);
+}
+
+
+TkIntSet *
+TkTextTagSetJoinNonIntersection(
+    TkIntSet *dst,
+    const TkIntSet *ts1,
+    const TkIntSet *ts2)
+{
+    assert(dst);
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1 == ts2) {
+	return dst;
+    }
+    if (dst == ts1 || TkIntSetIsEmpty(ts1)) {
+	return TkIntSetJoin(dst, ts2);
+    }
+    if (dst == ts2 || TkIntSetIsEmpty(ts2)) {
+	return TkIntSetJoin(dst, ts1);
+    }
+    return TkIntSetJoinNonIntersection(MakeCopyIfNeeded(dst), ts1, ts2);
+}
+
+
+TkIntSet *
+TkTextTagSetJoin2ComplementToIntersection(
+    TkIntSet *dst,
+    const TkIntSet *add,
+    const TkIntSet *ts1,
+    const TkIntSet *ts2)
+{
+    assert(dst);
+    assert(add);
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1 == ts2) {
+	return TkIntSetJoin(dst, add);
+    }
+    if (TkIntSetIsEmpty(ts1)) {
+	return TkIntSetJoin2(dst, add, ts2);
+    }
+    if (TkIntSetIsEmpty(ts2)) {
+	return TkIntSetJoin2(dst, add, ts1);
+    }
+    return TkIntSetJoin2ComplementToIntersection(MakeCopyIfNeeded(dst), add, ts1, ts2);
+}
+
+
+TkIntSet *
+TkTextTagSetAdd(
+    TkIntSet *dst,
+    unsigned n)
+{
+    assert(dst);
+    return TkIntSetAdd(MakeCopyIfNeeded(dst), n);
+}
+
+
+TkIntSet *
+TkTextTagSetErase(
+    TkIntSet *dst,
+    unsigned n)
+{
+    assert(dst);
+    return TkIntSetErase(MakeCopyIfNeeded(dst), n);
+}
+
+
+TkIntSet *
+TkTextTagSetTestAndSet(
+    TkIntSet *dst,
+    unsigned n)
+{
+    assert(dst);
+
+    if (dst->refCount <= 1) {
+	return TkIntSetTestAndSet(dst, n);
+    }
+    if (TkIntSetTest(dst, n)) {
+	return NULL;
+    }
+    dst->refCount -= 1;
+    return TkIntSetAdd(TkIntSetCopy(dst), n);
+}
+
+
+TkIntSet *
+TkTextTagSetTestAndUnset(
+    TkIntSet *dst,
+    unsigned n)
+{
+    assert(dst);
+
+    if (dst->refCount <= 1) {
+	return TkIntSetTestAndUnset(dst, n);
+    }
+    if (!TkIntSetTest(dst, n)) {
+	return NULL;
+    }
+    dst->refCount -= 1;
+    return TkIntSetErase(TkIntSetCopy(dst), n);
+}
+
+
+TkIntSet *
+TkTextTagSetJoinOfDifferences(
+    TkIntSet *dst,
+    const TkIntSet *ts1,
+    const TkIntSet *ts2)
+{
+    assert(dst);
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1 == ts2) {
+	return TkIntSetRemove(dst, ts1);
+    }
+    if (dst == ts1) {
+	TkIntSetDecrRefCount(dst);
+	TkIntSetIncrRefCount((TkIntSet *) ts1); /* mutable due to concept */
+	return TkIntSetRemove((TkIntSet *) ts1, ts2);
+    }
+    return TkIntSetJoinOfDifferences(MakeCopyIfNeeded(dst), ts1, ts2);
+}
+
+#endif  /* !TK_TEXT_USE_BITFIELDS */
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+/* Additionally we need stand-alone object code. */
+#define inline extern
+#if !TK_TEXT_DONT_USE_BITFIELDS
+inline TkTextTagSet *TkTextTagSetNew(unsigned size);
+inline unsigned TkTextTagSetRefCount(const TkTextTagSet *ts);
+inline void TkTextTagSetIncrRefCount(TkTextTagSet *ts);
+inline unsigned TkTextTagSetDecrRefCount(TkTextTagSet *ts);
+inline TkTextTagSet *TkTextTagSetCopy(const TkTextTagSet *src);
+inline bool TkTextTagSetIsEmpty(const TkTextTagSet *ts);
+inline bool TkTextTagSetIsBitField(const TkTextTagSet *ts);
+inline unsigned TkTextTagSetSize(const TkTextTagSet *ts);
+inline unsigned TkTextTagSetCount(const TkTextTagSet *ts);
+inline bool TkTextTagSetTest(const TkTextTagSet *ts, unsigned n);
+inline bool TkTextTagSetNone(const TkTextTagSet *ts);
+inline bool TkTextTagSetAny(const TkTextTagSet *ts);
+inline bool TkTextTagSetIsEqual(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+inline bool TkTextTagSetContains(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+inline bool TkTextTagSetDisjunctive(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+inline bool TkTextTagSetIntersects(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+inline bool TkTextTagSetIntersectionIsEqual(const TkTextTagSet *ts1, const TkTextTagSet *ts2,
+    const TkBitField *bf);
+inline bool TkTextTagBitContainsSet(const TkBitField *bf, const TkTextTagSet *ts);
+inline bool TkTextTagSetIsEqualBits(const TkTextTagSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetContainsBits(const TkTextTagSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetDisjunctiveBits(const TkTextTagSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetIntersectsBits(const TkTextTagSet *ts, const TkBitField *bf);
+inline unsigned TkTextTagSetFindFirst(const TkTextTagSet *ts);
+inline unsigned TkTextTagSetFindNext(const TkTextTagSet *ts, unsigned prev);
+inline TkTextTagSet *TkTextTagSetAddOrErase(TkTextTagSet *ts, unsigned n, bool value);
+inline unsigned TkTextTagSetRangeSize(const TkTextTagSet *ts);
+inline const unsigned char *TkTextTagSetData(const TkTextTagSet *ts);
+inline unsigned TkTextTagSetByteSize(const TkTextTagSet *ts);
+#else /* integer set only implementation **************************************/
+inline TkIntSet *TkTextTagSetNew(unsigned size);
+inline TkIntSet *TkTextTagSetResize(TkIntSet *ts, unsigned newSize);
+inline void TkTextTagSetDestroy(TkIntSet **tsPtr);
+inline unsigned TkTextTagSetRefCount(const TkIntSet *ts);
+inline void TkTextTagSetIncrRefCount(TkIntSet *ts);
+inline unsigned TkTextTagSetDecrRefCount(TkIntSet *ts);
+inline TkIntSet *TkTextTagSetCopy(const TkIntSet *src);
+inline bool TkTextTagSetIsEmpty(const TkIntSet *ts);
+inline bool TkTextTagSetIsBitField(const TkIntSet *ts);
+inline unsigned TkTextTagSetSize(const TkIntSet *ts);
+inline unsigned TkTextTagSetCount(const TkIntSet *ts);
+inline bool TkTextTagSetTest(const TkIntSet *ts, unsigned n);
+inline bool TkTextTagSetNone(const TkIntSet *ts);
+inline bool TkTextTagSetAny(const TkIntSet *ts);
+inline bool TkTextTagSetIsEqual(const TkIntSet *ts1, const TkIntSet *ts2);
+inline bool TkTextTagSetContains(const TkIntSet *ts1, const TkIntSet *ts2);
+inline bool TkTextTagSetDisjunctive(const TkIntSet *ts1, const TkIntSet *ts2);
+inline bool TkTextTagSetIntersects(const TkIntSet *ts1, const TkIntSet *ts2);
+inline bool TkTextTagSetIntersectionIsEqual(const TkIntSet *ts1, const TkIntSet *ts2,
+    const TkBitField *bf);
+inline bool TkTextTagBitContainsSet(const TkBitField *bf, const TkIntSet *ts);
+inline bool TkTextTagSetIsEqualBits(const TkIntSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetContainsBits(const TkIntSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetDisjunctiveBits(const TkIntSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetIntersectsBits(const TkIntSet *ts, const TkBitField *bf);
+inline unsigned TkTextTagSetFindFirst(const TkIntSet *ts);
+inline unsigned TkTextTagSetFindNext(const TkIntSet *ts, unsigned prev);
+inline unsigned TkTextTagSetFindFirstInIntersection(const TkIntSet *ts, const TkBitField *bf);
+inline TkIntSet *TkTextTagSetAddOrErase(TkIntSet *ts, unsigned n, bool value);
+inline TkIntSet *TkTextTagSetClear(TkIntSet *ts);
+inline unsigned TkTextTagSetRangeSize(const TkIntSet *ts);
+inline const unsigned char *TkTextTagSetData(const TkIntSet *ts);
+inline unsigned TkTextTagSetByteSize(const TkIntSet *ts);
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+#endif /* __STDC_VERSION__ >= 199901L */
+
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkTextTagSet.h
===================================================================
--- src/tktext/tkTextTagSet.h	(revision 0)
+++ src/tktext/tkTextTagSet.h	(working copy)
@@ -0,0 +1,292 @@
+/*
+ * tkTextTagSet.h --
+ *
+ *	This module implements a set for tagging information. The real type
+ *	is either a bit field, or a set of integers, depending on the size
+ *	of the tag set.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKTEXTTAGSET
+#define _TKTEXTTAGSET
+
+#include "tkBitField.h"
+#include "tkIntSet.h"
+
+#include <stdint.h>
+
+#if defined(__GNUC__) || defined(__clang__)
+# define __warn_unused__ __attribute__((warn_unused_result))
+#else
+# define __warn_unused__
+#endif
+
+#ifdef _MSC_VER
+# if _MSC_VER >= 1900
+#  define inline __inline
+# else
+#  define inline
+# endif
+#elif __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+/*
+ * Currently our implementation is using a shared bitfield/integer set implementation.
+ * Bitfields will be used as long as the number of tags is below a certain limit
+ * (will be satisfied in most applications), but in some sophisticated applications
+ * this limit will be exceeded, and in this case the integer set comes into play,
+ * because a bitfield is too memory hungry with a large number of tags. Bitfields
+ * are very, very fast, and integer sets are moderate in speed. So a bitfield will be
+ * preferred. Nevertheless this implementation might be a bit over the top, probably
+ * an implementation only with integer sets is already satisfactory.
+ *
+ * NOTE: The bit field implementation shouldn't be removed, even if this implementation
+ * will not be used, because it is required for testing the integer set (TkIntSet).
+ *
+ * We will use the compiler constant TK_TEXT_DONT_USE_BITFIELDS for the choice (with or
+ * without bitfields).
+ */
+
+/* This is common to both implementations. */
+# define TK_TEXT_TAG_SET_NPOS TK_SET_NPOS
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS /* shared implementation ****************************/
+
+/*
+ * The struct below is using C inheritance, this is portable due to C99 section
+ * 6.7.2.1 bullet point 13:
+ *
+ *	Within a structure object, the non-bit-field members and the units 
+ *	in which bit-fields reside have addresses that increase in the order
+ *	in which they are declared. A pointer to a structure object, suitably
+ *	converted, points to its initial member (or if that member is a
+ *	bit-field, then to the unit in which it resides), and vice versa.
+ *	There may be unnamed padding within a structure object, but not at
+ *	beginning.
+ *
+ * This inheritance concept is also used in the portable GTK library.
+ */
+
+typedef struct TkTextTagSetBase {
+    uint32_t refCount:31;
+    uint32_t isSetFlag:1;
+} TkTextTagSetBase;
+
+typedef union TkTextTagSet {
+    TkTextTagSetBase base;
+    TkBitField bf;
+    TkIntSet set;
+} TkTextTagSet;
+
+
+inline TkTextTagSet *TkTextTagSetNew(unsigned size) __warn_unused__;
+TkTextTagSet *TkTextTagSetResize(TkTextTagSet *ts, unsigned newSize) __warn_unused__;
+void TkTextTagSetDestroy(TkTextTagSet **tsPtr);
+
+inline unsigned TkTextTagSetRefCount(const TkTextTagSet *ts);
+inline void TkTextTagSetIncrRefCount(TkTextTagSet *ts);
+inline unsigned TkTextTagSetDecrRefCount(TkTextTagSet *ts);
+
+inline TkTextTagSet *TkTextTagSetCopy(const TkTextTagSet *src) __warn_unused__;
+TkBitField *TkTextTagSetToBits(const TkTextTagSet *src, int size) __warn_unused__;
+
+TkTextTagSet *TkTextTagSetJoin(TkTextTagSet *dst, const TkTextTagSet *src) __warn_unused__;
+TkTextTagSet *TkTextTagSetIntersect(TkTextTagSet *dst, const TkTextTagSet *src) __warn_unused__;
+TkTextTagSet *TkTextTagSetRemove(TkTextTagSet *dst, const TkTextTagSet *src) __warn_unused__;
+
+TkTextTagSet *TkTextTagSetIntersectBits(TkTextTagSet *dst, const TkBitField *src) __warn_unused__;
+TkTextTagSet *TkTextTagSetRemoveBits(TkTextTagSet *dst, const TkBitField *src) __warn_unused__;
+
+/* dst := dst + ts1 + ts2 */
+TkTextTagSet *TkTextTagSetJoin2(TkTextTagSet *dst, const TkTextTagSet *ts1, const TkTextTagSet *ts2)
+    __warn_unused__;
+/* dst := src - dst */
+TkTextTagSet *TkTextTagSetComplementTo(TkTextTagSet *dst, const TkTextTagSet *src) __warn_unused__;
+/* dst := dst + (ts2 - ts1) */
+TkTextTagSet *TkTextTagSetJoinComplementTo(TkTextTagSet *dst,
+    const TkTextTagSet *ts1, const TkTextTagSet *ts2) __warn_unused__;
+/* dst := dst + (ts1 - ts2) + (ts2 - ts1) */
+TkTextTagSet *TkTextTagSetJoinNonIntersection(TkTextTagSet *dst,
+    const TkTextTagSet *ts1, const TkTextTagSet *ts2) __warn_unused__;
+/* dst := dst + add + ((ts1 + ts2) - (ts1 & ts2)) */
+TkTextTagSet *TkTextTagSetJoin2ComplementToIntersection(TkTextTagSet *dst,
+    const TkTextTagSet *add, const TkTextTagSet *ts1, const TkTextTagSet *ts2) __warn_unused__;
+/* dst := (dst - ts1) + (ts1 - ts2) */
+TkTextTagSet *TkTextTagSetJoinOfDifferences(TkTextTagSet *dst, const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2) __warn_unused__;
+
+inline bool TkTextTagSetIsEmpty(const TkTextTagSet *ts);
+inline bool TkTextTagSetIsBitField(const TkTextTagSet *ts);
+
+inline unsigned TkTextTagSetSize(const TkTextTagSet *ts);
+inline unsigned TkTextTagSetCount(const TkTextTagSet *ts);
+
+inline bool TkTextTagSetTest(const TkTextTagSet *ts, unsigned n);
+inline bool TkTextTagSetNone(const TkTextTagSet *ts);
+inline bool TkTextTagSetAny(const TkTextTagSet *ts);
+
+inline bool TkTextTagSetIsEqual(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+inline bool TkTextTagSetContains(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+inline bool TkTextTagSetDisjunctive(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+inline bool TkTextTagSetIntersects(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+/* (ts1 & bf) == (ts2 & bf) */
+inline bool TkTextTagSetIntersectionIsEqual(const TkTextTagSet *ts1, const TkTextTagSet *ts2,
+    const TkBitField *bf);
+inline bool TkTextTagBitContainsSet(const TkBitField *bf, const TkTextTagSet *ts);
+
+inline bool TkTextTagSetIsEqualBits(const TkTextTagSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetContainsBits(const TkTextTagSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetDisjunctiveBits(const TkTextTagSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetIntersectsBits(const TkTextTagSet *ts, const TkBitField *bf);
+
+inline unsigned TkTextTagSetFindFirst(const TkTextTagSet *ts);
+inline unsigned TkTextTagSetFindNext(const TkTextTagSet *ts, unsigned prev);
+unsigned TkTextTagSetFindFirstInIntersection(const TkTextTagSet *ts, const TkBitField *bf);
+
+TkTextTagSet *TkTextTagSetAdd(TkTextTagSet *ts, unsigned n) __warn_unused__;
+TkTextTagSet *TkTextTagSetErase(TkTextTagSet *ts, unsigned n) __warn_unused__;
+inline TkTextTagSet *TkTextTagSetAddOrErase(TkTextTagSet *ts, unsigned n, bool value)
+    __warn_unused__;
+TkTextTagSet *TkTextTagSetTestAndSet(TkTextTagSet *ts, unsigned n) __warn_unused__;
+TkTextTagSet *TkTextTagSetTestAndUnset(TkTextTagSet *ts, unsigned n) __warn_unused__;
+TkTextTagSet *TkTextTagSetClear(TkTextTagSet *ts) __warn_unused__;
+
+inline unsigned TkTextTagSetRangeSize(const TkTextTagSet *ts);
+
+inline const unsigned char *TkTextTagSetData(const TkTextTagSet *ts);
+inline unsigned TkTextTagSetByteSize(const TkTextTagSet *ts);
+
+# if !NDEBUG
+void TkTextTagSetPrint(const TkTextTagSet *set);
+# endif
+
+
+# if 0
+
+/*
+ * These functions are not needed anymore, but shouldn't be removed, because sometimes
+ * any of these functions might be useful.
+ */
+
+/* dst := (dst + (ts - sub)) & ts */
+TkTextTagSet *TkTextTagSetInnerJoinDifference(TkTextTagSet *dst,
+    const TkTextTagSet *ts, const TkTextTagSet *sub) __warn_unused__;
+/* ((ts + (add - sub)) & add) == nil */
+bool TkTextTagSetInnerJoinDifferenceIsEmpty(const TkTextTagSet *ts,
+    const TkTextTagSet *add, const TkTextTagSet *sub);
+/* ts1 == ts2 - sub2 */
+bool TkTextTagSetIsEqualToDifference(const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2, const TkTextTagSet *sub2);
+/* ts1 == ts2 + (add2 & ts2) */
+bool TkTextTagSetIsEqualToInnerJoin(const TkTextTagSet *ts1, const TkTextTagSet *ts2,
+    const TkTextTagSet *add2);
+/* ts1 == ((ts2 + (add2 - sub2)) & add2) */
+bool TkTextTagSetIsEqualToInnerJoinDifference(const TkTextTagSet *ts1, const TkTextTagSet *ts2,
+    const TkTextTagSet *add2, const TkTextTagSet *sub2);
+/* ((ts1 + (add - sub)) & add) == ((ts2 + (add - sub)) & add) */
+bool TkTextTagSetInnerJoinDifferenceIsEqual(const TkTextTagSet *ts1, const TkTextTagSet *ts2,
+    const TkTextTagSet *add, const TkTextTagSet *sub);
+
+# endif /* 0 */
+
+#else /* integer set only implementation **************************************/
+
+# define TkTextTagSet TkIntSet
+
+inline TkIntSet *TkTextTagSetNew(unsigned size) __warn_unused__;
+inline TkIntSet *TkTextTagSetResize(TkIntSet *ts, unsigned newSize) __warn_unused__;
+inline void TkTextTagSetDestroy(TkIntSet **tsPtr);
+
+inline unsigned TkTextTagSetRefCount(const TkIntSet *ts);
+inline void TkTextTagSetIncrRefCount(TkIntSet *ts);
+inline unsigned TkTextTagSetDecrRefCount(TkIntSet *ts);
+
+inline TkIntSet *TkTextTagSetCopy(const TkIntSet *src) __warn_unused__;
+TkBitField *TkTextTagSetToBits(const TkTextTagSet *src, int size) __warn_unused__;
+
+TkIntSet *TkTextTagSetJoin(TkIntSet *dst, const TkIntSet *src) __warn_unused__;
+TkIntSet *TkTextTagSetIntersect(TkIntSet *dst, const TkIntSet *src) __warn_unused__;
+TkIntSet *TkTextTagSetRemove(TkIntSet *dst, const TkIntSet *src) __warn_unused__;
+
+TkIntSet *TkTextTagSetIntersectBits(TkIntSet *dst, const TkBitField *src) __warn_unused__;
+TkIntSet *TkTextTagSetRemoveBits(TkIntSet *dst, const TkBitField *src) __warn_unused__;
+
+/* dst := dst + ts1 + ts2 */
+TkIntSet *TkTextTagSetJoin2(TkIntSet *dst, const TkIntSet *ts1, const TkIntSet *ts2) __warn_unused__;
+/* dst := src - dst */
+TkIntSet *TkTextTagSetComplementTo(TkIntSet *dst, const TkIntSet *src) __warn_unused__;
+/* dst := dst + (bf2 - bf1) */
+TkIntSet *TkTextTagSetJoinComplementTo(TkIntSet *dst, const TkIntSet *ts1, const TkIntSet *ts2)
+    __warn_unused__;
+/* dst := dst + (set1 - set2) + (set2 - set1) */
+TkIntSet *TkTextTagSetJoinNonIntersection(TkIntSet *dst, const TkIntSet *ts1, const TkIntSet *ts2)
+    __warn_unused__;
+/* dst := dst + add + ((ts1 + ts2) - (ts1 & ts2)) */
+TkIntSet *TkTextTagSetJoin2ComplementToIntersection(TkIntSet *dst, const TkIntSet *add,
+    const TkIntSet *ts1, const TkIntSet *ts2) __warn_unused__;
+/* dst := (dst - ts1) + (ts1 - ts2) */
+TkIntSet *TkTextTagSetJoinOfDifferences(TkIntSet *dst, const TkIntSet *ts1, const TkIntSet *ts2)
+    __warn_unused__;
+
+inline bool TkTextTagSetIsEmpty(const TkIntSet *ts);
+inline bool TkTextTagSetIsBitField(const TkIntSet *ts);
+
+inline unsigned TkTextTagSetSize(const TkIntSet *ts);
+inline unsigned TkTextTagSetCount(const TkIntSet *ts);
+
+inline bool TkTextTagSetTest(const TkIntSet *ts, unsigned n);
+inline bool TkTextTagSetNone(const TkIntSet *ts);
+inline bool TkTextTagSetAny(const TkIntSet *ts);
+
+inline bool TkTextTagSetIsEqual(const TkIntSet *ts1, const TkIntSet *ts2);
+inline bool TkTextTagSetContains(const TkIntSet *ts1, const TkIntSet *ts2);
+inline bool TkTextTagSetDisjunctive(const TkIntSet *ts1, const TkIntSet *ts2);
+inline bool TkTextTagSetIntersects(const TkIntSet *ts1, const TkIntSet *ts2);
+/* (ts1 & bf) == (ts2 & bf) */
+inline bool TkTextTagSetIntersectionIsEqual(const TkIntSet *ts1, const TkIntSet *ts2,
+    const TkBitField *bf);
+inline bool TkTextTagBitContainsSet(const TkBitField *bf, const TkIntSet *ts);
+
+inline bool TkTextTagSetIsEqualBits(const TkIntSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetContainsBits(const TkIntSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetDisjunctiveBits(const TkIntSet *ts, const TkBitField *bf);
+inline bool TkTextTagSetIntersectsBits(const TkIntSet *ts, const TkBitField *bf);
+
+inline unsigned TkTextTagSetFindFirst(const TkIntSet *ts);
+inline unsigned TkTextTagSetFindNext(const TkIntSet *ts, unsigned prev);
+inline unsigned TkTextTagSetFindFirstInIntersection(const TkIntSet *ts, const TkBitField *bf);
+
+TkIntSet *TkTextTagSetAdd(TkIntSet *ts, unsigned n) __warn_unused__;
+TkIntSet *TkTextTagSetErase(TkIntSet *ts, unsigned n) __warn_unused__;
+inline TkIntSet *TkTextTagSetAddOrErase(TkIntSet *ts, unsigned n, bool value) __warn_unused__;
+TkIntSet *TkTextTagSetTestAndSet(TkIntSet *ts, unsigned n) __warn_unused__;
+TkIntSet *TkTextTagSetTestAndUnset(TkIntSet *ts, unsigned n) __warn_unused__;
+inline TkIntSet *TkTextTagSetClear(TkIntSet *ts) __warn_unused__;
+
+inline unsigned TkTextTagSetRangeSize(const TkIntSet *ts);
+
+inline const unsigned char *TkTextTagSetData(const TkIntSet *ts);
+inline unsigned TkTextTagSetByteSize(const TkIntSet *ts);
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+
+
+#undef __warn_unused__
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+# define _TK_NEED_IMPLEMENTATION
+# include "tkTextTagSetPriv.h"
+# undef _TK_NEED_IMPLEMENTATION
+#else
+# undef inline
+#endif
+
+#endif /* _TKTEXTTAGSET */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkTextTagSetPriv.h
===================================================================
--- src/tktext/tkTextTagSetPriv.h	(revision 0)
+++ src/tktext/tkTextTagSetPriv.h	(working copy)
@@ -0,0 +1,499 @@
+/*
+ * tkTextTagSetPriv.h --
+ *
+ *	Private implementation.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKTEXTTAGSET
+# error "do not include this private header file"
+#endif
+
+
+#ifndef _TKTEXTTAGSETPRIV
+#define _TKTEXTTAGSETPRIV
+
+#if !TK_TEXT_DONT_USE_BITFIELDS /* shared implementation ****************************/
+
+/*
+ * The constant TK_TEXT_SET_MAX_BIT_SIZE is defining the upper bound of
+ * the bit size in bit fields. This means that if more than TK_TEXT_SET_MAX_BIT_SIZE
+ * tags are in usage, the tag set is using integer sets instead of bit fields,
+ * because large bit fields are exploding the memory usage.
+ *
+ * The constant TK_TEXT_SET_MAX_BIT_SIZE must be a multiple of TK_BIT_NBITS.
+ */
+
+#ifdef TCL_WIDE_INT_IS_LONG
+
+/*
+ * On 64 bit systems this is the optimal size and it is not recommended to
+ * choose a lower size.
+ */
+# define TK_TEXT_SET_MAX_BIT_SIZE (((512 + TK_BIT_NBITS - 1)/TK_BIT_NBITS)*TK_BIT_NBITS)
+
+#else /* TCL_WIDE_INT_IS_LONG */
+
+/*
+ * On 32 bit systems the current size (512) might be too large. If so it should
+ * be reduced to 256, but it is not recommended to define a lower constant than
+ * 256.
+ */
+# define TK_TEXT_SET_MAX_BIT_SIZE (((512 + TK_BIT_NBITS - 1)/TK_BIT_NBITS)*TK_BIT_NBITS)
+
+#endif /* TCL_WIDE_INT_IS_LONG */
+
+
+MODULE_SCOPE bool TkTextTagSetIsEqual_(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+MODULE_SCOPE bool TkTextTagSetContains_(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+MODULE_SCOPE bool TkTextTagSetDisjunctive_(const TkTextTagSet *ts1, const TkTextTagSet *ts2);
+MODULE_SCOPE bool TkTextTagSetIntersectionIsEqual_(const TkTextTagSet *ts1, const TkTextTagSet *ts2,
+		    const TkBitField *bf);
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+#endif /* _TKTEXTTAGSETPRIV */
+
+
+#ifdef _TK_NEED_IMPLEMENTATION
+
+#ifndef _TK
+#include "tk.h"
+#endif
+
+#include <assert.h>
+
+#if __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+#if !TK_TEXT_DONT_USE_BITFIELDS /* shared implementation ****************************/
+
+inline
+TkTextTagSet *
+TkTextTagSetNew(
+    unsigned size)
+{
+    if (size <= TK_TEXT_SET_MAX_BIT_SIZE) {
+	return (TkTextTagSet *) TkBitNew(size);
+    }
+    return (TkTextTagSet *) TkIntSetNew();
+}
+
+
+inline
+unsigned
+TkTextTagSetRefCount(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return ts->base.refCount;
+}
+
+
+inline
+void
+TkTextTagSetIncrRefCount(
+    TkTextTagSet *ts)
+{
+    assert(ts);
+    ts->base.refCount += 1;
+}
+
+
+inline
+unsigned
+TkTextTagSetDecrRefCount(
+    TkTextTagSet *ts)
+{
+    unsigned refCount;
+
+    assert(ts);
+    assert(TkTextTagSetRefCount(ts) > 0);
+
+    if ((refCount = --ts->base.refCount) == 0) {
+	TkTextTagSetDestroy(&ts);
+    }
+    return refCount;
+}
+
+
+inline
+bool
+TkTextTagSetIsEmpty(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return ts->base.isSetFlag ? TkIntSetIsEmpty(&ts->set) : TkBitNone(&ts->bf);
+}
+
+
+inline
+bool
+TkTextTagSetIsBitField(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return !ts->base.isSetFlag;
+}
+
+
+inline
+unsigned
+TkTextTagSetSize(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return ts->base.isSetFlag ? TK_TEXT_TAG_SET_NPOS - 1 : TkBitSize(&ts->bf);
+}
+
+
+inline
+unsigned
+TkTextTagSetRangeSize(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+
+    if (!ts->base.isSetFlag) {
+	return TkBitSize(&ts->bf);
+    }
+    return TkIntSetIsEmpty(&ts->set) ? 0 : TkIntSetMax(&ts->set) + 1;
+}
+
+
+inline
+unsigned
+TkTextTagSetCount(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return ts->base.isSetFlag ? TkIntSetSize(&ts->set) : TkBitCount(&ts->bf);
+}
+
+
+inline
+bool
+TkTextTagSetIsEqual(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1->base.isSetFlag || ts2->base.isSetFlag) {
+	return TkTextTagSetIsEqual_(ts1, ts2);
+    }
+    return TkBitIsEqual(&ts1->bf, &ts2->bf);
+}
+
+
+inline
+bool
+TkTextTagSetContains(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1->base.isSetFlag || ts2->base.isSetFlag) {
+	return TkTextTagSetContains_(ts1, ts2);
+    }
+    return TkBitContains(&ts1->bf, &ts2->bf);
+}
+
+
+inline
+bool
+TkTextTagSetDisjunctive(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1->base.isSetFlag || ts2->base.isSetFlag) {
+	return TkTextTagSetDisjunctive_(ts1, ts2);
+    }
+    return TkBitDisjunctive(&ts1->bf, &ts2->bf);
+}
+
+
+inline
+bool
+TkTextTagSetIntersects(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2)
+{
+    return !TkTextTagSetDisjunctive(ts1, ts2);
+}
+
+
+inline
+bool
+TkTextTagSetIntersectionIsEqual(
+    const TkTextTagSet *ts1,
+    const TkTextTagSet *ts2,
+    const TkBitField *bf)
+{
+    assert(ts1);
+    assert(ts2);
+
+    if (ts1->base.isSetFlag || ts2->base.isSetFlag) {
+	return TkTextTagSetIntersectionIsEqual_(ts1, ts2, bf);
+    }
+    return TkBitIntersectionIsEqual(&ts1->bf, &ts2->bf, bf);
+}
+
+
+inline
+bool
+TkTextTagBitContainsSet(
+    const TkBitField *bf,
+    const TkTextTagSet *ts)
+{
+    return ts->base.isSetFlag ? TkIntSetIsContainedBits(&ts->set, bf) : TkBitContains(bf, &ts->bf);
+}
+
+
+inline
+bool
+TkTextTagSetIsEqualBits(
+    const TkTextTagSet *ts,
+    const TkBitField *bf)
+{
+    assert(ts);
+    assert(bf);
+    return ts->base.isSetFlag ? TkIntSetIsEqualBits(&ts->set, bf) : TkBitIsEqual(&ts->bf, bf);
+}
+
+
+inline
+bool
+TkTextTagSetContainsBits(
+    const TkTextTagSet *ts,
+    const TkBitField *bf)
+{
+    assert(ts);
+    assert(bf);
+    return ts->base.isSetFlag ? TkIntSetContainsBits(&ts->set, bf) : TkBitContains(&ts->bf, bf);
+}
+
+
+inline
+bool
+TkTextTagSetDisjunctiveBits(
+    const TkTextTagSet *ts,
+    const TkBitField *bf)
+{
+    assert(ts);
+    assert(bf);
+    return ts->base.isSetFlag ? TkIntSetDisjunctiveBits(&ts->set, bf) : TkBitDisjunctive(&ts->bf, bf);
+}
+
+
+inline
+bool
+TkTextTagSetIntersectsBits(
+    const TkTextTagSet *ts,
+    const TkBitField *bf)
+{
+    return !TkTextTagSetDisjunctiveBits(ts, bf);
+}
+
+
+inline
+bool
+TkTextTagSetTest(
+    const TkTextTagSet *ts,
+    unsigned n)
+{
+    assert(ts);
+
+    if (ts->base.isSetFlag) {
+	return TkIntSetTest(&ts->set, n);
+    }
+    return n < TkBitSize(&ts->bf) && TkBitTest(&ts->bf, n);
+}
+
+
+inline
+bool
+TkTextTagSetNone(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return ts->base.isSetFlag ? TkIntSetNone(&ts->set) : TkBitNone(&ts->bf);
+}
+
+
+inline
+bool
+TkTextTagSetAny(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return ts->base.isSetFlag ? TkIntSetAny(&ts->set) : TkBitAny(&ts->bf);
+}
+
+
+inline
+TkTextTagSet *
+TkTextTagSetCopy(
+    const TkTextTagSet *src)
+{
+    assert(src);
+
+    if (src->base.isSetFlag) {
+	return (TkTextTagSet *) TkIntSetCopy(&src->set);
+    }
+    return (TkTextTagSet *) TkBitCopy(&src->bf, -1);
+}
+
+
+inline
+unsigned
+TkTextTagSetFindFirst(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return ts->base.isSetFlag ? TkIntSetFindFirst(&ts->set) : TkBitFindFirst(&ts->bf);
+}
+
+
+inline
+unsigned
+TkTextTagSetFindNext(
+    const TkTextTagSet *ts,
+    unsigned prev)
+{
+    assert(ts);
+    return ts->base.isSetFlag ? TkIntSetFindNext(&ts->set) :  TkBitFindNext(&ts->bf, prev);
+}
+
+
+inline
+TkTextTagSet *
+TkTextTagSetAddOrErase(
+    TkTextTagSet *ts,
+    unsigned n,
+    bool value)
+{
+    assert(ts);
+    return value ? TkTextTagSetAdd(ts, n) : TkTextTagSetErase(ts, n);
+}
+
+
+inline
+const unsigned char *
+TkTextTagSetData(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return ts->base.isSetFlag ? TkIntSetData(&ts->set) : TkBitData(&ts->bf);
+}
+
+
+inline
+unsigned
+TkTextTagSetByteSize(
+    const TkTextTagSet *ts)
+{
+    assert(ts);
+    return ts->base.isSetFlag ? TkIntSetByteSize(&ts->set) : TkBitByteSize(&ts->bf);
+}
+
+#else /* integer set only implementation **************************************/
+
+inline TkIntSet *TkTextTagSetNew(unsigned size) { return TkIntSetNew(); }
+
+inline TkIntSet *TkTextTagSetResize(TkIntSet *ts, unsigned newSize)
+{ if (!ts) { (ts = TkIntSetNew())->refCount = 1; }; return ts; }
+
+inline void TkTextTagSetDestroy(TkIntSet **tsPtr) { TkIntSetDestroy(tsPtr); }
+
+inline unsigned TkTextTagSetRefCount(const TkIntSet *ts) { return TkIntSetRefCount(ts); }
+
+inline void TkTextTagSetIncrRefCount(TkIntSet *ts) { TkIntSetIncrRefCount(ts); }
+
+inline unsigned TkTextTagSetDecrRefCount(TkIntSet *ts) { return TkIntSetDecrRefCount(ts); }
+
+inline TkIntSet *TkTextTagSetCopy(const TkIntSet *src) { return TkIntSetCopy(src); }
+
+inline bool TkTextTagSetIsEmpty(const TkIntSet *ts) { return TkIntSetIsEmpty(ts); }
+
+inline bool TkTextTagSetIsBitField(const TkIntSet *ts) { assert(ts); return true; }
+
+inline unsigned TkTextTagSetSize(const TkIntSet *ts) { return TK_TEXT_TAG_SET_NPOS - 1; }
+
+inline unsigned TkTextTagSetCount(const TkIntSet *ts) { return TkIntSetSize(ts); }
+
+inline bool TkTextTagSetTest(const TkIntSet *ts, unsigned n) { return TkIntSetTest(ts, n); }
+
+inline bool TkTextTagSetNone(const TkIntSet *ts) { return TkIntSetNone(ts); }
+
+inline bool TkTextTagSetAny(const TkIntSet *ts) { return TkIntSetAny(ts); }
+
+inline bool TkTextTagSetIsEqual(const TkIntSet *ts1, const TkIntSet *ts2)
+{ return TkIntSetIsEqual(ts1, ts2); }
+
+inline bool TkTextTagSetContains(const TkIntSet *ts1, const TkIntSet *ts2)
+{ return TkIntSetContains(ts1, ts2); }
+
+inline bool TkTextTagSetDisjunctive(const TkIntSet *ts1, const TkIntSet *ts2)
+{ return TkIntSetDisjunctive(ts1, ts2); }
+
+inline bool TkTextTagSetIntersects(const TkIntSet *ts1, const TkIntSet *ts2)
+{ return TkIntSetIntersects(ts1, ts2); }
+
+inline bool TkTextTagSetIntersectionIsEqual(const TkIntSet *ts1, const TkIntSet *ts2,
+    const TkBitField *src)
+{ return TkIntSetIntersectionIsEqual(ts1, ts2, src); }
+
+inline bool TkTextTagBitContainsSet(const TkBitField *bf, const TkIntSet *ts)
+{ return TkIntSetIsContainedBits(ts, bf); }
+
+inline bool TkTextTagSetIsEqualBits(const TkIntSet *ts, const TkBitField *bf)
+{ return TkIntSetIsEqualBits(ts, bf); }
+
+inline bool TkTextTagSetContainsBits(const TkIntSet *ts, const TkBitField *bf)
+{ return TkIntSetContainsBits(ts, bf); }
+
+inline bool TkTextTagSetDisjunctiveBits(const TkIntSet *ts, const TkBitField *bf)
+{ return TkIntSetDisjunctiveBits(ts, bf); }
+
+inline bool TkTextTagSetIntersectsBits(const TkIntSet *ts, const TkBitField *bf)
+{ return !TkTextTagSetDisjunctiveBits(ts, bf); }
+
+inline unsigned TkTextTagSetFindFirst(const TkIntSet *ts) { return TkIntSetFindFirst(ts); }
+
+inline unsigned TkTextTagSetFindNext(const TkIntSet *ts, unsigned prev)
+{ return TkIntSetFindNext(ts); }
+
+inline unsigned TkTextTagSetFindFirstInIntersection(const TkIntSet *ts, const TkBitField *bf)
+{ return TkIntSetFindFirstInIntersection(ts, bf); }
+
+inline TkIntSet *TkTextTagSetAddOrErase(TkIntSet *ts, unsigned n, bool value)
+{ return value ? TkTextTagSetAdd(ts, n) : TkTextTagSetErase(ts, n); }
+
+inline TkIntSet *TkTextTagSetClear(TkIntSet *ts) { return TkIntSetClear(ts); }
+
+inline unsigned TkTextTagSetRangeSize(const TkIntSet *ts)
+{ return TkIntSetIsEmpty(ts) ? 0 : TkIntSetMax(ts) + 1; }
+
+inline unsigned char *TkTextTagSetData(const TkTextTagSet *ts)
+{ assert(ts); return TkIntSetData(&ts->set); }
+
+inline unsigned
+TkTextTagSetByteSize(const TkTextTagSet *ts)
+{ assert(ts); return TkIntSetByteSize(&ts->set); }
+
+#endif /* !TK_TEXT_DONT_USE_BITFIELDS */
+#undef _TK_NEED_IMPLEMENTATION
+#endif /* _TK_NEED_IMPLEMENTATION */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkTextUndo.c
===================================================================
--- src/tktext/tkTextUndo.c	(revision 0)
+++ src/tktext/tkTextUndo.c	(working copy)
@@ -0,0 +1,1073 @@
+/*
+ * tkTextUndo.c --
+ *
+ *	This module provides the implementation of an undo stack.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkTextUndo.h"
+#include "tkInt.h"
+#include "tkAlloc.h"
+#include <assert.h>
+
+#if !(__STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900))
+# define _TK_NEED_IMPLEMENTATION
+# include "tkTextUndoPriv.h"
+#endif
+
+#ifndef MAX
+# define MAX(a,b) ((a) < (b) ? b : a)
+#endif
+
+#ifndef MIN
+# define MIN(a,b) ((a) < (b) ? a : b)
+#endif
+
+
+typedef TkTextUndoMyAtom MyUndoAtom;
+
+
+/*
+ * Our list of undo/redo atoms is a circular double linked list.
+ * It's circular beause the "last" pointer is connected with the
+ * "root" pointer. The list starts either with the oldest undo atom,
+ * or with the newest redo atom if no undo atom exists.
+ *
+ * 'stack->last' is always pointing to the newest undo item, or
+ * NULL if no undo item exists.
+ *
+ * 'stack->root' is always pointing either to the oldest undo item,
+ * or to the oldest redo item if no undo item exists.
+ *
+ * 'stack->current' is the current atom which receives all pushed
+ * items (TkTextUndoPushItem), and is not yet linked into the list.
+ * 'stack->current' can be NULL, in this case it has to be created
+ * when the user is pushing an item.
+ *
+ * last ------------------+
+ * root --+               |
+ *        V               V
+ *      +---+   +---+   +---+   +---+   +---+
+ *   +->| A |-->| B |-->| C |-->| d |-->| e |--+
+ *   |  +---+   +---+   +---+   +---+   +---+  |
+ *   ------------------------------------------+
+ *      undo: 3	                redo: 2
+ *
+ * A = oldest undo item
+ * B = second oldest undo item
+ * C = newest undo item
+ * d = newest redo item
+ * e = oldest redo item
+ */
+
+
+#define ATOM_SIZE(n) (Tk_Offset(TkTextUndoMyAtom, data) \
+	+ Tk_Offset(TkTextUndoAtom, array) + (n)*sizeof(TkTextUndoSubAtom))
+
+
+enum { InitialCapacity = 20 };
+
+
+static void
+FreeItems(
+    const TkTextUndoStack stack,
+    const TkTextUndoAtom *atom)
+{
+    TkTextUndoFreeProc *freeProc = stack->freeProc;
+    const TkTextUndoSubAtom *arr;
+    unsigned i, n;
+
+    assert(atom);
+
+    if (!freeProc) {
+	return;
+    }
+
+    arr = atom->array;
+    n = atom->arraySize;
+
+    for (i = 0; i < n; ++i) {
+	freeProc(stack, &arr[i]);
+    }
+}
+
+
+static void
+Release(
+    TkTextUndoStack stack,
+    MyUndoAtom *atom)
+{
+    MyUndoAtom *first, *root, *prev;
+
+    if (!atom) {
+	return;
+    }
+
+    assert(stack->root);
+    first = atom;
+    root = stack->root;
+    prev = atom->prev;
+
+    /*
+     * Now delete all atoms starting at 'atom' until we reach the end (inclusive).
+     */
+
+    do {
+	MyUndoAtom *next = atom->next;
+	FreeItems(stack, &atom->data);
+	free(atom);
+	atom = next;
+    } while (atom != root);
+
+    /*
+     * Update the list pointers accordingly.
+     */
+
+    if (first == root) {
+	stack->root = stack->last = NULL;
+    } else {
+	root->prev = prev;
+	prev->next = root;
+    }
+}
+
+
+static void
+ResetCurrent(
+    TkTextUndoStack stack,
+    bool force)
+{
+    TkTextUndoMyAtom *current = stack->current;
+
+    if (current) {
+	FreeItems(stack, &current->data);
+    }
+
+    if (force || !current || current->capacity > InitialCapacity) {
+	static unsigned Size = ATOM_SIZE(InitialCapacity);
+	current = stack->current = memset(realloc(current, Size), 0, Size);
+	current->capacity = InitialCapacity;
+    }
+
+    current->data.arraySize = 0;
+    current->data.size = 0;
+    current->undoSize = 0;
+}
+
+
+static MyUndoAtom *
+SwapCurrent(
+    TkTextUndoStack stack,
+    MyUndoAtom *atom)
+{
+    MyUndoAtom *current = stack->current;
+
+    assert(atom != current);
+
+    if (current->capacity != current->data.size) {
+	current = stack->current = realloc(current, ATOM_SIZE(current->data.arraySize));
+	current->capacity = current->data.arraySize;
+    }
+
+    if (!atom) {
+	/*
+	 * Just use the 'stack->current' item.
+	 */
+	stack->current = NULL;
+	return current;
+    }
+
+    /*
+     * Exchange given 'atom' with 'stack->current', this means that
+     * 'stack->current' will be linked into the list replacing 'atom',
+     * and 'atom' will become 'stack->current'.
+     */
+
+    if (atom->next == atom) {
+	current->next = current;
+	current->prev = current;
+    } else {
+	current->next = atom->next;
+	current->prev = atom->prev;
+	atom->next->prev = current;
+	atom->prev->next = current;
+    }
+
+    stack->current = atom;
+    atom->data.arraySize = 0;
+    atom->data.size = 0;
+    atom->undoSize = 0;
+    atom->next = atom->prev = NULL;
+
+    if (stack->root == atom) {
+	stack->root = current;
+    }
+    if (stack->last == atom) {
+	stack->last = current;
+    }
+
+    return current;
+}
+
+
+static bool
+ClearRedoStack(
+    TkTextUndoStack stack)
+{
+    MyUndoAtom *atom;
+
+    if (stack->redoDepth == 0) {
+	return false;
+    }
+
+    atom = stack->last ? stack->last->next : stack->root;
+
+    assert(atom);
+    stack->redoDepth = 0;
+    stack->redoSize = 0;
+    stack->redoItems = 0;
+    Release(stack, atom);
+
+    return true;
+}
+
+
+static void
+InsertCurrentAtom(
+    TkTextUndoStack stack)
+{
+    MyUndoAtom *atom;
+    MyUndoAtom *current = stack->current;
+
+    if (!current || current->data.arraySize == 0) {
+	assert(!stack->doingUndo && !stack->doingRedo);
+	return;
+    }
+
+    if (stack->maxSize > 0 && !stack->doingRedo) {
+	unsigned newStackSize = current->data.size;
+
+	if (stack->doingUndo) {
+	    newStackSize = MAX(current->undoSize, newStackSize);
+	}
+	newStackSize += stack->undoSize + stack->redoSize;
+
+	if (newStackSize > stack->maxSize) {
+	    /*
+	     * We do not push this atom, because the addtional size would
+	     * exceed the maximal content size.
+	     *
+	     * Note that we must push an undo atom while performing a redo,
+	     * but this case is already catched, and the size of this atom
+	     * has already been taken into account (with the check of
+	     * 'current->undoSize' when inserting the reverting redo atom;
+	     * we assume that the new undo atom size is the same as the
+	     * undo size before the redo).
+	     */
+	    if (stack->doingUndo) {
+		/*
+		 * We do not push this redo atom while peforming an undo, so all
+		 * redoes are expired, we have to delete them.
+		 */
+		ClearRedoStack(stack);
+	    } else {
+		/*
+		 * We do not push this undo atom, so the content becomes irreversible.
+		 */
+		stack->irreversible = true;
+	    }
+	    FreeItems(stack, &stack->current->data);
+	    ResetCurrent(stack, false);
+	    return;
+	}
+    }
+
+    if (stack->doingRedo) {
+	/*
+	 * We'll push an undo atom while performing a redo.
+	 */
+	if (!stack->last) {
+	    stack->last = stack->root;
+	}
+	atom = stack->last;
+	SwapCurrent(stack, atom);
+	stack->undoDepth += 1;
+	stack->undoSize += atom->data.size;
+	stack->undoItems += atom->data.arraySize;
+    } else if (stack->doingUndo) {
+	/*
+	 * We'll push a redo atom while performing an undo.
+	 */
+	assert(stack->maxRedoDepth <= 0 || stack->redoDepth < stack->maxRedoDepth);
+	atom = stack->last ? stack->last->next : stack->root;
+	SwapCurrent(stack, atom);
+	stack->redoDepth += 1;
+	stack->redoSize += atom->data.size;
+	stack->redoItems += atom->data.arraySize;
+    } else if (stack->last && stack->undoDepth == stack->maxUndoDepth) {
+	/*
+	 * We've reached the maximal stack limit, so delete the oldest undo
+	 * before inserting the new item. The consequence is that now the content
+	 * becomes irreversible. Furthermore all redo items will expire.
+	 */
+	ClearRedoStack(stack);
+	assert(stack->last);
+	atom = stack->last->next;
+	stack->root = atom->next;
+	stack->last = atom;
+	stack->undoSize -= atom->data.size;
+	stack->undoItems -= atom->data.arraySize;
+	stack->irreversible = true;
+	FreeItems(stack, &atom->data);
+	SwapCurrent(stack, atom);
+	stack->undoSize += atom->data.size;
+	stack->undoItems += atom->data.arraySize;
+    } else {
+	/*
+	 * Just insert the newly undo atom. Furthermore all redo items will expire.
+	 */
+	ClearRedoStack(stack);
+	if (stack->last == NULL) {
+	    stack->last = stack->root;
+	}
+	atom = SwapCurrent(stack, NULL);
+	if ((atom->prev = stack->last)) {
+	    atom->next = stack->last->next;
+	    stack->last->next->prev = atom;
+	    stack->last->next = atom;
+	} else {
+	    atom->next = atom->prev = stack->root = atom;
+	}
+	stack->last = atom;
+	stack->undoDepth += 1;
+	stack->undoSize += atom->data.size;
+	stack->undoItems += atom->data.arraySize;
+    }
+
+    if (!stack->doingUndo) {
+	/*
+	 * Remember the size of this undo atom, probably we need it for the
+	 * decision whether to push a redo atom when performing an undo.
+	 */
+	atom->undoSize = atom->data.size;
+    }
+
+    /*
+     * Reset the buffer for next action.
+     */
+    ResetCurrent(stack, false);
+}
+
+
+static int
+ResetStack(
+    TkTextUndoStack stack,
+    bool irreversible)
+{
+    bool contentChanged;
+
+    assert(stack);
+
+    if (stack->doingUndo || stack->doingRedo) {
+	return TCL_ERROR;
+    }
+
+    contentChanged = stack->undoDepth > 0 || stack->redoDepth > 0 || stack->current;
+
+    if (contentChanged) {
+	Release(stack, stack->root);
+	ResetCurrent(stack, true);
+	stack->root = NULL;
+	stack->last = NULL;
+	stack->undoDepth = 0;
+	stack->redoDepth = 0;
+	stack->undoItems = 0;
+	stack->redoItems = 0;
+	stack->undoSize = 0;
+	stack->redoSize = 0;
+	stack->irreversible = irreversible;
+	stack->pushSeparator = false;
+
+	if (stack->contentChangedProc) {
+	    stack->contentChangedProc(stack);
+	}
+    }
+
+    return TCL_OK;
+}
+
+
+TkTextUndoStack
+TkTextUndoCreateStack(
+    unsigned maxUndoDepth,
+    int maxRedoDepth,
+    unsigned maxSize,
+    TkTextUndoPerformProc undoProc,
+    TkTextUndoFreeProc freeProc,
+    TkTextUndoStackContentChangedProc contentChangedProc)
+{
+    TkTextUndoStack stack;
+
+    assert(undoProc);
+
+    stack = memset(malloc(sizeof(*stack)), 0, sizeof(*stack));
+    stack->undoProc = undoProc;
+    stack->freeProc = freeProc;
+    stack->contentChangedProc = contentChangedProc;
+    stack->maxUndoDepth = maxUndoDepth;
+    stack->maxRedoDepth = MAX(maxRedoDepth, -1);
+    stack->maxSize = maxSize;
+
+    return stack;
+}
+
+
+void
+TkTextUndoDestroyStack(
+    TkTextUndoStack *stackPtr)
+{
+    if (stackPtr) {
+	TkTextUndoStack stack = *stackPtr;
+
+	if (stack) {
+	    assert(stack);
+	    TkTextUndoClearStack(stack);
+	    if (stack->current) {
+		FreeItems(stack, &stack->current->data);
+	    }
+	    free(stack);
+	    *stackPtr = NULL;
+	}
+    }
+}
+
+
+int
+TkTextUndoResetStack(
+    TkTextUndoStack stack)
+{
+    return stack ? ResetStack(stack, false) : TCL_ERROR;
+}
+
+
+int
+TkTextUndoClearStack(
+    TkTextUndoStack stack)
+{
+    return stack ? ResetStack(stack, stack->undoDepth > 0) : TCL_ERROR;
+}
+
+
+int
+TkTextUndoClearUndoStack(
+    TkTextUndoStack stack)
+{
+    if (!stack) {
+	return TCL_OK;
+    }
+
+    if (stack->doingUndo || stack->doingRedo) {
+	return TCL_ERROR;
+    }
+
+    if (stack->undoDepth > 0) {
+	TkTextUndoMyAtom *atom;
+
+	assert(stack->last);
+	stack->undoDepth = 0;
+	stack->undoSize = 0;
+	stack->undoItems = 0;
+	atom = stack->root;
+	stack->root = stack->last->next;
+	stack->last = NULL;
+	Release(stack, atom);
+	ResetCurrent(stack, true);
+	stack->irreversible = true;
+
+	if (stack->contentChangedProc) {
+	    stack->contentChangedProc(stack);
+	}
+    }
+
+    return TCL_OK;
+}
+
+
+int
+TkTextUndoClearRedoStack(
+    TkTextUndoStack stack)
+{
+    if (!stack) {
+	return TCL_OK;
+    }
+
+    if (stack->doingUndo || stack->doingRedo) {
+	return TCL_ERROR;
+    }
+
+    if (ClearRedoStack(stack) && stack->contentChangedProc) {
+	stack->contentChangedProc(stack);
+    }
+
+    return TCL_OK;
+}
+
+
+int
+TkTextUndoSetMaxStackDepth(
+    TkTextUndoStack stack,
+    unsigned maxUndoDepth,
+    int maxRedoDepth)
+{
+    assert(stack);
+
+    if (stack->doingUndo || stack->doingRedo) {
+	return TCL_ERROR;
+    }
+
+    if (maxUndoDepth > 0 || maxRedoDepth >= 0) {
+	unsigned depth = stack->maxUndoDepth;
+
+	if (depth == 0) {
+	    depth = stack->undoDepth + stack->redoDepth;
+	}
+
+	if ((0 < maxUndoDepth && maxUndoDepth < depth)
+		|| (0 <= maxRedoDepth && (unsigned) maxRedoDepth < (unsigned) stack->maxRedoDepth)) {
+	    unsigned deleteRedos = MIN(stack->redoDepth, depth - maxUndoDepth);
+
+	    if (0 <= maxRedoDepth && maxRedoDepth < stack->maxRedoDepth) {
+		deleteRedos = MIN(stack->redoDepth,
+			MAX(deleteRedos, stack->maxRedoDepth - maxRedoDepth));
+	    }
+
+	    stack->redoDepth -= deleteRedos;
+	    depth = maxUndoDepth - deleteRedos;
+
+	    if (deleteRedos > 0) {
+		MyUndoAtom *atom = stack->root;
+
+		/*
+		 * We have to reduce the stack size until the depth will not
+		 * exceed the given limit anymore. Start with oldest redoes,
+		 * and continue with oldest undoes if necessary.
+		 */
+
+		for ( ; deleteRedos > 0; --deleteRedos) {
+		    atom = atom->prev;
+		    stack->redoSize -= atom->data.size;
+		    stack->redoItems -= atom->data.arraySize;
+		}
+
+		Release(stack, atom);
+	    }
+
+	    if (maxUndoDepth > 0 && stack->undoDepth > depth) {
+		MyUndoAtom *root = stack->root;
+		MyUndoAtom *atom = stack->root;
+		unsigned deleteUndos = stack->undoDepth - depth;
+
+		stack->undoDepth -= deleteUndos;
+
+		for ( ; deleteUndos > 0; --deleteUndos) {
+		    stack->undoSize -= root->data.size;
+		    stack->undoItems -= root->data.arraySize;
+		    root = root->next;
+		}
+
+		stack->root = root;
+
+		/* We have to delete undoes, so the content becomes irreversible. */
+		stack->irreversible = true;
+
+		Release(stack, atom);
+	    }
+
+	    if (stack->contentChangedProc) {
+		stack->contentChangedProc(stack);
+	    }
+	}
+    }
+
+    stack->maxUndoDepth = maxUndoDepth;
+    stack->maxRedoDepth = MAX(maxRedoDepth, -1);
+    return TCL_OK;
+}
+
+
+int
+TkTextUndoSetMaxStackSize(
+    TkTextUndoStack stack,
+    unsigned maxSize,
+    bool applyImmediately)
+{
+    assert(stack);
+
+    if (stack->doingUndo || stack->doingRedo) {
+	return TCL_ERROR;
+    }
+
+    if (applyImmediately
+	    && 0 < maxSize
+	    && maxSize < stack->undoSize + stack->redoSize) {
+	unsigned size = stack->undoSize + stack->redoSize;
+	MyUndoAtom *atom = stack->root;
+	unsigned depth = stack->redoDepth;
+
+	/*
+	 * We have to reduce the stack size until the size will not exceed
+	 * the given limit anymore. Start with oldest redoes, and continue
+	 * with oldest undoes if necessary.
+	 */
+
+	while (depth > 0 && maxSize < size) {
+	    atom = atom->prev;
+	    size -= atom->data.size;
+	    stack->redoSize -= atom->data.size;
+	    stack->redoItems -= atom->data.arraySize;
+	    depth -= 1;
+	}
+
+	while (atom->data.size == 0 && atom != stack->root) {
+	    stack->redoItems += atom->data.arraySize;
+	    atom = atom->next;
+	    depth += 1;
+	}
+
+	if (depth < stack->redoDepth) {
+	    stack->redoDepth = depth;
+	    Release(stack, atom);
+	}
+
+	if (maxSize < size && stack->last) {
+	    MyUndoAtom *root = stack->root;
+
+	    depth = stack->undoDepth;
+
+	    while (depth > 0 && maxSize < size) {
+		size -= root->data.size;
+		stack->undoSize -= root->data.size;
+		stack->undoItems -= root->data.arraySize;
+		depth -= 1;
+		root = root->next;
+	    }
+
+	    while (root->data.size == 0 && depth < stack->undoDepth) {
+		stack->undoItems += root->data.arraySize;
+		depth += 1;
+		root = root->prev;
+	    }
+
+	    if (depth < stack->undoDepth) {
+		stack->undoDepth = depth;
+		atom = stack->root;
+		stack->root = root;
+		/*
+		 * We have to delete undoes, so the content becomes irreversible.
+		 */
+		stack->irreversible = true;
+		Release(stack, atom);
+	    }
+	}
+
+	if (stack->contentChangedProc) {
+	    stack->contentChangedProc(stack);
+	}
+    }
+
+    stack->maxSize = maxSize;
+    return TCL_OK;
+}
+
+
+static void
+PushSeparator(
+    TkTextUndoStack stack,
+    bool force)
+{
+    assert(stack);
+
+    if (force || stack->pushSeparator) {
+	/*
+	 * When performing an undo/redo, exact one reverting undo/redo atom has
+	 * to be inserted, not more. So we do not allow the push of separators
+	 * as long as an undo/redo action is in progress.
+	 */
+
+	if (!stack->doingUndo && !stack->doingRedo) {
+	    /*
+	     * Do not trigger stack->contentChangedProc here, because this has been
+	     * already done via TkTextUndoPushItem/TkTextUndoPushRedoItem.
+	     */
+	    InsertCurrentAtom(stack);
+	}
+    }
+
+    stack->pushSeparator = false;
+}
+
+
+void
+TkTextUndoPushSeparator(
+    TkTextUndoStack stack,
+    bool immediately)
+{
+    assert(stack);
+
+    if (immediately) {
+	PushSeparator(stack, true);
+    } else {
+	/* Postpone pushing a separator until next item will be pushed. */
+	stack->pushSeparator = true;
+    }
+}
+
+
+int
+TkTextUndoPushItem(
+    TkTextUndoStack stack,
+    TkTextUndoItem item,
+    unsigned size)
+{
+    MyUndoAtom *atom;
+    TkTextUndoSubAtom *subAtom;
+
+    assert(stack);
+    assert(item);
+
+    PushSeparator(stack, false);
+
+    if (stack->doingUndo && TkTextUndoRedoStackIsFull(stack)) {
+	if (stack->freeProc) {
+	    stack->freeProc(stack, item);
+	}
+	return TCL_ERROR;
+    }
+
+    atom = stack->current;
+
+    if (!atom) {
+	ResetCurrent(stack, true);
+	atom = stack->current;
+    } else if (atom->data.arraySize == atom->capacity) {
+	atom->capacity *= 2;
+	atom = stack->current = realloc(atom, ATOM_SIZE(atom->capacity));
+    }
+
+    subAtom = ((TkTextUndoSubAtom *) atom->data.array) + atom->data.arraySize++;
+    subAtom->item = item;
+    subAtom->size = size;
+    subAtom->redo = stack->doingUndo;
+    atom->data.size += size;
+    atom->data.redo = stack->doingUndo;
+
+    if (stack->contentChangedProc && !stack->doingUndo && !stack->doingRedo) {
+	stack->contentChangedProc(stack);
+    }
+
+    return TCL_OK;
+}
+
+
+int
+TkTextUndoPushRedoItem(
+    TkTextUndoStack stack,
+    TkTextUndoItem item,
+    unsigned size)
+{
+    int rc;
+
+    assert(stack);
+    assert(!TkTextUndoIsPerformingUndoRedo(stack));
+
+    PushSeparator(stack, true);
+    stack->doingUndo = true;
+    rc = TkTextUndoPushItem(stack, item, size);
+    stack->doingUndo = false;
+
+    return rc;
+}
+
+
+TkTextUndoItem
+TkTextUndoSwapLastItem(
+    TkTextUndoStack stack,
+    TkTextUndoItem item,
+    unsigned *size)
+{
+    TkTextUndoAtom *last;
+    TkTextUndoSubAtom *subAtom;
+    TkTextUndoItem oldItem;
+    unsigned oldSize;
+
+    assert(stack);
+    assert(TkTextUndoGetLastUndoSubAtom(stack));
+
+    last = stack->current ? &stack->current->data : &stack->last->data;
+    subAtom = (TkTextUndoSubAtom *) last->array + (last->arraySize - 1);
+    oldSize = subAtom->size;
+    last->size -= oldSize;
+    last->size += *size;
+    stack->undoSize -= oldSize;
+    stack->undoSize += *size;
+    oldItem = subAtom->item;
+    subAtom->item = item;
+    subAtom->size = *size;
+    *size = oldSize;
+
+    return oldItem;
+}
+
+
+int
+TkTextUndoDoUndo(
+    TkTextUndoStack stack)
+{
+    int rc;
+
+    assert(stack);
+
+    if (stack->doingUndo || stack->doingRedo) {
+	return TCL_ERROR;
+    }
+
+    InsertCurrentAtom(stack);
+
+    if (stack->undoDepth == 0) {
+	rc = TCL_ERROR;
+    } else {
+	MyUndoAtom *atom;
+
+	assert(stack->last);
+
+	stack->actual = atom = stack->last;
+	stack->doingUndo = true;
+	stack->undoDepth -= 1;
+	stack->undoSize -= stack->actual->data.size;
+	stack->undoItems -= stack->actual->data.arraySize;
+	stack->undoProc(stack, &stack->actual->data);
+	stack->last = stack->undoDepth ? stack->last->prev : NULL;
+	stack->actual = NULL;
+
+	if (!stack->current || stack->current->data.arraySize == 0) {
+	    /*
+	     * We didn't receive reverting items while performing an undo.
+	     * So all redo items are expired, we have to delete them.
+	     */
+	    stack->redoDepth = 0;
+	    stack->redoSize = 0;
+	    stack->redoItems = 0;
+	    Release(stack, stack->last ? stack->last->next : stack->root);
+	} else {
+	    FreeItems(stack, &atom->data);
+	    InsertCurrentAtom(stack);
+	}
+
+	stack->doingUndo = false;
+	rc = TCL_OK;
+
+	if (stack->contentChangedProc) {
+	    stack->contentChangedProc(stack);
+	}
+    }
+    return rc;
+}
+
+
+int
+TkTextUndoDoRedo(
+    TkTextUndoStack stack)
+{
+    int rc;
+
+    assert(stack);
+
+    if (stack->doingUndo || stack->doingRedo) {
+	return TCL_ERROR;
+    }
+
+    InsertCurrentAtom(stack);
+
+    if (stack->redoDepth == 0) {
+	rc = TCL_ERROR;
+    } else {
+	MyUndoAtom *atom;
+
+	stack->actual = atom = stack->last ? stack->last->next : stack->root;
+	stack->doingRedo = true;
+	stack->redoDepth -= 1;
+	stack->redoSize -= atom->data.size;
+	stack->redoItems -= atom->data.arraySize;
+	stack->undoProc(stack, &atom->data);
+	stack->last = atom;
+	stack->actual = NULL;
+
+	if (!stack->current || stack->current->data.arraySize == 0) {
+	    /*
+	     * Oops, we did not receive reverting items while performing a redo.
+	     * So we cannot apply the preceding undoes, we have to remove them.
+	     * Now the content will become irreversible.
+	     */
+	    if (stack->undoDepth > 0) {
+		stack->undoDepth = 0;
+		stack->undoItems = 0;
+		stack->undoSize = 0;
+		atom = stack->root;
+		stack->root = stack->last->next;
+		stack->last = NULL;
+	    } else {
+		stack->root = atom->next;
+	    }
+	    Release(stack, atom);
+	    stack->irreversible = true;
+	} else {
+	    FreeItems(stack, &atom->data);
+	    InsertCurrentAtom(stack);
+	}
+
+	stack->doingRedo = false;
+	rc = TCL_OK;
+
+	if (stack->contentChangedProc) {
+	    stack->contentChangedProc(stack);
+	}
+    }
+
+    return rc;
+}
+
+bool
+TkTextUndoStackIsFull(
+    const TkTextUndoStack stack)
+{
+    if (!stack) {
+	return true;
+    }
+    if (stack->doingUndo) {
+	return stack->maxRedoDepth >= 0 && stack->redoDepth >= stack->maxRedoDepth;
+    }
+    return stack->maxUndoDepth > 0 && stack->undoDepth >= stack->maxUndoDepth;
+}
+
+
+const TkTextUndoAtom *
+TkTextUndoFirstUndoAtom(
+    TkTextUndoStack stack)
+{
+    assert(stack);
+
+    if (stack->current && stack->current->data.arraySize && !stack->doingUndo) {
+	return &(stack->iter = stack->current)->data;
+    }
+
+    if (stack->undoDepth > 0 && stack->last != stack->actual) {
+	return &(stack->iter = stack->last)->data;
+    }
+
+    stack->iter = NULL;
+    return NULL;
+}
+
+
+const TkTextUndoAtom *
+TkTextUndoNextUndoAtom(
+    TkTextUndoStack stack)
+{
+    assert(stack);
+
+    if (stack->iter) {
+	if (stack->iter == stack->current) {
+	    if (stack->undoDepth > 0 && stack->last != stack->actual) {
+		return &(stack->iter = stack->last)->data;
+	    }
+	    stack->iter = NULL;
+	} else if (stack->iter != stack->root && (stack->iter = stack->iter->prev) != stack->actual) {
+	    return &stack->iter->data;
+	} else {
+	    stack->iter = NULL;
+	}
+    }
+
+    return NULL;
+}
+
+
+const TkTextUndoAtom *
+TkTextUndoFirstRedoAtom(
+    TkTextUndoStack stack)
+{
+    assert(stack);
+
+    if (stack->redoDepth > 0 && stack->root->prev != stack->actual) {
+	return &(stack->iter = stack->root->prev)->data;
+    }
+
+    stack->iter = NULL;
+
+    if (stack->current && stack->current->data.arraySize && stack->doingUndo) {
+	return &stack->current->data;
+    }
+
+    return NULL;
+}
+
+
+const TkTextUndoAtom *
+TkTextUndoNextRedoAtom(
+    TkTextUndoStack stack)
+{
+    assert(stack);
+
+    if (stack->iter) {
+	if (stack->iter != stack->root
+		&& (stack->iter = stack->iter->prev) != stack->last
+		&& stack->iter != stack->actual) {
+	    return &stack->iter->data;
+	}
+
+	stack->iter = NULL;
+
+	if (stack->current && stack->current->data.arraySize && stack->doingUndo) {
+	    return &stack->current->data;
+	}
+    }
+
+    return NULL;
+}
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+/* Additionally we need stand-alone object code. */
+#define inline extern
+inline void TkTextUndoSetContext(TkTextUndoStack stack, TkTextUndoContext context);
+inline TkTextUndoContext TkTextUndoGetContext(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetMaxUndoDepth(const TkTextUndoStack stack);
+inline int TkTextUndoGetMaxRedoDepth(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetMaxSize(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentDepth(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentSize(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentUndoStackDepth(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentRedoStackDepth(const TkTextUndoStack stack);
+inline unsigned TkTextUndoCountUndoItems(const TkTextUndoStack stack);
+inline unsigned TkTextUndoCountRedoItems(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentUndoSize(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentRedoSize(const TkTextUndoStack stack);
+inline unsigned TkTextUndoCountCurrentUndoItems(const TkTextUndoStack stack);
+inline unsigned TkTextUndoCountCurrentRedoItems(const TkTextUndoStack stack);
+inline bool TkTextUndoContentIsIrreversible(const TkTextUndoStack stack);
+inline bool TkTextUndoContentIsModified(const TkTextUndoStack stack);
+inline bool TkTextUndoIsPerformingUndo(const TkTextUndoStack stack);
+inline bool TkTextUndoIsPerformingRedo(const TkTextUndoStack stack);
+inline bool TkTextUndoIsPerformingUndoRedo(const TkTextUndoStack stack);
+inline const TkTextUndoAtom *TkTextUndoCurrentUndoAtom(const TkTextUndoStack stack);
+inline const TkTextUndoAtom *TkTextUndoCurrentRedoAtom(const TkTextUndoStack stack);
+inline const TkTextUndoSubAtom *TkTextUndoGetLastUndoSubAtom(const TkTextUndoStack stack);
+inline bool TkTextUndoUndoStackIsFull(const TkTextUndoStack stack);
+inline bool TkTextUndoRedoStackIsFull(const TkTextUndoStack stack);
+#endif /* __STDC_VERSION__ >= 199901L */
+
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkTextUndo.h
===================================================================
--- src/tktext/tkTextUndo.h	(revision 0)
+++ src/tktext/tkTextUndo.h	(working copy)
@@ -0,0 +1,260 @@
+/*
+ * tkTextUndo.h --
+ *
+ * The implementation of an undo/redo stack. The design and implementation
+ * of tkUndo is not useful for our purposes:
+ *
+ * 1. We are not pushing an undo/redo pair on the stack. Our stack is only
+ *    pushing the undo item, and applying this undo item will replace this
+ *    item by a redo item (and vice versa when performing the redo; in fact
+ *    there is no difference between an undo and redo item - the undo of
+ *    insert is delete, the undo of delete is insert, and the same applies
+ *    to redo). The advantage is that our undo (or redo) item for insert
+ *    contains exact zero characters, contrary to the undo/redo pairs in
+ *    tkUndo, one of the undo/redo items in this pair always contains a
+ *    copy of the text content (a waste of memory).
+ *
+ * 2. tkUndo expects a script, our stack expects memory addresses (it's also
+ *    an general implementation which can be shared).
+ *
+ * 3. Our stack allows to control the undo and redo stacks separately.
+ *
+ * 4. Moreover our stack supports to limit the size, not only the depth.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKTEXTUNDO
+#define _TKTEXTUNDO
+
+#include "tkBool.h"
+#include <stdint.h>
+
+#ifdef _MSC_VER
+# if _MSC_VER >= 1900
+#  define inline __inline
+# else
+#  define inline
+# endif
+#elif __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+
+/*
+ * Our (private) stack type.
+ */
+
+struct TkTextUndoStack;
+typedef struct TkTextUndoStack * TkTextUndoStack;
+
+/*
+ * The generic context type.
+ */
+
+typedef void * TkTextUndoContext;
+
+/*
+ * Basic type of an undo/redo item, the user has to know the real type.
+ */
+
+typedef void * TkTextUndoItem;
+
+/*
+ * Struct defining a single action, one or more of which may be defined (and
+ * stored in a linked list) separately for each undo and redo action of an
+ * undo atom.
+ */
+
+typedef struct TkTextUndoSubAtom {
+    TkTextUndoItem item;	/* The data of this undo/redo item. */
+    uint32_t size:31;		/* Size info for this item. */
+    uint32_t redo:1;		/* Is redo item? */
+} TkTextUndoSubAtom;
+
+/*
+ * Struct representing a single undo+redo atom to be placed in the stack.
+ */
+
+typedef struct TkTextUndoAtom {
+    uint32_t arraySize;		/* Number of elements in this array. */
+    uint32_t size:31;		/* Total size of all items. */
+    uint32_t redo:1;		/* Is redo atom? */
+    const TkTextUndoSubAtom array[1];
+				/* Array of undo/redo actions. */
+} TkTextUndoAtom;
+
+/*
+ * Callback to carry out undo or redo actions. This function may
+ * push redo (undo) items for this undo (redo) onto the stack.
+ * The user should push the reverting items while this action will
+ * be performed.
+ *
+ * Note that the atom is given as a const value, but it's allowed
+ * to change/reset the items of the sub-atoms.
+ */
+
+typedef void (TkTextUndoPerformProc)(TkTextUndoStack stack, const TkTextUndoAtom *atom);
+
+/*
+ * Callback proc type to free undo/redo items. This function will be
+ * called when the user is clearing the stack (destroying the stack
+ * is implicitly clearing the stack), or when the push operation
+ * is deleting the oldest undo atom (for keeping the max. depth and
+ * max. size).
+ */
+
+typedef void (TkTextUndoFreeProc)(const TkTextUndoStack stack, const TkTextUndoSubAtom *atom);
+
+/*
+ * Callback proc type for stack changes. Every time when the stack is
+ * changing this callback function will be triggered.
+ */
+
+typedef void (TkTextUndoStackContentChangedProc)(const TkTextUndoStack stack);
+
+/*
+ * Functions for constructing/destructing the stack. Use zero for unlimited
+ * stack depth, also use zero for unlimited size. 'freeProc' can be NULL,
+ * but normally this function is required. It's clear that 'undoProc' is
+ * mandatory. 'informStackChangeProc' and pushSeparatorProc can also be NULL.
+ */
+
+TkTextUndoStack TkTextUndoCreateStack(
+    unsigned maxUndoDepth, int maxRedoDepth, unsigned maxSize,
+    TkTextUndoPerformProc undoProc, TkTextUndoFreeProc freeProc,
+    TkTextUndoStackContentChangedProc contentChangedProc);
+void TkTextUndoDestroyStack(TkTextUndoStack *stackPtr);
+
+/*
+ * Managing the stack. Use zero for unlimited stack depth, also use zero
+ * for unlimited size. Setting a lower limit than the current depth is
+ * reducing the stack immediately. Setting a lower limit than the current
+ * size is also reducing the stack immediately iff 'applyImmediately' is
+ * 'true', otherwise the size will shrink when performing undo actions.
+ * It is not allowed to use these functions while an undo/redo action is
+ * performed, TCL_ERROR will be returned in this case.
+ *
+ * For convenience the functions TkTextUndoResetStack, TkTextUndoClearStack,
+ * TkTextUndoClearUndoStack, and TkTextUndoClearRedoStack, are allowing
+ * NULL arguments.
+ */
+
+int TkTextUndoSetMaxStackDepth(TkTextUndoStack stack,
+    unsigned maxUndoDepth, int maxRedoDepth);
+int TkTextUndoSetMaxStackSize(TkTextUndoStack stack,
+    unsigned maxSize, bool applyImmediately);
+int TkTextUndoResetStack(TkTextUndoStack stack);
+int TkTextUndoClearStack(TkTextUndoStack stack);
+int TkTextUndoClearUndoStack(TkTextUndoStack stack);
+int TkTextUndoClearRedoStack(TkTextUndoStack stack);
+
+/*
+ * Functions to set/get the context. This is an additional information
+ * for the user.
+ */
+
+inline void TkTextUndoSetContext(TkTextUndoStack stack, TkTextUndoContext context);
+inline TkTextUndoContext TkTextUndoGetContext(const TkTextUndoStack stack);
+
+/*
+ * Accessing attributes.
+ *
+ * The content is irreversible if:
+ * 1. The stack has exceeded the depth/size limit when adding undo atoms.
+ * 2. Setting a lower limit has caused the deletion of undo atoms.
+ * 3. Performing an redo did not push undo items.
+ * Clearing the stack is resetting this state to false.
+ *
+ * The content is modified if undo stack is not empty, or the content
+ * is irreversible.
+ */
+
+inline unsigned TkTextUndoGetMaxUndoDepth(const TkTextUndoStack stack);
+inline int TkTextUndoGetMaxRedoDepth(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetMaxSize(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentDepth(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentSize(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentUndoStackDepth(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentRedoStackDepth(const TkTextUndoStack stack);
+inline unsigned TkTextUndoCountUndoItems(const TkTextUndoStack stack);
+inline unsigned TkTextUndoCountRedoItems(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentUndoSize(const TkTextUndoStack stack);
+inline unsigned TkTextUndoGetCurrentRedoSize(const TkTextUndoStack stack);
+inline unsigned TkTextUndoCountCurrentUndoItems(const TkTextUndoStack stack);
+inline unsigned TkTextUndoCountCurrentRedoItems(const TkTextUndoStack stack);
+inline bool TkTextUndoContentIsIrreversible(const TkTextUndoStack stack);
+inline bool TkTextUndoContentIsModified(const TkTextUndoStack stack);
+inline bool TkTextUndoIsPerformingUndo(const TkTextUndoStack stack);
+inline bool TkTextUndoIsPerformingRedo(const TkTextUndoStack stack);
+inline bool TkTextUndoIsPerformingUndoRedo(const TkTextUndoStack stack);
+inline const TkTextUndoAtom *TkTextUndoCurrentUndoAtom(const TkTextUndoStack stack);
+inline const TkTextUndoAtom *TkTextUndoCurrentRedoAtom(const TkTextUndoStack stack);
+inline const TkTextUndoSubAtom *TkTextUndoGetLastUndoSubAtom(const TkTextUndoStack stack);
+
+/*
+ * Stack iterator functions.
+ */
+
+const TkTextUndoAtom *TkTextUndoFirstUndoAtom(TkTextUndoStack stack);
+const TkTextUndoAtom *TkTextUndoNextUndoAtom(TkTextUndoStack stack);
+const TkTextUndoAtom *TkTextUndoFirstRedoAtom(TkTextUndoStack stack);
+const TkTextUndoAtom *TkTextUndoNextRedoAtom(TkTextUndoStack stack);
+
+/* For convenience these functions are allowing NULL for the stack argument. */
+inline bool TkTextUndoUndoStackIsFull(const TkTextUndoStack stack);
+inline bool TkTextUndoRedoStackIsFull(const TkTextUndoStack stack);
+bool TkTextUndoStackIsFull(const TkTextUndoStack stack);
+
+/*
+ * Push the items. Pushing a separator will group items into compound edit
+ * actions. Pushing a separator without existing items will be ignored.
+ *
+ * While an undo/redo action is still in progress pushing separators will be
+ * ignored, in this case the undo/action will push automatically a single
+ * separator after the action is completed.
+ */
+
+int TkTextUndoPushItem(TkTextUndoStack stack, TkTextUndoItem item, unsigned size);
+void TkTextUndoPushSeparator(TkTextUndoStack stack, bool immediately);
+
+/*
+ * Normally redo items will be pushed while undo will be performed. The next function
+ * is only useful for the reconstruction of the stack.
+ */
+
+int TkTextUndoPushRedoItem(TkTextUndoStack stack, TkTextUndoItem item, unsigned size);
+
+/*
+ * Swap newest undo item with given item. Returns the old item. Note that this
+ * function does not check whether the maximal undo byte size will be exceeded.
+ *
+ * Parameter 'size':
+ * In: size of given item.
+ * Out: size of returned item.
+ */
+
+TkTextUndoItem TkTextUndoSwapLastItem(TkTextUndoStack stack, TkTextUndoItem item, unsigned *size);
+
+/*
+ * Perform undo/redo operations. Before the action starts a separator will be
+ * pushed. Returns an error (TCL_ERROR) if no undo (redo) action is possible.
+ */
+
+int TkTextUndoDoUndo(TkTextUndoStack stack);
+int TkTextUndoDoRedo(TkTextUndoStack stack);
+
+
+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+# define _TK_NEED_IMPLEMENTATION
+# include "tkTextUndoPriv.h"
+# undef _TK_NEED_IMPLEMENTATION
+#else
+# undef inline
+#endif
+
+#endif /* _TKTEXTUNDO */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkTextUndoPriv.h
===================================================================
--- src/tktext/tkTextUndoPriv.h	(revision 0)
+++ src/tktext/tkTextUndoPriv.h	(working copy)
@@ -0,0 +1,216 @@
+/*
+ * tkTextUndoPriv.h --
+ *
+ *	Private implementation for undo stack.
+ *
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKTEXTUNDO
+# error "do not include this private header file"
+#endif
+
+#ifndef _TKTEXTUNDOPRIV
+#define _TKTEXTUNDOPRIV
+
+#include <stddef.h>
+
+typedef struct TkTextUndoMyAtom {
+    unsigned capacity;
+    unsigned undoSize;
+    struct TkTextUndoMyAtom* next;
+    struct TkTextUndoMyAtom* prev;
+    TkTextUndoAtom data;
+} TkTextUndoMyAtom;
+
+struct TkTextUndoStack {
+    TkTextUndoPerformProc *undoProc;
+    				/* Function for callback to perform undo/redo actions. */
+    TkTextUndoFreeProc *freeProc;
+    				/* Function which frees stack items, can be NULL. */
+    TkTextUndoStackContentChangedProc *contentChangedProc;
+    				/* Function which informs about stack changes. */
+    TkTextUndoContext context;	/* User data. */
+    TkTextUndoMyAtom *current;	/* Current undo atom (not yet pushed). */
+    TkTextUndoMyAtom *root;	/* The root of the undo/redo stack. */
+    TkTextUndoMyAtom *last;	/* Last added undo atom. */
+    TkTextUndoMyAtom *iter;	/* Current atom in iteration loop. */
+    TkTextUndoMyAtom *actual;	/* Current undo/redo atom in processing. */
+    bool irreversible;		/* Whether undo actions has been released due to limited depth/size. */
+    unsigned maxUndoDepth;	/* Maximal depth of the undo stack. */
+    int maxRedoDepth;		/* Maximal depth of the redo stack. */
+    unsigned maxSize;		/* Maximal size of the stack. */
+    unsigned undoDepth;		/* Current depth of undo stack. */
+    unsigned redoDepth;		/* Current depth of redo stack. */
+    unsigned undoItems;		/* Current number of items on undo stack. */
+    unsigned redoItems;		/* Current number of items on redo stack. */
+    unsigned undoSize;		/* Total size of undo items. */
+    unsigned redoSize;		/* Total size of redo items. */
+    bool doingUndo;		/* Currently an undo action is performed? */
+    bool doingRedo;		/* Currently a redo action is performed? */
+    bool pushSeparator;		/* Push a separator before pushing a new item (iff true). */
+};
+
+#endif /* _TKTEXTUNDOPRIV */
+
+#ifdef _TK_NEED_IMPLEMENTATION
+
+#include <assert.h>
+
+#if __STDC_VERSION__ < 199901L
+# define inline /* we are not C99 conform */
+#endif
+
+inline unsigned
+TkTextUndoGetMaxUndoDepth(const TkTextUndoStack stack)
+{ assert(stack); return stack->maxUndoDepth; }
+
+inline int
+TkTextUndoGetMaxRedoDepth(const TkTextUndoStack stack)
+{ assert(stack); return stack->maxRedoDepth; }
+
+inline unsigned
+TkTextUndoGetMaxSize(const TkTextUndoStack stack)
+{ assert(stack); return stack->maxSize; }
+
+inline bool
+TkTextUndoContentIsModified(const TkTextUndoStack stack)
+{ assert(stack); return stack->undoDepth > 0 || stack->irreversible; }
+
+inline bool
+TkTextUndoContentIsIrreversible(const TkTextUndoStack stack)
+{ assert(stack); return stack->irreversible; }
+
+inline bool
+TkTextUndoIsPerformingUndo(const TkTextUndoStack stack)
+{ assert(stack); return stack->doingUndo; }
+
+inline bool
+TkTextUndoIsPerformingRedo(const TkTextUndoStack stack)
+{ assert(stack); return stack->doingRedo; }
+
+inline bool
+TkTextUndoIsPerformingUndoRedo(const TkTextUndoStack stack)
+{ assert(stack); return stack->doingUndo || stack->doingRedo; }
+
+inline bool
+TkTextUndoUndoStackIsFull(const TkTextUndoStack stack)
+{ return !stack || (stack->maxUndoDepth > 0 && stack->undoDepth >= stack->maxUndoDepth); }
+
+inline bool
+TkTextUndoRedoStackIsFull(const TkTextUndoStack stack)
+{ return !stack || (stack->maxRedoDepth >= 0 && stack->redoDepth >= stack->maxRedoDepth); }
+
+inline unsigned
+TkTextUndoCountCurrentUndoItems(const TkTextUndoStack stack)
+{ assert(stack); return stack->current && !stack->doingUndo ? stack->current->data.arraySize : 0; }
+
+inline unsigned
+TkTextUndoCountCurrentRedoItems(const TkTextUndoStack stack)
+{ assert(stack); return stack->current && stack->doingUndo ? stack->current->data.arraySize : 0; }
+
+inline unsigned
+TkTextUndoGetCurrentUndoStackDepth(const TkTextUndoStack stack)
+{ assert(stack); return stack->undoDepth + (TkTextUndoCountCurrentUndoItems(stack) ? 1 : 0); }
+
+inline unsigned
+TkTextUndoGetCurrentRedoStackDepth(const TkTextUndoStack stack)
+{ assert(stack); return stack->redoDepth + (TkTextUndoCountCurrentRedoItems(stack) ? 1 : 0); }
+
+inline unsigned
+TkTextUndoCountUndoItems(const TkTextUndoStack stack)
+{ assert(stack); return stack->undoItems + TkTextUndoCountCurrentUndoItems(stack); }
+
+inline unsigned
+TkTextUndoCountRedoItems(const TkTextUndoStack stack)
+{ assert(stack); return stack->redoItems + TkTextUndoCountCurrentRedoItems(stack); }
+
+inline void
+TkTextUndoSetContext(TkTextUndoStack stack, TkTextUndoContext context)
+{ assert(stack); stack->context = context; }
+
+inline TkTextUndoContext
+TkTextUndoGetContext(const TkTextUndoStack stack)
+{ assert(stack); return stack->context; }
+
+inline unsigned
+TkTextUndoGetCurrentDepth(
+    const TkTextUndoStack stack)
+{
+    assert(stack);
+    return stack->undoDepth + stack->redoDepth +
+	    (stack->current && stack->current->data.arraySize > 0 ? 1 : 0);
+}
+
+inline unsigned
+TkTextUndoGetCurrentUndoSize(
+    const TkTextUndoStack stack)
+{
+    assert(stack);
+    return stack->undoSize + (!stack->doingUndo && stack->current ? stack->current->undoSize : 0);
+}
+
+inline unsigned
+TkTextUndoGetCurrentRedoSize(
+    const TkTextUndoStack stack)
+{
+    assert(stack);
+    return stack->redoSize + (!stack->doingRedo && stack->current ? stack->current->undoSize : 0);
+}
+
+inline unsigned
+TkTextUndoGetCurrentSize(
+    const TkTextUndoStack stack)
+{
+    assert(stack);
+    return stack->undoSize + stack->redoSize + (stack->current ? stack->current->undoSize : 0);
+}
+
+inline const TkTextUndoAtom *
+TkTextUndoCurrentUndoAtom(
+    const TkTextUndoStack stack)
+{
+    assert(stack);
+
+    if (stack->doingUndo) {
+	return NULL;
+    }
+    return stack->current && stack->current->data.arraySize > 0 ? &stack->current->data : NULL;
+}
+
+inline const TkTextUndoAtom *
+TkTextUndoCurrentRedoAtom(
+    const TkTextUndoStack stack)
+{
+    assert(stack);
+
+    if (stack->doingRedo) {
+	return NULL;
+    }
+    return stack->current && stack->current->data.arraySize > 0 ? &stack->current->data : NULL;
+}
+
+inline const TkTextUndoSubAtom *
+TkTextUndoGetLastUndoSubAtom(
+    const TkTextUndoStack stack)
+{
+    TkTextUndoAtom *last;
+
+    assert(stack);
+
+    if (stack->current) {
+	last = &stack->current->data;
+    } else if (stack->last) {
+	last = &stack->last->data;
+    } else {
+	return NULL;
+    }
+    return last->arraySize > 0 ? last->array + (last->arraySize - 1) : NULL;
+}
+
+#undef _TK_NEED_IMPLEMENTATION
+#endif /* _TK_NEED_IMPLEMENTATION */
+/* vi:set ts=8 sw=4: */
Index: src/tktext/tkTextWind.c
===================================================================
--- src/tktext/tkTextWind.c	(revision 0)
+++ src/tktext/tkTextWind.c	(working copy)
@@ -0,0 +1,1812 @@
+/*
+ * tkTextWind.c --
+ *
+ *	This file contains code that allows arbitrary windows to be nested
+ *	inside text widgets. It also implements the "window" widget command
+ *	for texts.
+ *
+ * Copyright (c) 1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright (c) 2015-2017 Gregor Cramer
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#include "tkPort.h"
+#include "tkText.h"
+#include "tkTextTagSet.h"
+#include "tkTextUndo.h"
+#include <assert.h>
+
+#if NDEBUG
+# define DEBUG(expr)
+#else
+# define DEBUG(expr) expr
+#endif
+
+/*
+ * Support of tk8.5.
+ */
+#ifdef CONST
+# undef CONST
+#endif
+#if TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION == 5
+# define CONST
+#else
+# define CONST const
+#endif
+
+/*
+ * The following structure is the official type record for the embedded window
+ * geometry manager:
+ */
+
+static void EmbWinRequestProc(ClientData clientData, Tk_Window tkwin);
+static void EmbWinLostSlaveProc(ClientData clientData, Tk_Window tkwin);
+
+static const Tk_GeomMgr textGeomType = {
+    "text",			/* name */
+    EmbWinRequestProc,		/* requestProc */
+    EmbWinLostSlaveProc,	/* lostSlaveProc */
+};
+
+/*
+ * Prototypes for functions defined in this file:
+ */
+
+static void		EmbWinCheckProc(const TkSharedText *sharedTextPtr, const TkTextSegment *segPtr);
+static Tcl_Obj *	EmbWinInspectProc(const TkSharedText *sharedTextPtr,
+			    const TkTextSegment *segPtr);
+static void		EmbWinBboxProc(TkText *textPtr,
+			    TkTextDispChunk *chunkPtr, int index, int y,
+			    int lineHeight, int baseline, int *xPtr,int *yPtr,
+			    int *widthPtr, int *heightPtr);
+static int		EmbWinConfigure(TkText *textPtr, TkTextSegment *ewPtr,
+			    int objc, Tcl_Obj *const objv[]);
+static void		EmbWinDelayedUnmap(ClientData clientData);
+static bool		EmbWinDeleteProc(TkTextBTree tree, TkTextSegment *segPtr, int treeGone);
+static void		EmbWinRestoreProc(TkTextSegment *segPtr);
+static int		EmbWinLayoutProc(const TkTextIndex *indexPtr, TkTextSegment *segPtr,
+			    int offset, int maxX, int maxChars, bool noCharsYet,
+			    TkWrapMode wrapMode, TkTextSpaceMode spaceMode, TkTextDispChunk *chunkPtr);
+static void		EmbWinStructureProc(ClientData clientData, XEvent *eventPtr);
+static void	        EmbWinDisplayProc(TkText *textPtr, TkTextDispChunk *chunkPtr,
+                            int x, int y, int lineHeight, int baseline, Display *display,
+			    Drawable dst, int screenY);
+static void		EmbWinUndisplayProc(TkText *textPtr, TkTextDispChunk *chunkPtr);
+static TkTextEmbWindowClient *EmbWinGetClient(const TkText *textPtr, TkTextSegment *ewPtr);
+static TkTextSegment *	MakeWindow(TkText *textPtr);
+static void		ReleaseWindow(TkTextSegment *ewPtr);
+static void		DestroyOrUnmapWindow(TkTextSegment *ewPtr);
+
+static const TkTextDispChunkProcs layoutWindowProcs = {
+    TEXT_DISP_WINDOW,		/* type */
+    EmbWinDisplayProc,	        /* displayProc */
+    EmbWinUndisplayProc,        /* undisplayProc */
+    NULL,	                /* measureProc */
+    EmbWinBboxProc,	        /* bboxProc */
+};
+
+/*
+ * We need some private undo/redo stuff.
+ */
+
+static void UndoLinkSegmentPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void RedoLinkSegmentPerform(TkSharedText *, TkTextUndoInfo *, TkTextUndoInfo *, bool);
+static void UndoLinkSegmentDestroy(TkSharedText *, TkTextUndoToken *, bool);
+static void UndoLinkSegmentGetRange(const TkSharedText *, const TkTextUndoToken *,
+	TkTextIndex *, TkTextIndex *);
+static void RedoLinkSegmentGetRange(const TkSharedText *, const TkTextUndoToken *,
+	TkTextIndex *, TkTextIndex *);
+static Tcl_Obj *UndoLinkSegmentGetCommand(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *UndoLinkSegmentInspect(const TkSharedText *, const TkTextUndoToken *);
+static Tcl_Obj *RedoLinkSegmentInspect(const TkSharedText *, const TkTextUndoToken *);
+
+static const Tk_UndoType undoTokenLinkSegmentType = {
+    TK_TEXT_UNDO_WINDOW,	/* action */
+    UndoLinkSegmentGetCommand,	/* commandProc */
+    UndoLinkSegmentPerform,	/* undoProc */
+    UndoLinkSegmentDestroy,	/* destroyProc */
+    UndoLinkSegmentGetRange,	/* rangeProc */
+    UndoLinkSegmentInspect	/* inspectProc */
+};
+
+static const Tk_UndoType redoTokenLinkSegmentType = {
+    TK_TEXT_REDO_WINDOW,	/* action */
+    UndoLinkSegmentGetCommand,	/* commandProc */
+    RedoLinkSegmentPerform,	/* undoProc */
+    UndoLinkSegmentDestroy,	/* destroyProc */
+    RedoLinkSegmentGetRange,	/* rangeProc */
+    RedoLinkSegmentInspect	/* inspectProc */
+};
+
+typedef struct UndoTokenLinkSegment {
+    const Tk_UndoType *undoType;
+    TkTextSegment *segPtr;
+} UndoTokenLinkSegment;
+
+typedef struct RedoTokenLinkSegment {
+    const Tk_UndoType *undoType;
+    TkTextSegment *segPtr;
+    TkTextUndoIndex index;
+} RedoTokenLinkSegment;
+
+/*
+ * The following structure declares the "embedded window" segment type.
+ */
+
+const Tk_SegType tkTextEmbWindowType = {
+    "window",			/* name */
+    SEG_GROUP_WINDOW,		/* group */
+    GRAVITY_NEUTRAL,		/* leftGravity */
+    EmbWinDeleteProc,		/* deleteProc */
+    EmbWinRestoreProc,		/* restoreProc */
+    EmbWinLayoutProc,		/* layoutProc */
+    EmbWinCheckProc,		/* checkProc */
+    EmbWinInspectProc		/* inspectProc */
+};
+
+/*
+ * Definitions for alignment values:
+ */
+
+static const char *CONST alignStrings[] = {
+    "baseline", "bottom", "center", "top", NULL
+};
+
+typedef enum {
+    ALIGN_BASELINE, ALIGN_BOTTOM, ALIGN_CENTER, ALIGN_TOP
+} alignMode;
+
+/*
+ * Information used for parsing window configuration options:
+ */
+
+static const Tk_OptionSpec optionSpecs[] = {
+    {TK_OPTION_STRING_TABLE, "-align", NULL, NULL,
+	"center", -1, Tk_Offset(TkTextEmbWindow, align), 0, alignStrings, 0},
+    {TK_OPTION_STRING, "-create", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextEmbWindow, create), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_PIXELS, "-padx", NULL, NULL,
+	"0", -1, Tk_Offset(TkTextEmbWindow, padX), 0, 0, 0},
+    {TK_OPTION_PIXELS, "-pady", NULL, NULL,
+	"0", -1, Tk_Offset(TkTextEmbWindow, padY), 0, 0, 0},
+    {TK_OPTION_BOOLEAN, "-stretch", NULL, NULL,
+	"0", -1, Tk_Offset(TkTextEmbWindow, stretch), 0, 0, 0},
+    {TK_OPTION_WINDOW, "-window", NULL, NULL,
+	NULL, -1, Tk_Offset(TkTextEmbWindow, tkwin), TK_OPTION_NULL_OK, 0, 0},
+    {TK_OPTION_END, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0}
+};
+
+DEBUG_ALLOC(extern unsigned tkTextCountDestroySegment);
+DEBUG_ALLOC(extern unsigned tkTextCountNewSegment);
+DEBUG_ALLOC(extern unsigned tkTextCountNewUndoToken);
+
+/*
+ * Some useful helpers.
+ */
+
+static void
+TextChanged(
+    TkSharedText *sharedTextPtr,
+    TkTextIndex *indexPtr)
+{
+    TkTextChanged(sharedTextPtr, NULL, indexPtr, indexPtr);
+
+    /*
+     * TODO: It's probably not true that all window configuration can change
+     * the line height, so we could be more efficient here and only call this
+     * when necessary.
+     */
+
+    TkTextInvalidateLineMetrics(sharedTextPtr, NULL,
+	    TkTextIndexGetLine(indexPtr), 0, TK_TEXT_INVALIDATE_ONLY);
+}
+
+/*
+ * Some functions for the undo/redo mechanism.
+ */
+
+static void
+GetIndex(
+    const TkSharedText *sharedTextPtr,
+    TkTextSegment *segPtr,
+    TkTextIndex *indexPtr)
+{
+    TkTextIndexClear2(indexPtr, NULL, sharedTextPtr->tree);
+    TkTextIndexSetSegment(indexPtr, segPtr);
+}
+
+static Tcl_Obj *
+UndoLinkSegmentGetCommand(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj("window", -1));
+    return objPtr;
+}
+
+static Tcl_Obj *
+UndoLinkSegmentInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const UndoTokenLinkSegment *token = (const UndoTokenLinkSegment *) item;
+    Tcl_Obj *objPtr = UndoLinkSegmentGetCommand(sharedTextPtr, item);
+    char buf[TK_POS_CHARS];
+    TkTextIndex index;
+
+    GetIndex(sharedTextPtr, token->segPtr, &index);
+    TkTextIndexPrint(sharedTextPtr, NULL, &index, buf);
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(buf, -1));
+    return objPtr;
+}
+
+static void
+UndoLinkSegmentPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    const UndoTokenLinkSegment *token = (const UndoTokenLinkSegment *) undoInfo->token;
+    TkTextSegment *segPtr = token->segPtr;
+    TkTextIndex index;
+
+    if (redoInfo) {
+	RedoTokenLinkSegment *redoToken;
+	redoToken = malloc(sizeof(RedoTokenLinkSegment));
+	redoToken->undoType = &redoTokenLinkSegmentType;
+	TkBTreeMakeUndoIndex(sharedTextPtr, segPtr, &redoToken->index);
+	redoInfo->token = (TkTextUndoToken *) redoToken;
+	(redoToken->segPtr = segPtr)->refCount += 1;
+	DEBUG_ALLOC(tkTextCountNewUndoToken++);
+    }
+
+    GetIndex(sharedTextPtr, segPtr, &index);
+    TextChanged(sharedTextPtr, &index);
+    TkBTreeUnlinkSegment(sharedTextPtr, segPtr);
+    EmbWinDeleteProc(sharedTextPtr->tree, segPtr, 0);
+    TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+}
+
+static void
+UndoLinkSegmentDestroy(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoToken *item,
+    bool reused)
+{
+    UndoTokenLinkSegment *token = (UndoTokenLinkSegment *) item;
+
+    assert(!reused);
+
+    if (--token->segPtr->refCount == 0) {
+	ReleaseWindow(token->segPtr);
+    }
+}
+
+static void
+UndoLinkSegmentGetRange(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item,
+    TkTextIndex *startIndex,
+    TkTextIndex *endIndex)
+{
+    const UndoTokenLinkSegment *token = (const UndoTokenLinkSegment *) item;
+
+    GetIndex(sharedTextPtr, token->segPtr, startIndex);
+    *endIndex = *startIndex;
+}
+
+static Tcl_Obj *
+RedoLinkSegmentInspect(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item)
+{
+    const RedoTokenLinkSegment *token = (const RedoTokenLinkSegment *) item;
+    Tcl_Obj *objPtr = EmbWinInspectProc(sharedTextPtr, token->segPtr);
+    char buf[TK_POS_CHARS];
+    TkTextIndex index;
+    Tcl_Obj *idxPtr;
+
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->index, &index);
+    TkTextIndexPrint(sharedTextPtr, NULL, &index, buf);
+    idxPtr = Tcl_NewStringObj(buf, -1);
+    Tcl_ListObjReplace(NULL, objPtr, 1, 0, 1, &idxPtr);
+    return objPtr;
+}
+
+static void
+RedoLinkSegmentPerform(
+    TkSharedText *sharedTextPtr,
+    TkTextUndoInfo *undoInfo,
+    TkTextUndoInfo *redoInfo,
+    bool isRedo)
+{
+    RedoTokenLinkSegment *token = (RedoTokenLinkSegment *) undoInfo->token;
+    TkTextIndex index;
+
+    TkBTreeReInsertSegment(sharedTextPtr, &token->index, token->segPtr);
+
+    if (redoInfo) {
+	redoInfo->token = undoInfo->token;
+	token->undoType = &undoTokenLinkSegmentType;
+    }
+
+    GetIndex(sharedTextPtr, token->segPtr, &index);
+    TextChanged(sharedTextPtr, &index);
+    token->segPtr->refCount += 1;
+    TK_BTREE_DEBUG(TkBTreeCheck(sharedTextPtr->tree));
+}
+
+static void
+RedoLinkSegmentGetRange(
+    const TkSharedText *sharedTextPtr,
+    const TkTextUndoToken *item,
+    TkTextIndex *startIndex,
+    TkTextIndex *endIndex)
+{
+    const RedoTokenLinkSegment *token = (const RedoTokenLinkSegment *) item;
+    TkBTreeUndoIndexToIndex(sharedTextPtr, &token->index, startIndex);
+    *endIndex = *startIndex;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextWindowCmd --
+ *
+ *	This function implements the "window" widget command for text widgets.
+ *	See the user documentation for details on what it does.
+ *
+ * Results:
+ *	A standard Tcl result or error.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *--------------------------------------------------------------
+ */
+
+int
+TkTextWindowCmd(
+    TkText *textPtr,		/* Information about text widget. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. Someone else has already
+				 * parsed this command enough to know that
+				 * objv[1] is "window". */
+{
+    int optionIndex;
+    static const char *const windOptionStrings[] = {
+	"cget", "configure", "create", "names", NULL
+    };
+    enum windOptions {
+	WIND_CGET, WIND_CONFIGURE, WIND_CREATE, WIND_NAMES
+    };
+    TkTextSegment *ewPtr;
+
+    assert(textPtr);
+
+    if (objc < 3) {
+	Tcl_WrongNumArgs(interp, 2, objv, "option ?arg arg ...?");
+	return TCL_ERROR;
+    }
+    if (Tcl_GetIndexFromObjStruct(interp, objv[2], windOptionStrings,
+	    sizeof(char *), "window option", 0, &optionIndex) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    switch ((enum windOptions) optionIndex) {
+    case WIND_CGET: {
+	TkTextIndex index;
+	TkTextSegment *ewPtr;
+	Tcl_Obj *objPtr;
+	TkTextEmbWindowClient *client;
+
+	if (objc != 5) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "index option");
+	    return TCL_ERROR;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[3], &index)) {
+	    return TCL_ERROR;
+	}
+	ewPtr = TkTextIndexGetContentSegment(&index, NULL);
+	if (ewPtr->typePtr != &tkTextEmbWindowType) {
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		    "no embedded window at index \"%s\"", Tcl_GetString(objv[3])));
+	    Tcl_SetErrorCode(interp, "TK", "TEXT", "NO_WINDOW", NULL);
+	    return TCL_ERROR;
+	}
+
+	/*
+	 * Copy over client specific value before querying.
+	 */
+
+	if ((client = EmbWinGetClient(textPtr, ewPtr))) {
+	    ewPtr->body.ew.tkwin = client->tkwin;
+	} else {
+	    ewPtr->body.ew.tkwin = NULL;
+	}
+
+	objPtr = Tk_GetOptionValue(interp, (char *) &ewPtr->body.ew,
+		ewPtr->body.ew.optionTable, objv[4], textPtr->tkwin);
+	if (!objPtr) {
+	    return TCL_ERROR;
+	}
+	Tcl_SetObjResult(interp, objPtr);
+	return TCL_OK;
+    }
+    case WIND_CONFIGURE: {
+	TkTextIndex index;
+	TkTextSegment *ewPtr;
+
+	if (objc < 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "index ?option value ...?");
+	    return TCL_ERROR;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[3], &index)) {
+	    return TCL_ERROR;
+	}
+	ewPtr = TkTextIndexGetContentSegment(&index, NULL);
+	if (ewPtr->typePtr != &tkTextEmbWindowType) {
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
+		    "no embedded window at index \"%s\"", Tcl_GetString(objv[3])));
+	    Tcl_SetErrorCode(interp, "TK", "TEXT", "NO_WINDOW", NULL);
+	    return TCL_ERROR;
+	}
+	if (objc <= 5) {
+	    TkTextEmbWindowClient *client;
+	    Tcl_Obj *objPtr;
+
+	    /*
+	     * Copy over client specific value before querying.
+	     */
+
+	    if ((client = EmbWinGetClient(textPtr, ewPtr))) {
+		ewPtr->body.ew.tkwin = client->tkwin;
+	    } else {
+		ewPtr->body.ew.tkwin = NULL;
+	    }
+
+	    objPtr = Tk_GetOptionInfo(
+		    interp,
+		    (char *) &ewPtr->body.ew,
+		    ewPtr->body.ew.optionTable,
+		    objc == 5 ? objv[4] : NULL,
+		    textPtr->tkwin);
+	    if (!objPtr) {
+		return TCL_ERROR;
+	    }
+	    Tcl_SetObjResult(interp, objPtr);
+	    return TCL_OK;
+	} else {
+	    TextChanged(textPtr->sharedTextPtr, &index);
+	    return EmbWinConfigure(textPtr, ewPtr, objc - 4, objv + 4);
+	}
+    }
+    case WIND_CREATE: {
+	TkSharedText *sharedTextPtr = textPtr->sharedTextPtr;
+	TkTextIndex index;
+	TkTextEmbWindowClient *client;
+	int res;
+
+	/*
+	 * Add a new window. Find where to put the new window, and mark that
+	 * position for redisplay.
+	 */
+
+	if (objc < 4) {
+	    Tcl_WrongNumArgs(interp, 3, objv, "index ?option value ...?");
+	    return TCL_ERROR;
+	}
+	if (!TkTextGetIndexFromObj(interp, textPtr, objv[3], &index)) {
+	    return TCL_ERROR;
+	}
+
+	if (textPtr->state == TK_TEXT_STATE_DISABLED) {
+#if !SUPPORT_DEPRECATED_MODS_OF_DISABLED_WIDGET
+	    Tcl_SetObjResult(interp, Tcl_ObjPrintf("attempt to modify disabled widget"));
+	    Tcl_SetErrorCode(interp, "TK", "TEXT", "NOT_ALLOWED", NULL);
+	    return TCL_ERROR;
+#endif /* SUPPORT_DEPRECATED_MODS_OF_DISABLED_WIDGET */
+	}
+
+	/*
+	 * Don't allow insertions on the last line of the text.
+	 */
+
+	if (!TkTextIndexEnsureBeforeLastChar(&index)) {
+#if SUPPORT_DEPRECATED_MODS_OF_DISABLED_WIDGET
+		return TCL_OK;
+#else
+		Tcl_SetObjResult(textPtr->interp, Tcl_NewStringObj(
+			"cannot insert window into dead peer", -1));
+		Tcl_SetErrorCode(textPtr->interp, "TK", "TEXT", "WINDOW_CREATE_USAGE", NULL);
+		return TCL_ERROR;
+#endif
+	}
+
+	/*
+	 * Create the new window segment and initialize it.
+	 */
+
+	ewPtr = MakeWindow(textPtr);
+	client = ewPtr->body.ew.clients;
+
+	/*
+	 * Link the segment into the text widget, then configure it (delete it
+	 * again if the configuration fails).
+	 */
+
+	TkBTreeLinkSegment(sharedTextPtr, ewPtr, &index);
+	res = EmbWinConfigure(textPtr, ewPtr, objc - 4, objv + 4);
+	client->tkwin = ewPtr->body.ew.tkwin;
+	if (res != TCL_OK) {
+	    TkBTreeUnlinkSegment(sharedTextPtr, ewPtr);
+	    TkTextWinFreeClient(NULL, client);
+	    ewPtr->body.ew.clients = NULL;
+	    ReleaseWindow(ewPtr);
+	    return TCL_ERROR;
+	}
+	TextChanged(sharedTextPtr, &index);
+
+	if (!TkTextUndoStackIsFull(sharedTextPtr->undoStack)) {
+	    UndoTokenLinkSegment *token;
+
+	    assert(sharedTextPtr->undoStack);
+	    assert(ewPtr->typePtr == &tkTextEmbWindowType);
+
+	    token = malloc(sizeof(UndoTokenLinkSegment));
+	    token->undoType = &undoTokenLinkSegmentType;
+	    token->segPtr = ewPtr;
+	    ewPtr->refCount += 1;
+	    DEBUG_ALLOC(tkTextCountNewUndoToken++);
+
+	    TkTextPushUndoToken(sharedTextPtr, token, 0);
+	}
+
+	TkTextUpdateAlteredFlag(sharedTextPtr);
+	break;
+    }
+    case WIND_NAMES: {
+	Tcl_HashSearch search;
+	Tcl_HashEntry *hPtr;
+	Tcl_Obj *resultObj;
+
+	if (objc != 3) {
+	    Tcl_WrongNumArgs(interp, 3, objv, NULL);
+	    return TCL_ERROR;
+	}
+	resultObj = Tcl_NewObj();
+	for (hPtr = Tcl_FirstHashEntry(&textPtr->sharedTextPtr->windowTable, &search);
+		hPtr;
+		hPtr = Tcl_NextHashEntry(&search)) {
+	    Tcl_ListObjAppendElement(NULL, resultObj, Tcl_NewStringObj(
+		    Tcl_GetHashKey(&textPtr->sharedTextPtr->markTable, hPtr), -1));
+	}
+	Tcl_SetObjResult(interp, resultObj);
+	break;
+    }
+    }
+    return TCL_OK;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * MakeWindow --
+ *
+ *	This function is called to create a window segment.
+ *
+ * Results:
+ *	The return value is the newly created window.
+ *
+ * Side effects:
+ *	Some memory will be allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextSegment *
+MakeWindow(
+    TkText *textPtr)		/* Information about text widget that contains embedded image. */
+{
+    TkTextSegment *ewPtr;
+    TkTextEmbWindowClient *client;
+
+    ewPtr = memset(malloc(SEG_SIZE(TkTextEmbWindow)), 0, SEG_SIZE(TkTextEmbWindow));
+    ewPtr->typePtr = &tkTextEmbWindowType;
+    ewPtr->size = 1;
+    ewPtr->refCount = 1;
+    ewPtr->body.ew.sharedTextPtr = textPtr->sharedTextPtr;
+    ewPtr->body.ew.align = ALIGN_CENTER;
+    ewPtr->body.ew.optionTable = Tk_CreateOptionTable(textPtr->interp, optionSpecs);
+    DEBUG_ALLOC(tkTextCountNewSegment++);
+
+    client = memset(malloc(sizeof(TkTextEmbWindowClient)), 0, sizeof(TkTextEmbWindowClient));
+    client->textPtr = textPtr;
+    client->parent = ewPtr;
+    ewPtr->body.ew.clients = client;
+
+    return ewPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextMakeWindow --
+ *
+ *	This function is called to create a window segment.
+ *
+ * Results:
+ *	The return value is a standard Tcl result. If TCL_ERROR is returned,
+ *	then the interp's result contains an error message.
+ *
+ * Side effects:
+ *	Some memory will be allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+TkTextSegment *
+TkTextMakeWindow(
+    TkText *textPtr,		/* Information about text widget that contains embedded window. */
+    Tcl_Obj *options)		/* Options for this window. */
+{
+    TkTextSegment *ewPtr;
+    Tcl_Obj **objv;
+    int objc;
+
+    assert(options);
+
+    if (Tcl_ListObjGetElements(textPtr->interp, options, &objc, &objv) != TCL_OK) {
+	return NULL;
+    }
+
+    ewPtr = MakeWindow(textPtr);
+
+    if (EmbWinConfigure(textPtr, ewPtr, objc, objv) == TCL_OK) {
+	Tcl_ResetResult(textPtr->interp);
+    } else {
+	TkTextWinFreeClient(NULL, ewPtr->body.ew.clients);
+	ewPtr->body.ew.clients = NULL;
+	ReleaseWindow(ewPtr);
+	ewPtr = NULL;
+    }
+
+    return ewPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinConfigure --
+ *
+ *	This function is called to handle configuration options for an
+ *	embedded window, using an objc/objv list.
+ *
+ * Results:
+ *	The return value is a standard Tcl result. If TCL_ERROR is returned,
+ *	then the interp's result contains an error message..
+ *
+ * Side effects:
+ *	Configuration information for the embedded window changes, such as
+ *	alignment, stretching, or name of the embedded window.
+ *
+ *	Note that this function may leave widget specific client information
+ *	with a NULL tkwin attached to ewPtr. While we could choose to clean up
+ *	the client data structure here, there is no need to do so, and it is
+ *	likely that the user is going to adjust the tkwin again soon.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+IsPreservedWindow(
+    const TkTextEmbWindowClient *client)
+{
+    return client && !client->hPtr;
+}
+
+static int
+EmbWinConfigure(
+    TkText *textPtr,		/* Information about text widget that contains
+				 * embedded window. */
+    TkTextSegment *ewPtr,	/* Embedded window to be configured. */
+    int objc,			/* Number of strings in objv. */
+    Tcl_Obj *const objv[])	/* Array of objects describing configuration options. */
+{
+    Tk_Window oldWindow;
+    TkTextEmbWindowClient *client;
+
+    assert(textPtr);
+
+    /*
+     * Copy over client specific value before querying or setting.
+     */
+
+    client = EmbWinGetClient(textPtr, ewPtr);
+    ewPtr->body.ew.tkwin = client ? client->tkwin : NULL;
+    oldWindow = ewPtr->body.ew.tkwin;
+
+    if (Tk_SetOptions(textPtr->interp, (char *) &ewPtr->body.ew,
+	    ewPtr->body.ew.optionTable, objc, objv, textPtr->tkwin, NULL, NULL) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    if (oldWindow != ewPtr->body.ew.tkwin && (!oldWindow || !IsPreservedWindow(client))) {
+	if (oldWindow) {
+	    Tcl_HashEntry *hPtr;
+
+	    textPtr->sharedTextPtr->numWindows -= 1;
+	    hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->windowTable, Tk_PathName(oldWindow));
+	    assert(hPtr);
+	    Tcl_DeleteHashEntry(hPtr);
+	    Tk_DeleteEventHandler(oldWindow, StructureNotifyMask, EmbWinStructureProc, client);
+	    Tk_ManageGeometry(oldWindow, NULL, NULL);
+	    if (textPtr->tkwin != Tk_Parent(oldWindow)) {
+		Tk_UnmaintainGeometry(oldWindow, textPtr->tkwin);
+	    } else {
+		Tk_UnmapWindow(oldWindow);
+	    }
+	}
+	if (client) {
+	    client->tkwin = NULL;
+	    client->hPtr = NULL;
+	}
+	if (ewPtr->body.ew.tkwin) {
+	    Tk_Window ancestor, parent;
+	    bool cantEmbed = false;
+	    bool isNew;
+
+	    /*
+	     * Make sure that the text is either the parent of the embedded
+	     * window or a descendant of that parent. Also, don't allow a
+	     * top-level window to be managed inside a text.
+	     */
+
+	    parent = Tk_Parent(ewPtr->body.ew.tkwin);
+	    for (ancestor = textPtr->tkwin; ; ancestor = Tk_Parent(ancestor)) {
+		if (ancestor == parent) {
+		    break;
+		}
+		if (Tk_TopWinHierarchy(ancestor)) {
+		    cantEmbed = true;
+		    break;
+		}
+	    }
+	    if (cantEmbed
+		    || Tk_TopWinHierarchy(ewPtr->body.ew.tkwin)
+		    || (ewPtr->body.ew.tkwin == textPtr->tkwin)) {
+		Tcl_SetObjResult(textPtr->interp, Tcl_ObjPrintf("can't embed %s in %s",
+			Tk_PathName(ewPtr->body.ew.tkwin), Tk_PathName(textPtr->tkwin)));
+		Tcl_SetErrorCode(textPtr->interp, "TK", "GEOMETRY", "HIERARCHY", NULL);
+		ewPtr->body.ew.tkwin = NULL;
+		if (client) {
+		    client->tkwin = NULL;
+		}
+		return TCL_ERROR;
+	    }
+
+	    if (!client) {
+		/*
+		 * Have to make the new client.
+		 */
+
+		client = malloc(sizeof(TkTextEmbWindowClient));
+		memset(client, 0, sizeof(TkTextEmbWindowClient));
+		client->next = ewPtr->body.ew.clients;
+		client->textPtr = textPtr;
+		client->parent = ewPtr;
+		ewPtr->body.ew.clients = client;
+	    }
+	    client->tkwin = ewPtr->body.ew.tkwin;
+
+	    /*
+	     * Take over geometry management for the window, plus create an
+	     * event handler to find out when it is deleted.
+	     */
+
+	    Tk_ManageGeometry(ewPtr->body.ew.tkwin, &textGeomType, client);
+	    Tk_CreateEventHandler(ewPtr->body.ew.tkwin, StructureNotifyMask,
+		    EmbWinStructureProc, client);
+
+	    /*
+	     * Special trick! Must enter into the hash table *after* calling
+	     * Tk_ManageGeometry: if the window was already managed elsewhere
+	     * in this text, the Tk_ManageGeometry call will cause the entry
+	     * to be removed, which could potentially lose the new entry.
+	     */
+
+	    client->hPtr = Tcl_CreateHashEntry(
+		    &textPtr->sharedTextPtr->windowTable,
+		    Tk_PathName(ewPtr->body.ew.tkwin),
+		    (int *) &isNew);
+	    Tcl_SetHashValue(client->hPtr, ewPtr);
+	    textPtr->sharedTextPtr->numWindows += 1;
+	}
+    }
+    return TCL_OK;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinStructureProc --
+ *
+ *	This function is invoked by the Tk event loop whenever StructureNotify
+ *	events occur for a window that's embedded in a text widget. This
+ *	function's only purpose is to clean up when windows are deleted.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The window is disassociated from the window segment, and the portion
+ *	of the text is redisplayed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbWinStructureProc(
+    ClientData clientData,	/* Pointer to record describing window item. */
+    XEvent *eventPtr)		/* Describes what just happened. */
+{
+    TkTextEmbWindowClient *client = clientData;
+    TkTextSegment *ewPtr;
+
+    if (eventPtr->type != DestroyNotify || !client->hPtr) {
+	return;
+    }
+
+    ewPtr = client->parent;
+
+    assert(ewPtr->typePtr);
+    assert(client->hPtr == Tcl_FindHashEntry(&ewPtr->body.ew.sharedTextPtr->windowTable,
+	    Tk_PathName(client->tkwin)));
+
+    /*
+     * This may not exist if the entire widget is being deleted.
+     */
+
+    Tcl_DeleteHashEntry(client->hPtr);
+    ewPtr->body.ew.sharedTextPtr->numWindows -= 1;
+    ewPtr->body.ew.tkwin = NULL;
+    client->tkwin = NULL;
+    client->hPtr = NULL;
+    EmbWinRequestProc(client, NULL);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinRequestProc --
+ *
+ *	This function is invoked whenever a window that's associated with a
+ *	window canvas item changes its requested dimensions.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The size and location on the screen of the window may change,
+ *	depending on the options specified for the window item.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbWinRequestProc(
+    ClientData clientData,	/* Pointer to record for window item. */
+    Tk_Window tkwin)		/* Window that changed its desired size. */
+{
+    TkTextEmbWindowClient *client = clientData;
+    TkTextSegment *ewPtr = client->parent;
+    TkTextIndex index;
+
+    assert(ewPtr->typePtr);
+
+    if (ewPtr->sectionPtr) {
+	assert(ewPtr->sectionPtr);
+	TkTextIndexClear(&index, client->textPtr);
+	TkTextIndexSetSegment(&index, ewPtr);
+	TextChanged(ewPtr->body.ew.sharedTextPtr, &index);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinLostSlaveProc --
+ *
+ *	This function is invoked by the Tk geometry manager when a slave
+ *	window managed by a text widget is claimed away by another geometry
+ *	manager.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The window is disassociated from the window segment, and the portion
+ *	of the text is redisplayed.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbWinLostSlaveProc(
+    ClientData clientData,	/* Pointer to record describing window item. */
+    Tk_Window tkwin)		/* Window that was claimed away by another geometry manager. */
+{
+    TkTextEmbWindowClient *client = clientData;
+    TkTextSegment *ewPtr = client->parent;
+    TkText *textPtr = client->textPtr;
+    TkTextIndex index;
+    TkTextEmbWindowClient *loop;
+
+    assert(!IsPreservedWindow(client));
+
+    assert(client->tkwin);
+    client->displayed = false;
+    Tk_DeleteEventHandler(client->tkwin, StructureNotifyMask, EmbWinStructureProc, client);
+    EmbWinDelayedUnmap(client);
+    if (client->hPtr) {
+	ewPtr->body.ew.sharedTextPtr->numWindows -= 1;
+	Tcl_DeleteHashEntry(client->hPtr);
+	client->hPtr = NULL;
+    }
+    client->tkwin = NULL;
+    ewPtr->body.ew.tkwin = NULL;
+
+    /*
+     * Free up the memory allocation for this client.
+     */
+
+    loop = ewPtr->body.ew.clients;
+    if (loop == client) {
+	ewPtr->body.ew.clients = client->next;
+    } else {
+	while (loop->next != client) {
+	    loop = loop->next;
+	}
+	loop->next = client->next;
+    }
+    free(client);
+
+    TkTextIndexClear(&index, textPtr);
+    TkTextIndexSetSegment(&index, ewPtr);
+    TextChanged(ewPtr->body.ew.sharedTextPtr, &index);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextWinFreeClient --
+ *
+ *	Free up the hash entry and client information for a given embedded
+ *	window.
+ *
+ *	It is assumed the caller will manage the linked list of clients
+ *	associated with the relevant TkTextSegment.
+ *
+ * Results:
+ *	Nothing.
+ *
+ * Side effects:
+ *	The embedded window information for a single client is deleted, if it
+ *	exists, and any resources associated with it are released.
+ *
+ *--------------------------------------------------------------
+ */
+
+void
+TkTextWinFreeClient(
+    Tcl_HashEntry *hPtr,	/* Hash entry corresponding to this client, or NULL */
+    TkTextEmbWindowClient *client)
+				/* Client data structure, with the 'tkwin' field to be cleaned up. */
+{
+    if (hPtr) {
+	/*
+	 * (It's possible for there to be no hash table entry for this window,
+	 * if an error occurred while creating the window segment but before
+	 * the window got added to the table)
+	 */
+
+	client->parent->body.ew.sharedTextPtr->numWindows -= 1;
+	Tcl_DeleteHashEntry(hPtr);
+    }
+
+    /*
+     * Delete the event handler for the window before destroying the window,
+     * so that EmbWinStructureProc doesn't get called (we'll already do
+     * everything that it would have done, and it will just get confused).
+     */
+
+    if (client->tkwin) {
+	Tk_DeleteEventHandler(client->tkwin, StructureNotifyMask, EmbWinStructureProc, client);
+	Tk_DestroyWindow(client->tkwin);
+    }
+    Tcl_CancelIdleCall(EmbWinDelayedUnmap, client);
+
+    /*
+     * Free up this client.
+     */
+
+    free(client);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinInspectProc --
+ *
+ *	This function is invoked to build the information for
+ *	"inspect".
+ *
+ * Results:
+ *	Return a TCL object containing the information for
+ *	"inspect".
+ *
+ * Side effects:
+ *	Storage is allocated.
+ *
+ *--------------------------------------------------------------
+ */
+
+static Tcl_Obj *
+EmbWinInspectProc(
+    const TkSharedText *sharedTextPtr,
+    const TkTextSegment *segPtr)
+{
+    Tcl_Obj *objPtr = Tcl_NewObj();
+    Tcl_Obj *objPtr2 = Tcl_NewObj();
+    TkTextTag **tagLookup = sharedTextPtr->tagLookup;
+    const TkTextTagSet *tagInfoPtr = segPtr->tagInfoPtr;
+    unsigned i = TkTextTagSetFindFirst(tagInfoPtr);
+    Tcl_DString opts;
+
+    assert(sharedTextPtr->peers);
+
+    for ( ; i != TK_TEXT_TAG_SET_NPOS; i = TkTextTagSetFindNext(tagInfoPtr, i)) {
+	const TkTextTag *tagPtr = tagLookup[i];
+	Tcl_ListObjAppendElement(NULL, objPtr2, Tcl_NewStringObj(tagPtr->name, -1));
+    }
+
+    Tcl_DStringInit(&opts);
+    TkTextInspectOptions(sharedTextPtr->peers, &segPtr->body.ew, segPtr->body.ew.optionTable,
+	    &opts, false, false);
+
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(segPtr->typePtr->name, -1));
+    Tcl_ListObjAppendElement(NULL, objPtr, objPtr2);
+    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewStringObj(Tcl_DStringValue(&opts),
+	    Tcl_DStringLength(&opts)));
+
+    Tcl_DStringFree(&opts);
+    return objPtr;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * ReleaseWindow --
+ *
+ *	Free embedded window
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The embedded window is deleted, and any resources
+ *	associated with it are released.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+ReleaseWindow(
+    TkTextSegment *ewPtr)
+{
+    TkTextEmbWindowClient *client = ewPtr->body.ew.clients;
+
+    assert(ewPtr->typePtr);
+
+    while (client) {
+	TkTextEmbWindowClient *next = client->next;
+	if (client->hPtr) {
+	    TkTextWinFreeClient(client->hPtr, client);
+	}
+	client = next;
+    }
+    ewPtr->body.ew.clients = NULL;
+    Tk_FreeConfigOptions((char *) &ewPtr->body.ew, ewPtr->body.ew.optionTable, NULL);
+    TkTextTagSetDecrRefCount(ewPtr->tagInfoPtr);
+    FREE_SEGMENT(ewPtr);
+    DEBUG_ALLOC(tkTextCountDestroySegment++);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * DestroyOrUnmapWindow --
+ *
+ *	Unmap all clients of given window.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	Either destroy or only unmap the embedded window.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+DestroyOrUnmapWindow(
+    TkTextSegment *ewPtr)
+{
+    TkTextEmbWindowClient *client = ewPtr->body.ew.clients;
+
+    assert(ewPtr->typePtr);
+    assert(ewPtr->refCount > 0);
+
+    for ( ; client; client = client->next) {
+	if (client->hPtr) {
+	    client->parent->body.ew.sharedTextPtr->numWindows -= 1;
+	    Tcl_DeleteHashEntry(client->hPtr);
+	    client->hPtr = NULL;
+	    client->displayed = false;
+	}
+	Tcl_CancelIdleCall(EmbWinDelayedUnmap, client);
+	if (client->tkwin && ewPtr->body.ew.create) {
+	    Tk_DeleteEventHandler(client->tkwin, StructureNotifyMask, EmbWinStructureProc, client);
+	    Tk_DestroyWindow(client->tkwin);
+	    client->tkwin = NULL;
+	    ewPtr->body.ew.tkwin = NULL;
+	} else {
+	    EmbWinDelayedUnmap(client);
+	}
+    }
+}
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinDeleteProc --
+ *
+ *	This function is invoked by the text B-tree code whenever an embedded
+ *	window lies in a range of characters being deleted.
+ *
+ * Results:
+ *	Returns true to indicate that the deletion has been accepted.
+ *
+ * Side effects:
+ *	Depends on the action, see ReleaseWindow and DestroyOrUnmapWindow.
+ *
+ *--------------------------------------------------------------
+ */
+
+static bool
+EmbWinDeleteProc(
+    TkTextBTree tree,
+    TkTextSegment *ewPtr,	/* Segment being deleted. */
+    int flags)			/* Flags controlling the deletion. */
+{
+    assert(ewPtr->typePtr);
+
+    if (--ewPtr->refCount == 0) {
+	ReleaseWindow(ewPtr);
+    } else {
+	DestroyOrUnmapWindow(ewPtr);
+    }
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinRestoreProc --
+ *
+ *	This function is called when a window segment will be restored
+ *	from the undo chain.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The name of the mark will be freed, and the mark will be
+ *	re-entered into the hash table.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbWinRestoreProc(
+    TkTextSegment *ewPtr)	/* Segment to reuse. */
+{
+    bool isNew;
+
+    if (ewPtr->body.ew.create) {
+	/*
+	 * EmbWinLayoutProc is doing the creation of the window.
+	 */
+	assert(!ewPtr->body.ew.tkwin);
+    } else {
+	TkTextEmbWindowClient *client = ewPtr->body.ew.clients;
+
+	for ( ; client; client = client->next) {
+	    if (client->tkwin && !client->hPtr) {
+		client->hPtr = Tcl_CreateHashEntry(
+			&ewPtr->body.ew.sharedTextPtr->windowTable,
+			Tk_PathName(client->tkwin),
+			(int *) &isNew);
+		assert(isNew);
+		Tcl_SetHashValue(client->hPtr, ewPtr);
+		ewPtr->body.ew.sharedTextPtr->numWindows += 1;
+	    }
+	}
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinLayoutProc --
+ *
+ *	This function is the "layoutProc" for embedded window segments.
+ *
+ * Results:
+ *	1 is returned to indicate that the segment should be displayed. The
+ *	chunkPtr structure is filled in.
+ *
+ * Side effects:
+ *	None, except for filling in chunkPtr.
+ *
+ *--------------------------------------------------------------
+ */
+
+static int
+EmbWinLayoutProc(
+    const TkTextIndex *indexPtr,/* Identifies first character in chunk. */
+    TkTextSegment *ewPtr,	/* Segment corresponding to indexPtr. */
+    int offset,			/* Offset within segPtr corresponding to indexPtr (always 0). */
+    int maxX,			/* Chunk must not occupy pixels at this position or higher. */
+    int maxChars,		/* Chunk must not include more than this many characters. */
+    bool noCharsYet,		/* 'true' means no characters have been assigned to this line yet. */
+    TkWrapMode wrapMode,	/* Wrap mode to use for line: TEXT_WRAPMODE_CHAR, TEXT_WRAPMODE_NONE,
+    				 * TEXT_WRAPMODE_WORD, or TEXT_WRAPMODE_CODEPOINT. */
+    TkTextSpaceMode spaceMode,	/* Not used. */
+    TkTextDispChunk *chunkPtr)	/* Structure to fill in with information about this chunk. The x
+    				 * field has already been set by the caller. */
+{
+    int width, height;
+    TkTextEmbWindowClient *client;
+    TkText *textPtr = indexPtr->textPtr;
+    bool cantEmbed = false;
+
+    assert(indexPtr->textPtr);
+    assert(offset == 0);
+
+    client = EmbWinGetClient(textPtr, ewPtr);
+    ewPtr->body.ew.tkwin = client ? client->tkwin : NULL;
+
+    if (!ewPtr->body.ew.tkwin && ewPtr->body.ew.create) {
+	int code;
+	bool isNew;
+	Tk_Window ancestor;
+	const char *before, *string;
+	Tcl_DString name, buf, *dsPtr = NULL;
+
+	before = ewPtr->body.ew.create;
+
+	/*
+	 * Find everything up to the next % character and append it to the
+	 * result string.
+	 */
+
+	string = before;
+	while (*string != 0) {
+	    if (string[0] == '%' && (string[1] == '%' || string[1] == 'W')) {
+		if (!dsPtr) {
+		    Tcl_DStringInit(&buf);
+		    dsPtr = &buf;
+		}
+		if (string != before) {
+		    Tcl_DStringAppend(dsPtr, before, (int) (string-before));
+		    before = string;
+		}
+		if (string[1] == '%') {
+		    Tcl_DStringAppend(dsPtr, "%", 1);
+		} else {
+		    /*
+		     * Substitute string as proper Tcl list element.
+		     */
+
+		    int spaceNeeded, cvtFlags, length;
+		    const char *str = Tk_PathName(textPtr->tkwin);
+
+		    spaceNeeded = Tcl_ScanElement(str, &cvtFlags);
+		    length = Tcl_DStringLength(dsPtr);
+		    Tcl_DStringSetLength(dsPtr, length + spaceNeeded);
+		    spaceNeeded = Tcl_ConvertElement(str,
+			    Tcl_DStringValue(dsPtr) + length,
+			    cvtFlags | TCL_DONT_USE_BRACES);
+		    Tcl_DStringSetLength(dsPtr, length + spaceNeeded);
+		}
+		before += 2;
+		string += 1;
+	    }
+	    string += 1;
+	}
+
+	/*
+	 * The window doesn't currently exist. Create it by evaluating the
+	 * creation script. The script must return the window's path name:
+	 * look up that name to get back to the window token. Then register
+	 * ourselves as the geometry manager for the window.
+	 */
+
+	if (dsPtr) {
+	    Tcl_DStringAppend(dsPtr, before, (int) (string-before));
+	    code = Tcl_EvalEx(textPtr->interp, Tcl_DStringValue(dsPtr), -1, TCL_EVAL_GLOBAL);
+	    Tcl_DStringFree(dsPtr);
+	} else {
+	    code = Tcl_EvalEx(textPtr->interp, ewPtr->body.ew.create, -1, TCL_EVAL_GLOBAL);
+	}
+	if (code != TCL_OK) {
+	createError:
+	    Tcl_BackgroundException(textPtr->interp, code);
+	    goto gotWindow;
+	}
+	Tcl_DStringInit(&name);
+	Tcl_DStringAppend(&name, Tcl_GetStringResult(textPtr->interp), -1);
+	Tcl_ResetResult(textPtr->interp);
+	ewPtr->body.ew.tkwin = Tk_NameToWindow(textPtr->interp, Tcl_DStringValue(&name), textPtr->tkwin);
+	Tcl_DStringFree(&name);
+	if (!ewPtr->body.ew.tkwin) {
+	    goto createError;
+	}
+
+	for (ancestor = textPtr->tkwin; ; ancestor = Tk_Parent(ancestor)) {
+	    if (ancestor == Tk_Parent(ewPtr->body.ew.tkwin)) {
+		break;
+	    }
+	    if (Tk_TopWinHierarchy(ancestor)) {
+	    	cantEmbed = true;
+		break;
+	    }
+	}
+	if (cantEmbed
+		|| Tk_TopWinHierarchy(ewPtr->body.ew.tkwin)
+		|| textPtr->tkwin == ewPtr->body.ew.tkwin) {
+	    Tcl_SetObjResult(textPtr->interp, Tcl_ObjPrintf("can't embed %s relative to %s",
+		    Tk_PathName(ewPtr->body.ew.tkwin), Tk_PathName(textPtr->tkwin)));
+	    Tcl_SetErrorCode(textPtr->interp, "TK", "GEOMETRY", "HIERARCHY", NULL);
+	    Tcl_BackgroundException(textPtr->interp, TCL_ERROR);
+	    ewPtr->body.ew.tkwin = NULL;
+	    goto gotWindow;
+	}
+
+	if (!client) {
+	    /*
+	     * We just used a '-create' script to make a new window, which we
+	     * now need to add to our client list.
+	     */
+
+	    client = malloc(sizeof(TkTextEmbWindowClient));
+	    memset(client, 0, sizeof(TkTextEmbWindowClient));
+	    client->next = ewPtr->body.ew.clients;
+	    client->textPtr = textPtr;
+	    client->parent = ewPtr;
+	    ewPtr->body.ew.clients = client;
+	}
+
+	client->tkwin = ewPtr->body.ew.tkwin;
+	Tk_ManageGeometry(client->tkwin, &textGeomType, client);
+	Tk_CreateEventHandler(client->tkwin, StructureNotifyMask, EmbWinStructureProc, client);
+
+	/*
+	 * Special trick! Must enter into the hash table *after* calling
+	 * Tk_ManageGeometry: if the window was already managed elsewhere in
+	 * this text, the Tk_ManageGeometry call will cause the entry to be
+	 * removed, which could potentially lose the new entry.
+	 */
+
+	client->hPtr = Tcl_CreateHashEntry(
+		&textPtr->sharedTextPtr->windowTable, Tk_PathName(client->tkwin), (int *) &isNew);
+	Tcl_SetHashValue(client->hPtr, ewPtr);
+	ewPtr->body.ew.sharedTextPtr->numWindows += 1;
+    }
+
+    /*
+     * See if there's room for this window on this line.
+     */
+
+  gotWindow:
+    if (!ewPtr->body.ew.tkwin) {
+	width = 0;
+	height = 0;
+    } else {
+	width = Tk_ReqWidth(ewPtr->body.ew.tkwin) + 2*ewPtr->body.ew.padX;
+	height = Tk_ReqHeight(ewPtr->body.ew.tkwin) + 2*ewPtr->body.ew.padY;
+    }
+    if (width > maxX - chunkPtr->x && !noCharsYet && textPtr->wrapMode != TEXT_WRAPMODE_NONE) {
+	return 0;
+    }
+
+    /*
+     * Fill in the chunk structure.
+     */
+
+    chunkPtr->layoutProcs = &layoutWindowProcs;
+    chunkPtr->numBytes = 1;
+    if (ewPtr->body.ew.align == ALIGN_BASELINE) {
+	chunkPtr->minAscent = height - ewPtr->body.ew.padY;
+	chunkPtr->minDescent = ewPtr->body.ew.padY;
+	chunkPtr->minHeight = 0;
+    } else {
+	chunkPtr->minAscent = 0;
+	chunkPtr->minDescent = 0;
+	chunkPtr->minHeight = height;
+    }
+    chunkPtr->width = width;
+    chunkPtr->breakIndex = (wrapMode == TEXT_WRAPMODE_NONE) ? -1 : 1;
+    chunkPtr->clientData = ewPtr;
+    if (client) {
+	client->chunkCount += 1;
+    }
+    return 1;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinCheckProc --
+ *
+ *	This function is invoked by the B-tree code to perform consistency
+ *	checks on embedded windows.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The function panics if it detects anything wrong with the embedded
+ *	window.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbWinCheckProc(
+    const TkSharedText *sharedTextPtr,	/* Handle to shared text resource. */
+    const TkTextSegment *ewPtr)		/* Segment to check. */
+{
+    if (!ewPtr->nextPtr) {
+	Tcl_Panic("EmbWinCheckProc: embedded window is last segment in line");
+    }
+    if (ewPtr->size != 1) {
+	Tcl_Panic("EmbWinCheckProc: embedded window has size %d", ewPtr->size);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinDisplayProc --
+ *
+ *	This function is invoked by the text displaying code when it is time
+ *	to actually draw an embedded window chunk on the screen.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The embedded window gets moved to the correct location and mapped onto
+ *	the screen.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbWinDisplayProc(
+    TkText *textPtr,		/* Information about text widget. */
+    TkTextDispChunk *chunkPtr,	/* Chunk that is to be drawn. */
+    int x,			/* X-position in dst at which to draw this
+				 * chunk (differs from the x-position in the
+				 * chunk because of scrolling). */
+    int y,			/* Top of rectangular bounding box for line:
+				 * tells where to draw this chunk in dst
+				 * (x-position is in the chunk itself). */
+    int lineHeight,		/* Total height of line. */
+    int baseline,		/* Offset of baseline from y. */
+    Display *display,		/* Display to use for drawing (unused).  */
+    Drawable dst,		/* Pixmap or window in which to draw (unused).  */
+    int screenY)		/* Y-coordinate in text window that corresponds to y. */
+{
+    int lineX, windowX, windowY, width, height;
+    Tk_Window tkwin;
+    TkTextSegment *ewPtr = chunkPtr->clientData;
+    TkTextEmbWindowClient *client = EmbWinGetClient(textPtr, ewPtr);
+
+    if (!client || !(tkwin = client->tkwin)) {
+	return;
+    }
+
+    if (x + chunkPtr->width <= 0) {
+	/*
+	 * The window is off-screen; just unmap it.
+	 */
+
+	client->displayed = false;
+	EmbWinDelayedUnmap(client);
+	return;
+    }
+
+    /*
+     * Compute the window's location and size in the text widget, taking into
+     * account the align and stretch values for the window.
+     */
+
+    EmbWinBboxProc(textPtr, chunkPtr, 0, screenY, lineHeight, baseline,
+	    &lineX, &windowY, &width, &height);
+    windowX = lineX - chunkPtr->x + x;
+
+    /*
+     * Mark the window as displayed so that it won't get unmapped.
+     * This needs to be done before the next instruction block because
+     * Tk_MaintainGeometry/Tk_MapWindow will run event handlers, in
+     * particular for the <Map> event, and if the bound script deletes
+     * the embedded window its clients will get freed.
+     */
+
+    if (textPtr->tkwin == Tk_Parent(tkwin)) {
+	if (windowX != Tk_X(tkwin)
+		|| windowY != Tk_Y(tkwin)
+		|| Tk_ReqWidth(tkwin) != Tk_Width(tkwin)
+		|| height != Tk_Height(tkwin)) {
+	    Tk_MoveResizeWindow(tkwin, windowX, windowY, width, height);
+	}
+	if (!client->displayed) {
+	    Tk_MapWindow(tkwin);
+	}
+    } else {
+	Tk_MaintainGeometry(tkwin, textPtr->tkwin, windowX, windowY, width, height);
+    }
+
+    client->displayed = true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinUndisplayProc --
+ *
+ *	This function is called when the chunk for an embedded window is no
+ *	longer going to be displayed. It arranges for the window associated
+ *	with the chunk to be unmapped.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The window is scheduled for unmapping.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbWinUndisplayProc(
+    TkText *textPtr,		/* Overall information about text widget. */
+    TkTextDispChunk *chunkPtr)	/* Chunk that is about to be freed. */
+{
+    TkTextSegment *ewPtr = chunkPtr->clientData;
+    TkTextEmbWindowClient *client = EmbWinGetClient(textPtr, ewPtr);
+
+    if (client && --client->chunkCount == 0) {
+	/*
+	 * Don't unmap the window immediately, since there's a good chance
+	 * that it will immediately be redisplayed, perhaps even in the same
+	 * place. Instead, schedule the window to be unmapped later; the call
+	 * to EmbWinDelayedUnmap will be cancelled in the likely event that
+	 * the unmap becomes unnecessary.
+	 */
+
+	client->displayed = false;
+	Tcl_DoWhenIdle(EmbWinDelayedUnmap, client);
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinBboxProc --
+ *
+ *	This function is called to compute the bounding box of the area
+ *	occupied by an embedded window.
+ *
+ * Results:
+ *	There is no return value. *xPtr and *yPtr are filled in with the
+ *	coordinates of the upper left corner of the window, and *widthPtr and
+ *	*heightPtr are filled in with the dimensions of the window in pixels.
+ *	Note: not all of the returned bbox is necessarily visible on the
+ *	screen (the rightmost part might be off-screen to the right, and the
+ *	bottommost part might be off-screen to the bottom).
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbWinBboxProc(
+    TkText *textPtr,		/* Information about text widget. */
+    TkTextDispChunk *chunkPtr,	/* Chunk containing desired char. */
+    int index,			/* Index of desired character within the chunk. */
+    int y,			/* Topmost pixel in area allocated for this line. */
+    int lineHeight,		/* Total height of line. */
+    int baseline,		/* Location of line's baseline, in pixels measured down from y. */
+    int *xPtr, int *yPtr,	/* Gets filled in with coords of character's upper-left pixel. */
+    int *widthPtr,		/* Gets filled in with width of window, in pixels. */
+    int *heightPtr)		/* Gets filled in with height of window, in pixels. */
+{
+    Tk_Window tkwin;
+    TkTextSegment *ewPtr = chunkPtr->clientData;
+    TkTextEmbWindowClient *client = EmbWinGetClient(textPtr, ewPtr);
+
+    tkwin = client ? client->tkwin : NULL;
+    if (tkwin) {
+	*widthPtr = Tk_ReqWidth(tkwin);
+	*heightPtr = Tk_ReqHeight(tkwin);
+    } else {
+	*widthPtr = 0;
+	*heightPtr = 0;
+    }
+    *xPtr = chunkPtr->x + ewPtr->body.ew.padX;
+    if (ewPtr->body.ew.stretch) {
+	if (ewPtr->body.ew.align == ALIGN_BASELINE) {
+	    *heightPtr = baseline - ewPtr->body.ew.padY;
+	} else {
+	    *heightPtr = lineHeight - 2*ewPtr->body.ew.padY;
+	}
+    }
+    switch (ewPtr->body.ew.align) {
+    case ALIGN_BOTTOM:
+	*yPtr = y + (lineHeight - *heightPtr - ewPtr->body.ew.padY);
+	break;
+    case ALIGN_CENTER:
+	*yPtr = y + (lineHeight - *heightPtr)/2;
+	break;
+    case ALIGN_TOP:
+	*yPtr = y + ewPtr->body.ew.padY;
+	break;
+    case ALIGN_BASELINE:
+	*yPtr = y + (baseline - *heightPtr);
+	break;
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinDelayedUnmap --
+ *
+ *	This function is an idle handler that does the actual work of
+ *	unmapping an embedded window. See the comment in EmbWinUndisplayProc
+ *	for details.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The window gets unmapped, unless its chunk reference count has become
+ *	non-zero again.
+ *
+ *--------------------------------------------------------------
+ */
+
+static void
+EmbWinDelayedUnmap(
+    ClientData clientData)	/* Token for the window to be unmapped. */
+{
+    TkTextEmbWindowClient *client = clientData;
+
+    if (!client->displayed && client->tkwin) {
+	if (client->textPtr->tkwin != Tk_Parent(client->tkwin)) {
+	    Tk_UnmaintainGeometry(client->tkwin, client->textPtr->tkwin);
+	} else {
+	    Tk_UnmapWindow(client->tkwin);
+	}
+    }
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * TkTextWindowIndex --
+ *
+ *	Given the name of an embedded window within a text widget, returns an
+ *	index corresponding to the window's position in the text.
+ *
+ * Results:
+ *	The return value is true if there is an embedded window by the given name
+ *	in the text widget, false otherwise. If the window exists, *indexPtr is
+ *	filled in with its index.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+bool
+TkTextWindowIndex(
+    TkText *textPtr,		/* Text widget containing window. */
+    const char *name,		/* Name of window. */
+    TkTextIndex *indexPtr)	/* Index information gets stored here. */
+{
+    Tcl_HashEntry *hPtr;
+    TkTextSegment *ewPtr;
+
+    assert(textPtr);
+
+    if (!(hPtr = Tcl_FindHashEntry(&textPtr->sharedTextPtr->windowTable, name))) {
+	return false;
+    }
+
+    ewPtr = Tcl_GetHashValue(hPtr);
+    TkTextIndexClear(indexPtr, textPtr);
+    TkTextIndexSetSegment(indexPtr, ewPtr);
+    return true;
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * EmbWinGetClient --
+ *
+ *	Given a text widget and a segment which contains an embedded window,
+ *	find the text-widget specific information about the embedded window,
+ *	if any.
+ *
+ *	This function performs a completely linear lookup for a matching data
+ *	structure. If we envisage using this code with dozens of peer widgets,
+ *	then performance could become an issue and a more sophisticated lookup
+ *	mechanism might be desirable.
+ *
+ * Results:
+ *	NULL if no widget-specific info exists, otherwise the structure is
+ *	returned.
+ *
+ * Side effects:
+ *	None.
+ *
+ *--------------------------------------------------------------
+ */
+
+static TkTextEmbWindowClient *
+EmbWinGetClient(
+    const TkText *textPtr,	/* Information about text widget. */
+    TkTextSegment *ewPtr)	/* Segment containing embedded window. */
+{
+    TkTextEmbWindowClient *client = ewPtr->body.ew.clients;
+
+    while (client) {
+	if (client->textPtr == textPtr) {
+	    return client;
+	}
+	client = client->next;
+    }
+    return NULL;
+}
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 105
+ * End:
+ * vi:set ts=8 sw=4:
+ */
Index: tcl/tktext/text.tcl
===================================================================
--- tcl/tktext/text.tcl	(revision 0)
+++ tcl/tktext/text.tcl	(working copy)
@@ -0,0 +1,1374 @@
+# text.tcl --
+#
+# This file defines the default bindings for Tk text widgets and provides
+# procedures that help in implementing the bindings.
+#
+# Copyright (c) 1992-1994 The Regents of the University of California.
+# Copyright (c) 1994-1997 Sun Microsystems, Inc.
+# Copyright (c) 1998 by Scriptics Corporation.
+# Copyright (c) 2015-2017 Gregor Cramer
+#
+# See the file "license.terms" for information on usage and redistribution
+# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+#
+
+##########################################################################
+# TODO:
+# Currently we cannot use identifier "begin" for very first index, because
+# it has still lowest precedence, and this may clash if the application is
+# using this identifier for marks. In a later version of this file all
+# occurences of "1.0" should be replaced with "begin", as soon as "begin"
+# has highest precedence.
+##########################################################################
+
+#-------------------------------------------------------------------------
+# Elements of ::tk::Priv that are used in this file:
+#
+# afterId -		If non-null, it means that auto-scanning is underway
+#			and it gives the "after" id for the next auto-scan
+#			command to be executed.
+# char -		Character position on the line;  kept in order
+#			to allow moving up or down past short lines while
+#			still remembering the desired position.
+# mouseMoved -		Non-zero means the mouse has moved a significant
+#			amount since the button went down (so, for example,
+#			start dragging out a selection).
+# prevPos -		Used when moving up or down lines via the keyboard.
+#			Keeps track of the previous insert position, so
+#			we can distinguish a series of ups and downs, all
+#			in a row, from a new up or down.
+# selectMode -		The style of selection currently underway:
+#			char, word, or line.
+# x, y -		Last known mouse coordinates for scanning
+#			and auto-scanning.
+#
+#-------------------------------------------------------------------------
+
+#-------------------------------------------------------------------------
+# The code below creates the default class bindings for text widgets.
+#-------------------------------------------------------------------------
+
+# Standard Motif bindings:
+
+bind Text <1> {
+    tk::TextButton1 %W %x %y
+    %W tag remove sel 1.0 end
+}
+bind Text <B1-Motion> {
+    set tk::Priv(x) %x
+    set tk::Priv(y) %y
+    tk::TextSelectTo %W %x %y
+}
+bind Text <Double-1> {
+    set tk::Priv(selectMode) word
+    tk::TextSelectTo %W %x %y
+    catch {%W mark set insert sel.first}
+}
+bind Text <Triple-1> {
+    set tk::Priv(selectMode) line
+    tk::TextSelectTo %W %x %y
+    catch {%W mark set insert sel.first}
+}
+bind Text <Shift-1> {
+    tk::TextResetAnchor %W @%x,%y
+    set tk::Priv(selectMode) char
+    tk::TextSelectTo %W %x %y
+}
+bind Text <Double-Shift-1>	{
+    set tk::Priv(selectMode) word
+    tk::TextSelectTo %W %x %y 1
+}
+bind Text <Triple-Shift-1>	{
+    set tk::Priv(selectMode) line
+    tk::TextSelectTo %W %x %y
+}
+bind Text <B1-Leave> {
+    set tk::Priv(x) %x
+    set tk::Priv(y) %y
+    tk::TextAutoScan %W
+}
+bind Text <B1-Enter> {
+    tk::CancelRepeat
+}
+bind Text <ButtonRelease-1> {
+    tk::CancelRepeat
+}
+bind Text <Control-1> {
+    %W mark set insert @%x,%y
+    # An operation that moves the insert mark without making it
+    # one end of the selection must insert an autoseparator
+    if {[%W cget -autoseparators]} {
+	%W edit separator
+    }
+}
+# stop an accidental double click triggering <Double-Button-1>
+bind Text <Double-Control-1> { # nothing }
+# stop an accidental movement triggering <B1-Motion>
+bind Text <Control-B1-Motion> { # nothing }
+bind Text <<PrevChar>> {
+    tk::TextSetCursor %W insert-1displaychars
+}
+bind Text <<NextChar>> {
+    tk::TextSetCursor %W insert+1displaychars
+}
+bind Text <<PrevLine>> {
+    tk::TextSetCursor %W [tk::TextUpDownLine %W -1]
+}
+bind Text <<NextLine>> {
+    tk::TextSetCursor %W [tk::TextUpDownLine %W 1]
+}
+bind Text <<SelectPrevChar>> {
+    tk::TextKeySelect %W [%W index {insert - 1displaychars}]
+}
+bind Text <<SelectNextChar>> {
+    tk::TextKeySelect %W [%W index {insert + 1displaychars}]
+}
+bind Text <<SelectPrevLine>> {
+    tk::TextKeySelect %W [tk::TextUpDownLine %W -1 yes]
+}
+bind Text <<SelectNextLine>> {
+    tk::TextKeySelect %W [tk::TextUpDownLine %W 1 yes]
+}
+bind Text <<PrevWord>> {
+    tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
+}
+bind Text <<NextWord>> {
+    tk::TextSetCursor %W [tk::TextNextWord %W insert]
+}
+bind Text <<PrevPara>> {
+    tk::TextSetCursor %W [tk::TextPrevPara %W insert]
+}
+bind Text <<NextPara>> {
+    tk::TextSetCursor %W [tk::TextNextPara %W insert]
+}
+bind Text <<SelectPrevWord>> {
+    tk::TextKeySelect %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
+}
+bind Text <<SelectNextWord>> {
+    tk::TextKeySelect %W [tk::TextNextWord %W insert]
+}
+bind Text <<SelectPrevPara>> {
+    tk::TextKeySelect %W [tk::TextPrevPara %W insert]
+}
+bind Text <<SelectNextPara>> {
+    tk::TextKeySelect %W [tk::TextNextPara %W insert]
+}
+bind Text <Prior> {
+    tk::TextSetCursor %W [tk::TextScrollPages %W -1]
+}
+bind Text <Shift-Prior> {
+    tk::TextKeySelect %W [tk::TextScrollPages %W -1]
+}
+bind Text <Next> {
+    tk::TextSetCursor %W [tk::TextScrollPages %W 1]
+}
+bind Text <Shift-Next> {
+    tk::TextKeySelect %W [tk::TextScrollPages %W 1]
+}
+bind Text <Control-Prior> {
+    %W xview scroll -1 page
+}
+bind Text <Control-Next> {
+    %W xview scroll 1 page
+}
+
+bind Text <<LineStart>> {
+    tk::TextSetCursor %W {insert display linestart}
+}
+bind Text <<SelectLineStart>> {
+    tk::TextKeySelect %W {insert display linestart}
+}
+bind Text <<LineEnd>> {
+    tk::TextSetCursor %W {insert display lineend}
+}
+bind Text <<SelectLineEnd>> {
+    tk::TextKeySelect %W {insert display lineend}
+}
+bind Text <Control-Home> {
+    tk::TextSetCursor %W 1.0
+}
+bind Text <Control-Shift-Home> {
+    tk::TextKeySelect %W 1.0
+}
+bind Text <Control-End> {
+    tk::TextSetCursor %W {end - 1 indices}
+}
+bind Text <Control-Shift-End> {
+    tk::TextKeySelect %W {end - 1 indices}
+}
+
+bind Text <Tab> {
+    if {[%W cget -state] eq "normal"} {
+	tk::TextInsert %W \t
+	focus %W
+	break
+    }
+}
+bind Text <Shift-Tab> {
+    # Needed only to keep <Tab> binding from triggering; doesn't
+    # have to actually do anything.
+    break
+}
+bind Text <Control-Tab> {
+    focus [tk_focusNext %W]
+}
+bind Text <Control-Shift-Tab> {
+    focus [tk_focusPrev %W]
+}
+bind Text <Control-i> {
+    tk::TextInsert %W \t
+}
+bind Text <Return> {
+    if {[%W cget -state] eq "normal"} {
+	tk::TextInsert %W \n
+	if {[%W cget -autoseparators]} {
+	    %W edit separator
+	}
+    }
+}
+bind Text <Delete> {
+    if {[%W cget -state] eq "normal"} {
+	if {[tk::TextCursorInSelection %W]} {
+	    tk::TextDelete %W sel.first sel.last
+	} else {
+	    if {[%W compare end != insert+1i]} {
+		%W delete insert
+	    }
+	    %W see insert
+	}
+    }
+}
+bind Text <BackSpace> {
+    if {[%W cget -state] eq "normal"} {
+	if {[tk::TextCursorInSelection %W]} {
+	    tk::TextDelete %W sel.first sel.last
+	} else {
+	    if {[%W compare insert != 1.0]} {
+		# ensure that this operation is triggering "watch"
+		%W mark set insert insert-1i
+		%W delete insert
+	    }
+	    %W see insert
+	}
+    }
+}
+
+bind Text <Control-space> {
+    %W mark set [tk::TextAnchor %W] insert
+}
+bind Text <Select> {
+    %W mark set [tk::TextAnchor %W] insert
+}
+bind Text <Control-Shift-space> {
+    set tk::Priv(selectMode) char
+    tk::TextKeyExtend %W insert
+}
+bind Text <Shift-Select> {
+    set tk::Priv(selectMode) char
+    tk::TextKeyExtend %W insert
+}
+bind Text <<SelectAll>> {
+    %W tag add sel 1.0 end
+}
+bind Text <<SelectNone>> {
+    %W tag remove sel 1.0 end
+    # An operation that clears the selection must insert an autoseparator,
+    # because the selection operation may have moved the insert mark.
+    if {[%W cget -autoseparators]} {
+	%W edit separator
+    }
+}
+bind Text <<Cut>> {
+    tk_textCut %W
+}
+bind Text <<Copy>> {
+    tk_textCopy %W
+}
+bind Text <<Paste>> {
+    tk_textPaste %W
+}
+bind Text <<Clear>> {
+    if {[%W cget -state] eq "normal"} {
+	# Make <<Clear>> an atomic operation on the Undo stack,
+	# i.e. separate it from other delete operations on either side
+	if {[%W cget -autoseparators]} {
+	    %W edit separator
+	}
+	catch { tk::TextDelete %W sel.first sel.last }
+	if {[%W cget -autoseparators]} {
+	    %W edit separator
+	}
+    }
+}
+bind Text <<PasteSelection>> {
+    if {$tk_strictMotif || ![info exists tk::Priv(mouseMoved)] || !$tk::Priv(mouseMoved)} {
+	tk::TextPasteSelection %W %x %y
+    }
+}
+bind Text <Insert> {
+    if {[%W cget -state] eq "normal"} {
+	catch {tk::TextInsert %W [::tk::GetSelection %W PRIMARY]}
+    }
+}
+bind Text <KeyPress> {
+    tk::TextInsert %W %A
+}
+
+# Ignore all Alt, Meta, and Control keypresses unless explicitly bound.
+# Otherwise, if a widget binding for one of these is defined, the
+# <KeyPress> class binding will also fire and insert the character,
+# which is wrong.  Ditto for <Escape>.
+
+bind Text <Alt-KeyPress> {# nothing }
+bind Text <Meta-KeyPress> {# nothing}
+bind Text <Control-KeyPress> {# nothing}
+bind Text <Escape> {# nothing}
+bind Text <KP_Enter> {# nothing}
+if {[tk windowingsystem] eq "aqua"} {
+    bind Text <Command-KeyPress> {# nothing}
+}
+
+# Additional emacs-like bindings:
+
+bind Text <Control-d> {
+    if {[%W cget -state] eq "normal" && !$tk_strictMotif && [%W compare end != insert+1i]} {
+	%W delete insert
+    }
+}
+bind Text <Control-k> {
+    if {[%W cget -state] eq "normal" && !$tk_strictMotif && [%W compare end != insert+1i]} {
+	if {[%W compare insert == {insert lineend}]} {
+	    %W delete insert
+	} else {
+	    %W delete insert {insert lineend}
+	}
+    }
+}
+bind Text <Control-o> {
+    if {[%W cget -state] eq "normal" && !$tk_strictMotif} {
+	%W insert insert \n
+	%W mark set insert insert-1i
+    }
+}
+bind Text <Control-t> {
+    if {!$tk_strictMotif} {
+	tk::TextTranspose %W
+    }
+}
+
+bind Text <<Undo>> {
+    if {[%W cget -state] eq "normal"} {
+	# An Undo operation may remove the separator at the top of the Undo stack.
+	# Then the item at the top of the stack gets merged with the subsequent changes.
+	# Place separators before and after Undo to prevent this.
+	if {[%W cget -autoseparators]} {
+	    %W edit separator
+	}
+	catch { %W edit undo }
+	if {[%W cget -autoseparators]} {
+	    %W edit separator
+	}
+    }
+}
+
+bind Text <<Redo>> {
+    if {[%W cget -state] eq "normal"} {
+	catch { %W edit redo }
+    }
+}
+
+bind Text <Meta-b> {
+    if {!$tk_strictMotif} {
+	tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
+    }
+}
+bind Text <Meta-d> {
+    if {!$tk_strictMotif && [%W compare end != insert+1i]} {
+	%W delete insert [tk::TextNextWord %W insert]
+    }
+}
+bind Text <Meta-f> {
+    if {!$tk_strictMotif} {
+	tk::TextSetCursor %W [tk::TextNextWord %W insert]
+    }
+}
+bind Text <Meta-less> {
+    if {!$tk_strictMotif} {
+	tk::TextSetCursor %W 1.0
+    }
+}
+bind Text <Meta-greater> {
+    if {!$tk_strictMotif} {
+	tk::TextSetCursor %W end-1i
+    }
+}
+bind Text <Meta-BackSpace> {
+    if {[%W cget -state] eq "normal" && !$tk_strictMotif} {
+	tk::TextDelete %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord] insert
+    }
+}
+bind Text <Meta-Delete> {
+    if {[%W cget -state] eq "normal" && !$tk_strictMotif} {
+	tk::TextDelete %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord] insert
+    }
+}
+
+# Macintosh only bindings:
+
+if {[tk windowingsystem] eq "aqua"} {
+   bind Text <Control-v> {
+       tk::TextScrollPages %W 1
+   }
+
+# End of Mac only bindings
+}
+
+# A few additional bindings of my own.
+
+bind Text <Control-h> {
+    if {[%W cget -state] eq "normal" && !$tk_strictMotif && [%W compare insert != 1.0]} {
+	# ensure that this operation is triggering "watch"
+	%W mark set insert insert-1i
+	%W delete insert
+	%W see insert
+    }
+}
+bind Text <2> {
+    if {!$tk_strictMotif} {
+	tk::TextScanMark %W %x %y
+    }
+}
+bind Text <B2-Motion> {
+    if {!$tk_strictMotif} {
+	tk::TextScanDrag %W %x %y
+    }
+}
+set ::tk::Priv(prevPos) {}
+
+# The MouseWheel will typically only fire on Windows and MacOS X.
+# However, someone could use the "event generate" command to produce one
+# on other platforms.  We must be careful not to round -ve values of %D
+# down to zero.
+
+if {[tk windowingsystem] eq "aqua"} {
+    bind Text <MouseWheel> {
+	%W yview scroll [expr {-15 * (%D)}] pixels
+    }
+    bind Text <Option-MouseWheel> {
+	%W yview scroll [expr {-150 * (%D)}] pixels
+    }
+    bind Text <Shift-MouseWheel> {
+	%W xview scroll [expr {-15 * (%D)}] pixels
+    }
+    bind Text <Shift-Option-MouseWheel> {
+	%W xview scroll [expr {-150 * (%D)}] pixels
+    }
+} else {
+    # We must make sure that positive and negative movements are rounded
+    # equally to integers, avoiding the problem that
+    #     (int)1/3 = 0,
+    # but
+    #     (int)-1/3 = -1
+    # The following code ensure equal +/- behaviour.
+    bind Text <MouseWheel> {
+	if {%D >= 0} {
+	    %W yview scroll [expr {-%D/3}] pixels
+	} else {
+	    %W yview scroll [expr {(2-%D)/3}] pixels
+	}
+    }
+    bind Text <Shift-MouseWheel> {
+	if {%D >= 0} {
+	    %W xview scroll [expr {-%D/3}] pixels
+	} else {
+	    %W xview scroll [expr {(2-%D)/3}] pixels
+	}
+    }
+}
+
+if {"x11" eq [tk windowingsystem]} {
+    # Support for mousewheels on Linux/Unix commonly comes through mapping
+    # the wheel to the extended buttons.  If you have a mousewheel, find
+    # Linux configuration info at:
+    #	http://www.inria.fr/koala/colas/mouse-wheel-scroll/
+    bind Text <4> {
+	if {!$tk_strictMotif} {
+	    %W yview scroll -50 pixels
+	}
+    }
+    bind Text <5> {
+	if {!$tk_strictMotif} {
+	    %W yview scroll 50 pixels
+	}
+    }
+    bind Text <Shift-4> {
+	if {!$tk_strictMotif} {
+	    %W xview scroll -50 pixels
+	}
+    }
+    bind Text <Shift-5> {
+	if {!$tk_strictMotif} {
+	    %W xview scroll 50 pixels
+	}
+    }
+}
+
+# ::tk::TextCursorPos --
+# Given x and y coordinates, this procedure computes the "cursor"
+# position, and returns the index of the character at this position.
+#
+# Arguments:
+# w -		The text window.
+# x -		X-coordinate within the window.
+# y -		Y-coordinate within the window.
+
+proc ::tk::TextCursorPos {w x y} {
+    if {[$w cget -blockcursor]} {
+	# If we have a block cursor, then use the actual x-position
+	# for cursor position.
+	return [$w index @$x,$y]
+    }
+    return [TextClosestGap $w $x $y]
+}
+
+# ::tk::TextClosestGap --
+# Given x and y coordinates, this procedure finds the closest boundary
+# between characters to the given coordinates and returns the index
+# of the character just after the boundary.
+#
+# Arguments:
+# w -		The text window.
+# x -		X-coordinate within the window.
+# y -		Y-coordinate within the window.
+
+proc ::tk::TextClosestGap {w x y} {
+    set pos [$w index @$x,$y]
+    set bbox [$w bbox $pos]
+    if {[llength $bbox] == 0} {
+    	return $pos
+    }
+    if {($x - [lindex $bbox 0]) < ([lindex $bbox 2]/2)} {
+    	return $pos
+    }
+    $w index "$pos + 1i"
+}
+
+# ::tk::TextButton1 --
+# This procedure is invoked to handle button-1 presses in text
+# widgets.  It moves the insertion cursor, sets the selection anchor,
+# and claims the input focus.
+#
+# Arguments:
+# w -		The text window in which the button was pressed.
+# x -		The x-coordinate of the button press.
+# y -		The x-coordinate of the button press.
+
+proc ::tk::TextButton1 {w x y} {
+    variable Priv
+    # Catch the very special case with dead peers.
+    if {![$w isdead]} {
+	set Priv(selectMode) char
+	set Priv(mouseMoved) 0
+	set Priv(pressX) $x
+	set pos [TextCursorPos $w $x $y]
+	set thisLineNo [$w lineno @last,$y]
+	if {[$w lineno $pos] ne $thisLineNo} {
+	    # The button has been pressed at an x position after last character.
+	    # In this case [$w index @$x,$y] is returning the start of next line,
+	    # but we want the end of this line.
+	    set pos "$thisLineNo.end"
+	}
+	$w mark set insert $pos
+	if {[$w cget -blockcursor]} {
+	    set anchor [TextClosestGap $w $x $y]
+	} else {
+	    # this is already the closest gap
+	    set anchor insert
+	}
+	# Set the anchor mark's gravity depending on the click position
+	# relative to the gap.
+	set bbox [$w bbox $anchor]
+	set gravity [expr {$x > [lindex $bbox 0] ? "right" : "left"}]
+	$w mark set [TextAnchor $w] $anchor $gravity
+	if {[$w cget -state] eq "normal" && [$w cget -autoseparators]} {
+	    $w edit separator
+	}
+    }
+
+    # Allow focus in any case on Windows, because that will let the
+    # selection be displayed even for state disabled text widgets.
+    if {[tk windowingsystem] eq "win32" || [$w cget -state] eq "normal"} {
+	focus $w
+    }
+}
+
+# ::tk::TextSelectTo --
+# This procedure is invoked to extend the selection, typically when
+# dragging it with the mouse.  Depending on the selection mode (character,
+# word, line) it selects in different-sized units.  This procedure
+# ignores mouse motions initially until the mouse has moved from
+# one character to another or until there have been multiple clicks.
+#
+# Note that the 'anchor' is implemented programmatically using
+# a text widget mark, and uses a name that will be unique for each
+# text widget (even when there are multiple peers).
+#
+# Arguments:
+# w -		The text window in which the button was pressed.
+# x -		Mouse x position.
+# y - 		Mouse y position.
+
+proc ::tk::TextAnchor {w} {
+    variable Priv
+
+    if {![info exists Priv(textanchor,$w)]} {
+	# This gives us a private mark, not visible with
+	# "mark names|next|previous|..".
+	set Priv(textanchor,$w) [$w mark generate]
+	# The Tk library still has a big weakness: it's not possible to
+	# bind variables to a widget, so we use a private command for this
+	# binding; this means that the variable will be unset automatically
+	# when the widget will be destroyed. This is the only proper way to
+	# handle unique identifiers.
+	$w tk_bindvar [namespace current]::Priv(textanchor,$w)
+    }
+    return $Priv(textanchor,$w)
+}
+
+proc ::tk::TextSelectTo {w x y {extend 0}} {
+    variable Priv
+    if {[$w isdead]} {
+	# Catch the very special case with dead peers.
+	return
+    }
+    set anchorname [TextAnchor $w]
+    set cur [TextCursorPos $w $x $y]
+    if {![$w mark exists $anchorname]} {
+	$w mark set $anchorname $cur
+    }
+    set anchor [$w index $anchorname]
+    if {[$w compare $cur != $anchor] || (abs($Priv(pressX) - $x) >= 3)} {
+	set Priv(mouseMoved) 1
+    }
+    switch -- $Priv(selectMode) {
+	char {
+	    if {[$w compare $cur < $anchorname]} {
+		set first $cur
+		set last $anchorname
+	    } else {
+		set first $anchorname
+		set last $cur
+	    }
+	}
+	word {
+	    set first [$w index @$x,$y]
+	    set isEmbedded [expr {[string length [$w get $first]] == 0}]
+	    if {$isEmbedded} {
+		# Don't extend the range if we have an embedded item at this position
+		set last "$first+1i"
+	    } else {
+		# Set initial range based only on the anchor (1 char min width)
+		if {[$w mark gravity $anchorname] eq "right"} {
+		    set first $anchorname
+		    set last "$anchorname + 1i"
+		} else {
+		    set first "$anchorname - 1i"
+		    set last $anchorname
+		}
+		# Extend range (if necessary) based on the current point
+		if {[$w compare $cur < $first]} {
+		    set first $cur
+		} elseif {[$w compare $cur > $last]} {
+		    set last $cur
+		}
+
+		# Now find word boundaries
+		set first [TextPrevPos $w "$first + 1i" tcl_wordBreakBefore]
+		set last [TextNextPos $w "$last - 1i" tcl_wordBreakAfter]
+	    }
+	}
+	line {
+	    # Set initial range based only on the anchor
+	    set first "$anchorname linestart"
+	    set last "$anchorname lineend"
+
+	    # Extend range (if necessary) based on the current point
+	    if {[$w compare $cur < $first]} {
+		set first "$cur linestart"
+	    } elseif {[$w compare $cur > $last]} {
+		set last "$cur lineend"
+	    }
+	    set first [$w index $first]
+	    set last [$w index "$last + 1i"]
+	}
+    }
+    if {$Priv(mouseMoved) || ($Priv(selectMode) ne "char")} {
+	$w mark set insert $cur
+	$w tag remove sel 1.0 $first
+	$w tag add sel $first $last
+	$w tag remove sel $last end
+	update idletasks
+    }
+}
+
+# ::tk::TextKeyExtend --
+# This procedure handles extending the selection from the keyboard,
+# where the point to extend to is really the boundary between two
+# characters rather than a particular character.
+#
+# Arguments:
+# w -		The text window.
+# index -	The point to which the selection is to be extended.
+
+proc ::tk::TextKeyExtend {w index} {
+    set anchorname [TextAnchor $w]
+    set cur [$w index $index]
+    if {![$w mark exists $anchorname]} {
+	$w mark set $anchorname $cur left
+    }
+    set anchor [$w index $anchorname]
+    if {[$w compare $cur < $anchorname]} {
+	set first $cur
+	set last $anchorname
+    } else {
+	set first $anchorname
+	set last $cur
+    }
+    $w tag remove sel 1.0 $first
+    $w tag add sel $first $last
+    $w tag remove sel $last end
+}
+
+# ::tk::TextPasteSelection --
+# This procedure sets the insertion cursor to the mouse position,
+# inserts the selection, and sets the focus to the window.
+#
+# Arguments:
+# w -		The text window.
+# x, y - 	Position of the mouse.
+
+proc ::tk::TextPasteSelection {w x y} {
+    if {[$w cget -state] eq "normal"} {
+	$w mark set insert [TextCursorPos $w $x $y]
+	TextInsertSelection $w PRIMARY
+    }
+    if {[$w cget -state] eq "normal"} {
+	focus $w
+    }
+}
+
+# ::tk::TextAutoScan --
+# This procedure is invoked when the mouse leaves a text window
+# with button 1 down.  It scrolls the window up, down, left, or right,
+# depending on where the mouse is (this information was saved in
+# ::tk::Priv(x) and ::tk::Priv(y)), and reschedules itself as an "after"
+# command so that the window continues to scroll until the mouse
+# moves back into the window or the mouse button is released.
+#
+# Arguments:
+# w -		The text window.
+
+proc ::tk::TextAutoScan {w} {
+    variable Priv
+    if {![winfo exists $w]} {
+	return
+    }
+    if {$Priv(y) >= [winfo height $w]} {
+	$w yview scroll [expr {1 + $Priv(y) - [winfo height $w]}] pixels
+    } elseif {$Priv(y) < 0} {
+	$w yview scroll [expr {-1 + $Priv(y)}] pixels
+    } elseif {$Priv(x) >= [winfo width $w]} {
+	$w xview scroll 2 units
+    } elseif {$Priv(x) < 0} {
+	$w xview scroll -2 units
+    } else {
+	return
+    }
+    TextSelectTo $w $Priv(x) $Priv(y)
+    set Priv(afterId) [after 50 [list ::tk::TextAutoScan $w]]
+}
+
+# ::tk::TextSetCursor
+# Move the insertion cursor to a given position in a text.  Also
+# clears the selection, if there is one in the text, and makes sure
+# that the insertion cursor is visible.  Also, don't let the insertion
+# cursor appear on the dummy last line of the text.
+#
+# Arguments:
+# w -		The text window.
+# pos -		The desired new position for the cursor in the window.
+
+proc ::tk::TextSetCursor {w pos} {
+    if {[$w compare $pos == end]} {
+	set pos {end - 1i}
+    }
+    $w mark set insert $pos
+    $w tag remove sel 1.0 end
+    $w see insert
+    if {[$w cget -autoseparators]} {
+	$w edit separator
+    }
+}
+
+# ::tk::TextKeySelect
+# This procedure is invoked when stroking out selections using the
+# keyboard.  It moves the cursor to a new position, then extends
+# the selection to that position.
+#
+# Arguments:
+# w -		The text window.
+# new -		A new position for the insertion cursor (the cursor hasn't
+#		actually been moved to this position yet).
+
+proc ::tk::TextKeySelect {w new} {
+    if {[$w isdead]} {
+	# Catch the very special case with dead peers.
+	return
+    }
+    set anchorname [TextAnchor $w]
+    if {[llength [$w tag nextrange sel 1.0 end]] == 0} {
+	if {[$w compare $new < insert]} {
+	    $w tag add sel $new insert
+	} else {
+	    $w tag add sel insert $new
+	}
+	$w mark set $anchorname insert
+    } else {
+	if {[$w compare $new < $anchorname]} {
+	    set first $new
+	    set last $anchorname
+	} else {
+	    set first $anchorname
+	    set last $new
+	}
+	$w tag remove sel 1.0 $first
+	$w tag add sel $first $last
+	$w tag remove sel $last end
+    }
+    $w mark set insert $new
+    $w see insert
+    update idletasks
+}
+
+# ::tk::TextResetAnchor --
+# Set the selection anchor to whichever end is farthest from the
+# index argument.  One special trick: if the selection has two or
+# fewer characters, just leave the anchor where it is.  In this
+# case it doesn't matter which point gets chosen for the anchor,
+# and for the things like Shift-Left and Shift-Right this produces
+# better behavior when the cursor moves back and forth across the
+# anchor.
+#
+# Arguments:
+# w -		The text widget.
+# index -	Position at which mouse button was pressed, which determines
+#		which end of selection should be used as anchor point.
+
+proc ::tk::TextResetAnchor {w index} {
+    if {[llength [$w tag ranges sel]] == 0} {
+	# Don't move the anchor if there is no selection now; this
+	# makes the widget behave "correctly" when the user clicks
+	# once, then shift-clicks somewhere -- ie, the area between
+	# the two clicks will be selected. [Bug: 5929].
+	return
+    }
+    set anchorname [TextAnchor $w]
+    set a [$w index $index]
+    set b [$w index sel.first]
+    set c [$w index sel.last]
+    if {[$w compare $a < $b]} {
+	$w mark set $anchorname sel.last
+	return
+    }
+    if {[$w compare $a > $c]} {
+	$w mark set $anchorname sel.first
+	return
+    }
+    scan $a "%d.%d" lineA chA
+    scan $b "%d.%d" lineB chB
+    scan $c "%d.%d" lineC chC
+    if {$lineB < $lineC + 2} {
+	set total [string length [$w get $b $c]]
+	if {$total <= 2} {
+	    return
+	}
+	if {[string length [$w get $b $a]] < ($total/2)} {
+	    $w mark set $anchorname sel.last
+	} else {
+	    $w mark set $anchorname sel.first
+	}
+	return
+    }
+    if {$lineA - $lineB < $lineC - $lineA} {
+	$w mark set $anchorname sel.last
+    } else {
+	$w mark set $anchorname sel.first
+    }
+}
+
+# ::tk::TextCursorInSelection --
+# Check whether the selection exists and contains the insertion cursor. Note
+# that it assumes that the selection is contiguous.
+#
+# Arguments:
+# w -		The text widget whose selection is to be checked
+
+proc ::tk::TextCursorInSelection {w} {
+    expr {[llength [$w tag ranges sel]]
+	&& [$w compare sel.first <= insert]
+	&& [$w compare sel.last >= insert]
+    }
+}
+
+# ::tk::TextInsert --
+# Insert a string into a text at the point of the insertion cursor.
+# If there is a selection in the text, and it covers the point of the
+# insertion cursor, then delete the selection before inserting.
+#
+# Arguments:
+# w -		The text window in which to insert the string
+# s -		The string to insert (usually just a single character)
+
+proc ::tk::TextInsert {w s} {
+    if {[string length $s] == 0 || [$w cget -state] ne "normal"} {
+	return
+    }
+    if {[TextCursorInSelection $w]} {
+	if {[$w cget -autoseparators]} {
+	    $w edit separator
+	}
+	# ensure that this operation is triggering "watch"
+	$w mark set insert sel.first
+	$w replace insert sel.last $s
+    } else {
+	$w insert insert $s
+    }
+    $w see insert
+}
+
+# ::tk::TextUpDownLine --
+# Returns the index of the character one display line above or below the
+# insertion cursor.  There are two tricky things here.  First, we want to
+# maintain the original x position across repeated operations, even though
+# some lines that will get passed through don't have enough characters to
+# cover the original column.  Second, don't try to scroll past the
+# beginning or end of the text if we don't select.
+#
+# Arguments:
+# w -		The text window in which the cursor is to move.
+# n -		The number of display lines to move: -1 for up one line,
+#		+1 for down one line.
+# sel		Boolean value whether we are selecting text.
+
+proc ::tk::TextUpDownLine {w n {sel no}} {
+    variable Priv
+
+    set i [$w index insert]
+    if {$Priv(prevPos) ne $i} {
+	set Priv(textPosOrig) $i
+    }
+    set lines [$w count -displaylines $Priv(textPosOrig) $i]
+    set new [$w index "$Priv(textPosOrig) + [expr {$lines + $n}] displaylines"]
+    if {!$sel && ([$w compare $new == end] || [$w compare $new == "insert display linestart"])} {
+	set new $i
+    }
+    set Priv(prevPos) $new
+    return $new
+}
+
+# ::tk::TextPrevPara --
+# Returns the index of the beginning of the paragraph just before a given
+# position in the text (the beginning of a paragraph is the first non-blank
+# character after a blank line).
+#
+# Arguments:
+# w -		The text window in which the cursor is to move.
+# pos -		Position at which to start search.
+
+proc ::tk::TextPrevPara {w pos} {
+    set pos [$w index "$pos linestart"]
+    while {1} {
+	set newPos [$w index "$pos - 1 line"]
+	if {([$w get $newPos] eq "\n" && ([$w get $pos] ne "\n")) || [$w compare $pos == 1.0]} {
+	    if {[regexp -indices -- {^[ \t]+(.)} [$w get $pos "$pos lineend"] -> index]} {
+		set pos [$w index "$pos + [lindex $index 0] chars"]
+	    }
+	    if {[$w compare $pos != insert] || [$w compare [$w index "$pos linestart"] == 1.0]} {
+		return $pos
+	    }
+	}
+	set pos $newPos
+    }
+}
+
+# ::tk::TextNextPara --
+# Returns the index of the beginning of the paragraph just after a given
+# position in the text (the beginning of a paragraph is the first non-blank
+# character after a blank line).
+#
+# Arguments:
+# w -		The text window in which the cursor is to move.
+# start -	Position at which to start search.
+
+proc ::tk::TextNextPara {w start} {
+    set pos [$w index "$start linestart + 1 line"]
+    while {[$w get $pos] ne "\n"} {
+	if {[$w compare $pos == end]} {
+	    return [$w index "end - 1i"]
+	}
+	set pos [$w index "$pos + 1 line"]
+    }
+    while {[$w get $pos] eq "\n"} {
+	set pos [$w index "$pos + 1 line"]
+	if {[$w compare $pos == end]} {
+	    return [$w index "end - 1i"]
+	}
+    }
+    if {[regexp -indices -- {^[ \t]+(.)} [$w get $pos "$pos lineend"] -> index]} {
+	return [$w index "$pos + [lindex $index 0] chars"]
+    }
+    return $pos
+}
+
+# ::tk::TextScrollPages --
+# This is a utility procedure used in bindings for moving up and down
+# pages and possibly extending the selection along the way.  It scrolls
+# the view in the widget by the number of pages, and it returns the
+# index of the character that is at the same position in the new view
+# as the insertion cursor used to be in the old view.
+#
+# Arguments:
+# w -		The text window in which the cursor is to move.
+# count -	Number of pages forward to scroll;  may be negative
+#		to scroll backwards.
+
+proc ::tk::TextScrollPages {w count} {
+    set bbox [$w bbox insert]
+    $w yview scroll $count pages
+    if {[llength $bbox] == 0} {
+	return [$w index @[expr {[winfo height $w]/2}],0]
+    }
+    return [$w index @[lindex $bbox 0],[lindex $bbox 1]]
+}
+
+# ::tk::TextTranspose --
+# This procedure implements the "transpose" function for text widgets.
+# It tranposes the characters on either side of the insertion cursor,
+# unless the cursor is at the end of the line.  In this case it
+# transposes the two characters to the left of the cursor.  In either
+# case, the cursor ends up to the right of the transposed characters.
+#
+# Arguments:
+# w -		Text window in which to transpose.
+
+proc ::tk::TextTranspose w {
+    if {[$w cget -state] ne "normal" || [$w compare insert == 1.0]} {
+	return
+    }
+    set pos insert
+    if {[$w compare insert != "insert lineend"]} {
+	append pos +1i
+    }
+    set pos [$w index $pos]
+    # ensure that this operation is triggering "watch"
+    set insPos [$w index insert]
+    $w mark set insert ${pos}-2c
+    set new [$w get insert+1i][$w get insert]
+    $w replace insert $pos $new
+    $w mark set insert $insPos
+    $w see insert
+}
+
+# ::tk_textCopy --
+# This procedure copies the selection from a text widget into the
+# clipboard.
+#
+# Arguments:
+# w -		Name of a text widget.
+
+proc ::tk_textCopy w {
+    if {![catch {set data [$w get sel.first sel.last]}]} {
+	clipboard clear -displayof $w
+	clipboard append -displayof $w $data
+    }
+}
+
+# ::tk_textCut --
+# This procedure copies the selection from a text widget into the
+# clipboard, then deletes the selection (if it exists in the given
+# widget).
+#
+# Arguments:
+# w -		Name of a text widget.
+
+proc ::tk_textCut w {
+    if {![catch {set data [$w get sel.first sel.last]}]} {
+	# make <<Cut>> an atomic operation on the Undo stack,
+	# i.e. separate it from other delete operations on either side
+	if {[$w cget -autoseparators]} {
+	    $w edit separator
+	}
+	clipboard clear -displayof $w
+	clipboard append -displayof $w $data
+	if {[$w cget -state] eq "normal"} {
+	    ::tk::TextDelete $w sel.first sel.last
+	}
+	if {[$w cget -autoseparators]} {
+	    $w edit separator
+	}
+    }
+}
+
+# ::tk_textPaste --
+# This procedure pastes the contents of the clipboard to the insertion
+# point in a text widget.
+#
+# Arguments:
+# w -		Name of a text widget.
+
+proc ::tk_textPaste w {
+    if {[$w cget -state] eq "normal"} {
+	::tk::TextInsertSelection $w CLIPBOARD
+    }
+}
+
+# ::tk::TextNextWord --
+# Returns the index of the next word position after a given position in the
+# text.  The next word is platform dependent and may be either the next
+# end-of-word position or the next start-of-word position after the next
+# end-of-word position.
+#
+# Arguments:
+# w -		The text window in which the cursor is to move.
+# start -	Position at which to start search.
+
+if {[tk windowingsystem] eq "win32"}  {
+    proc ::tk::TextNextWord {w start} {
+	TextNextPos $w [TextNextPos $w $start tcl_endOfWord] tcl_startOfNextWord
+    }
+} else {
+    proc ::tk::TextNextWord {w start} {
+	TextNextPos $w $start tcl_endOfWord
+    }
+}
+
+# ::tk::TextNextPos --
+# Returns the index of the next position after the given starting
+# position in the text as computed by a specified function.
+#
+# Arguments:
+# w -		The text window in which the cursor is to move.
+# start -	Position at which to start search.
+# op -		Function to use to find next position.
+
+proc ::tk::TextNextPos {w start op} {
+    set text ""
+    set cur $start
+    while {[$w compare $cur < end]} {
+	set end [$w index "$cur lineend + 1i"]
+	append text [$w get -displaychars $cur $end]
+	set pos [$op $text 0]
+	if {$pos >= 0} {
+	    return [$w index "$start + $pos display chars"]
+	}
+	set cur $end
+    }
+    return end
+}
+
+# ::tk::TextPrevPos --
+# Returns the index of the previous position before the given starting
+# position in the text as computed by a specified function.
+#
+# Arguments:
+# w -		The text window in which the cursor is to move.
+# start -	Position at which to start search.
+# op -		Function to use to find next position.
+
+proc ::tk::TextPrevPos {w start op} {
+    set text ""
+    set succ ""
+    set cur $start
+    while {[$w compare $cur > 1.0]} {
+	append text [$w get -displaychars "$cur linestart - 1i" $cur] $succ
+	set pos [$op $text end]
+	if {$pos >= 0} {
+	    return [$w index "$cur linestart - 1i + $pos display chars"]
+	}
+	set cur [$w index "$cur linestart - 1i"]
+	set succ $text
+    }
+    return 1.0
+}
+
+# ::tk::TextScanMark --
+#
+# Marks the start of a possible scan drag operation
+#
+# Arguments:
+# w -	The text window from which the text to get
+# x -	x location on screen
+# y -	y location on screen
+
+proc ::tk::TextScanMark {w x y} {
+    variable Priv
+    $w scan mark $x $y
+    set Priv(x) $x
+    set Priv(y) $y
+    set Priv(mouseMoved) 0
+}
+
+# ::tk::TextScanDrag --
+#
+# Marks the start of a possible scan drag operation
+#
+# Arguments:
+# w -	The text window from which the text to get
+# x -	x location on screen
+# y -	y location on screen
+
+proc ::tk::TextScanDrag {w x y} {
+    variable Priv
+    # Make sure these exist, as some weird situations can trigger the
+    # motion binding without the initial press.  [Bug #220269]
+    if {![info exists Priv(x)]} {
+	set Priv(x) $x
+    }
+    if {![info exists Priv(y)]} {
+	set Priv(y) $y
+    }
+    if {$x != $Priv(x) || $y != $Priv(y)} {
+	set Priv(mouseMoved) 1
+    }
+    if {[info exists Priv(mouseMoved)] && $Priv(mouseMoved)} {
+	$w scan dragto $x $y
+    }
+}
+
+# ::tk::TextDelete --
+#
+# Delete the characters in given range.
+# Ensure that "watch" will be triggered, and consider
+# that "insert" may be involved in the given range.
+# This implementation avoids unnecessary mappings of indices.
+
+proc ::tk::TextDelete {w start end} {
+    # Remember old positions, use temporary marks ('mark generate'),
+    # take into account that $end may refer "insert" mark.
+    $w mark set [set insPos [$w mark generate]] insert
+    $w mark set [set endPos [$w mark generate]] $end
+    $w mark set insert $start
+    $w delete insert $endPos
+    $w mark set insert $insPos
+    $w mark unset $insPos
+    $w mark unset $endPos
+}
+
+# ::tk::TextInsertSelection --
+# This procedure inserts the selection.
+#
+# Arguments:
+# w -		The text window.
+# x, y - 	Position of the mouse.
+# selection	atom name of the selection
+
+proc ::tk::TextInsertSelection {w selection} {
+    if {[catch {GetSelection $w $selection} sel]} {
+	return
+    }
+    set oldSeparator [$w cget -autoseparators]
+    if {$oldSeparator} {
+	$w configure -autoseparators 0
+	$w edit separator
+    }
+    if {$selection eq "CLIPBOARD" && [tk windowingsystem] ne "x11"} {
+	catch { TextDelete $w sel.first sel.last }
+    }
+    $w insert insert $sel
+    if {$oldSeparator} {
+	$w edit separator
+	$w configure -autoseparators 1
+    }
+}
+
+# ::tk_textInsert --
+# This procedure supports the insertion of text with hyphen information.
+#
+# Arguments:
+# w -		The text window.
+# args -	Arguments for text insertion.
+
+proc ::tk_textInsert {w args} {
+   # Use an internal command:
+   uplevel [list $w tk_textInsert {*}$args]
+}
+
+# ::tk_textReplace --
+# This procedure supports the replacement of text with hyphen information.
+#
+# Arguments:
+# w -		The text window.
+# args -	Arguments for text insertion.
+
+proc ::tk_textReplace {w args} {
+   # Use an internal command:
+   uplevel [list $w tk_textReplace {*}$args]
+}
+
+# ::tk_mergeRange --
+# This procedure is merging a range into a sorted list of ranges.
+# If given range is adjacent to, or intersecting a range in given
+# list, then it will be amalgamated.
+#
+# Arguments:
+# rangeListVar -	Name of variable containing the list of ranges.
+# newRange -		New range which should be merged into given list.
+
+proc tk_mergeRange {rangeListVar newRange} {
+    upvar $rangeListVar ranges
+
+    if {![info exists ranges]} {
+	lappend ranges $newRange
+	return $ranges
+    }
+
+    lassign $newRange s e
+    lassign [split $s .] sline scol
+    lassign [split $e .] eline ecol
+    set newRangeList {}
+    set n [llength $ranges]
+
+    for {set i 0} {$i < $n} {incr i} {
+	set range [lindex $ranges $i]
+	lassign $range s1 e1
+	lassign [split $s1 .] sline1 scol1
+	lassign [split $e1 .] eline1 ecol1
+
+	# [$w compare "$e+1i" < $s1]
+	if {$eline < $sline1 || ($eline == $sline1 && $ecol + 1 < $scol1)} {
+	    lappend newRangeList [list $s $e]
+	    lappend newRangeList {*}[lrange $ranges $i end]
+	    set ranges $newRangeList
+	    return $newRangeList
+	}
+	# [$w compare $s <= "$e1+1i"]
+	if {$sline < $eline1 || ($sline == $eline1 && $scol <= $ecol1 + 1)} {
+	    # [$w compare $s > $s1]
+	    if {$sline > $sline1 || ($sline == $sline1 && $scol > $scol1)} {
+		set s $s1; set sline $sline1; set scol $scol1
+	    }
+	    # [$w compare $e < $e1]
+	    if {$eline < $eline1 || ($eline == $eline1 && $ecol < $ecol1)} {
+		set e $e1; set eline $eline1; set ecol $ecol1
+	    }
+	} else {
+	    lappend newRangeList $range
+	}
+    }
+
+    lappend newRangeList [list $s $e]
+    set ranges $newRangeList
+    return $newRangeList
+}
+
+# vi:set ts=8 sw=4:
