Index: src/movelist.h
===================================================================
--- src/movelist.h	(revision 1088)
+++ src/movelist.h	(working copy)
@@ -43,15 +43,21 @@
     squareT  capturedSquare; // ONLY different to "to" field if this capture
                             //    is an en passant capture.
     byte     castleFlags;    // pre-move information
+    bool     castling960;
     squareT  epSquare;       // pre-move information
     ushort   oldHalfMoveClock;
     int      score;          // used for alpha/beta ordering.
+        
+    simpleMoveT() 
+    {
+        castling960 = false;
+    }
 };
 
 inline bool isNullMove (simpleMoveT * sm)
 {
-    return (sm->from == sm->to  &&  sm->from != NULL_SQUARE
-              &&  piece_Type(sm->movingPiece) == KING);
+  return (sm->from != NULL_SQUARE && 
+          sm->from == sm->to && (!(piece_Type(sm->movingPiece) == KING && sm->castling960 == true)));
 }
 
 #ifdef WINCE
Index: src/game.cpp
===================================================================
--- src/game.cpp	(revision 1088)
+++ src/game.cpp	(working copy)
@@ -758,6 +758,7 @@
     newsm->to = sm->to;
     newsm->capturedPiece = sm->capturedPiece;
     newsm->promote = sm->promote;
+    newsm->castling960 = sm->castling960;
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -3018,14 +3019,19 @@
         1, 2, 3, 0, 0, 0, 0, 9, 4, 0, 5, 10, 0, 0, 0, 0, 6, 7, 8
     };
 
+    if (diff >= -4 && diff <= 5  && sm->castling960) {
+      if (sm->to == C1 || sm->to == C8) {diff = -2; }
+      if (sm->to == G1 || sm->to == G8) {diff = 2; }
+    }
+    
     // If target square is the from square, it is the null move, which
     // is represented as a king move to its own square and is encoded
     // as the byte value zero.
-    if (sm->to == sm->from) {
+    if (sm->to == sm->from && diff != 2 && diff  != -2) {
         buf->PutByte (makeMoveByte (0, 0));
         return;
     }
-
+    
     // Verify we have a valid King move:
     ASSERT(diff >= -9  &&  diff <= 9  &&  val[diff+9] != 0);
     buf->PutByte (makeMoveByte (0, val [diff + 9]));
@@ -3042,12 +3048,33 @@
     };
 
     if (val == 0) {
-      sm->to = sm->from;  // Null move
-        return OK;
+      if (sm->to < H8) {
+        sm->to = sm->from;  // Null move
+        sm->castling960 = true;
+     }
+      return OK;
     }
-
     if (val < 1  ||  val > 10) { return ERROR_Decode; }
+    
     sm->to = sm->from + sqdiff[val];
+ 
+    if (sqdiff[val] == -2) {
+      sm->castling960 = true;
+      if (sm->from <= G1) {
+        sm->to = C1;
+      } else {
+        sm->to = C8;
+      }
+    }
+    if (sqdiff[val] == 2) {
+      sm->castling960 = true;
+      if (sm->from <= G1) {
+        sm->to = G1;
+      } else {
+        sm->to = G8;
+      }
+    }
+    
     return OK;
 }
 
@@ -3361,7 +3388,8 @@
     sm->movingPiece = board[sm->from];
 
     sm->promote = EMPTY;
-
+    sm->castling960 = false;
+ 
     errorT err = OK;
     pieceT pt = piece_Type (sm->movingPiece);
     switch (pt) {
Index: src/position.cpp
===================================================================
--- src/position.cpp	(revision 1088)
+++ src/position.cpp	(working copy)
@@ -34,7 +34,7 @@
 
 Position::Position(const Position& p)
 {
-    memcpy (this, &p, sizeof(Position));
+	memcpy (this, &p, sizeof(Position));
 }
 
 inline void
@@ -81,6 +81,31 @@
     UnHash (p, sq);
 }
 
+inline void
+Position::AddToBoard960 (pieceT p, squareT sq)
+{
+    Board[sq] = p;
+    NumOnRank[p][square_Rank(sq)]++;
+    NumOnFyle[p][square_Fyle(sq)]++;
+    NumOnLeftDiag[p][square_LeftDiag(sq)]++;
+    NumOnRightDiag[p][square_RightDiag(sq)]++;
+    NumOnSquareColor[p][square_Color(sq)]++;
+    AddHash (p, sq);
+}
+
+inline void
+Position::RemoveFromBoard960 (pieceT p, squareT sq)
+{
+    if (Board[sq] != p) { p = Board[sq]; }
+    Board[sq] = EMPTY;
+    NumOnRank[p][square_Rank(sq)]--;
+    NumOnFyle[p][square_Fyle(sq)]--;
+    NumOnLeftDiag[p][square_LeftDiag(sq)]--;
+    NumOnRightDiag[p][square_RightDiag(sq)]--;
+    NumOnSquareColor[p][square_Color(sq)]--;
+    UnHash (p, sq);
+}
+
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // initHashValues:
 //    Initialises the table of Zobrist hash values.
@@ -224,7 +249,7 @@
 //      Add a legal move to the move list.
 //
 inline void
-Position::AddLegalMove (MoveList * mlist, squareT from, squareT to, pieceT promo)
+Position::AddLegalMove (MoveList * mlist, squareT from, squareT to, pieceT promo, bool castling)
 {
     ASSERT (mlist != NULL);
     simpleMoveT * sm = mlist->Add();
@@ -238,6 +263,7 @@
     sm->promote = promo;
     sm->movingPiece = Board[from];
     sm->capturedPiece = Board[to];
+    sm->castling960 = castling;
 }
 
 
@@ -253,14 +279,13 @@
     squareT dest = fromSq;
     squareT last = square_Last (fromSq, dir);
     int delta = direction_Delta (dir);
-
     while (dest != last) {
         dest += delta;
         pieceT p = Board[dest];
         if (p == EMPTY) {
             if (! capturesOnly) {
                 if (sqset == NULL  ||  sqset->Contains(dest)) {
-                    AddLegalMove (mlist, fromSq, dest, EMPTY);
+                    AddLegalMove (mlist, fromSq, dest, EMPTY, false);
                 }
             }
             continue;
@@ -268,7 +293,7 @@
         // We have reached a piece. Add the capture if it is an enemy.
         if (piece_Color_NotEmpty(p) != color) {
             if (sqset == NULL  ||  sqset->Contains(dest)) {
-                AddLegalMove (mlist, fromSq, dest, EMPTY);
+                AddLegalMove (mlist, fromSq, dest, EMPTY, false);
             }
         }
         break;
@@ -292,64 +317,111 @@
         if (capturesOnly  &&  p == EMPTY) { continue; }
         if (piece_Color(p) != c) {
             if (sqset == NULL  ||  sqset->Contains(dest)) {
-                AddLegalMove (mlist, fromSq, dest, EMPTY);
+                AddLegalMove (mlist, fromSq, dest, EMPTY, false);
             }
         }
     }
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-// Position::GenCastling():
-//    Generate the legal castling moves.
+// Position::Gen960Castling():
+//    Generate the legal castling moves for chess960.
+//
+// Rules are:
+// 1)	Unmoved: The king and the castling rook must not have moved before in
+// the game, including castling.
+//
+// 2)	Unattacked: No square between the king's initial and final squares 
+// (including the initial and final squares) may be under attack by any opposing
+// piece.
+//
+// 3) Unimpeded: All the squares between the king's initial and final squares
+// (including the final square), and all of the squares between the rook's
+// initial and final squares (including the final square), must be vacant except
+// for the king and castling rook. An equivalent way of stating this is that the
+// smallest back rank interval containing the king, the castling rook, and their
+// destination squares contains no pieces other than the king and castling rook.
+//
 //    Assumes the side to move is NOT in check, so the caller
 //    should verify this first.
 //
+
 void
-Position::GenCastling (MoveList * mlist)
+Position::Gen960Castling (MoveList * mlist)
 {
     ASSERT (! IsKingInCheck());
     squareT from = GetKingSquare(ToMove);
-    if (from != (ToMove == WHITE ? E1 : E8))  { return; }
+    if (ToMove == WHITE) {
+        if (((from < B1) || (from > G1)) || Board[from] != WK) {return; }
+    } else {
+        if (((from < B8) || (from > G8)) || Board[from] != BK) {return; }
+    }
+    
     squareT enemyKingSq = GetEnemyKingSquare();
     squareT target, skip, rookSq;
-    pieceT rookPiece;
+    pieceT rookPiece, kingPiece;
 
-    // Try kingside first
+    bool canCastle = true;
 
-    // Kingside Castling:
-    if (!StrictCastling  ||  GetCastling (ToMove, KSIDE)) {
+    // Queenside Castling:
+    if (!StrictCastling  ||  GetCastling (ToMove, QSIDE)) {
         if (ToMove == WHITE) {
-            target = G1; skip = F1; rookSq = H1; rookPiece = WR;
+            target = C1; rookSq = WQRStart; rookPiece = WR; kingPiece = WK;
         } else {
-            target = G8; skip = F8; rookSq = H8; rookPiece = BR;
+            target = C8; rookSq = BQRStart; rookPiece = BR; kingPiece = BK;
         }
-        if (Board[target] == EMPTY  &&  Board[skip] == EMPTY
-                &&  Board[rookSq] == rookPiece
-                &&  CalcNumChecks (target) == 0
-                &&  CalcNumChecks (skip) == 0
-                &&  ! square_Adjacent (target, enemyKingSq)) {
-            AddLegalMove (mlist, from, target, EMPTY);
+        if (from == B1 || from == B8) {
+            if ((Board[target] == EMPTY) || (Board[target] == kingPiece) || (Board[target] == rookPiece)) {
+                if ((Board[target] != EMPTY) || (Board[target + 1] != EMPTY)) { canCastle = false; }
+                if (!(CalcNumChecks (target) == 0) || !(CalcNumChecks (from) == 0)) { canCastle = false; }
+                if (square_Adjacent (target, enemyKingSq) || square_Adjacent (from, enemyKingSq)) { canCastle = false; }
+                if ((Board[rookSq] == rookPiece) && canCastle) {
+                     AddLegalMove (mlist, from, target, EMPTY, true); 
+	        }
+            }
+        } else {
+	  if (!(from == target && Board[target + 1] != EMPTY)) {
+	    if ((Board[target] == EMPTY) || (Board[target] == kingPiece) || (Board[target] == rookPiece)) {
+	        for (skip = from - 1; skip > rookSq; skip--) {	
+                    if (Board[skip] != EMPTY) { canCastle = false; }
+                }
+                for (skip = from; skip >= target; skip--) {
+                    if (!(CalcNumChecks (skip) == 0) || square_Adjacent (skip, enemyKingSq)) { canCastle = false; }
+                }
+                if ((Board[rookSq] == rookPiece) && canCastle) {
+		     AddLegalMove (mlist, from, target, EMPTY, true); 
+	        }
+            }
+	  }
         }
     }
 
-    // Queenside Castling:
-    if (!StrictCastling  ||  GetCastling (ToMove, QSIDE)) {
+    canCastle = true;
+
+    // Kingside Castling:
+    if (!StrictCastling  ||  GetCastling (ToMove, KSIDE)) {
         if (ToMove == WHITE) {
-            target = C1; skip = D1; rookSq = A1; rookPiece = WR;
+            target = G1; rookSq = WKRStart; rookPiece = WR; kingPiece = WK;
         } else {
-            target = C8; skip = D8; rookSq = A8; rookPiece = BR;
+            target = G8; rookSq = BKRStart; rookPiece = BR; kingPiece = BK;
         }
-        if (Board[target] == EMPTY  &&  Board[skip] == EMPTY
-                &&  Board[rookSq] == rookPiece
-                &&  Board[target - 1] == EMPTY // B1 or B8 must be empty too!
-                &&  CalcNumChecks (target) == 0
-                &&  CalcNumChecks (skip) == 0
-                &&  ! square_Adjacent (target, enemyKingSq)) {
-            AddLegalMove (mlist, from, target, EMPTY);
+        if (!((from == target) && (Board[target - 1] != EMPTY))) {
+	  if ((Board[target] == EMPTY) || (Board[target] == kingPiece) || (Board[target] == rookPiece)) {
+            for (skip = from + 1; skip < rookSq; skip++) {
+                if (Board[skip] != EMPTY) { canCastle = false; }
+            }
+            for (skip = from; skip <= target; skip++) {
+                if (!(CalcNumChecks (skip) == 0) || square_Adjacent (skip, enemyKingSq)) { canCastle = false; }
+            }
+            if ((Board[rookSq] == rookPiece) && canCastle) {
+                AddLegalMove (mlist, from, target, EMPTY, true); 
+	    }
+	  }
         }
     }
 }
 
+
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Position::GenKingMoves():
 //      Generate the legal King moves. Castling is generated as well, if
@@ -394,11 +466,11 @@
             Board[kingSq] = king;
             Board[destSq] = captured;
         }
-        if (addThisMove) { AddLegalMove (mlist, kingSq, destSq, EMPTY); }
+        if (addThisMove) { AddLegalMove (mlist, kingSq, destSq, EMPTY, false); }
         destPtr++;
     }
     // Now generate castling moves, if possible:
-    if (genNonCaptures  &&  castling) { GenCastling (mlist); }
+    if (genNonCaptures  &&  castling) { Gen960Castling (mlist); }  
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -412,10 +484,10 @@
     ASSERT (piece_Type (Board[from]) == PAWN);
     ASSERT (square_Rank (dest) == RANK_1  ||  square_Rank (dest) == RANK_8);
 
-    AddLegalMove (mlist, from, dest, QUEEN);
-    AddLegalMove (mlist, from, dest, ROOK);
-    AddLegalMove (mlist, from, dest, BISHOP);
-    AddLegalMove (mlist, from, dest, KNIGHT);
+    AddLegalMove (mlist, from, dest, QUEEN, false);
+    AddLegalMove (mlist, from, dest, ROOK, false);
+    AddLegalMove (mlist, from, dest, BISHOP, false);
+    AddLegalMove (mlist, from, dest, KNIGHT, false);
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -484,13 +556,13 @@
             if (square_Rank(dest) == promoRank) {
                 AddPromotions (mlist, from, dest);
             } else {
-                AddLegalMove (mlist, from, dest, EMPTY);
+                AddLegalMove (mlist, from, dest, EMPTY, false);
             }
         }
         if (square_Rank(from) == secondRank  &&  Board[dest] == EMPTY) {
             dest = square_Move (dest, forward);
             if (Board[dest]==EMPTY  &&  (sqset==NULL || sqset->Contains(dest))) {
-                AddLegalMove (mlist, from, dest, EMPTY);
+                AddLegalMove (mlist, from, dest, EMPTY, false);
             }
         }
     }
@@ -509,7 +581,7 @@
             if (square_Rank(dest) == promoRank) {
                 AddPromotions (mlist, from, dest);
             } else {
-                AddLegalMove (mlist, from, dest, EMPTY);
+                AddLegalMove (mlist, from, dest, EMPTY, false);
             }
         }
     }
@@ -520,7 +592,7 @@
             if (square_Rank(dest) == promoRank) {
                 AddPromotions (mlist, from, dest);
             } else {
-                AddLegalMove (mlist, from, dest, EMPTY);
+                AddLegalMove (mlist, from, dest, EMPTY, false);
             }
         }
     }
@@ -572,8 +644,12 @@
     // Setting up a valid board is left to StdStart() or Clear().
     Board [COLOR_SQUARE] = EMPTY;
     Board [NULL_SQUARE] = END_OF_BOARD;
-	LegalMoves.Clear();
+    LegalMoves.Clear();
     StrictCastling = true;
+    WKRStart = NS;
+    BKRStart = NS;
+    WQRStart = NS;
+    BQRStart = NS;
 
     // Make sure all tables used for move generation, hashing,
     // square tests, etc have been computed:
@@ -609,7 +685,7 @@
     HalfMoveClock = 0;
     Hash = 0;
     PawnHash = 0;
-	LegalMoves.Clear();
+    LegalMoves.Clear();
     return;
 }
 
@@ -659,6 +735,8 @@
         Castling = 0;
         SetCastling (WHITE, QSIDE, true);  SetCastling (WHITE, KSIDE, true);
         SetCastling (BLACK, QSIDE, true);  SetCastling (BLACK, KSIDE, true);
+        SetWQRStart (A1); SetBKRStart (H8); SetBQRStart (A8); SetWKRStart (H1);
+
         EPTarget = NULL_SQUARE;
         ToMove = WHITE;
         PlyCounter = 0;
@@ -666,6 +744,7 @@
         Board [NULL_SQUARE] = END_OF_BOARD;
         Hash = stdStartHash;
         PawnHash = stdStartPawnHash;
+	StandardPosition = true;
     }
     else {
         if (startPositionTemplate == NULL){
@@ -787,11 +866,10 @@
 Position::GenPieceMoves (MoveList * mlist, squareT fromSq,
                          SquareSet * sqset, bool capturesOnly)
 {
-    colorT c = ToMove;
     pieceT p = Board[fromSq];
     pieceT ptype = piece_Type(p);
+    colorT c = ToMove;
     ASSERT (p != EMPTY  &&  ptype != KING  &&  ptype != PAWN);
-
     if (ptype == KNIGHT) {
         GenKnightMoves (mlist, c, fromSq, sqset, capturesOnly);
         return;
@@ -821,13 +899,12 @@
 {
     bool genNonCaptures = (genType & GEN_NON_CAPS);
     bool capturesOnly = !genNonCaptures;
+    if (LegalMoves.Size() > 0 && pieceType == EMPTY && genType == GEN_ALL_MOVES) {
+        if(mlist != NULL)
+            memcpy (mlist, &LegalMoves, sizeof(MoveList));
+        return;
+    }
 
-	if (LegalMoves.Size() > 0 && pieceType == EMPTY && genType == GEN_ALL_MOVES) {
-		if(mlist != NULL)
-			memcpy (mlist, &LegalMoves, sizeof(MoveList));
-		return;
-	}
-
     uint mask = 0;
     if (pieceType != EMPTY) {
         mask = 1 << pieceType;
@@ -837,9 +914,9 @@
     }
 
     // Use the objects own move list if none was provided:
-	if( mlist == NULL)
-		mlist = &LegalMoves;
-	mlist->Clear();
+    if( mlist == NULL)
+        mlist = &LegalMoves;
+    mlist->Clear();
 
     // Compute which pieces of the side to move are pinned to the king:
     CalcPins();
@@ -867,6 +944,7 @@
         squareT sq = List[ToMove][x];
         pieceT p = Board[sq];
         pieceT ptype = piece_Type(p);
+
         if (! (mask & (1 << ptype))) { continue; }
         directionT pinned = Pinned[x];
 
@@ -905,9 +983,10 @@
         bool castling = !numChecks;
         GenKingMoves (mlist, genType, castling);
     }
+    if (pieceType == EMPTY && genType == GEN_ALL_MOVES && mlist != NULL)
+        memcpy (&LegalMoves, mlist, sizeof(MoveList));
+    
 
-	if (pieceType == EMPTY && genType == GEN_ALL_MOVES && mlist != NULL)
-		memcpy (&LegalMoves, mlist, sizeof(MoveList));
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -985,7 +1064,7 @@
             // The move must be castling, or illegal.
             if (IsKingInCheck()) { return false; }
             MoveList mlist;
-            GenCastling (&mlist);
+            Gen960Castling (&mlist);
             return (mlist.Find(sm) >= 0);
         }
     }
@@ -1117,7 +1196,7 @@
                 if (CalcNumChecks (kingSq) > 0)  { tryMove = 0; }
                 Board[*sqPtr] = p;
                 Board[target] = captured;
-                if (tryMove == 1)  { AddLegalMove (mlist, *sqPtr, target, EMPTY); }
+                if (tryMove == 1)  { AddLegalMove (mlist, *sqPtr, target, EMPTY, false); }
             }
         }
     }
@@ -1232,7 +1311,7 @@
     }
 
     if (legal == 1) {
-        AddLegalMove (mlist, from, to, promote);
+        AddLegalMove (mlist, from, to, promote, false);
         return OK;
     }
     return ERROR_InvalidMove;
@@ -1247,78 +1326,26 @@
 errorT
 Position::MatchKingMove (MoveList * mlist, squareT target)
 {
+    bool islegalmove = false;
     mlist->Clear();
-    squareT kingSq = GetKingSquare(ToMove);
-    sint diff = (int)target - (int) kingSq;
-
-    // Valid diffs are: -9, -8, -7, -2, -1, 1, 2, 7, 8, 9. (-2,2: Castling)
-
-    if (diff < -9  ||  diff > 9) { return ERROR_InvalidMove; }
-    if (diff > -7  &&  diff < -2) { return ERROR_InvalidMove; }
-    if (diff > 2  &&  diff < 7) { return ERROR_InvalidMove; }
-    if (diff == 0) { return ERROR_InvalidMove; }
-
-    if (diff == 2) { // KingSide Castling
-        if (kingSq != (ToMove == WHITE ? E1 : E8)) {
-            return ERROR_InvalidMove;
-        }
-        if (StrictCastling  &&  ! GetCastling (ToMove, KSIDE)) {
-            return ERROR_InvalidMove;
-        }
-
-        // XXX We also need to verify that the target square does not
-        //     lie adjacent to the location of the enemy king!
-
-        if (Board[kingSq + 1] != EMPTY  ||  Board[kingSq + 2] != EMPTY
-            ||  CalcNumChecks(kingSq) > 0
-            ||  CalcNumChecks(kingSq + 1) > 0
-            ||  CalcNumChecks(kingSq + 2) > 0) {
-            return ERROR_InvalidMove;
-        }
-        AddLegalMove (mlist, kingSq, target, EMPTY);
-        return OK;
+    genMovesT allmoves = GEN_ALL_MOVES;
+    MoveList tmlist;
+    tmlist.Clear();
+    GenKingMoves(&tmlist, allmoves, true);
+    
+    for (uint i=0; i < tmlist.Size(); i++) {
+       simpleMoveT * sm = tmlist.Get(i);
+       if (sm->to == target) {
+	 mlist->Add(sm);
+	 islegalmove = true;
+       }
     }
-
-    if (diff == -2) { // Queenside Castling
-        if (kingSq != (ToMove == WHITE ? E1 : E8)) {
-            return ERROR_InvalidMove;
-        }
-        if (StrictCastling  &&  ! GetCastling (ToMove, QSIDE)) {
-            return ERROR_InvalidMove;
-        }
-        if (Board[kingSq - 1] != EMPTY  ||  Board[kingSq - 2] != EMPTY
-            ||  Board[kingSq - 3] != EMPTY
-            ||  CalcNumChecks(kingSq) > 0
-            ||  CalcNumChecks(kingSq - 1) > 0
-            ||  CalcNumChecks(kingSq - 2) > 0) {
-            return ERROR_InvalidMove;
-        }
-        AddLegalMove (mlist, kingSq, target, EMPTY);
-        return OK;
+    
+    if (islegalmove) {
+      return OK;
+    } else {
+      return ERROR_InvalidMove;
     }
-    pieceT captured = Board[target];
-    if (piece_Color(captured) == ToMove) {
-        // Capturing a friendly piece!
-        return ERROR_InvalidMove;
-    }
-
-    // Now make the move on the Board and Material lists, and see if it
-    // leaves the King in check:
-    // XXX We should also check for adjacency to enemy King!!
-
-    Board[target] = piece_Make(ToMove, KING);
-    Board[kingSq] = EMPTY;
-    if (captured != EMPTY) { Material[captured]--; }
-    uint legal = 0;
-    if (CalcNumChecks(target) == 0) { legal = 1; }
-    if (captured != EMPTY) { Material[captured]++; }
-    Board[target] = captured;
-    Board[kingSq] = piece_Make(ToMove, KING);
-    if (legal == 1) {
-        AddLegalMove (mlist, kingSq, target, EMPTY);
-        return OK;
-    }
-    return ERROR_InvalidMove;
 }
 
 
@@ -1837,18 +1864,22 @@
 void
 Position::DoSimpleMove (simpleMoveT * sm)
 {
-    ASSERT (sm != NULL);
+   ASSERT (sm != NULL);
     squareT from = sm->from;
     squareT to = sm->to;
     pieceT p = Board[from];
     pieceT ptype = piece_Type(p);
     colorT enemy = color_Flip(ToMove);
     ASSERT (p != EMPTY);
-
     // update move fields that (maybe) have not yet been set:
+    
+    sm->pieceNum = ListPos[from];
 
-    sm->pieceNum = ListPos[from];
-    sm->capturedPiece = Board[to];
+    if (sm->castling960 != true) {
+      sm->capturedPiece = Board[to];
+    } else { 
+      sm->capturedPiece = EMPTY;
+    }
     sm->capturedSquare = to;
     sm->castleFlags = Castling;
     sm->epSquare = EPTarget;
@@ -1856,8 +1887,8 @@
 
     HalfMoveClock++;
     PlyCounter++;
-	LegalMoves.Clear();
-
+    LegalMoves.Clear();
+    
     // Check for a null (empty) move:
     if (isNullMove(sm)) {
         ToMove = enemy;
@@ -1891,8 +1922,8 @@
         Material[sm->capturedPiece]--;
         HalfMoveClock = 0;
         RemoveFromBoard (sm->capturedPiece, sm->capturedSquare);
-    }
-
+     }
+ 
     // handle promotion:
 
     if (sm->promote != EMPTY) {
@@ -1903,32 +1934,54 @@
         Material[p]++;
         AddToBoard (p, from);
     }
-
+   
     // now make the move:
-    List[ToMove][sm->pieceNum] = to;
-    ListPos[to] = sm->pieceNum;
-    RemoveFromBoard (p, from);
-    AddToBoard (p, to);
+   if (sm->castling960 != true) {
+     List[ToMove][sm->pieceNum] = to;
+     ListPos[to] = sm->pieceNum;
+     RemoveFromBoard (p, from);
+     AddToBoard (p, to);
+ }
 
     // handle Castling:
-
-    if (ptype == KING  &&  square_Fyle(from) == E_FYLE  &&
-            (square_Fyle(to) == C_FYLE  ||  square_Fyle(to) == G_FYLE)) {
-        squareT rookfrom, rookto;
-        pieceT rook = piece_Make (ToMove, ROOK);
-        if (square_Fyle(to) == C_FYLE) {
-            rookfrom = to - 2;
-            rookto = to + 1;
+    if (sm->castling960 == true && ptype == KING &&
+         (square_Fyle(to) == C_FYLE  ||  square_Fyle(to) == G_FYLE)) {
+      squareT rookfrom, rookto;
+      pieceT rook = piece_Make (ToMove, ROOK);
+      if (square_Fyle(to) == C_FYLE) {
+        rookto = to + 1;
+        if (ToMove == WHITE) {
+          for (int i = H1; i >= A1; i--) {
+            if (Board[i] == WR) {rookfrom = i;}
+          }
         } else {
-            rookfrom = to + 1;
-            rookto = to - 1;
+          for (int i = H8; i >= A8; i--) {
+           if (Board[i] == BR) {rookfrom = i;}
+          }
         }
-        ListPos[rookto] = ListPos[rookfrom];
-        List[ToMove][ListPos[rookto]] = rookto;
-        RemoveFromBoard (rook, rookfrom);
-        AddToBoard (rook, rookto);
+      } else {
+        rookto = to - 1;
+        if (ToMove == WHITE) {
+          for (int i = A1; i <= H1; i++) {
+            if (Board[i] == WR) { rookfrom = i; }
+          }
+        } else {
+          for (int i = A8; i <= H8; i++) {
+            if (Board[i] == BR) {rookfrom = i;}
+          }
+        }
+      }
+   
+      ListPos[rookto] = ListPos[rookfrom];
+      List[ToMove][ sm->pieceNum] = to;
+      List[ToMove][ListPos[rookto]] = rookto;
+      ListPos[to] = sm->pieceNum;
+ 
+      RemoveFromBoard960 (p, from);
+      RemoveFromBoard960 (rook, rookfrom);
+      AddToBoard960 (p, to);
+      AddToBoard960 (rook, rookto);
     }
-
     // Handle clearing of castling flags:
 
     if (Castling) {
@@ -1938,15 +1991,15 @@
         }
         // See if a rook moved or was captured:
         if (ToMove == WHITE) {
-            if (from == A1)  { SetCastling (WHITE, QSIDE, false); }
-            if (from == H1)  { SetCastling (WHITE, KSIDE, false); }
-            if (to == A8)    { SetCastling (BLACK, QSIDE, false); }
-            if (to == H8)    { SetCastling (BLACK, KSIDE, false); }
+            if (from == WQRStart)  { SetCastling (WHITE, QSIDE, false); }
+            if (from == WKRStart)  { SetCastling (WHITE, KSIDE, false); }
+            if (to == BQRStart)    { SetCastling (BLACK, QSIDE, false); }
+            if (to == BKRStart)    { SetCastling (BLACK, KSIDE, false); }
         } else {
-            if (from == A8)  { SetCastling (BLACK, QSIDE, false); }
-            if (from == H8)  { SetCastling (BLACK, KSIDE, false); }
-            if (to == A1)    { SetCastling (WHITE, QSIDE, false); }
-            if (to == H1)    { SetCastling (WHITE, KSIDE, false); }
+            if (from == BQRStart)  { SetCastling (BLACK, QSIDE, false); }
+            if (from == BKRStart)  { SetCastling (BLACK, KSIDE, false); }
+            if (to == WQRStart)    { SetCastling (WHITE, QSIDE, false); }
+            if (to == WKRStart)    { SetCastling (WHITE, KSIDE, false); }
         }
     }
 
@@ -1968,17 +2021,17 @@
         }
         HalfMoveClock = 0; // 50-move clock resets on pawn moves.
     }
-
     ToMove = enemy;
 
+    
+    
 #ifdef ASSERTIONS
     // Do a SLOW, careful check for corruption:
     if (AssertPos() != OK) {
         abort();
     }
 #endif
-
-    return;
+  return;
 }
 
 
@@ -1989,7 +2042,7 @@
 void
 Position::UndoSimpleMove (simpleMoveT * m)
 {
-    ASSERT (m != NULL);
+   ASSERT (m != NULL);
     squareT from = m->from;
     squareT to = m->to;
     pieceT p = Board[to];
@@ -1999,13 +2052,13 @@
     PlyCounter--;
     ToMove = color_Flip(ToMove);
     m->pieceNum = ListPos[to];
-	LegalMoves.Clear();
-
+    LegalMoves.Clear();
+    
     // Check for a null move:
     if (isNullMove(m)) {
         return;
     }
-
+ 
     // Handle a capture: insert piece back into piecelist.
     // This works for EP captures too, since the square of the captured
     // piece is in the "capturedSquare" field rather than assuming the
@@ -2021,7 +2074,7 @@
         Material[m->capturedPiece]++;
         Count[c]++;
     }
-
+ 
     // handle promotion:
 
     if (m->promote != EMPTY) {
@@ -2031,9 +2084,9 @@
         Material[p]++;
         AddToBoard (p, to);
     }
-
+ 
     // now make the move:
-
+  if (m->castling960 != true) {
     List[ToMove][m->pieceNum] = from;
     ListPos[from] = m->pieceNum;
     RemoveFromBoard (p, to);
@@ -2041,34 +2094,47 @@
     if (m->capturedPiece != EMPTY) {
         AddToBoard (m->capturedPiece, m->capturedSquare);
     }
-
-    // handle Castling:
-
-    if ((piece_Type(p) == KING) && square_Fyle(from) == E_FYLE
-            && (square_Fyle(to) == C_FYLE || square_Fyle(to) == G_FYLE)) {
-        squareT rookfrom, rookto;
-        pieceT rook = (ToMove == WHITE? WR : BR);
-        if (square_Fyle(to) == C_FYLE) {
-            rookfrom = to - 2;   rookto = to + 1;
-        } else {
-            rookfrom = to + 1;   rookto = to - 1;
-        }
-        ListPos[rookfrom] = ListPos[rookto];
-        List[ToMove][ListPos[rookto]] = rookfrom;
-        RemoveFromBoard (rook, rookto);
-        AddToBoard (rook, rookfrom);
+ 
+  }
+  // handle Castling:
+  if ((piece_Type(p) == KING) && m->castling960 == true && (square_Fyle(to) == C_FYLE || square_Fyle(to) == G_FYLE)) {
+    squareT rookfrom, rookto;
+    pieceT rook = (ToMove == WHITE? WR : BR);
+    if (square_Fyle(to) == C_FYLE) {
+      if (ToMove == WHITE) {
+        rookfrom = WQRStart;
+      } else {
+        rookfrom = BQRStart;
+      }
+      rookto = to + 1;
+    } else {
+      if (ToMove == WHITE) {
+        rookfrom = WKRStart;
+      } else {
+        rookfrom = BKRStart;
+      }
+      rookto = to - 1;
     }
+  
+    ListPos[rookfrom] = ListPos[rookto];
+    List[ToMove][ListPos[rookto]] = rookfrom;
+    List[ToMove][ m->pieceNum] = from;
+    ListPos[from] = m->pieceNum;
+   
+    RemoveFromBoard960 (p, to);
+    RemoveFromBoard960 (rook, rookto);
+    AddToBoard960 (p, from);
+    AddToBoard960 (rook, rookfrom);  
+  }
 
 #ifdef ASSERTIONS
     if (AssertPos() != OK) {
         abort();
     }
 #endif
-
     return;
 }
 
-
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Position::RelocatePiece():
 //    Given a from-square and to-square, modifies the position so
@@ -2086,9 +2152,9 @@
 
     // If squares are identical, just return success:
     if (fromSq == toSq) { return OK; }
+    
+    LegalMoves.Clear();
 
-	LegalMoves.Clear();
-
     pieceT piece = Board[fromSq];
     pieceT ptype = piece_Type(piece);
     colorT pcolor = piece_Color(piece);
@@ -2191,11 +2257,11 @@
         if (isNullMove(m)) {
             //*c++ = 'n'; *c++ = 'u'; *c++ = 'l'; *c++ = 'l';
             *c++ = '-'; *c++ = '-';
-        } else
-        if ((square_Fyle(from)==E_FYLE) && (square_Fyle(to)==G_FYLE)) {
+        } else 
+        if (m->castling960 == true && (square_Fyle(to)==G_FYLE)) {
             *c++ = 'O'; *c++ = '-'; *c++ = 'O';
         } else
-        if ((square_Fyle(from)==E_FYLE) && (square_Fyle(to)==C_FYLE)) {
+        if (m->castling960 == true && (square_Fyle(to)==C_FYLE)) {
             *c++ = 'O'; *c++ = '-'; *c++ = 'O'; *c++ = '-'; *c++ = 'O';
         } else {  // regular King move
             *c++ = 'K';
@@ -2252,7 +2318,7 @@
     // Now do the check or mate symbol:
     if (flag != SAN_NO_CHECKTEST) {
         // Now we make the move to test for check:
-		MoveList backup = LegalMoves;
+        MoveList backup = LegalMoves;
         DoSimpleMove (m);
         if (CalcNumChecks (GetKingSquare()) > 0) {
             char ch = '+';
@@ -2264,7 +2330,7 @@
             *c++ = ch;
         }
         UndoSimpleMove (m);
-		LegalMoves = backup;
+        LegalMoves = backup;
     }
     *c = 0;
 }
@@ -2277,13 +2343,12 @@
 Position::MakeUCIString (simpleMoveT * m, char * s)
 {
     ASSERT (m != NULL  &&  s != NULL);
-
     // Make sure m->pieceNum is updated:
     m->pieceNum = ListPos[m->from];
     pieceT  p    = piece_Type (Board[List[ToMove][m->pieceNum]]);
+    pieceT king, rook;
     squareT from = List[ToMove][m->pieceNum];
     squareT to   = m->to;
-
     char * c     = s;
 
     if (from == to && to != NULL_SQUARE) {
@@ -2292,6 +2357,26 @@
       return;
     }
 
+    if (m->castling960) {
+      if (ToMove == WHITE ) {
+        king = WK; 
+        rook = WR;
+        if (to == C1) {
+	  to = WQRStart;
+        } else {
+	  to = WKRStart;
+        }
+      } else {
+        king = BK;
+        rook = BR;
+        if (to == C8) {
+	  to = BQRStart;
+        } else {
+	  to = BKRStart;
+        }
+      }
+    }
+    
     *c++ = square_FyleChar(from);
     *c++ = square_RankChar(from);
     *c++ = square_FyleChar(to);
@@ -2305,6 +2390,7 @@
     *c = 0;
 }
 
+
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Position::ReadCoordMove():
 //      Given a non-promotion move in coordinate notation,
@@ -2319,14 +2405,27 @@
     ASSERT (m != NULL  &&  str != NULL);
     fyleT fromFyle, toFyle;
     rankT fromRank, toRank;
-    squareT from, to;
+    squareT from, to, castle_square;
     pieceT promo = EMPTY;
+    bool castle = false;
+    bool uci = true;
+    pieceT king, rook;
 
     uint slen = strLength(str);
+    if (slen == 6) {
+        promo = piece_FromChar(toupper(str[5]));
+    } else if (slen != 5 && slen != 4) { return ERROR_InvalidMove; }
+
     if (slen == 5) {
-        promo = piece_FromChar(toupper(str[4]));
-    } else if (slen != 4) { return ERROR_InvalidMove; }
-
+      if (str[4] == 't') {
+	castle = true;
+      } else if (str[4] == 'f') {
+	castle = false;
+      } else if (str[4] == 'u') {
+	uci = true;
+      }
+    }
+    
     fromFyle = fyle_FromChar (str[0]);
     fromRank = rank_FromChar (str[1]);
     from = square_Make (fromFyle, fromRank);
@@ -2336,11 +2435,36 @@
     toRank = rank_FromChar (str[3]);
     to = square_Make (toFyle, toRank);
     if (to == NS) { return ERROR_InvalidMove; }
-
     GenerateMoves();
+    
+    if (ToMove == WHITE ) {
+      king = WK; 
+      rook = WR;
+      if (WQRStart == to) {
+	castle_square = C1;
+      } else {
+	castle_square = G1;
+      }
+    } else {
+      king = BK;
+      rook = BR;
+      if (BQRStart == to) {
+	castle_square = C8;
+      } else {
+	castle_square = G8;
+      }
+    }
+    
+    if (Board[to] == rook && Board[from] == king) {
+      castle = true;
+      to = castle_square;
+    }
 
     for (uint i=0; i < LegalMoves.Size(); i++) {
         simpleMoveT * sm = LegalMoves.Get(i);
+        if (!(sm->castling960)) {
+          sm->castling960 = castle;
+        }
         if (sm->promote == promo) {
             if (sm->from == from  &&  sm->to == to) {
                 *m = *sm;
@@ -2368,11 +2492,10 @@
     const char * s = str;
     char mStr [255];
     pieceT p;
-    squareT from = NS;
     squareT to = NS;
     rankT frRank, toRank;
     fyleT frFyle, toFyle;
-
+  
     MoveList mlist;
     mlist.Clear();
 
@@ -2405,7 +2528,7 @@
     if (token == TOKEN_Move_Pawn  ||  token == TOKEN_Move_Promote) {
 
         pieceT promo = EMPTY;
-        if (token == TOKEN_Move_Promote) {
+	   if (token == TOKEN_Move_Promote) {
             // Last char must be Q/R/B/N.
             // Accept the move even if it is of the form "a8Q" not "a8=Q":
             // if (s[slen-2] != '=') { return ERROR_InvalidMove; }
@@ -2422,6 +2545,7 @@
         } else {
             // Check if it is a coordinates-style move, in which case it
             // could be any piece:
+        
             if (slen >= 4  &&
                 islower(s[0])  &&  isdigit(s[1])  &&
                 islower(s[slen-2])  &&  isdigit(s[slen-1])) {
@@ -2431,7 +2555,7 @@
         // First char MUST be a fyle:
         if (*s < 'a'  ||  *s > 'h')  {  return ERROR_InvalidMove; }
         frFyle = fyle_FromChar (s[0]);
-
+        
         // Check for the compact form of capture with no rank,
         // e.g. "ed" or "de=Q":
         if (slen == 2  &&  (s[1] >= 'a'  &&  s[1] <= 'h')) {
@@ -2444,15 +2568,16 @@
                     return OK;
                 }
             }
-            // It is NOT a valid capture with no rank:
+        
+// It is NOT a valid capture with no rank:
             return ERROR_InvalidMove;
         }
-
+        
         toFyle = fyle_FromChar (s[slen-2]);
         toRank = rank_FromChar (s[slen-1]);
         to = square_Make (toFyle, toRank);
         if (to == NS) { return ERROR_InvalidMove; }
-
+        
         if (MatchPawnMove (&mlist, frFyle, to, promo) != OK) {
             return ERROR_InvalidMove;
         } else {
@@ -2460,17 +2585,28 @@
             return OK;
         }
     }
-
+        
     // Here we handle piece moves, including castling
     if (token != TOKEN_Move_Piece) {  // Must be castling move
         ASSERT (token == TOKEN_Move_Castle_King  ||  token == TOKEN_Move_Castle_Queen);
-        from = (ToMove == WHITE ? E1 : E8);
-        if (GetKingSquare(ToMove) != from) { return ERROR_InvalidMove; }
-        to = (token == TOKEN_Move_Castle_King ? (from + 2) : (from - 2));
-        if (MatchKingMove (&mlist, to) != OK) {
+ 	if (token == TOKEN_Move_Castle_Queen) {
+	   if (ToMove == WHITE) { 
+	     to = C1;
+	   } else {
+	     to = C8;
+	   }
+	} else {
+	   if (ToMove == WHITE) { 
+	     to = G1;
+	   } else {
+	     to = G8;
+	   }
+	}
+	if (MatchKingMove (&mlist, to) != OK) {
             return ERROR_InvalidMove;
         } else {
-            *m = *(mlist.Get(0));
+	    *m = *(mlist.Get(0));
+	    m->castling960 = true;
             return OK;
         }
     }
@@ -2929,6 +3065,8 @@
     ASSERT (str != NULL);
     const char * s = str;
     int count = 0;
+    
+    squareT sq;
 
     if (firstCall) {
         firstCall = 0;
@@ -2987,6 +3125,8 @@
 
     if (! IsLegal()) { return ERROR_InvalidFEN; }
 
+    StandardPosition = true;
+    
     // Now the castling flags:
     while (isspace(*s)) { s++; }
     if (*s == '-') {
@@ -3005,21 +3145,96 @@
         }
     } else {
         while (!isspace(*s)  &&  *s != 0) {
-            switch (*s) {
+	    switch (*s) {
             case 'Q':
                 SetCastling (WHITE, QSIDE, true);
-                break;
+		for (int i = H1; i >= A1; i--) {
+		    if (Board[i] == WR) {
+		       SetWQRStart (i);
+		       if (i != A1) { StandardPosition = false; }
+		    }
+		 } 
+		 break;
             case 'q':
                 SetCastling (BLACK, QSIDE, true);
+		for (int i = H8; i >= A8; i--) {
+		    if (Board[i] == BR) {
+		       SetBQRStart (i);
+		       if (i != A8) { StandardPosition = false; }
+		    }
+		 } 
                 break;
             case 'K':
                 SetCastling (WHITE, KSIDE, true);
+		for (int i = A1; i <= H1; i++) {
+		    if (Board[i] == WR) {
+		       SetWKRStart (i);
+		       if (i != H1) { StandardPosition = false; }
+		    }
+		 } 
                 break;
             case 'k':
                 SetCastling (BLACK, KSIDE, true);
+		for (int i = A8; i <= H8; i++) {
+		    if (Board[i] == BR) {
+		       SetBKRStart (i);
+		       if (i != H8) { StandardPosition = false; }
+		    }
+		 } 
                 break;
             default:
-                return ERROR_InvalidFEN;
+		if (*s >= 'A' && *s <= 'H') {
+		  if (*s == 'A') {  sq = A1;}
+		  if (*s == 'B') {  sq = B1;}
+		  if (*s == 'C') {  sq = C1;}
+		  if (*s == 'D') {  sq = D1;}
+		  if (*s == 'E') {  sq = E1;}
+		  if (*s == 'F') {  sq = F1;}
+		  if (*s == 'G') {  sq = G1;}
+		  if (*s == 'H') {  sq = H1;}
+		  for (int i = sq; i <= H1; i++) {
+		     if (Board[i] == WK) {
+		       SetCastling (WHITE, QSIDE, true); 
+		       SetWQRStart (sq);
+		       if (i != A1) { StandardPosition = false; }
+		    }
+		  }
+		  for (int i = sq; i >= A1; i--) {
+		     if (Board[i] == WK) {
+		       SetCastling (WHITE, KSIDE, true);
+		       SetWKRStart (sq);
+		       if (i != H1) { StandardPosition = false; }
+		     }
+		  }
+		} else {
+		  if (*s >= 'a' && *s <= 'h') {
+		  if (*s == 'a') {  sq = A8;}
+		  if (*s == 'b') {  sq = B8;}
+		  if (*s == 'c') {  sq = C8;}
+		  if (*s == 'd') {  sq = D8;}
+		  if (*s == 'e') {  sq = E8;}
+		  if (*s == 'f') {  sq = F8;}
+		  if (*s == 'g') {  sq = G8;}
+		  if (*s == 'h') {  sq = H8;}
+		  for (int i = sq; i <= H8; i++) {
+		     if (Board[i] == BK) {
+		       SetCastling (BLACK, QSIDE, true);
+		       SetBQRStart (sq);
+		       if (i != A8) { StandardPosition = false; }
+		     }
+		  }
+		  for (int i = sq; i >= A8; i--) {
+		     if (Board[i] == BK) {
+		       SetCastling (BLACK, KSIDE, true);
+		       SetBKRStart (sq);		       
+		       if (i != H8) { StandardPosition = false; }
+		    }
+		  }
+		    
+		} else {
+		    return ERROR_InvalidFEN;
+		  }
+		}
             }
             s++;
         }
@@ -3082,39 +3297,115 @@
     ASSERT (str != NULL);
     uint emptyRun, iRank, iFyle;
     pieceT * pBoard = Board;
+    char white[8] = {'A','B','C','D','E','F','G','H'};
+    char black[8] = {'a','b','c','d','e','f','g','h'};
+    bool outside;
     for (iRank = 0; iRank < 8; iRank++) {
         pBoard = &(Board[(7 - iRank) * 8]);
         emptyRun = 0;
         if (iRank > 0  &&  flags > FEN_COMPACT) { *str++ = '/'; }
         for (iFyle = 0; iFyle < 8; iFyle++, pBoard++) {
             if (*pBoard != EMPTY) {
-                if (emptyRun) { *str++ = (byte) emptyRun + '0'; }
+                if (emptyRun) { *str++ = (byte) emptyRun + '0';}
                 emptyRun = 0;
                 *str++ = PIECE_CHAR[*pBoard];
             } else {
                 emptyRun++;
             }
         }
-        if (emptyRun) { *str++ = (byte) emptyRun + '0'; }
+        if (emptyRun) { *str++ = (byte) emptyRun + '0';}
     }
-
+     *str = 0;
     if (flags > FEN_COMPACT) { *str++ = ' '; }
     *str++ = (ToMove == WHITE ? 'w' : 'b');
+    
     *str = 0;
-
+   
     if (flags >= FEN_CASTLING_EP) {
         // Add the castling flags and EP flag as well:
         *str++ = ' ';
         if (Castling == 0)  {
             *str++ = '-';
         } else {
-            if (GetCastling (WHITE, KSIDE))  { *str++ = 'K'; }
-            if (GetCastling (WHITE, QSIDE))  { *str++ = 'Q'; }
-            if (GetCastling (BLACK, KSIDE))  { *str++ = 'k'; }
-            if (GetCastling (BLACK, QSIDE))  { *str++ = 'q'; }
+            if (GetCastling (WHITE, KSIDE))  { 
+	      if ((flags & FEN_XFEN) == 4) {
+	        outside = true;
+	        for (int square = H1; square > WKRStart; square--) {
+		  if (Board[square] == WR) { outside = false; }
+	        }
+	        if (outside) {
+	  	  *str++ = 'K'; 
+	        } else {
+		  *str++ = white[square_Fyle(WKRStart)];
+	        }
+	      } else {
+	        if (StandardPosition) {
+		  *str++ = 'K';
+	        } else {
+		  *str++ = white[square_Fyle(WKRStart)];
+	        }
+	      }
+	    }
+            if (GetCastling (WHITE, QSIDE))  {
+	      if ((flags & FEN_XFEN) == 4) {
+	        outside = true;
+	        for (int square = A1; square < WQRStart; square++) {
+		  if (Board[square] == WR) { outside = false; }
+	        }
+	        if (outside) {
+	  	  *str++ = 'Q'; 
+	        } else {
+		  *str++ = white[square_Fyle(WQRStart)];
+	        }
+	      } else {
+	        if (StandardPosition) {
+		  *str++ = 'Q';
+	        } else {
+		  *str++ = white[square_Fyle(WQRStart)];
+	        }
+	      }
+	    }
+            if (GetCastling (BLACK, KSIDE))  {
+	      if ((flags & FEN_XFEN) == 4) {
+	        outside = true;
+	        for (int square = H8; square > BKRStart; square--) {
+	  	  if (Board[square] == BR) { outside = false; }
+	        }
+	        if (outside) {
+		  *str++ = 'k'; 
+	        } else {
+		  *str++ = black[square_Fyle(BKRStart)];
+	        } 
+	      } else {
+	        if (StandardPosition) {
+		  *str++ = 'k';
+	        } else {
+		  *str++ = black[square_Fyle(BKRStart)];
+	        }
+	      }
+	    }
+            if (GetCastling (BLACK, QSIDE))  {
+	      if ((flags & FEN_XFEN) == 4) {
+	        outside = true;
+	        for (int square = A8; square < BQRStart; square++) {
+	  	  if (Board[square] == BR) { outside = false; }
+	        }
+	        if (outside) {
+		  *str++ = 'q'; 
+	        } else {
+		  *str++ = black[square_Fyle(BQRStart)];
+	        }
+	      } else {
+	        if (StandardPosition) {
+		  *str++ = 'q';
+	        } else {
+		  *str++ = black[square_Fyle(BQRStart)];
+	        }
+	      }
+	    }
         }
         *str++ = ' ';
-
+   
         // Now the EP target square:
         if (EPTarget == NULL_SQUARE) {
             *str++ = '-';
@@ -3279,7 +3570,7 @@
 void
 Position::CopyFrom (Position * src)
 {
-  memcpy (this, src, sizeof(Position));
+    memcpy (this, src, sizeof(Position));
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -3316,7 +3607,7 @@
     pieceT pieces [32];         // List of pieces excluding kings
     uint nPieces[2] = {0, 0};   // Number of pieces per side excluding kings.
     uint total = 0;             // Total number of pieces excluding kings.
-	LegalMoves.Clear();
+    LegalMoves.Clear();
 
     colorT side = WHITE;
 
Index: src/position.h
===================================================================
--- src/position.h	(revision 1088)
+++ src/position.h	(working copy)
@@ -45,7 +45,8 @@
     FEN_COMPACT = 0,
     FEN_BOARD = 1,
     FEN_CASTLING_EP = 2,
-    FEN_ALL_FIELDS = 3;
+    FEN_ALL_FIELDS = 3,
+    FEN_XFEN = 4;
 
 
 // Flags that Position::GenerateMoves() recognises:
@@ -103,12 +104,16 @@
     byte            Castling;       // castling flags
     bool            StrictCastling; // If false, allow castling after moving
                                         // the King or Rook.
+    squareT         WKRStart, BKRStart, WQRStart, BQRStart; // The initial squares
+                                                            // of the rooks  
 
     uint            Hash;           // Hash value.
     uint            PawnHash;       // Pawn structure hash value.
 
     MoveList        LegalMoves;     // list of legal moves
-
+    
+    bool            StandardPosition; // Normal game or Chess960 
+    
     //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     //  Position:  Private Functions
 
@@ -117,6 +122,8 @@
 
     inline void AddToBoard (pieceT p, squareT sq);
     inline void RemoveFromBoard (pieceT p, squareT sq);
+    inline void AddToBoard960 (pieceT p, squareT sq);
+    inline void RemoveFromBoard960 (pieceT p, squareT sq);
 
     void  CalcPinsDir (directionT dir, pieceT attacker);
 
@@ -126,8 +133,8 @@
     void  GenKnightMoves (MoveList * mlist, colorT c, squareT sq,
                           SquareSet * sqset, bool capturesOnly);
 
-    void  AddLegalMove (MoveList * mlist, squareT from, squareT to, pieceT promo);
-    void  GenCastling (MoveList * mlist);
+    void  AddLegalMove (MoveList * mlist, squareT from, squareT to, pieceT promo, bool castling);
+    void  Gen960Castling (MoveList * mlist);
     void  GenKingMoves (MoveList * mlist, genMovesT genType, bool castling);
     void  AddPromotions (MoveList * mlist, squareT from, squareT dest);
     bool  IsValidEnPassant (squareT from, squareT to);
@@ -178,6 +185,16 @@
     void        SetPlyCounter (ushort x) { PlyCounter = x; }
     ushort      GetPlyCounter ()         { return PlyCounter; }
     ushort      GetFullMoveCount ()      { return PlyCounter / 2 + 1; }
+    MoveList    GetLegalMoves ()         { return LegalMoves; }
+    void        SetWKRStart (squareT s)  { WKRStart = s; }
+    void        SetBKRStart (squareT s)  { BKRStart = s; }
+    void        SetWQRStart (squareT s)  { WQRStart = s; }
+    void        SetBQRStart (squareT s)  { BQRStart = s; }
+    squareT     GetWKRStart ()  { return WKRStart; }
+    squareT     GetBKRStart ()  { return BKRStart; }
+    squareT     GetWQRStart ()  { return WQRStart; }
+    squareT     GetBQRStart ()  { return BQRStart; }
+    bool        GetStandardPosition () { return StandardPosition; }
 
     // Methods to get the Board or piece lists -- used in game.cpp to
     // decode moves:
Index: src/tkscid.h
===================================================================
--- src/tkscid.h	(revision 1088)
+++ src/tkscid.h	(working copy)
@@ -517,7 +517,9 @@
 int sc_move_addSan    (TCL_ARGS);
 int sc_move_addUCI    (TCL_ARGS);
 int sc_move_back      (TCL_ARGS);
+int sc_move_duplicate (TCL_ARGS);
 int sc_move_forward   (TCL_ARGS);
+int sc_move_inplace   (TCL_ARGS);
 int sc_move_pgn       (TCL_ARGS);
 
 int sc_name           (TCL_ARGS);
Index: src/movelist.cpp
===================================================================
--- src/movelist.cpp	(revision 1088)
+++ src/movelist.cpp	(working copy)
@@ -166,7 +166,7 @@
     writeOneByte (fp, sm->capturedPiece);
 
     writeOneByte (fp, sm->promote);
-    writeOneByte (fp, 0);     // Obsolete unused value
+    writeOneByte (fp, sm->castling960);
 
     writeOneByte (fp, sm->capturedSquare);
     writeOneByte (fp, sm->castleFlags);
@@ -193,7 +193,7 @@
     sm->capturedPiece = readOneByte (fp);
 
     sm->promote = readOneByte (fp);
-    readOneByte (fp);   // Obsolete unused value
+    sm->castling960 = readOneByte (fp);
 
     sm->capturedSquare = readOneByte (fp);
     sm->castleFlags = readOneByte (fp);
Index: src/tkscid.cpp
===================================================================
--- src/tkscid.cpp	(revision 1088)
+++ src/tkscid.cpp	(working copy)
@@ -10176,11 +10176,11 @@
 {
     static const char * options [] = {
         "add", "addSan", "addUCI", "back", "end", "forward",
-        "pgn", "ply", "start", NULL
+        "pgn", "ply", "start", "duplicate", "inplace", NULL
     };
     enum {
         MOVE_ADD, MOVE_ADDSAN, MOVE_ADDUCI, MOVE_BACK, MOVE_END, MOVE_FORWARD,
-        MOVE_PGN, MOVE_PLY, MOVE_START
+        MOVE_PGN, MOVE_PLY, MOVE_START, MOVE_DUPLICATE, MOVE_INPLACE
     };
     int index = -1;
 
@@ -10201,6 +10201,9 @@
     case MOVE_BACK:
         return sc_move_back (cd, ti, argc, argv);
 
+    case MOVE_DUPLICATE:
+        return sc_move_duplicate (cd, ti, argc, argv);
+
     case MOVE_END:
         db->game->MoveToPly(0);
         {
@@ -10214,6 +10217,9 @@
     case MOVE_FORWARD:
         return sc_move_forward (cd, ti, argc, argv);
 
+    case MOVE_INPLACE:
+        return sc_move_inplace (cd, ti, argc, argv);
+    
     case MOVE_PGN:
         return sc_move_pgn (cd, ti, argc, argv);
 
@@ -10239,32 +10245,40 @@
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-// sc_move_add: takes a move specified by three parameters
-//      (square square promo) and adds it to the game.
+// sc_move_add: takes a move specified by four parameters
+//      (square square castling promo) and adds it to the game.
 int
 sc_move_add (ClientData cd, Tcl_Interp * ti, int argc, const char ** argv)
 {
 
-    if (argc != 5) {
-        return errorResult (ti, "Usage: sc_move add <sq> <sq> <promo>");
+    if (argc != 6) {
+        return errorResult (ti, "Usage: sc_move add <sq> <sq> <promo> <castle>");
     }
 
     uint sq1 = strGetUnsigned (argv[2]);
     uint sq2 = strGetUnsigned (argv[3]);
     uint promo = strGetUnsigned (argv[4]);
     if (promo == 0) { promo = EMPTY; }
+    uint castle = strGetUnsigned (argv[5]);
+    if (castle == 0) { castle = EMPTY; }
 
     char s[8];
     s[0] = square_FyleChar (sq1);
     s[1] = square_RankChar (sq1);
     s[2] = square_FyleChar (sq2);
     s[3] = square_RankChar (sq2);
+    if (castle == EMPTY ) {
+      s[4] = 'f';
+    } else {
+      s[4] = 't';
+    } 
     if (promo == EMPTY) {
-        s[4] = 0;
+        s[5] = 0;
     } else {
-        s[4] = piece_Char(promo);
-        s[5] = 0;
+        s[5] = piece_Char(promo);
+        s[6] = 0;
     }
+
     simpleMoveT sm;
     Position * pos = db->game->GetCurrentPos();
     errorT err = pos->ReadCoordMove (&sm, s, true);
@@ -10336,13 +10350,22 @@
         ptr += 4;        
       } else {
         s[4] = ptr[4];
-        s[5] = 0;
-        ptr += 6;
+        if (ptr[5] == ' ') {
+	  s[5] = 0;
+	  ptr += 6;
+        } else if (ptr[5] == 0) {
+	  s[5] = 0;
+	  ptr += 5;
+        } else { 
+          // oops 
+          break;
+        }
       }
       simpleMoveT sm;
       Position * pos = db->game->GetCurrentPos();
       errorT err = pos->ReadCoordMove (&sm, s, true);
       if (err == OK) {
+printf ("%s ok\n",s);
         err = db->game->AddMove (&sm, NULL);
         if (err == OK) {
             db->gameAltered = true;
@@ -10354,6 +10377,7 @@
             break;
         }
       } else {
+printf ("%s fail\n",s);
         //Tcl_AppendResult (ti, "Error reading move(s): ", ptr, NULL);
         break;
       }
@@ -10385,6 +10409,39 @@
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// sc_move_duplicate
+//
+// Takes two squares and returns true if there are two moves with those squares, false otherwise
+int
+sc_move_duplicate(ClientData cd, Tcl_Interp * ti, int argc, const char ** argv)
+{
+    if (argc != 4) {
+        return errorResult (ti, "Usage: sc_move duplicate <from sq> <to sq>");
+    }
+
+    uint tosq = strGetUnsigned (argv[2]);
+    uint fromsq = strGetUnsigned (argv[3]);
+    uint timesAppeared = 0;
+    
+    Position * pos = db->game->GetCurrentPos();
+    pos->GenerateMoves();
+    MoveList mList = pos->GetLegalMoves();
+    for (uint i=0; i < mList.Size(); i++) {
+      simpleMoveT * sm = mList.Get(i);
+      if (sm->to == tosq && sm->from == fromsq) {timesAppeared++;}
+    }	
+    if (timesAppeared == 0) {
+      for (uint i=0; i < mList.Size(); i++) {
+         simpleMoveT * sm = mList.Get(i);
+         if (sm->to == fromsq && sm->from == tosq) {timesAppeared++;}
+     }
+    }
+    if (timesAppeared > 1) {setBoolResult(ti, true);} else {setBoolResult(ti, false);}
+   
+    return TCL_OK;
+}
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // sc_move_forward:
 //    Moves forward a specified number of moves (default = 1 move).
 int
@@ -10408,6 +10465,33 @@
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// sc_move_inplace
+//
+// Takes one square and returns true if there are two moves with those squares, false otherwise
+int
+sc_move_inplace(ClientData cd, Tcl_Interp * ti, int argc, const char ** argv)
+{
+    if (argc != 3) {
+        return errorResult (ti, "Usage: sc_move inplace <sq>");
+    }
+
+    uint sq = strGetUnsigned (argv[2]);
+    
+    Position * pos = db->game->GetCurrentPos();
+    pos->GenerateMoves();
+     
+    MoveList mList = pos->GetLegalMoves();
+    for (uint i=0; i < mList.Size(); i++) {
+      simpleMoveT * sm = mList.Get(i);
+      if (sm->to == sq && sm->from == sq) {
+        setBoolResult(ti, true);
+        return TCL_OK;
+      }
+    }	
+    setBoolResult(ti, false);
+    return TCL_OK;
+}
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // sc_move_pgn:
 //    Set the current board to the position closest to
 //    the specified place in the PGN output (given as a byte count
Index: tcl/lang/swedish.tcl
===================================================================
--- tcl/lang/swedish.tcl	(revision 1088)
+++ tcl/lang/swedish.tcl	(working copy)
@@ -2013,6 +2013,8 @@
 # ====== TODO To be translated ======
 translate W DoneWithPosition {Klar med position}
 # ====== TODO To be translated ======
+translate W DidYouCastle {Did you castle?}
+# ====== TODO To be translated ======
 }
 
 ############################################################
Index: tcl/lang/serbian.tcl
===================================================================
--- tcl/lang/serbian.tcl	(revision 1088)
+++ tcl/lang/serbian.tcl	(working copy)
@@ -2016,6 +2016,9 @@
 # ====== TODO To be translated ======
 translate Y DoneWithPosition {Done with position}
 # ====== TODO To be translated ======
+translate Y DidYouCastle {Did you castle?}
+# ====== TODO To be translated ======
+
 }
 # end of serbian.tcl
 
Index: tcl/lang/russian.tcl
===================================================================
--- tcl/lang/russian.tcl	(revision 1088)
+++ tcl/lang/russian.tcl	(working copy)
@@ -2043,6 +2043,9 @@
 # ====== TODO To be translated ======
 translate R DoneWithPosition {Done with position}
 # ====== TODO To be translated ======
+translate R DidYouCastle {Did you castle?}
+# ====== TODO To be translated ======
+
 }
 # end of russian.tcl
 
Index: tcl/lang/english.tcl
===================================================================
--- tcl/lang/english.tcl	(revision 1088)
+++ tcl/lang/english.tcl	(working copy)
@@ -1641,5 +1641,8 @@
 # Calculation of Variations
 translate E DoneWithPosition {Done with position}
 
+# Ask about ambiguous castling in chess 960
+translate E DidYouCastle {Did you castle?}
+
 }
 # end of english.tcl
Index: tcl/lang/norsk.tcl
===================================================================
--- tcl/lang/norsk.tcl	(revision 1088)
+++ tcl/lang/norsk.tcl	(working copy)
@@ -2008,6 +2008,9 @@
 # ====== TODO To be translated ======
 translate O DoneWithPosition {Done with position}
 # ====== TODO To be translated ======
+translate O DidYouCastle {Did you castle?}
+# ====== TODO To be translated ======
+
 }
 
 # norsk.tcl
Index: tcl/tools/uci.tcl
===================================================================
--- tcl/tools/uci.tcl	(revision 1088)
+++ tcl/tools/uci.tcl	(working copy)
@@ -19,8 +19,8 @@
   set infoToken {depth seldepth time nodes pv multipv score cp mate lowerbound upperbound currmove currmovenumber hashfull nps tbhits sbhits cpuload string refutation currline}
 
   set optionToken {name type default min max var }
-  set optionImportant { MultiPV Hash OwnBook BookFile UCI_LimitStrength UCI_Elo }
-  set optionToKeep { UCI_LimitStrength UCI_Elo UCI_ShredderbasesPath }
+  set optionImportant { MultiPV Hash OwnBook BookFile UCI_LimitStrength UCI_Elo UCI_Chess960}
+  set optionToKeep { UCI_LimitStrength UCI_Elo UCI_ShredderbasesPath UCI_Chess960}
   array set uciInfo {}
   ################################################################################
   #
@@ -35,6 +35,7 @@
     set uciInfo(scoremate$n) ""
     set uciInfo(currmove$n) ""
     set uciInfo(currmovenumber$n) 0
+    set uciInfo(chess960$n) 0
     # hmmm
     # set uciInfo(score$n) ""
   }
@@ -62,7 +63,8 @@
   ################################################################################
 
   # todo: sort out the analyze var with computer tournament feature &&&
-
+set ::ccg 0
+set ::ccc 0
   proc processAnalysisInput { { n 1 } { analyze 1 } } {
     global analysis ::uci::uciInfo ::uci::optionToken
 
@@ -290,8 +292,16 @@
 
       # convert to something more readable
       if ($toBeFormatted) {
+incr ::ccc
+incr ::ccg [lindex [time {
         set uciInfo(pv$n) [formatPv $uciInfo(pv$n) $analysis(fen$n)]
         set toBeFormatted 0
+}] 0]
+if {$::ccc == 20} {
+set ::ccc 0
+puts "avg [expr $::ccg / 20]"
+set ::ccg 0
+}
       }
 
       set idx [ expr $uciInfo(multipv$n) -1 ]
@@ -798,6 +808,24 @@
 
   proc sendUCIoptions {n} {
     global analysis
+
+    set chess960 0
+    foreach checkChess960 $analysis(uciOptions$n) {
+    set name [lindex $checkChess960 0]
+      if { $name == "UCI_Chess960" } {
+	  set chess960 1
+      }
+    }
+    if { [sc_game info standard] == 0 } {
+       if {$chess960 == 1} {
+	  sendToEngine $n "setoption name UCI_Chess960 value true"
+       } else {
+	  tk_messageBox -title "Scid: error starting engine" -icon warning -type ok \
+		-message "This program does not support Chess960\n"
+	  return 
+       }
+    }
+
     set engineData [ lindex $::engines(list) $n ]
     set options [ lindex $engineData 8 ]
     foreach opt $options {
@@ -949,17 +977,16 @@
   # returns 1 if an error occured when entering a move
   ################################################################################
   proc sc_move_add { moves } {
+    sc_move addUCI $moves
+    return 0
 
     foreach m $moves {
       # get rid of leading piece
-      set c [string index $m 0]
-      if {$c == "K" || $c == "Q" || $c == "R" || $c == "B" || $c == "N"} {
+      if {[string first [string index $m 0] {KQRBN}] > -1} {
         set m [string range $m 1 end]
       }
-      set s1 [string range $m 0 1]
-      set s1 [::board::sq $s1]
-      set s2 [string range $m 2 3]
-      set s2 [::board::sq $s2]
+      set s1 [::board::sq [string range $m 0 1]]
+      set s2 [::board::sq [string range $m 2 3]]
       if {[string length $m] > 4} {
         set promo [string range $m 4 end]
         # inverse transformation : const char PIECE_CHAR [] = "xKQRBNP.xkqrbnpxMm";
@@ -975,9 +1002,12 @@
           n { set p 5}
           default {puts "Promo error $promo for moves $moves"}
         }
-        if { [catch { sc_move add $s1 $s2 $p } ] } { return 1 }
+
+	if { [catch { sc_move addUCI $m } ] } { return 1 }
+        # if { [catch { sc_move add $s1 $s2 $p } ] } { return 1 }
       } else  {
-        if { [catch { sc_move add $s1 $s2 0 } ] } { return 1 }
+	if { [catch { sc_move addUCI $m } ] } { return 1 }
+        # if { [catch { sc_move add $s1 $s2 0 } ] } { return 1 }
       }
     }
     return 0
Index: tcl/tools/analysis.tcl
===================================================================
--- tcl/tools/analysis.tcl	(revision 1088)
+++ tcl/tools/analysis.tcl	(working copy)
@@ -3295,6 +3295,11 @@
 	if {$analysis(isCrafty$n)} {
           sendToEngine $n "mn [sc_pos moveNumber]"
         }
+
+        if { [sc_game info standard] == 0 } {
+	  sendToEngine $n "variant fischerrandom"
+        }
+
 	sendToEngine $n analyze
 	return
       }
@@ -3340,6 +3345,10 @@
 	}
 	
       }
+
+      if { [sc_game info standard] == 0 } {
+	sendToEngine $n "variant fischerrandom"
+      }
       
       sendToEngine $n analyze
       
@@ -3356,6 +3365,11 @@
       if {(!$windowsOS)  &&  $analysis(send_sigint$n)} {
 	catch {exec -- kill -s INT [pid $analysis(pipe$n)]}
       }
+
+      if { [sc_game info standard] == 0 } {
+	sendToEngine $n "variant fischerrandom"
+      }
+
       sendToEngine $n new
       sendToEngine $n force
       if { $nonStdStart && ! $analysis(has_setboard$n) } {
@@ -3363,6 +3377,7 @@
 	updateAnalysisText $n
 	return
       }
+
       if {$analysis(has_setboard$n)} {
 	sendToEngine $n "setboard [sc_pos fen]"
       } else  {
Index: tcl/main.tcl
===================================================================
--- tcl/main.tcl	(revision 1088)
+++ tcl/main.tcl	(working copy)
@@ -1213,7 +1213,20 @@
     } else {
       set ::sergame::lastPlayerMoveUci ""
     }
-    sc_move add $sq1 $sq2 $promo
+
+    set castle 0
+    if {[sc_move duplicate $sq1 $sq2] == 1} {
+	set answer [tk_messageBox -message "Did you castle?" -type yesno -icon question]
+	switch -- $answer {
+	    yes {set castle 1}
+	    no {set castle 0}
+	}
+    }
+    if {[sc_move inplace $sq1] == 1} {
+	set castle 1
+    }
+    sc_move add $sq1 $sq2 $promo $castle
+
     set san [sc_game info previous]
     if {$action == "mainline"} {
       sc_var exit
@@ -1382,7 +1395,7 @@
 
   if { [winfo exists .calvarWin] } { return }
 
-  global selectedSq bestSq
+  global selectedSq bestSq currentSq
 
   set w .board
   ::board::setDragSquare $w -1
@@ -1393,6 +1406,20 @@
   }
 
   if {$square == $selectedSq} {
+    set castle 0
+    if {[sc_move inplace $square] == 1} {
+	set answer [tk_messageBox -message $DidYouCastle -type yesno -icon question]
+	switch -- $answer {
+	    yes {
+		set selectedSq -1
+		::board::colorSquare $w $square
+
+		addMove $square $square -animate
+		enterSquare $square
+	    }
+	    no {}
+	}
+   } else {
     if {$::suggestMoves} {
       # User pressed and released on same square, so make the
       # suggested move if there is one:
@@ -1405,6 +1432,7 @@
       # Current square is the square user pressed the button on,
       # so we do nothing.
     }
+   }
   } else {
     # User has dragged to another square, so try to add this as a move:
     addMove $square $selectedSq
Index: tcl/edit.tcl
===================================================================
--- tcl/edit.tcl	(revision 1088)
+++ tcl/edit.tcl	(working copy)
@@ -356,7 +356,7 @@
   makeSetupFen
 }
 proc check_castling {a b c} {
-  ::utils::validate::Regexp {^(-|[KQkq]*)$} $a $b $c
+  ::utils::validate::Regexp {^(-|[KQkqa-hA-H]*)$} $a $b $c
   makeSetupFen
 }
 trace variable moveNum w check_moveNum
Index: tcl/board.tcl
===================================================================
--- tcl/board.tcl	(revision 1088)
+++ tcl/board.tcl	(working copy)
@@ -2439,6 +2460,8 @@
   if {$diffcount == 4} {
     # Check for making/unmaking a castling move
 
+    set normalcastle 0
+
     set oldlower [string tolower $oldboard]
     set newlower [string tolower $newboard]
 
@@ -2454,6 +2477,7 @@
           eval $w.bd coords p$rto [::board::midSquare $w $rfrom]
           set from $kfrom
           set to $kto
+          set normalcastle 1
         } elseif {[string index $newlower $kfrom] == {k}  &&
 	    [string index $newlower $rfrom] == {r}  &&
 	    [string index $oldlower $kto] == {k}  &&
@@ -2461,13 +2485,50 @@
           # An undo-castling animation. No need to move the rook.
           set from $kto
           set to $kfrom
+          set normalcastle 1
         }
       }
     }
+    if {$normalcastle == 0} {
+      set oldcount 0
+      set newcount 0
+      for {set i 0} {$i < $diffcount} {incr i} {
+        if {$old($i) != "."} {
+          set oldone($oldcount) $old($i)
+          set oldsquare($oldcount) $sq($i)
+          incr oldcount
+        }
+        if {$new($i) != "."} {
+          set newone($newcount) $new($i)
+          set newsquare($newcount) $sq($i)
+          incr newcount
+        }
+      }
+      if {([string tolower $oldone(0)] == "r" && [string tolower $oldone(1)] == "k" && 
+           [string tolower $newone(0)] == "k" && [string tolower $newone(1)] == "r") ||
+          ([string tolower $oldone(0)] == "k" && [string tolower $oldone(1)] == "r" && 
+           [string tolower $newone(0)] == "r" && [string tolower $newone(1)] == "k")} {
+        if {($newone(0) == "k" || $newone(1) == "k") && $newsquare(0) >= [sq a8] && $newsquare(1) >= [sq a8]} {
+        } else {
+          if {($newone(0) == "K" || $newone(1) == "K") && $newsquare(0) <= [sq h1] && $newsquare(1) <= [sq h1]} {
+         } else {
+              return
+            }
+          }
+        if {[string tolower $oldone(0)] == "k"} {
+          set from $newsquare(0)
+          set to $newsquare(1) 
+        } else {
+          set from $newsquare(1)
+          set to $newsquare(0) 
+        }
+      }
+    }
   }
 
   if {$diffcount == 3} {
     # Three squares are different, so check for an En Passant capture:
+    set enpassant 0
     foreach i {0 1 2} {
       foreach j {0 1 2} {
         foreach k {0 1 2} {
@@ -2479,6 +2540,7 @@
             ($old($i) == "P" && $old($k) == "p"))} {
             set from $sq($i)
             set to $sq($j)
+            set enpassant 1
           }
           # Check for undoing an en-passant capture from j to i with
           # the enemy pawn on k:
@@ -2489,10 +2551,46 @@
             set to $sq($j)
             set captured $sq($k)
             set capturedPiece $new($k)
+            set enpassant 1
           }
         }
       }
     }
+    if {$enpassant == 0} {
+      set oldcount 0
+      set newcount 0
+      for {set i 0} {$i < $diffcount} {incr i} {
+        if {$old($i) != "."} {
+          set oldone($oldcount) $old($i)
+          set oldsquare($oldcount) $sq($i)
+          incr oldcount
+        }
+        if {$new($i) != "."} {
+          set newone($newcount) $new($i)
+          set newsquare($newcount) $sq($i)
+          incr newcount
+        }
+      }
+      if {([string tolower $oldone(0)] == "r" && [string tolower $oldone(1)] == "k" && 
+           [string tolower $newone(0)] == "k" && [string tolower $newone(1)] == "r") ||
+          ([string tolower $oldone(0)] == "k" && [string tolower $oldone(1)] == "r" && 
+           [string tolower $newone(0)] == "r" && [string tolower $newone(1)] == "k")} {
+        if {($newone(0) == "k" || $newone(1) == "k") && $newsquare(0) >= [sq a8] && $newsquare(1) >= [sq a8]} {
+        } else {
+          if {($newone(0) == "K" || $newone(1) == "K") && $newsquare(0) <= [sq h1] && $newsquare(1) <= [sq h1]} {
+         } else {
+              return
+            }
+          }
+        if {[string tolower $oldone(0)] == "k"} {
+          set from $newsquare(0)
+          set to $newsquare(1) 
+        } else {
+          set from $newsquare(1)
+          set to $newsquare(0) 
+        }
+      }
+    }
   }
 
   if {$diffcount == 2} {
@@ -2500,6 +2598,25 @@
     # same (non-empty) piece as the other new square, and at least one
     # of the old or new squares should be empty.
 
+   if {([string tolower $old(0)] == "r" && [string tolower $old(1)] == "k" && 
+        [string tolower $new(0)] == "k" && [string tolower $new(1)] == "r") ||
+        ([string tolower $old(0)] == "k" && [string tolower $old(1)] == "r" && 
+        [string tolower $new(0)] == "r" && [string tolower $new(1)] == "k")} {
+        if {($new(0) == "k" || $new(1) == "k") && $sq(0) >= [sq a8] && $sq(1) >= [sq a8]} {
+        } else {
+            if {($new(0) == "K" || $new(1) == "K") && $sq(0) <= [sq h1] && $sq(1) <= [sq h1]} {
+            } else {
+                return
+            }
+        }
+        if {[string tolower $old(0)] == "k"} {
+            set from $sq(0)
+            set to $sq(1) 
+        } else {
+            set from $sq(1)
+            set to $sq(0) 
+        }
+    } else { 
     if {$old(0) != "." && $old(1) != "." && $new(0) != "." && $new(1) != "."} {
       return
     }
@@ -2536,6 +2653,7 @@
       }
     }
   }
+  }
 
   # Check that we found a valid-looking move to animate:
   if {$from < 0  ||  $to < 0} { return }
