Index: src/mfile.h
===================================================================
--- src/mfile.h	(revision 1870)
+++ src/mfile.h	(working copy)
@@ -16,16 +16,32 @@
 // An MFile is a file that can be a regular file, or memory-only with
 // no actual file on any device.
 
+// -------------------------------------------------------------------
+// Extension by Gregor Cramer, 25 March 2014:
+// -------------------------------------------------------------------
+// For reading a whole file and avoiding the time consuming locking we
+// are using memory mapping (file mapping) under Windows.
+//
+// On Linux we have a simpler method, glibc is providing the function
+// getc_unlocked() for this purpose.
 
+
 #ifndef SCID_MFILE_H
 #define SCID_MFILE_H
 
 #include "common.h"
 #include "dstring.h"
 #include "error.h"
+ 
+#ifdef WIN32
+# include "win_mmap.h"
+#endif
 
 enum mfileT {
-    MFILE_REGULAR = 0, MFILE_MEMORY, MFILE_ZIP
+    MFILE_REGULAR = 0, MFILE_MEMORY, MFILE_ZIP,
+#ifdef WIN32
+    MFILE_MMAP,
+#endif
 };
 
 class MFile
@@ -44,6 +60,10 @@
 
     char *      FileBuffer;  // Only for files with unusual buffer size.
 
+#ifdef WIN32
+    WinMMap *   MappedFile;  // File mapping for fast read access.
+#endif
+
     void  Extend();
 
   public:
@@ -53,6 +73,9 @@
         if (Data != NULL) { delete[] Data; }
         if (FileBuffer != NULL) { delete[] FileBuffer; }
         if (FileName != NULL) { delete[] FileName; }
+#ifdef WIN32
+        delete MappedFile;
+#endif
     }
 
     void Init();
@@ -61,6 +84,9 @@
 
     errorT Create (const char * name, fileModeT fmode);
     errorT Open  (const char * name, fileModeT fmode);
+#ifdef WIN32
+    errorT OpenMappedFile (const char * name, fileModeT fmode);
+#endif
     void   CreateMemory () { Close(); Init(); }
     errorT Close ();
 
@@ -107,6 +133,10 @@
         return (Location >= Capacity);
     case MFILE_REGULAR:
         return feof(Handle);
+#ifdef WIN32
+    case MFILE_MMAP:
+        return Location >= MappedFile->size();
+#endif
     default:
         return false;
     }
@@ -137,12 +167,22 @@
         CurrentPtr++;
         return (int) value;
     }
+#ifdef WIN32
+    if (Type == MFILE_MMAP) {
+        if (Location >= MappedFile->size()) { return EOF; }
+        return *(MappedFile->address() + Location++);
+    } else {
+        Location++;
+        return getc(Handle);
+    }
+#else
     Location++;
-    #ifdef __GNUC__
+# ifdef __GNUC__
     return getc_unlocked(Handle);
-    #else
+# else
     return getc(Handle);
-    #endif
+# endif
+#endif
 }
 
 #endif  // SCID_MFILE_H
Index: src/index.h
===================================================================
--- src/index.h	(revision 1867)
+++ src/index.h	(working copy)
@@ -639,7 +639,6 @@
     uint         IndexEntrySize;
 
     // Used for sorting:
-    uint *        EntriesHeap;
     int           SortCriteria [INDEX_MaxSortCriteria];
 
     void         FreeEntries();
@@ -651,6 +650,7 @@
     //  Index:  Public Functions
     //----------------------------------
  public:
+    uint *        EntriesHeap;
 #ifdef WINCE
   void* operator new(size_t sz) {
     void* m = my_Tcl_AttemptAlloc(sz);
@@ -765,6 +765,11 @@
      errorT     WriteSorted () { return WriteSorted (0, NULL, NULL); }
 
      errorT     ParseSortCriteria (const char * inputStr);
+
+#ifdef WIN32 // Fast file read
+    class WinFileMapping;
+    friend class WinFileMapping;
+#endif
 };
 
 
Index: src/index.cpp
===================================================================
--- src/index.cpp	(revision 1867)
+++ src/index.cpp	(working copy)
@@ -53,7 +53,36 @@
     SORT_deleted, SORT_eventdate, SORT_variations, SORT_comments, SORT_random, SORT_sentinel
 };
 
+#ifdef WIN32 // Fast file read
 
+struct Index::WinFileMapping {
+    Index& index;
+    MFile* fp;
+	 uint pos;
+
+    WinFileMapping(Index& i, char const* fname) :index(i), fp(i.FilePtr), pos(i.FilePos) {
+        index.FilePtr = new MFile;
+
+        if (index.FilePtr->OpenMappedFile(fname, FMODE_ReadOnly) != OK) {
+            delete index.FilePtr;
+            index.FilePtr = fp; // use original handle in case of an error
+        } else {
+            index.FilePos = 0;
+        }
+    }
+
+    ~WinFileMapping()
+    {
+        if (index.FilePtr != fp) {
+            delete index.FilePtr;
+            index.FilePtr = fp;
+            index.FilePos = pos;
+        }
+    }
+};
+
+#endif
+
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // IndexEntry::Init():
 //        Initialise a single index entry.
@@ -1131,7 +1160,17 @@
         if (gamesToRead > INDEX_ENTRY_CHUNKSIZE) {
             gamesToRead = INDEX_ENTRY_CHUNKSIZE;
         }
+
+#ifdef WIN32 // Fast file read
+        { Index::WinFileMapping fileMapping(*this, FilePtr->GetFileName());
+#endif
+
         err = ReadEntries (Entries[chunkCount], readCount, gamesToRead);
+
+#ifdef WIN32 // Fast file read
+        }
+#endif
+
         if (err != OK) {
             for (uint i = 0; i <= chunkCount; i++) {
                 delete[] Entries[i];
Index: src/mfile.cpp
===================================================================
--- src/mfile.cpp	(revision 1870)
+++ src/mfile.cpp	(working copy)
@@ -28,6 +28,9 @@
     CurrentPtr = NULL;
     FileBuffer = NULL;
     FileName = NULL;
+#ifdef WIN32
+    MappedFile = NULL;
+#endif
 }
 
 void
@@ -44,7 +47,7 @@
     if (oldData != NULL) {
       // Copy data to new array:
       for (uint i=0; i < oldCapacity; i++) {
-	Data[i] = oldData[i];
+        Data[i] = oldData[i];
       }
       delete[] oldData;
     }
@@ -76,7 +79,15 @@
     if (FileMode != FMODE_Both  &&  Location == position) { return OK; }
 
     int result;
+#ifdef WIN32
+    if (Type == MFILE_MMAP) {
+        result = 0; // always succeeding
+     } else {
+#endif
     result = fseek (Handle, position, 0);
+#ifdef WIN32
+    }
+#endif
     if (result != 0) { return ERROR_FileSeek; }
     Location = position;
     return OK;
@@ -112,7 +123,24 @@
     return OK;
 }
 
+#ifdef WIN32
 errorT
+MFile::OpenMappedFile (const char * name, fileModeT fmode)
+{
+    ASSERT(Handle == NULL && GzHandle == NULL);
+    ASSERT(fmode == FMODE_ReadOnly);
+
+    Type = MFILE_MMAP;
+    FileName = strDuplicate(name);
+    MappedFile = new WinMMap(name);
+    FileMode = fmode;
+    Location = 0;
+
+    return MappedFile->isOpen() ? OK : ERROR_FileOpen;
+}
+#endif
+
+errorT
 MFile::Create (const char * name, fileModeT fmode)
 {
     ASSERT (Handle == NULL);
@@ -140,7 +168,16 @@
         return OK;
     }
     int result;
+#ifdef WIN32
+    if (Type == MFILE_MMAP) {
+        delete MappedFile;
+        MappedFile = NULL;
+     } else {
+#endif
     result = fclose (Handle);
+#ifdef WIN32
+    }
+#endif
 
     if (FileBuffer != NULL) {
         delete[] FileBuffer;
